var zv = Object.defineProperty;
var Xv = (s, t, e) => t in s ? zv(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;
var f = (s, t, e) => (Xv(s, typeof t != "symbol" ? t + "" : t, e), e);
import { Color as Ce, Vector2 as Z, Vector3 as B, Vector4 as Me, Matrix3 as qe, Matrix4 as J, EventDispatcher as PA, MathUtils as ce, LinearSRGBColorSpace as Vi, SRGBColorSpace as gt, StaticDrawUsage as Tl, InterleavedBuffer as Ai, InterleavedBufferAttribute as ve, DynamicDrawUsage as Ql, InstancedInterleavedBuffer as Wv, DepthTexture as Dh, NearestFilter as cs, LessCompare as Zv, WebGPUCoordinateSystem as Uv, ShaderMaterial as ze, NoColorSpace as Yl, Material as ks, WebGLCubeRenderTarget as ib, BoxGeometry as Nt, BackSide as Ov, NoBlending as jl, Mesh as le, Scene as Kh, LinearMipmapLinearFilter as wr, LinearFilter as Gt, CubeCamera as nb, RenderTarget as Qv, sRGBEncoding as Yv, LinearEncoding as jv, Float16BufferAttribute as Jv, REVISION as Hh, PerspectiveCamera as Ys, ShaderLib as fo, UniformsUtils as we, UniformsLib as Xt, ShaderChunk as Ee, MeshBasicMaterial as _t, Group as mt, DirectionalLight as Ph, AmbientLight as qv, TextureLoader as Ot, EquirectangularReflectionMapping as $v, OrthographicCamera as Zg, BufferGeometry as Qe, Float32BufferAttribute as ae, Quaternion as Ye, Ray as yt, Frustum as Nh, AdditiveBlending as NA, Points as Ug, BufferAttribute as Fe, Object3D as Wt, Clock as sb, WebGLRenderTarget as It, DepthStencilFormat as ob, UnsignedInt248Type as FA, WebGLMultipleRenderTargets as rb, RGBAFormat as Hs, HalfFloatType as xi, UnsignedByteType as Pi, RawShaderMaterial as eT, ColorManagement as Jl, SRGBTransfer as ab, LinearToneMapping as gb, ReinhardToneMapping as cb, CineonToneMapping as lb, ACESFilmicToneMapping as hb, CanvasTexture as ls, Texture as pa, DstColorFactor as tT, ZeroFactor as ql, AddEquation as yf, DstAlphaFactor as iT, LuminanceFormat as db, CustomBlending as kA, DataTexture as Ga, RedFormat as Ps, FloatType as ur, RepeatWrapping as ii, Box3 as Ue, LineSegments as Ma, LineBasicMaterial as _r, Box3Helper as $l, DoubleSide as xr, PlaneGeometry as Og, Plane as Zt, Sphere as Bn, ClampToEdgeWrapping as hs, AnimationMixer as nT, Raycaster as js, WebGLRenderer as VA, GLSL3 as sT, CameraHelper as zA, SphereGeometry as XA, FramebufferTexture as oT, Euler as pr, CylinderGeometry as Ri, OctahedronGeometry as sc, Line as es, TorusGeometry as Ha, PMREMGenerator as rT, TrianglesDrawMode as aT, TriangleFanDrawMode as eh, TriangleStripDrawMode as WA, OneFactor as Ll, Box2 as gT, FileLoader as rs, Loader as Fh, LoaderUtils as ma, SpotLight as ub, PointLight as Ib, MeshPhysicalMaterial as Ti, InstancedMesh as kh, ImageBitmapLoader as Ab, PointsMaterial as ZA, MeshStandardMaterial as Vh, PropertyBinding as Cb, SkinnedMesh as fb, LineLoop as pb, Skeleton as mb, InterpolateLinear as zh, AnimationClip as yb, Bone as Sb, NearestMipmapNearestFilter as bb, LinearMipmapNearestFilter as Bb, NearestMipmapLinearFilter as wb, MirroredRepeatWrapping as _b, InterpolateDiscrete as xb, FrontSide as vb, VectorKeyframeTrack as WI, QuaternionKeyframeTrack as th, NumberKeyframeTrack as ZI, Interpolant as Tb, CompressedCubeTexture as cT, CompressedArrayTexture as lT, CompressedTexture as Lb, RGBA_ASTC_4x4_Format as Gb, RGBA_BPTC_Format as Mb, RGBA_ETC2_EAC_Format as Eb, RGBA_PVRTC_4BPPV1_Format as Rb, RGBA_S3TC_DXT5_Format as Db, RGB_ETC1_Format as Kb, RGB_ETC2_Format as Hb, RGB_PVRTC_4BPPV1_Format as Pb, RGB_S3TC_DXT1_Format as Nb, RGFormat as aa, RGBA_ASTC_6x6_Format as UI, Data3DTexture as hT, DisplayP3ColorSpace as dT, LinearDisplayP3ColorSpace as uT, InstancedBufferAttribute as Ni, DefaultLoadingManager as Qg, SIGNED_RED_GREEN_RGTC2_Format as IT, RED_GREEN_RGTC2_Format as AT, SIGNED_RED_RGTC1_Format as CT, RED_RGTC1_Format as fT, RGB_BPTC_UNSIGNED_Format as pT, RGB_BPTC_SIGNED_Format as mT, RGBA_ASTC_12x12_Format as yT, RGBA_ASTC_12x10_Format as ST, RGBA_ASTC_10x10_Format as bT, RGBA_ASTC_10x8_Format as BT, RGBA_ASTC_10x6_Format as wT, RGBA_ASTC_10x5_Format as _T, RGBA_ASTC_8x8_Format as xT, RGBA_ASTC_8x6_Format as vT, RGBA_ASTC_8x5_Format as TT, RGBA_ASTC_6x5_Format as LT, RGBA_ASTC_5x5_Format as GT, RGBA_ASTC_5x4_Format as MT, RGBA_PVRTC_2BPPV1_Format as ET, RGB_PVRTC_2BPPV1_Format as RT, RGBA_S3TC_DXT3_Format as DT, RGBA_S3TC_DXT1_Format as KT, RGBAIntegerFormat as HT, RGIntegerFormat as PT, RedIntegerFormat as NT, LuminanceAlphaFormat as FT, AlphaFormat as kT, IntType as VT, UnsignedIntType as zT, UnsignedShort5551Type as XT, UnsignedShort4444Type as WT, ShortType as ZT, UnsignedShortType as UT, ByteType as OT, EdgesGeometry as QT, InstancedBufferGeometry as Fb, LoadingManager as YT } from "three";
const Vt = "mapv";
function Re(s, t) {
  if (s.className === void 0)
    s.className = t;
  else if (s.className !== t) {
    const e = s.className.split(/ +/);
    e.indexOf(t) === -1 && (e.push(t), s.className = e.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
  }
  return s;
}
function ih(s, t) {
  if (t)
    if (s.className === t)
      s.removeAttribute("class");
    else {
      const e = s.className.split(/ +/), i = e.indexOf(t);
      i !== -1 && (e.splice(i, 1), s.className = e.join(" "));
    }
  else
    s.className = void 0;
  return s;
}
const Sf = {};
function jT(s, t) {
  if (Sf[s])
    return;
  const e = t || document, i = document.createElement("style");
  i.type = "text/css", i.innerHTML = s;
  const n = e.getElementsByTagName("head")[0];
  try {
    n.appendChild(i), Sf[s] = !0;
  } catch {
  }
}
const JT = `.mapv-widgets-pane{position:absolute;z-index:15;bottom:0;left:0;right:0}.mapv-widgets-pane .bottom-right-anchor{position:absolute;width:52px;bottom:40px;right:20px}.mapv-widgets-pane .bottom-left-anchor{position:absolute;bottom:60px;left:20px}.mapv-widgets-pane .compass{width:52px;height:54px;margin-top:10px;visibility:visible;position:relative;background-size:266px;background-repeat:no-repeat;background-position:0 0}.mapv-widgets-pane .compass .compass-up{position:absolute;left:20px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-widgets-pane .compass .compass-up:hover{fill:#2c82ff}.mapv-widgets-pane .compass .compass-down{position:absolute;left:20px;bottom:2px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-widgets-pane .compass .compass-down:hover{fill:#2c82ff}.mapv-widgets-pane .compass .compass-left{cursor:pointer;position:absolute;top:5px;left:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px}.mapv-widgets-pane .compass .compass-left:hover{background-position:-89px -5px}.mapv-widgets-pane .compass .compass-right{cursor:pointer;position:absolute;top:5px;right:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px;transform:rotateY(180deg);-ms-transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-o-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}.mapv-widgets-pane .compass .compass-right:hover{background-position:-89px -5px}.mapv-widgets-pane .compass .compass-center{cursor:pointer;position:absolute;top:11px;left:19px;width:14px;height:32px;background-size:266px;background-repeat:no-repeat;background-position:-56px -10px;transform:rotate(0)}.mapv-widgets-pane .zoom{width:26px;height:54px;visibility:visible;margin-left:13px;margin-top:10px}.mapv-widgets-pane .zoom .zoom-add{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:2px 2px 0 0;background-position:0 0}.mapv-widgets-pane .zoom .zoom-add:hover .zoom-add-tag{background-position:20px 0}.mapv-widgets-pane .zoom .zoom-add-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px}.mapv-widgets-pane .zoom .zoom-sub{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:0 0 2px 2px}.mapv-widgets-pane .zoom .zoom-sub:hover .zoom-sub-tag{background-position:10px 0}.mapv-widgets-pane .zoom .zoom-sub-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px;background-position:-10px 0}.mapv-widgets-pane .scale{position:absolute;bottom:10px;left:100px;visibility:visible;width:90px;height:26px}.mapv-widgets-pane .scale .scale-text{width:100%;font-size:10px;text-align:center;user-select:none;transition:width .3s}.mapv-widgets-pane .scale .scale-line{position:relative;width:100%;height:8px;user-select:none}.mapv-widgets-pane .scale .scale-line-mid{position:absolute;left:2px;right:2px;top:3px;bottom:2px;background-color:#333;overflow:hidden}.mapv-widgets-pane .scale .scale-line-left{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden}.mapv-widgets-pane .scale .scale-line-right{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden;right:0}.mapv-widgets-pane .drawer{position:absolute;right:31px;bottom:164px;margin:2px;cursor:pointer}.mapv-widgets-pane .drawer .drawer-btn{background-color:#fff;padding:5px 5px 0;border-radius:2px}.mapv-widgets-pane .drawer .drawer-btn:hover{background-color:#f3f3f3}.mapv-widgets-pane .drawer .drawer-icon{height:16px;width:16px;fill:#797979}.mapv-widgets-pane .drawer .drawer-list{position:absolute;right:32px;top:0;display:none;list-style:none;background-color:#fff;box-shadow:0 0 20px #00000026;white-space:nowrap;border-radius:2px}.mapv-widgets-pane .drawer .drawer-item{display:flex;align-items:center;padding:0 16px;height:24px;line-height:24px}.mapv-widgets-pane .drawer .drawer-item-check{margin:0}.mapv-widgets-pane .drawer .drawer-item-name{margin-left:6px;font-size:12px}.mapv-widgets-pane .drawer .drawer-arrow{width:0;height:0;border-width:4px;border-style:solid;border-color:transparent transparent transparent #fff;position:absolute;top:11px;right:-7px}.mapv-widgets-pane .mouse-location{position:absolute;bottom:10px;right:20px;visibility:visible;padding:2px 6px;background-color:#fff;font-size:14px;border-radius:2px}.mapv-widgets-pane .logo{position:absolute;width:81px;height:27px;bottom:10px;left:5px;visibility:visible}.mapv-widgets-pane .geo-locate{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-widgets-pane .fullscreen{background-color:#fff;height:26px;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc}.mapv-widgets-pane .export-image{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-widgets-pane .geo-locate:hover .widgets-group-svg,.mapv-widgets-pane .fullscreen:hover .widgets-group-svg,.mapv-widgets-pane .export-image:hover .widgets-group-svg{fill:#2c82ff}.mapv-widgets-pane .widgets-group-svg{margin:5px;height:16px;width:16px;fill:#999}.mapv-overlay-pane{position:absolute;z-index:10}.mapv-overlay-pane .mapv-popup{width:200px;height:110px}.mapv-overlay-pane .mapv-popup .frame{width:198px;height:98px;background:white;border-radius:4px;border:1px solid #e6e1e1}.mapv-overlay-pane .mapv-popup .title{height:30px;border-bottom:1px solid #e6e1e1;line-height:30px;padding-left:10px;font-size:18px;font-weight:500}.mapv-overlay-pane .mapv-popup .close{width:20px;height:31px;position:absolute;font-size:20px;text-align:center;right:5px;cursor:pointer}.mapv-overlay-pane .mapv-popup .triangle{width:0;height:0;border-top:10px solid white;border-left:12px solid transparent;border-right:12px solid transparent;margin-left:88px}.mapv-overlay-pane .mapv-popup .content{padding:5px}.mapv-dom-points{position:absolute;z-index:10;user-select:none}.mapv-measure-pane{display:inline-block;position:absolute;height:30px;border-radius:5px;padding:0 5px;line-height:30px;background-color:#797774;color:#fff;transform:translate(-50%,-130%);overflow:visible;white-space:nowrap}.mapv-measure-pane:after{content:"";position:absolute;width:0;height:0;left:50%;bottom:0;border:6px solid transparent;border-top:6px solid #797774;background-color:transparent;transform:translate(-50%,10px)}.mapv-container{touch-action:none}.mapv-hidden{display:none!important}
`, bf = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
}, Kt = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, Ag = ["fragment", "vertex"], Bf = ["setup", "analyze", "generate"], qT = [...Ag, "compute"], UA = ["x", "y", "z", "w"];
function OA(s) {
  let t = "{";
  s.isNode === !0 && (t += `uuid:"${s.uuid}"`);
  for (const { property: e, index: i, childNode: n } of nh(s)) {
    let o = OA(n);
    o.includes(",") || (o = o.slice(o.indexOf('"'), o.indexOf("}"))), t += `,${e}${i !== void 0 ? "/" + i : ""}:${o}`;
  }
  return t += "}", t;
}
function* nh(s, t = !1) {
  for (const e in s) {
    if (e.startsWith("_") === !0)
      continue;
    const i = s[e];
    if (Array.isArray(i) === !0)
      for (let n = 0; n < i.length; n++) {
        const o = i[n];
        o && (o.isNode === !0 || t && typeof o.toJSON == "function") && (yield { property: e, index: n, childNode: o });
      }
    else if (i && i.isNode === !0)
      yield { property: e, childNode: i };
    else if (typeof i == "object")
      for (const n in i) {
        const o = i[n];
        o && (o.isNode === !0 || t && typeof o.toJSON == "function") && (yield { property: e, index: n, childNode: o });
      }
  }
}
function OI(s) {
  if (s == null)
    return null;
  const t = typeof s;
  return s.isNode === !0 ? "node" : t === "number" ? "float" : t === "boolean" ? "bool" : t === "string" ? "string" : t === "function" ? "shader" : s.isVector2 === !0 ? "vec2" : s.isVector3 === !0 ? "vec3" : s.isVector4 === !0 ? "vec4" : s.isMatrix3 === !0 ? "mat3" : s.isMatrix4 === !0 ? "mat4" : s.isColor === !0 ? "color" : s instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function kb(s, ...t) {
  const e = s ? s.slice(-4) : void 0;
  return t.length === 1 && (e === "vec2" ? t = [t[0], t[0]] : e === "vec3" ? t = [t[0], t[0], t[0]] : e === "vec4" && (t = [t[0], t[0], t[0], t[0]])), s === "color" ? new Ce(...t) : e === "vec2" ? new Z(...t) : e === "vec3" ? new B(...t) : e === "vec4" ? new Me(...t) : e === "mat3" ? new qe(...t) : e === "mat4" ? new J(...t) : s === "bool" ? t[0] || !1 : s === "float" || s === "int" || s === "uint" ? t[0] || 0 : s === "string" ? t[0] || "" : s === "ArrayBuffer" ? eL(t[0]) : null;
}
function $T(s) {
  let t = "";
  const e = new Uint8Array(s);
  for (let i = 0; i < e.length; i++)
    t += String.fromCharCode(e[i]);
  return btoa(t);
}
function eL(s) {
  return Uint8Array.from(atob(s), (t) => t.charCodeAt(0)).buffer;
}
const wf = /* @__PURE__ */ new Map();
let tL = 0;
class iL extends PA {
  constructor(t = null) {
    super(), this.nodeType = t, this.updateType = Kt.NONE, this.updateBeforeType = Kt.NONE, this.uuid = ce.generateUUID(), this.isNode = !0, Object.defineProperty(this, "id", { value: tL++ });
  }
  get type() {
    return this.constructor.type;
  }
  getSelf() {
    return this.self || this;
  }
  updateReference() {
    return this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    for (const { childNode: t } of nh(this))
      yield t;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(t) {
    t(this);
    for (const e of this.getChildren())
      e.traverse(t);
  }
  getCacheKey() {
    return OA(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(t) {
    const e = t.getNodeProperties(this);
    return e.outputNode ? e.outputNode.getNodeType(t) : this.nodeType;
  }
  getShared(t) {
    const e = this.getHash(t);
    return t.getNodeFromHash(e) || this;
  }
  setup(t) {
    const e = t.getNodeProperties(this);
    for (const i of this.getChildren())
      e["_node" + i.id] = i;
    return null;
  }
  construct(t) {
    return console.warn("THREE.Node: construct() is deprecated. Use setup() instead."), this.setup(t);
  }
  analyze(t) {
    const e = t.getDataFromNode(this);
    if (e.dependenciesCount = e.dependenciesCount === void 0 ? 1 : e.dependenciesCount + 1, e.dependenciesCount === 1) {
      const i = t.getNodeProperties(this);
      for (const n of Object.values(i))
        n && n.isNode === !0 && n.build(t);
    }
  }
  generate(t, e) {
    const { outputNode: i } = t.getNodeProperties(this);
    if (i && i.isNode === !0)
      return i.build(t, e);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(t, e = null) {
    const i = this.getShared(t);
    if (this !== i)
      return i.build(t, e);
    t.addNode(this), t.addChain(this);
    let n = null;
    const o = t.getBuildStage();
    if (o === "setup") {
      const r = t.getNodeProperties(this);
      if (r.initialized !== !0 || t.context.tempRead === !1) {
        const a = t.stack.nodes.length;
        r.initialized = !0, r.outputNode = this.setup(t), r.outputNode !== null && t.stack.nodes.length !== a && (r.outputNode = t.stack);
        for (const g of Object.values(r))
          g && g.isNode === !0 && g.build(t);
      }
    } else if (o === "analyze")
      this.analyze(t);
    else if (o === "generate")
      if (this.generate.length === 1) {
        const a = this.getNodeType(t), g = t.getDataFromNode(this);
        n = g.snippet, n === void 0 && (n = this.generate(t) || "", g.snippet = n), n = t.format(n, a, e);
      } else
        n = this.generate(t, e) || "";
    return t.removeChain(this), n;
  }
  getSerializeChildren() {
    return nh(this);
  }
  serialize(t) {
    const e = this.getSerializeChildren(), i = {};
    for (const { property: n, index: o, childNode: r } of e)
      o !== void 0 ? (i[n] === void 0 && (i[n] = Number.isInteger(o) ? [] : {}), i[n][o] = r.toJSON(t.meta).uuid) : i[n] = r.toJSON(t.meta).uuid;
    Object.keys(i).length > 0 && (t.inputNodes = i);
  }
  deserialize(t) {
    if (t.inputNodes !== void 0) {
      const e = t.meta.nodes;
      for (const i in t.inputNodes)
        if (Array.isArray(t.inputNodes[i])) {
          const n = [];
          for (const o of t.inputNodes[i])
            n.push(e[o]);
          this[i] = n;
        } else if (typeof t.inputNodes[i] == "object") {
          const n = {};
          for (const o in t.inputNodes[i]) {
            const r = t.inputNodes[i][o];
            n[o] = e[r];
          }
          this[i] = n;
        } else {
          const n = t.inputNodes[i];
          this[i] = e[n];
        }
    }
  }
  toJSON(t) {
    const { uuid: e, type: i } = this, n = t === void 0 || typeof t == "string";
    n && (t = {
      textures: {},
      images: {},
      nodes: {}
    });
    let o = t.nodes[e];
    o === void 0 && (o = {
      uuid: e,
      type: i,
      meta: t,
      metadata: {
        version: 4.6,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, n !== !0 && (t.nodes[o.uuid] = o), this.serialize(o), delete o.meta);
    function r(a) {
      const g = [];
      for (const c in a) {
        const l = a[c];
        delete l.metadata, g.push(l);
      }
      return g;
    }
    if (n) {
      const a = r(t.textures), g = r(t.images), c = r(t.nodes);
      a.length > 0 && (o.textures = a), g.length > 0 && (o.images = g), c.length > 0 && (o.nodes = c);
    }
    return o;
  }
}
const ct = iL;
function Le(s, t) {
  if (typeof t != "function" || !s)
    throw new Error(`Node class ${s} is not a class`);
  if (wf.has(s))
    throw new Error(`Redefinition of node class ${s}`);
  wf.set(s, t), t.type = s;
}
class Vb extends ct {
  constructor(t, e = null) {
    super(e), this.isInputNode = !0, this.value = t, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? OI(this.value) : this.nodeType;
  }
  getInputType(t) {
    return this.getNodeType(t);
  }
  setPrecision(t) {
    return this.precision = t, this;
  }
  serialize(t) {
    super.serialize(t), t.value = this.value, this.value && this.value.toArray && (t.value = this.value.toArray()), t.valueType = OI(this.value), t.nodeType = this.nodeType, t.valueType === "ArrayBuffer" && (t.value = $T(t.value)), t.precision = this.precision;
  }
  deserialize(t) {
    super.deserialize(t), this.nodeType = t.nodeType, this.value = Array.isArray(t.value) ? kb(t.valueType, ...t.value) : t.value, this.precision = t.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(t.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const QA = Vb;
Le("InputNode", Vb);
class zb extends ct {
  constructor(t, e) {
    super(), this.node = t, this.indexNode = e, this.isArrayElementNode = !0;
  }
  getNodeType(t) {
    return this.node.getNodeType(t);
  }
  generate(t) {
    const e = this.node.build(t), i = this.indexNode.build(t, "uint");
    return `${e}[ ${i} ]`;
  }
}
const Xb = zb;
Le("ArrayElementNode", zb);
class Wb extends ct {
  constructor(t, e) {
    super(), this.node = t, this.convertTo = e;
  }
  getNodeType(t) {
    const e = this.node.getNodeType(t);
    let i = null;
    for (const n of this.convertTo.split("|"))
      (i === null || t.getTypeLength(e) === t.getTypeLength(n)) && (i = n);
    return i;
  }
  serialize(t) {
    super.serialize(t), t.convertTo = this.convertTo;
  }
  deserialize(t) {
    super.deserialize(t), this.convertTo = t.convertTo;
  }
  generate(t, e) {
    const i = this.node, n = this.getNodeType(t), o = i.build(t, n);
    return t.format(o, n, e);
  }
}
const Zb = Wb;
Le("ConvertNode", Wb);
class Ub extends ct {
  constructor(t) {
    super(t), this.isTempNode = !0;
  }
  hasDependencies(t) {
    return t.getDataFromNode(this).dependenciesCount > 1;
  }
  build(t, e) {
    if (t.getBuildStage() === "generate") {
      const n = t.getVectorType(this.getNodeType(t, e)), o = t.getDataFromNode(this);
      if (t.context.tempRead !== !1 && o.propertyName !== void 0)
        return t.format(o.propertyName, n, e);
      if (t.context.tempWrite !== !1 && n !== "void" && e !== "void" && this.hasDependencies(t)) {
        const r = super.build(t, n), a = t.getVarFromNode(this, null, n), g = t.getPropertyName(a);
        return t.addLineFlowCode(`${g} = ${r}`), o.snippet = r, o.propertyName = g, t.format(o.propertyName, n, e);
      }
    }
    return super.build(t, e);
  }
}
const vr = Ub;
Le("TempNode", Ub);
class Ob extends vr {
  constructor(t = [], e = null) {
    super(e), this.nodes = t;
  }
  getNodeType(t) {
    return this.nodeType !== null ? t.getVectorType(this.nodeType) : t.getTypeFromLength(this.nodes.reduce((e, i) => e + t.getTypeLength(i.getNodeType(t)), 0));
  }
  generate(t, e) {
    const i = this.getNodeType(t), n = this.nodes, o = t.getPrimitiveType(i), r = [];
    for (const g of n) {
      let c = g.build(t);
      const l = t.getPrimitiveType(g.getNodeType(t));
      l !== o && (c = t.format(c, l, o)), r.push(c);
    }
    const a = `${t.getType(i)}( ${r.join(", ")} )`;
    return t.format(a, i, e);
  }
}
const nL = Ob;
Le("JoinNode", Ob);
const sL = UA.join("");
class Qb extends ct {
  constructor(t, e = "x") {
    super(), this.node = t, this.components = e, this.isSplitNode = !0;
  }
  getVectorLength() {
    let t = this.components.length;
    for (const e of this.components)
      t = Math.max(UA.indexOf(e) + 1, t);
    return t;
  }
  getNodeType(t) {
    return t.getTypeFromLength(this.components.length);
  }
  generate(t, e) {
    const i = this.node, n = t.getTypeLength(i.getNodeType(t));
    let o = null;
    if (n > 1) {
      let r = null;
      this.getVectorLength() >= n && (r = t.getTypeFromLength(this.getVectorLength()));
      const g = i.build(t, r);
      this.components.length === n && this.components === sL.slice(0, this.components.length) ? o = t.format(g, r, e) : o = t.format(`${g}.${this.components}`, this.getNodeType(t), e);
    } else
      o = i.build(t, e);
    return o;
  }
  serialize(t) {
    super.serialize(t), t.components = this.components;
  }
  deserialize(t) {
    super.deserialize(t), this.components = t.components;
  }
}
const _f = Qb;
Le("SplitNode", Qb);
class Yb extends vr {
  constructor(t, e, i) {
    super(), this.sourceNode = t, this.components = e, this.targetNode = i;
  }
  getNodeType(t) {
    return this.sourceNode.getNodeType(t);
  }
  generate(t) {
    const { sourceNode: e, components: i, targetNode: n } = this, o = this.getNodeType(t), r = t.getTypeFromLength(i.length), a = n.build(t, r), g = e.build(t, o), c = t.getTypeLength(o), l = [];
    for (let h = 0; h < c; h++) {
      const d = UA[h];
      d === i[0] ? (l.push(a), h += i.length - 1) : l.push(g + "." + d);
    }
    return `${t.getType(o)}( ${l.join(", ")} )`;
  }
}
const oL = Yb;
Le("SetNode", Yb);
class jb extends QA {
  constructor(t, e = null) {
    super(t, e), this.isConstNode = !0;
  }
  generateConst(t) {
    return t.getConst(this.getNodeType(t), this.value);
  }
  generate(t, e) {
    const i = this.getNodeType(t);
    return t.format(this.generateConst(t), i, e);
  }
}
const kn = jb;
Le("ConstNode", jb);
let Hg = null;
const ga = /* @__PURE__ */ new Map();
function ne(s, t) {
  if (ga.has(s))
    throw new Error(`Redefinition of node element ${s}`);
  if (typeof t != "function")
    throw new Error(`Node element ${s} is not a function`);
  ga.set(s, t);
}
const xf = (s) => s.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), Jb = {
  setup(s, t) {
    const e = t.shift();
    return s(qA(e), ...t);
  },
  get(s, t, e) {
    if (typeof t == "string" && s[t] === void 0) {
      if (s.isStackNode !== !0 && t === "assign")
        return (...i) => Hg.assign(e, ...i);
      if (ga.has(t)) {
        const i = ga.get(t);
        return s.isStackNode ? (...n) => e.add(i(...n)) : (...n) => i(e, ...n);
      } else {
        if (t === "self")
          return s;
        if (t.endsWith("Assign") && ga.has(t.slice(0, t.length - 6))) {
          const i = ga.get(t.slice(0, t.length - 6));
          return s.isStackNode ? (...n) => e.assign(n[0], i(...n)) : (...n) => e.assign(i(e, ...n));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(t) === !0)
            return t = xf(t), Xe(new _f(e, t));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(t) === !0)
            return t = xf(t.slice(3).toLowerCase()), t = t.split("").sort().join(""), (i) => Xe(new oL(s, t, i));
          if (t === "width" || t === "height" || t === "depth")
            return t === "width" ? t = "x" : t === "height" ? t = "y" : t === "depth" && (t = "z"), Xe(new _f(s, t));
          if (/^\d+$/.test(t) === !0)
            return Xe(new Xb(e, new kn(Number(t), "uint")));
        }
      }
    }
    return Reflect.get(s, t, e);
  },
  set(s, t, e, i) {
    return typeof t == "string" && s[t] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(t) === !0 || t === "width" || t === "height" || t === "depth" || /^\d+$/.test(t) === !0) ? (i[t].assign(e), !0) : Reflect.set(s, t, e, i);
  }
}, pd = /* @__PURE__ */ new WeakMap(), vf = /* @__PURE__ */ new WeakMap(), rL = function(s, t = null) {
  const e = OI(s);
  if (e === "node") {
    let i = pd.get(s);
    return i === void 0 && (i = new Proxy(s, Jb), pd.set(s, i), pd.set(i, i)), i;
  } else {
    if (t === null && (e === "float" || e === "boolean") || e && e !== "shader" && e !== "string")
      return Xe(QI(s, t));
    if (e === "shader")
      return $A(s);
  }
  return s;
}, aL = function(s, t = null) {
  for (const e in s)
    s[e] = Xe(s[e], t);
  return s;
}, gL = function(s, t = null) {
  const e = s.length;
  for (let i = 0; i < e; i++)
    s[i] = Xe(s[i], t);
  return s;
}, cL = function(s, t = null, e = null, i = null) {
  const n = (o) => Xe(i !== null ? Object.assign(o, i) : o);
  return t === null ? (...o) => n(new s(...Gl(o))) : e !== null ? (e = Xe(e), (...o) => n(new s(t, ...Gl(o), e))) : (...o) => n(new s(t, ...Gl(o)));
}, lL = function(s, ...t) {
  return Xe(new s(...Gl(t)));
};
class hL extends ct {
  constructor(t, e) {
    super(), this.shaderNode = t, this.inputNodes = e;
  }
  getNodeType(t) {
    const { outputNode: e } = t.getNodeProperties(this);
    return e ? e.getNodeType(t) : super.getNodeType(t);
  }
  call(t) {
    const { shaderNode: e, inputNodes: i } = this;
    if (e.layout) {
      let r = vf.get(t.constructor);
      r === void 0 && (r = /* @__PURE__ */ new WeakMap(), vf.set(t.constructor, r));
      let a = r.get(e);
      return a === void 0 && (a = Xe(t.buildFunctionNode(e)), r.set(e, a)), Xe(a.call(i));
    }
    const n = e.jsFunc, o = i !== null ? n(i, t.stack, t) : n(t.stack, t);
    return Xe(o);
  }
  setup(t) {
    return t.addStack(), t.stack.outputNode = this.call(t), t.removeStack();
  }
  generate(t, e) {
    const { outputNode: i } = t.getNodeProperties(this);
    return i === null ? this.call(t).build(t, e) : super.generate(t, e);
  }
}
class dL extends ct {
  constructor(t) {
    super(), this.jsFunc = t, this.layout = null;
  }
  get isArrayInput() {
    return /^\(\s+?\[/.test(this.jsFunc.toString());
  }
  setLayout(t) {
    return this.layout = t, this;
  }
  call(t = null) {
    return qA(t), Xe(new hL(this, t));
  }
  setup() {
    return this.call();
  }
}
const uL = [!1, !0], IL = [0, 1, 2, 3], AL = [-1, -2], qb = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], YA = /* @__PURE__ */ new Map();
for (const s of uL)
  YA.set(s, new kn(s));
const jA = /* @__PURE__ */ new Map();
for (const s of IL)
  jA.set(s, new kn(s, "uint"));
const JA = new Map([...jA].map((s) => new kn(s.value, "int")));
for (const s of AL)
  JA.set(s, new kn(s, "int"));
const Xh = new Map([...JA].map((s) => new kn(s.value)));
for (const s of qb)
  Xh.set(s, new kn(s));
for (const s of qb)
  Xh.set(-s, new kn(-s));
const Wh = { bool: YA, uint: jA, ints: JA, float: Xh }, Tf = new Map([...YA, ...Xh]), QI = (s, t) => Tf.has(s) ? Tf.get(s) : s.isNode === !0 ? s : new kn(s, t), CL = (s) => {
  try {
    return s.getNodeType();
  } catch {
    return;
  }
}, St = function(s, t = null) {
  return (...e) => {
    if ((e.length === 0 || !["bool", "float", "int", "uint"].includes(s) && e.every((n) => typeof n != "object")) && (e = [kb(s, ...e)]), e.length === 1 && t !== null && t.has(e[0]))
      return Xe(t.get(e[0]));
    if (e.length === 1) {
      const n = QI(e[0], s);
      return CL(n) === s ? Xe(n) : Xe(new Zb(n, s));
    }
    const i = e.map((n) => QI(n));
    return Xe(new nL(i, s));
  };
}, fL = (s) => s != null ? s.nodeType || s.convertTo || (typeof s == "string" ? s : null) : null;
function xg(s) {
  return new Proxy(new dL(s), Jb);
}
const Xe = (s, t = null) => rL(s, t), qA = (s, t = null) => new aL(s, t), Gl = (s, t = null) => new gL(s, t), de = (...s) => new cL(...s), me = (...s) => new lL(...s), $A = (s) => {
  const t = new xg(s), e = (...i) => {
    let n;
    return qA(i), i[0] && i[0].isNode ? n = [...i] : n = i[0], t.call(n);
  };
  return e.shaderNode = t, e.setLayout = (i) => (t.setLayout(i), e), e;
};
Le("ShaderNode", xg);
const sh = (s) => Hg = s, $b = () => Hg;
function pL(s) {
  return Hg && Hg.add(s), s;
}
ne("append", pL);
const mL = new St("color"), Do = new St("float", Wh.float), yL = new St("int", Wh.int), SL = new St("uint", Wh.uint), bL = new St("bool", Wh.bool), eC = new St("vec2"), BL = new St("ivec2"), wL = new St("uvec2"), _L = new St("bvec2"), Tt = new St("vec3"), xL = new St("ivec3"), vL = new St("uvec3"), TL = new St("bvec3"), Kn = new St("vec4"), LL = new St("ivec4"), GL = new St("uvec4"), ML = new St("bvec4"), eB = new St("mat3"), EL = new St("imat3"), RL = new St("umat3"), DL = new St("bmat3"), tB = new St("mat4"), KL = new St("imat4"), HL = new St("umat4"), PL = new St("bmat4"), NL = (s = "") => Xe(new kn(s, "string")), FL = (s) => Xe(new kn(s, "ArrayBuffer"));
ne("color", mL);
ne("float", Do);
ne("int", yL);
ne("uint", SL);
ne("bool", bL);
ne("vec2", eC);
ne("ivec2", BL);
ne("uvec2", wL);
ne("bvec2", _L);
ne("vec3", Tt);
ne("ivec3", xL);
ne("uvec3", vL);
ne("bvec3", TL);
ne("vec4", Kn);
ne("ivec4", LL);
ne("uvec4", GL);
ne("bvec4", ML);
ne("mat3", eB);
ne("imat3", EL);
ne("umat3", RL);
ne("bmat3", DL);
ne("mat4", tB);
ne("imat4", KL);
ne("umat4", HL);
ne("bmat4", PL);
ne("string", NL);
ne("arrayBuffer", FL);
const kL = de(Xb), VL = (s, t) => Xe(new Zb(Xe(s), t));
ne("element", kL);
ne("convert", VL);
class tC extends QA {
  constructor(t, e = null) {
    super(t, e), this.isUniformNode = !0;
  }
  getUniformHash(t) {
    return this.getHash(t);
  }
  generate(t, e) {
    const i = this.getNodeType(t), n = this.getUniformHash(t);
    let o = t.getNodeFromHash(n);
    o === void 0 && (t.setHashNode(this, n), o = this);
    const r = o.getInputType(t), a = t.getUniformFromNode(o, r, t.shaderStage, t.context.label), g = t.getPropertyName(a);
    return t.context.label !== void 0 && delete t.context.label, t.format(g, i, e);
  }
}
const Yg = tC, mr = (s, t) => {
  const e = fL(t || s), i = s && s.isNode === !0 ? s.node && s.node.value || s.value : s;
  return Xe(new tC(i, e));
};
Le("UniformNode", tC);
class iB extends ct {
  constructor(t, e = null) {
    super(), this.node = t, this.name = e, this.isVaryingNode = !0;
  }
  isGlobal() {
    return !0;
  }
  getHash(t) {
    return this.name || super.getHash(t);
  }
  getNodeType(t) {
    return this.node.getNodeType(t);
  }
  generate(t) {
    const { name: e, node: i } = this, n = this.getNodeType(t), o = t.getVaryingFromNode(this, n);
    o.needsInterpolation || (o.needsInterpolation = t.shaderStage === "fragment"), e !== null && (o.name = e);
    const r = t.getPropertyName(o, bf.VERTEX);
    return t.flowNodeFromShaderStage(bf.VERTEX, i, n, r), t.getPropertyName(o);
  }
}
const Fi = de(iB);
ne("varying", Fi);
Le("VaryingNode", iB);
class iC extends ct {
  constructor(t, e = null) {
    super(e), this._attributeName = t;
  }
  getHash(t) {
    return this.getAttributeName(t);
  }
  getNodeType(t) {
    let e = super.getNodeType(t);
    if (e === null) {
      const i = this.getAttributeName(t);
      if (t.hasGeometryAttribute(i)) {
        const n = t.geometry.getAttribute(i);
        e = t.getTypeFromAttribute(n);
      } else
        e = "float";
    }
    return e;
  }
  setAttributeName(t) {
    return this._attributeName = t, this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(t) {
    const e = this.getAttributeName(t), i = this.getNodeType(t);
    if (t.hasGeometryAttribute(e) === !0) {
      const o = t.geometry.getAttribute(e), r = t.getTypeFromAttribute(o), a = t.getAttribute(e, r);
      return t.shaderStage === "vertex" ? t.format(a.name, r, i) : Fi(this).build(t, i);
    } else
      return console.warn(`AttributeNode: Attribute "${e}" not found.`), t.getConst(i);
  }
}
const ya = (s, t) => Xe(new iC(s, t));
Le("AttributeNode", iC);
let zL = 0;
class XL {
  constructor() {
    this.id = zL++, this.nodesData = /* @__PURE__ */ new WeakMap();
  }
  getNodeData(t) {
    return this.nodesData.get(t);
  }
  setNodeData(t, e) {
    this.nodesData.set(t, e);
  }
}
const nB = XL;
class sB extends ct {
  constructor(t, e = new nB()) {
    super(), this.isCacheNode = !0, this.node = t, this.cache = e;
  }
  getNodeType(t) {
    return this.node.getNodeType(t);
  }
  build(t, ...e) {
    const i = t.getCache();
    t.setCache(this.cache);
    const n = this.node.build(t, ...e);
    return t.setCache(i), n;
  }
}
const YI = de(sB);
ne("cache", YI);
Le("CacheNode", sB);
class nC extends ct {
  constructor(t, e = {}) {
    super(), this.isContextNode = !0, this.node = t, this.context = e;
  }
  getNodeType(t) {
    return this.node.getNodeType(t);
  }
  setup(t) {
    const e = t.getContext();
    t.setContext({ ...t.context, ...this.context });
    const i = this.node.build(t);
    return t.setContext(e), i;
  }
  generate(t, e) {
    const i = t.getContext();
    t.setContext({ ...t.context, ...this.context });
    const n = this.node.build(t, e);
    return t.setContext(i), n;
  }
}
const Vs = de(nC), oB = (s, t) => Vs(s, { label: t });
ne("context", Vs);
ne("label", oB);
Le("ContextNode", nC);
class rB extends ct {
  constructor(t, e = null) {
    super(), this.node = t, this.name = e;
  }
  isGlobal() {
    return !0;
  }
  getHash(t) {
    return this.name || super.getHash(t);
  }
  getNodeType(t) {
    return this.node.getNodeType(t);
  }
  generate(t) {
    const { node: e, name: i } = this, n = t.getVarFromNode(this, i, t.getVectorType(this.getNodeType(t))), o = t.getPropertyName(n), r = e.build(t, n.type);
    return t.addLineFlowCode(`${o} = ${r}`), o;
  }
}
const sC = de(rB);
ne("temp", sC);
ne("toVar", (...s) => sC(...s).append());
Le("VarNode", rB);
class WL {
  constructor(t, e, i = null) {
    this.isNodeAttribute = !0, this.name = t, this.type = e, this.node = i;
  }
}
const Lf = WL;
class ZL {
  constructor(t, e, i, n = void 0) {
    this.isNodeUniform = !0, this.name = t, this.type = e, this.node = i.getSelf(), this.needsUpdate = n;
  }
  get value() {
    return this.node.value;
  }
  set value(t) {
    this.node.value = t;
  }
}
const UL = ZL;
class OL {
  constructor(t, e) {
    this.isNodeVar = !0, this.name = t, this.type = e;
  }
}
const aB = OL;
class QL extends aB {
  constructor(t, e) {
    super(t, e), this.needsInterpolation = !1, this.isNodeVarying = !0;
  }
}
const YL = QL;
class jL {
  constructor(t, e, i = "") {
    this.name = t, this.type = e, this.code = i, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
const JL = jL;
class qL {
  constructor() {
    this.keywords = [], this.nodes = [], this.keywordsCallback = {};
  }
  getNode(t) {
    let e = this.nodes[t];
    return e === void 0 && this.keywordsCallback[t] !== void 0 && (e = this.keywordsCallback[t](t), this.nodes[t] = e), e;
  }
  addKeyword(t, e) {
    return this.keywords.push(t), this.keywordsCallback[t] = e, this;
  }
  parse(t) {
    const e = this.keywords, i = new RegExp(`\\b${e.join("\\b|\\b")}\\b`, "g"), n = t.match(i), o = [];
    if (n !== null)
      for (const r of n) {
        const a = this.getNode(r);
        a !== void 0 && o.indexOf(a) === -1 && o.push(a);
      }
    return o;
  }
  include(t, e) {
    const i = this.parse(e);
    for (const n of i)
      n.build(t);
  }
}
const $L = qL;
class si extends ct {
  constructor(t, e = null) {
    super(t), this.name = e, this.isPropertyNode = !0;
  }
  getHash(t) {
    return this.name || super.getHash(t);
  }
  isGlobal() {
    return !0;
  }
  generate(t) {
    return t.getPropertyName(t.getVarFromNode(this, this.name));
  }
}
const oC = (s, t) => Xe(new si(s, t)), Er = me(si, "vec4", "DiffuseColor"), eG = me(si, "float", "Roughness");
me(si, "float", "Metalness");
me(si, "float", "Clearcoat");
const tG = me(si, "float", "ClearcoatRoughness");
me(si, "vec3", "Sheen");
me(si, "float", "SheenRoughness");
me(si, "float", "Iridescence");
me(si, "float", "IridescenceIOR");
me(si, "float", "IridescenceThickness");
me(si, "color", "SpecularColor");
me(si, "float", "Shininess");
const iG = me(si, "vec4", "Output");
me(si, "float", "dashSize");
me(si, "float", "gapSize");
me(si, "float", "pointWidth");
Le("PropertyNode", si);
class gB extends si {
  constructor(t, e = null) {
    super(t, e), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
const Gf = gB;
Le("ParameterNode", gB);
class cB extends iC {
  constructor(t = 0) {
    super(null, "vec2"), this.isUVNode = !0, this.index = t;
  }
  getAttributeName() {
    const t = this.index;
    return "uv" + (t > 0 ? t : "");
  }
  serialize(t) {
    super.serialize(t), t.index = this.index;
  }
  deserialize(t) {
    super.deserialize(t), this.index = t.index;
  }
}
const nG = (...s) => Xe(new cB(...s));
Le("UVNode", cB);
class lB extends ct {
  constructor(t, e = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = t, this.levelNode = e;
  }
  generate(t, e) {
    const i = this.textureNode.build(t, "property"), n = this.levelNode.build(t, "int");
    return t.format(`${t.getMethod("textureDimensions")}( ${i}, ${n} )`, this.getNodeType(t), e);
  }
}
const hB = de(lB);
ne("textureSize", hB);
Le("TextureSizeNode", lB);
class Rt extends vr {
  constructor(t, e, i, ...n) {
    if (super(), this.op = t, n.length > 0) {
      let o = i;
      for (let r = 0; r < n.length; r++)
        o = new Rt(t, o, n[r]);
      i = o;
    }
    this.aNode = e, this.bNode = i;
  }
  getNodeType(t, e) {
    const i = this.op, n = this.aNode, o = this.bNode, r = n.getNodeType(t), a = o.getNodeType(t);
    if (r === "void" || a === "void")
      return "void";
    if (i === "%")
      return r;
    if (i === "&" || i === "|" || i === "^" || i === ">>" || i === "<<")
      return t.getIntegerType(r);
    if (i === "==" || i === "&&" || i === "||" || i === "^^")
      return "bool";
    if (i === "<" || i === ">" || i === "<=" || i === ">=") {
      const g = e ? t.getTypeLength(e) : Math.max(t.getTypeLength(r), t.getTypeLength(a));
      return g > 1 ? `bvec${g}` : "bool";
    } else
      return r === "float" && t.isMatrix(a) ? a : t.isMatrix(r) && t.isVector(a) ? t.getVectorFromMatrix(r) : t.isVector(r) && t.isMatrix(a) ? t.getVectorFromMatrix(a) : t.getTypeLength(a) > t.getTypeLength(r) ? a : r;
  }
  generate(t, e) {
    const i = this.op, n = this.aNode, o = this.bNode, r = this.getNodeType(t, e);
    let a = null, g = null;
    r !== "void" ? (a = n.getNodeType(t), g = o.getNodeType(t), i === "<" || i === ">" || i === "<=" || i === ">=" || i === "==" ? t.isVector(a) ? g = a : a = g = "float" : i === ">>" || i === "<<" ? (a = r, g = t.changeComponentType(g, "uint")) : t.isMatrix(a) && t.isVector(g) ? g = t.getVectorFromMatrix(a) : t.isVector(a) && t.isMatrix(g) ? a = t.getVectorFromMatrix(g) : a = g = r) : a = g = r;
    const c = n.build(t, a), l = o.build(t, g), h = t.getTypeLength(e);
    if (e !== "void")
      return i === "<" && h > 1 ? t.format(`${t.getMethod("lessThan")}( ${c}, ${l} )`, r, e) : i === "<=" && h > 1 ? t.format(`${t.getMethod("lessThanEqual")}( ${c}, ${l} )`, r, e) : i === ">" && h > 1 ? t.format(`${t.getMethod("greaterThan")}( ${c}, ${l} )`, r, e) : i === ">=" && h > 1 ? t.format(`${t.getMethod("greaterThanEqual")}( ${c}, ${l} )`, r, e) : t.format(`( ${c} ${this.op} ${l} )`, r, e);
    if (a !== "void")
      return t.format(`${c} ${this.op} ${l}`, r, e);
  }
  serialize(t) {
    super.serialize(t), t.op = this.op;
  }
  deserialize(t) {
    super.deserialize(t), this.op = t.op;
  }
}
const jI = de(Rt, "+"), JI = de(Rt, "-"), dB = de(Rt, "*"), uB = de(Rt, "/"), sG = de(Rt, "%"), oG = de(Rt, "=="), rG = de(Rt, "!="), aG = de(Rt, "<"), gG = de(Rt, ">"), cG = de(Rt, "<="), lG = de(Rt, ">="), hG = de(Rt, "&&"), dG = de(Rt, "||"), uG = de(Rt, "^^"), IG = de(Rt, "&"), AG = de(Rt, "|"), CG = de(Rt, "^"), fG = de(Rt, "<<"), pG = de(Rt, ">>");
ne("add", jI);
ne("sub", JI);
ne("mul", dB);
ne("div", uB);
ne("remainder", sG);
ne("equal", oG);
ne("notEqual", rG);
ne("lessThan", aG);
ne("greaterThan", gG);
ne("lessThanEqual", cG);
ne("greaterThanEqual", lG);
ne("and", hG);
ne("or", dG);
ne("xor", uG);
ne("bitAnd", IG);
ne("bitOr", AG);
ne("bitXor", CG);
ne("shiftLeft", fG);
ne("shiftRight", pG);
Le("OperatorNode", Rt);
class j extends vr {
  constructor(t, e, i = null, n = null) {
    super(), this.method = t, this.aNode = e, this.bNode = i, this.cNode = n;
  }
  getInputType(t) {
    const e = this.aNode.getNodeType(t), i = this.bNode ? this.bNode.getNodeType(t) : null, n = this.cNode ? this.cNode.getNodeType(t) : null, o = t.isMatrix(e) ? 0 : t.getTypeLength(e), r = t.isMatrix(i) ? 0 : t.getTypeLength(i), a = t.isMatrix(n) ? 0 : t.getTypeLength(n);
    return o > r && o > a ? e : r > a ? i : a > o ? n : e;
  }
  getNodeType(t) {
    const e = this.method;
    return e === j.LENGTH || e === j.DISTANCE || e === j.DOT ? "float" : e === j.CROSS ? "vec3" : this.getInputType(t);
  }
  generate(t, e) {
    const i = this.method, n = this.getNodeType(t), o = this.getInputType(t), r = this.aNode, a = this.bNode, g = this.cNode, c = t.renderer.isWebGLRenderer === !0;
    if (i === j.TRANSFORM_DIRECTION) {
      let l = r, h = a;
      t.isMatrix(l.getNodeType(t)) ? h = Kn(Tt(h), 0) : l = Kn(Tt(l), 0);
      const d = dB(l, h).xyz;
      return Ws(d).build(t, e);
    } else {
      if (i === j.NEGATE)
        return t.format("( - " + r.build(t, o) + " )", n, e);
      if (i === j.ONE_MINUS)
        return JI(1, r).build(t, e);
      if (i === j.RECIPROCAL)
        return uB(1, r).build(t, e);
      if (i === j.DIFFERENCE)
        return IB(JI(r, a)).build(t, e);
      {
        const l = [];
        return i === j.CROSS ? l.push(
          r.build(t, n),
          a.build(t, n)
        ) : i === j.STEP ? l.push(
          r.build(t, t.getTypeLength(r.getNodeType(t)) === 1 ? "float" : o),
          a.build(t, o)
        ) : c && (i === j.MIN || i === j.MAX) || i === j.MOD ? l.push(
          r.build(t, o),
          a.build(t, t.getTypeLength(a.getNodeType(t)) === 1 ? "float" : o)
        ) : i === j.REFRACT ? l.push(
          r.build(t, o),
          a.build(t, o),
          g.build(t, "float")
        ) : i === j.MIX ? l.push(
          r.build(t, o),
          a.build(t, o),
          g.build(t, t.getTypeLength(g.getNodeType(t)) === 1 ? "float" : o)
        ) : (l.push(r.build(t, o)), a !== null && l.push(a.build(t, o)), g !== null && l.push(g.build(t, o))), t.format(`${t.getMethod(i)}( ${l.join(", ")} )`, n, e);
      }
    }
  }
  serialize(t) {
    super.serialize(t), t.method = this.method;
  }
  deserialize(t) {
    super.deserialize(t), this.method = t.method;
  }
}
j.RADIANS = "radians";
j.DEGREES = "degrees";
j.EXP = "exp";
j.EXP2 = "exp2";
j.LOG = "log";
j.LOG2 = "log2";
j.SQRT = "sqrt";
j.INVERSE_SQRT = "inversesqrt";
j.FLOOR = "floor";
j.CEIL = "ceil";
j.NORMALIZE = "normalize";
j.FRACT = "fract";
j.SIN = "sin";
j.COS = "cos";
j.TAN = "tan";
j.ASIN = "asin";
j.ACOS = "acos";
j.ATAN = "atan";
j.ABS = "abs";
j.SIGN = "sign";
j.LENGTH = "length";
j.NEGATE = "negate";
j.ONE_MINUS = "oneMinus";
j.DFDX = "dFdx";
j.DFDY = "dFdy";
j.ROUND = "round";
j.RECIPROCAL = "reciprocal";
j.TRUNC = "trunc";
j.FWIDTH = "fwidth";
j.ATAN2 = "atan2";
j.MIN = "min";
j.MAX = "max";
j.MOD = "mod";
j.STEP = "step";
j.REFLECT = "reflect";
j.DISTANCE = "distance";
j.DIFFERENCE = "difference";
j.DOT = "dot";
j.CROSS = "cross";
j.POW = "pow";
j.TRANSFORM_DIRECTION = "transformDirection";
j.MIX = "mix";
j.CLAMP = "clamp";
j.REFRACT = "refract";
j.SMOOTHSTEP = "smoothstep";
j.FACEFORWARD = "faceforward";
const mG = j;
Do(1e-6);
Do(1e6);
const yG = de(j, j.RADIANS), SG = de(j, j.DEGREES), bG = de(j, j.EXP), BG = de(j, j.EXP2), wG = de(j, j.LOG), _G = de(j, j.LOG2), xG = de(j, j.SQRT), vG = de(j, j.INVERSE_SQRT), TG = de(j, j.FLOOR), LG = de(j, j.CEIL), Ws = de(j, j.NORMALIZE), GG = de(j, j.FRACT), MG = de(j, j.SIN), EG = de(j, j.COS), RG = de(j, j.TAN), DG = de(j, j.ASIN), KG = de(j, j.ACOS), HG = de(j, j.ATAN), IB = de(j, j.ABS), PG = de(j, j.SIGN), NG = de(j, j.LENGTH), FG = de(j, j.NEGATE), kG = de(j, j.ONE_MINUS), VG = de(j, j.DFDX), zG = de(j, j.DFDY), XG = de(j, j.ROUND), WG = de(j, j.RECIPROCAL), ZG = de(j, j.TRUNC), UG = de(j, j.FWIDTH), OG = de(j, j.ATAN2), QG = de(j, j.MIN), YG = de(j, j.MAX), jG = de(j, j.MOD), JG = de(j, j.STEP), qG = de(j, j.REFLECT), $G = de(j, j.DISTANCE), eM = de(j, j.DIFFERENCE), tM = de(j, j.DOT), iM = de(j, j.CROSS), nM = de(j, j.POW), sM = de(j, j.POW, 2), oM = de(j, j.POW, 3), rM = de(j, j.POW, 4), aM = de(j, j.TRANSFORM_DIRECTION), Zh = de(j, j.MIX), AB = (s, t = 0, e = 1) => Xe(new j(j.CLAMP, Xe(s), Xe(t), Xe(e))), gM = (s) => AB(s), cM = de(j, j.REFRACT), lM = de(j, j.SMOOTHSTEP), hM = de(j, j.FACEFORWARD), dM = (s, t, e) => Zh(t, e, s), uM = (s, t, e) => lM(t, e, s);
ne("radians", yG);
ne("degrees", SG);
ne("exp", bG);
ne("exp2", BG);
ne("log", wG);
ne("log2", _G);
ne("sqrt", xG);
ne("inverseSqrt", vG);
ne("floor", TG);
ne("ceil", LG);
ne("normalize", Ws);
ne("fract", GG);
ne("sin", MG);
ne("cos", EG);
ne("tan", RG);
ne("asin", DG);
ne("acos", KG);
ne("atan", HG);
ne("abs", IB);
ne("sign", PG);
ne("length", NG);
ne("negate", FG);
ne("oneMinus", kG);
ne("dFdx", VG);
ne("dFdy", zG);
ne("round", XG);
ne("reciprocal", WG);
ne("trunc", ZG);
ne("fwidth", UG);
ne("atan2", OG);
ne("min", QG);
ne("max", YG);
ne("mod", jG);
ne("step", JG);
ne("reflect", qG);
ne("distance", $G);
ne("dot", tM);
ne("cross", iM);
ne("pow", nM);
ne("pow2", sM);
ne("pow3", oM);
ne("pow4", rM);
ne("transformDirection", aM);
ne("mix", dM);
ne("clamp", AB);
ne("refract", cM);
ne("smoothstep", uM);
ne("faceForward", hM);
ne("difference", eM);
ne("saturate", gM);
Le("MathNode", j);
const IM = $A((s) => {
  const { value: t } = s, { rgb: e } = t, i = e.mul(0.9478672986).add(0.0521327014).pow(2.4), n = e.mul(0.0773993808), o = e.lessThanEqual(0.04045), r = Zh(i, n, o);
  return Kn(r, t.a);
}), AM = $A((s) => {
  const { value: t } = s, { rgb: e } = t, i = e.pow(0.41666).mul(1.055).sub(0.055), n = e.mul(12.92), o = e.lessThanEqual(31308e-7), r = Zh(i, n, o);
  return Kn(r, t.a);
}), Mf = (s) => {
  let t = null;
  return s === Vi ? t = "Linear" : s === gt && (t = "sRGB"), t;
}, CB = (s, t) => Mf(s) + "To" + Mf(t);
class zi extends vr {
  constructor(t, e) {
    super("vec4"), this.method = t, this.node = e;
  }
  setup() {
    const { method: t, node: e } = this;
    return t === zi.LINEAR_TO_LINEAR ? e : CM[t]({ value: e });
  }
}
zi.LINEAR_TO_LINEAR = "LinearToLinear";
zi.LINEAR_TO_sRGB = "LinearTosRGB";
zi.sRGB_TO_LINEAR = "sRGBToLinear";
const CM = {
  [zi.LINEAR_TO_sRGB]: AM,
  [zi.sRGB_TO_LINEAR]: IM
}, fM = (s, t) => Xe(new zi(CB(Vi, t), Xe(s))), rC = (s, t) => Xe(new zi(CB(t, Vi), Xe(s))), pM = de(zi, zi.LINEAR_TO_sRGB), mM = de(zi, zi.sRGB_TO_LINEAR);
ne("linearTosRGB", pM);
ne("sRGBToLinear", mM);
ne("linearToColorSpace", fM);
ne("colorSpaceToLinear", rC);
Le("ColorSpaceNode", zi);
class fB extends ct {
  constructor(t = "", e = "void") {
    super(e), this.snippet = t;
  }
  generate(t, e) {
    const i = this.getNodeType(t), n = this.snippet;
    if (i === "void")
      t.addLineFlowCode(n);
    else
      return t.format(`( ${n} )`, i, e);
  }
}
const pB = de(fB);
Le("ExpressionNode", fB);
class aC extends Yg {
  constructor(t, e = null, i = null, n = null) {
    super(t), this.isTextureNode = !0, this.uvNode = e, this.levelNode = i, this.compareNode = n, this.updateMatrix = !1, this.updateType = Kt.NONE, this.setUpdateMatrix(e === null);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return nG(this.value.channel);
  }
  updateReference() {
    return this.value;
  }
  getTransformedUV(t) {
    const e = this.value;
    return mr(e.matrix).mul(Tt(t, 1)).xy;
  }
  setUpdateMatrix(t) {
    return this.updateMatrix = t, this.updateType = t ? Kt.FRAME : Kt.NONE, this;
  }
  setup(t) {
    const e = t.getNodeProperties(this);
    let i = this.uvNode;
    (i === null || t.context.forceUVContext === !0) && t.context.getUVNode && (i = t.context.getUVNode(this)), i || (i = this.getDefaultUV()), this.updateMatrix === !0 && (i = this.getTransformedUV(i));
    let n = this.levelNode;
    n === null && t.context.getSamplerLevelNode && (n = t.context.getSamplerLevelNode(this)), e.uvNode = i, e.levelNode = n ? t.context.getMIPLevelAlgorithmNode(this, n) : null;
  }
  generate(t, e) {
    const { uvNode: i, levelNode: n } = t.getNodeProperties(this), o = this.compareNode, r = this.value;
    if (!r || r.isTexture !== !0)
      throw new Error("TextureNode: Need a three.js texture.");
    const a = super.generate(t, "property");
    if (e === "sampler")
      return a + "_sampler";
    if (t.isReference(e))
      return a;
    {
      const g = t.getDataFromNode(this);
      let c = g.propertyName;
      if (c === void 0) {
        const d = i.build(t, "vec2"), C = t.getVarFromNode(this);
        c = t.getPropertyName(C);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(t, "float");
          p = t.getTextureLevel(r, a, d, m);
        } else if (o !== null) {
          const m = o.build(t, "float");
          p = t.getTextureCompare(r, a, d, m);
        } else
          p = t.getTexture(r, a, d);
        t.addLineFlowCode(`${c} = ${p}`), t.context.tempWrite !== !1 && (g.snippet = p, g.propertyName = c);
      }
      let l = c;
      const h = this.getNodeType(t);
      return t.needsColorSpaceToLinear(this.value) && (l = rC(pB(l, h), this.value.colorSpace).setup(t).build(t, h)), t.format(l, h, e);
    }
  }
  uv(t) {
    const e = this.clone();
    return e.uvNode = t, Xe(e);
  }
  level(t) {
    const e = this.clone();
    return e.levelNode = t, Vs(e, {
      getMIPLevelAlgorithmNode: (i, n) => n
    });
  }
  size(t) {
    return hB(this, t);
  }
  compare(t) {
    const e = this.clone();
    return e.compareNode = Xe(t), Xe(e);
  }
  serialize(t) {
    super.serialize(t), t.value = this.value.toJSON(t.meta).uuid;
  }
  deserialize(t) {
    super.deserialize(t), this.value = t.meta.textures[t.value];
  }
  update() {
    const t = this.value;
    t.matrixAutoUpdate === !0 && t.updateMatrix();
  }
  clone() {
    return new this.constructor(this.value, this.uvNode, this.levelNode, this.compareNode);
  }
}
const Sa = de(aC);
ne("texture", Sa);
Le("TextureNode", aC);
class gC extends ct {
  constructor(t, e, i = null) {
    super(), this.property = t, this.uniformType = e, this.object = i, this.reference = null, this.node = null, this.updateType = Kt.OBJECT, this.setNodeType(e);
  }
  updateReference(t) {
    return this.reference = this.object !== null ? this.object : t.object, this.reference;
  }
  setNodeType(t) {
    let e = null;
    t === "texture" ? e = Sa(null) : e = mr(t), this.node = e;
  }
  getNodeType(t) {
    return this.node.getNodeType(t);
  }
  update() {
    this.node.value = this.reference[this.property];
  }
  setup() {
    return this.node;
  }
}
const ba = (s, t, e) => Xe(new gC(s, t, e));
Le("ReferenceNode", gC);
class mB extends gC {
  constructor(t, e, i = null) {
    super(t, e, i), this.material = i, this.updateType = Kt.RENDER;
  }
  updateReference(t) {
    return this.reference = this.material !== null ? this.material : t.material, this.reference;
  }
  setup(t) {
    const e = this.material !== null ? this.material : t.material;
    return this.node.value = e[this.property], super.setup(t);
  }
}
const yM = (s, t, e) => Xe(new mB(s, t, e));
Le("MaterialReferenceNode", mB);
class He extends ct {
  constructor(t = He.VIEW_MATRIX, e = null) {
    super(), this.scope = t, this.object3d = e, this.updateType = Kt.OBJECT, this._uniformNode = new Yg(null);
  }
  getNodeType() {
    const t = this.scope;
    if (t === He.WORLD_MATRIX || t === He.VIEW_MATRIX)
      return "mat4";
    if (t === He.NORMAL_MATRIX)
      return "mat3";
    if (t === He.POSITION || t === He.VIEW_POSITION || t === He.DIRECTION || t === He.SCALE)
      return "vec3";
  }
  update(t) {
    const e = this.object3d, i = this._uniformNode, n = this.scope;
    if (n === He.VIEW_MATRIX)
      i.value = e.modelViewMatrix;
    else if (n === He.NORMAL_MATRIX)
      i.value = e.normalMatrix;
    else if (n === He.WORLD_MATRIX)
      i.value = e.matrixWorld;
    else if (n === He.POSITION)
      i.value = i.value || new B(), i.value.setFromMatrixPosition(e.matrixWorld);
    else if (n === He.SCALE)
      i.value = i.value || new B(), i.value.setFromMatrixScale(e.matrixWorld);
    else if (n === He.DIRECTION)
      i.value = i.value || new B(), e.getWorldDirection(i.value);
    else if (n === He.VIEW_POSITION) {
      const o = t.camera;
      i.value = i.value || new B(), i.value.setFromMatrixPosition(e.matrixWorld), i.value.applyMatrix4(o.matrixWorldInverse);
    }
  }
  generate(t) {
    const e = this.scope;
    return e === He.WORLD_MATRIX || e === He.VIEW_MATRIX ? this._uniformNode.nodeType = "mat4" : e === He.NORMAL_MATRIX ? this._uniformNode.nodeType = "mat3" : (e === He.POSITION || e === He.VIEW_POSITION || e === He.DIRECTION || e === He.SCALE) && (this._uniformNode.nodeType = "vec3"), this._uniformNode.build(t);
  }
  serialize(t) {
    super.serialize(t), t.scope = this.scope;
  }
  deserialize(t) {
    super.deserialize(t), this.scope = t.scope;
  }
}
He.VIEW_MATRIX = "viewMatrix";
He.NORMAL_MATRIX = "normalMatrix";
He.WORLD_MATRIX = "worldMatrix";
He.POSITION = "position";
He.SCALE = "scale";
He.VIEW_POSITION = "viewPosition";
He.DIRECTION = "direction";
const yB = He;
de(He, He.DIRECTION);
de(He, He.VIEW_MATRIX);
de(He, He.NORMAL_MATRIX);
de(He, He.WORLD_MATRIX);
de(He, He.POSITION);
de(He, He.SCALE);
de(He, He.VIEW_POSITION);
Le("Object3DNode", He);
class ht extends yB {
  constructor(t = ht.POSITION) {
    super(t);
  }
  getNodeType(t) {
    const e = this.scope;
    return e === ht.PROJECTION_MATRIX ? "mat4" : e === ht.NEAR || e === ht.FAR ? "float" : super.getNodeType(t);
  }
  update(t) {
    const e = t.camera, i = this._uniformNode, n = this.scope;
    n === ht.VIEW_MATRIX ? i.value = e.matrixWorldInverse : n === ht.PROJECTION_MATRIX ? i.value = e.projectionMatrix : n === ht.NEAR ? i.value = e.near : n === ht.FAR ? i.value = e.far : (this.object3d = e, super.update(t));
  }
  generate(t) {
    const e = this.scope;
    return e === ht.PROJECTION_MATRIX ? this._uniformNode.nodeType = "mat4" : (e === ht.NEAR || e === ht.FAR) && (this._uniformNode.nodeType = "float"), super.generate(t);
  }
}
ht.PROJECTION_MATRIX = "projectionMatrix";
ht.NEAR = "near";
ht.FAR = "far";
const SM = oB(me(ht, ht.PROJECTION_MATRIX), "projectionMatrix");
me(ht, ht.NEAR);
me(ht, ht.FAR);
const Ea = me(ht, ht.VIEW_MATRIX);
me(ht, ht.NORMAL_MATRIX);
me(ht, ht.WORLD_MATRIX);
me(ht, ht.POSITION);
Le("CameraNode", ht);
class fi extends yB {
  constructor(t = fi.VIEW_MATRIX) {
    super(t);
  }
  update(t) {
    this.object3d = t.object, super.update(t);
  }
}
me(fi, fi.DIRECTION);
const cC = me(fi, fi.VIEW_MATRIX).temp("ModelViewMatrix"), bM = me(fi, fi.NORMAL_MATRIX), Ef = me(fi, fi.WORLD_MATRIX);
me(fi, fi.POSITION);
me(fi, fi.SCALE);
me(fi, fi.VIEW_POSITION);
Le("ModelNode", fi);
class ei extends ct {
  constructor(t = ei.LOCAL) {
    super("vec3"), this.scope = t;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(t) {
    const e = this.scope;
    let i = null;
    if (e === ei.GEOMETRY)
      i = ya("normal", "vec3");
    else if (e === ei.LOCAL)
      i = Fi(BM);
    else if (e === ei.VIEW) {
      const n = bM.mul(Pg);
      i = Ws(Fi(n));
    } else if (e === ei.WORLD) {
      const n = oh.transformDirection(Ea);
      i = Ws(Fi(n));
    }
    return i.build(t, this.getNodeType(t));
  }
  serialize(t) {
    super.serialize(t), t.scope = this.scope;
  }
  deserialize(t) {
    super.deserialize(t), this.scope = t.scope;
  }
}
ei.GEOMETRY = "geometry";
ei.LOCAL = "local";
ei.VIEW = "view";
ei.WORLD = "world";
const BM = me(ei, ei.GEOMETRY), Pg = me(ei, ei.LOCAL).temp("Normal"), oh = me(ei, ei.VIEW), wM = me(ei, ei.WORLD), Ng = oC("vec3", "TransformedNormalView"), _M = Ng.transformDirection(Ea).normalize(), xM = oC("vec3", "TransformedClearcoatNormalView");
Le("NormalNode", ei);
const Rf = /* @__PURE__ */ new Map();
class ue extends ct {
  constructor(t) {
    super(), this.scope = t;
  }
  getCache(t, e) {
    let i = Rf.get(t);
    return i === void 0 && (i = yM(t, e), Rf.set(t, i)), i;
  }
  getFloat(t) {
    return this.getCache(t, "float");
  }
  getColor(t) {
    return this.getCache(t, "color");
  }
  getTexture(t) {
    return this.getCache(t === "map" ? "map" : t + "Map", "texture");
  }
  setup(t) {
    const e = t.context.material, i = this.scope;
    let n = null;
    if (i === ue.COLOR) {
      const o = this.getColor(i);
      e.map && e.map.isTexture === !0 ? n = o.mul(this.getTexture("map")) : n = o;
    } else if (i === ue.OPACITY) {
      const o = this.getFloat(i);
      e.alphaMap && e.alphaMap.isTexture === !0 ? n = o.mul(this.getTexture("alpha")) : n = o;
    } else if (i === ue.SPECULAR_STRENGTH)
      e.specularMap && e.specularMap.isTexture === !0 ? n = this.getTexture(i).r : n = Do(1);
    else if (i === ue.ROUGHNESS) {
      const o = this.getFloat(i);
      e.roughnessMap && e.roughnessMap.isTexture === !0 ? n = o.mul(this.getTexture(i).g) : n = o;
    } else if (i === ue.METALNESS) {
      const o = this.getFloat(i);
      e.metalnessMap && e.metalnessMap.isTexture === !0 ? n = o.mul(this.getTexture(i).b) : n = o;
    } else if (i === ue.EMISSIVE) {
      const o = this.getColor(i);
      e.emissiveMap && e.emissiveMap.isTexture === !0 ? n = o.mul(this.getTexture(i)) : n = o;
    } else if (i === ue.NORMAL)
      e.normalMap ? n = this.getTexture("normal").normalMap(this.getCache("normalScale", "vec2")) : e.bumpMap ? n = this.getTexture("bump").r.bumpMap(this.getFloat("bumpScale")) : n = oh;
    else if (i === ue.CLEARCOAT) {
      const o = this.getFloat(i);
      e.clearcoatMap && e.clearcoatMap.isTexture === !0 ? n = o.mul(this.getTexture(i).r) : n = o;
    } else if (i === ue.CLEARCOAT_ROUGHNESS) {
      const o = this.getFloat(i);
      e.clearcoatRoughnessMap && e.clearcoatRoughnessMap.isTexture === !0 ? n = o.mul(this.getTexture(i).r) : n = o;
    } else if (i === ue.CLEARCOAT_NORMAL)
      e.clearcoatNormalMap ? n = this.getTexture(i).normalMap(this.getCache(i + "Scale", "vec2")) : n = oh;
    else if (i === ue.SHEEN) {
      const o = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      e.sheenColorMap && e.sheenColorMap.isTexture === !0 ? n = o.mul(this.getTexture("sheenColor").rgb) : n = o;
    } else if (i === ue.SHEEN_ROUGHNESS) {
      const o = this.getFloat(i);
      e.sheenRoughnessMap && e.sheenRoughnessMap.isTexture === !0 ? n = o.mul(this.getTexture(i).a) : n = o, n = n.clamp(0.07, 1);
    } else if (i === ue.IRIDESCENCE_THICKNESS) {
      const o = ba(1, "float", e.iridescenceThicknessRange);
      if (e.iridescenceThicknessMap) {
        const r = ba(0, "float", e.iridescenceThicknessRange);
        n = o.sub(r).mul(this.getTexture(i).g).add(r);
      } else
        n = o;
    } else {
      const o = this.getNodeType(t);
      n = this.getCache(i, o);
    }
    return n;
  }
}
ue.ALPHA_TEST = "alphaTest";
ue.COLOR = "color";
ue.OPACITY = "opacity";
ue.SHININESS = "shininess";
ue.SPECULAR_COLOR = "specular";
ue.SPECULAR_STRENGTH = "specularStrength";
ue.REFLECTIVITY = "reflectivity";
ue.ROUGHNESS = "roughness";
ue.METALNESS = "metalness";
ue.NORMAL = "normal";
ue.CLEARCOAT = "clearcoat";
ue.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
ue.CLEARCOAT_NORMAL = "clearcoatNormal";
ue.EMISSIVE = "emissive";
ue.ROTATION = "rotation";
ue.SHEEN = "sheen";
ue.SHEEN_ROUGHNESS = "sheenRoughness";
ue.IRIDESCENCE = "iridescence";
ue.IRIDESCENCE_IOR = "iridescenceIOR";
ue.IRIDESCENCE_THICKNESS = "iridescenceThickness";
ue.LINE_SCALE = "scale";
ue.LINE_DASH_SIZE = "dashSize";
ue.LINE_GAP_SIZE = "gapSize";
ue.LINE_WIDTH = "linewidth";
ue.LINE_DASH_OFFSET = "dashOffset";
ue.POINT_WIDTH = "pointWidth";
const vM = me(ue, ue.ALPHA_TEST), TM = me(ue, ue.COLOR);
me(ue, ue.SHININESS);
const LM = me(ue, ue.EMISSIVE), GM = me(ue, ue.OPACITY);
me(ue, ue.SPECULAR_COLOR);
me(ue, ue.SPECULAR_STRENGTH);
me(ue, ue.REFLECTIVITY);
me(ue, ue.ROUGHNESS);
me(ue, ue.METALNESS);
const MM = me(ue, ue.NORMAL);
me(ue, ue.CLEARCOAT);
me(ue, ue.CLEARCOAT_ROUGHNESS);
me(ue, ue.CLEARCOAT_NORMAL);
me(ue, ue.ROTATION);
me(ue, ue.SHEEN);
me(ue, ue.SHEEN_ROUGHNESS);
me(ue, ue.IRIDESCENCE);
me(ue, ue.IRIDESCENCE_IOR);
me(ue, ue.IRIDESCENCE_THICKNESS);
me(ue, ue.LINE_SCALE);
me(ue, ue.LINE_DASH_SIZE);
me(ue, ue.LINE_GAP_SIZE);
me(ue, ue.LINE_WIDTH);
me(ue, ue.LINE_DASH_OFFSET);
me(ue, ue.POINT_WIDTH);
Le("MaterialNode", ue);
class Ct extends ct {
  constructor(t = Ct.LOCAL) {
    super("vec3"), this.scope = t;
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(t) {
    const e = this.scope;
    let i = null;
    if (e === Ct.GEOMETRY)
      i = ya("position", "vec3");
    else if (e === Ct.LOCAL)
      i = Fi(EM);
    else if (e === Ct.WORLD) {
      const n = Ef.mul(Pn);
      i = Fi(n);
    } else if (e === Ct.VIEW) {
      const n = cC.mul(Pn);
      i = Fi(n);
    } else if (e === Ct.VIEW_DIRECTION) {
      const n = qI.negate();
      i = Ws(Fi(n));
    } else if (e === Ct.WORLD_DIRECTION) {
      const n = Pn.transformDirection(Ef);
      i = Ws(Fi(n));
    }
    return i.build(t, this.getNodeType(t));
  }
  serialize(t) {
    super.serialize(t), t.scope = this.scope;
  }
  deserialize(t) {
    super.deserialize(t), this.scope = t.scope;
  }
}
Ct.GEOMETRY = "geometry";
Ct.LOCAL = "local";
Ct.WORLD = "world";
Ct.WORLD_DIRECTION = "worldDirection";
Ct.VIEW = "view";
Ct.VIEW_DIRECTION = "viewDirection";
const EM = me(Ct, Ct.GEOMETRY), Pn = me(Ct, Ct.LOCAL).temp("Position"), RM = me(Ct, Ct.WORLD), SB = me(Ct, Ct.WORLD_DIRECTION), qI = me(Ct, Ct.VIEW), bB = me(Ct, Ct.VIEW_DIRECTION);
Le("PositionNode", Ct);
class BB extends vr {
  constructor(t = Pn) {
    super("vec4"), this.positionNode = t;
  }
  setup() {
    return SM.mul(cC).mul(this.positionNode);
  }
}
const DM = de(BB);
Le("ModelViewProjectionNode", BB);
class wB extends QA {
  constructor(t, e = null, i = 0, n = 0) {
    super(t, e), this.isBufferNode = !0, this.bufferType = e, this.bufferStride = i, this.bufferOffset = n, this.usage = Tl, this.instanced = !1, this.attribute = null, t && t.isBufferAttribute === !0 && (this.attribute = t, this.usage = t.usage, this.instanced = t.isInstancedBufferAttribute);
  }
  getNodeType(t) {
    return this.bufferType === null && (this.bufferType = t.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  setup(t) {
    if (this.attribute !== null)
      return;
    const e = this.getNodeType(t), i = this.value, n = t.getTypeLength(e), o = this.bufferStride || n, r = this.bufferOffset, a = i.isInterleavedBuffer === !0 ? i : new Ai(i, o), g = new ve(a, n, r);
    a.setUsage(this.usage), this.attribute = g, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  generate(t) {
    const e = this.getNodeType(t), i = t.getBufferAttributeFromNode(this, e), n = t.getPropertyName(i);
    let o = null;
    return t.shaderStage === "vertex" ? o = n : o = Fi(this).build(t, e), o;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  setInstanced(t) {
    return this.instanced = t, this;
  }
}
const Uh = (s, t, e, i) => Xe(new wB(s, t, e, i)), KM = (s, t, e, i) => Uh(s, t, e, i).setUsage(Ql), HM = (s, t, e, i) => Uh(s, t, e, i).setInstanced(!0), PM = (s, t, e, i) => KM(s, t, e, i).setInstanced(!0);
ne("toAttribute", (s) => Uh(s.value));
Le("BufferAttributeNode", wB);
class _B extends ct {
  constructor(t) {
    super("void"), this.instanceMesh = t, this.instanceMatrixNode = null;
  }
  setup() {
    let t = this.instanceMatrixNode;
    if (t === null) {
      const a = this.instanceMesh.instanceMatrix, g = new Wv(a.array, 16, 1), c = a.usage === Ql ? PM : HM, l = [
        c(g, "vec4", 16, 0),
        c(g, "vec4", 16, 4),
        c(g, "vec4", 16, 8),
        c(g, "vec4", 16, 12)
      ];
      t = tB(...l), this.instanceMatrixNode = t;
    }
    const e = t.mul(Pn).xyz, i = eB(t[0].xyz, t[1].xyz, t[2].xyz), n = Pg.div(Tt(i[0].dot(i[0]), i[1].dot(i[1]), i[2].dot(i[2]))), o = i.mul(n).xyz;
    Pn.assign(e), Pg.assign(o);
  }
}
const NM = de(_B);
Le("InstanceNode", _B);
class xB extends Yg {
  constructor(t, e, i = 0) {
    super(t, e), this.isBufferNode = !0, this.bufferType = e, this.bufferCount = i;
  }
  getInputType() {
    return "buffer";
  }
}
const FM = (s, t, e) => Xe(new xB(s, t, e));
Le("BufferNode", xB);
class zt extends ct {
  constructor(t = zt.LOCAL) {
    super(), this.scope = t;
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === zt.GEOMETRY ? "vec4" : "vec3";
  }
  generate(t) {
    const e = this.scope;
    let i = null;
    if (e === zt.GEOMETRY)
      i = ya("tangent", "vec4");
    else if (e === zt.LOCAL)
      i = Fi(kM.xyz);
    else if (e === zt.VIEW) {
      const n = cC.mul(vB).xyz;
      i = Ws(Fi(n));
    } else if (e === zt.WORLD) {
      const n = TB.transformDirection(Ea);
      i = Ws(Fi(n));
    }
    return i.build(t, this.getNodeType(t));
  }
  serialize(t) {
    super.serialize(t), t.scope = this.scope;
  }
  deserialize(t) {
    super.deserialize(t), this.scope = t.scope;
  }
}
zt.GEOMETRY = "geometry";
zt.LOCAL = "local";
zt.VIEW = "view";
zt.WORLD = "world";
const kM = me(zt, zt.GEOMETRY), vB = me(zt, zt.LOCAL), TB = me(zt, zt.VIEW);
me(zt, zt.WORLD);
const VM = sC(TB, "TransformedTangentView");
Ws(VM.transformDirection(Ea));
Le("TangentNode", zt);
class LB extends ct {
  constructor(t) {
    super("void"), this.skinnedMesh = t, this.updateType = Kt.OBJECT, this.skinIndexNode = ya("skinIndex", "uvec4"), this.skinWeightNode = ya("skinWeight", "vec4"), this.bindMatrixNode = mr(t.bindMatrix, "mat4"), this.bindMatrixInverseNode = mr(t.bindMatrixInverse, "mat4"), this.boneMatricesNode = FM(t.skeleton.boneMatrices, "mat4", t.skeleton.bones.length);
  }
  setup(t) {
    const { skinIndexNode: e, skinWeightNode: i, bindMatrixNode: n, bindMatrixInverseNode: o, boneMatricesNode: r } = this, a = r.element(e.x), g = r.element(e.y), c = r.element(e.z), l = r.element(e.w), h = n.mul(Pn), d = jI(
      a.mul(i.x).mul(h),
      g.mul(i.y).mul(h),
      c.mul(i.z).mul(h),
      l.mul(i.w).mul(h)
    ), C = o.mul(d).xyz;
    let p = jI(
      i.x.mul(a),
      i.y.mul(g),
      i.z.mul(c),
      i.w.mul(l)
    );
    p = o.mul(p).mul(n);
    const m = p.transformDirection(Pg).xyz;
    Pn.assign(C), Pg.assign(m), t.hasGeometryAttribute("tangent") && vB.assign(m);
  }
  generate(t, e) {
    if (e !== "void")
      return Pn.build(t, e);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
}
const zM = de(LB);
Le("SkinningNode", LB);
class GB extends ct {
  constructor(t) {
    super("void"), this.mesh = t, this.morphBaseInfluence = mr(1), this.updateType = Kt.OBJECT;
  }
  setupAttribute(t, e = Pn) {
    const i = this.mesh, n = i.geometry.morphAttributes[t];
    e.mulAssign(this.morphBaseInfluence);
    for (let o = 0; o < n.length; o++) {
      const r = n[o], a = Uh(r.array, "vec3"), g = ba(o, "float", i.morphTargetInfluences);
      e.addAssign(a.mul(g));
    }
  }
  setup() {
    this.setupAttribute("position");
  }
  update() {
    const t = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? t.value = 1 : t.value = 1 - this.mesh.morphTargetInfluences.reduce((e, i) => e + i, 0);
  }
}
const XM = de(GB);
Le("MorphNode", GB);
class MB extends ct {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  setup() {
    return bB.negate().reflect(Ng).transformDirection(Ea);
  }
}
const WM = me(MB);
Le("ReflectVectorNode", MB);
class EB extends aC {
  constructor(t, e = null, i = null) {
    super(t, e, i), this.isCubeTextureNode = !0;
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return WM;
  }
  setUpdateMatrix() {
  }
  generate(t, e) {
    const { uvNode: i, levelNode: n } = t.getNodeProperties(this), o = this.value;
    if (!o || o.isCubeTexture !== !0)
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    const r = Yg.prototype.generate.call(this, t, "cubeTexture");
    if (e === "sampler")
      return r + "_sampler";
    if (t.isReference(e))
      return r;
    {
      const a = t.getDataFromNode(this);
      let g = a.propertyName;
      if (g === void 0) {
        const d = Tt(i.x.negate(), i.yz).build(t, "vec3"), C = t.getVarFromNode(this);
        g = t.getPropertyName(C);
        let p = null;
        if (n && n.isNode === !0) {
          const m = n.build(t, "float");
          p = t.getTextureLevel(this, r, d, m);
        } else
          p = t.getTexture(this, r, d);
        t.addLineFlowCode(`${g} = ${p}`), t.context.tempWrite !== !1 && (a.snippet = p, a.propertyName = g);
      }
      let c = g;
      const l = this.getNodeType(t);
      return t.needsColorSpaceToLinear(this.value) && (c = rC(pB(c, l), this.value.colorSpace).setup(t).build(t, l)), t.format(c, l, e);
    }
  }
}
const lC = de(EB);
ne("cubeTexture", lC);
Le("CubeTextureNode", EB);
class RB extends ct {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const hC = RB;
Le("LightingNode", RB);
let md = null;
class DB extends hC {
  constructor(t = null) {
    super(), this.updateType = Kt.FRAME, this.light = t, this.rtt = null, this.shadowNode = null, this.color = new Ce(), this.colorNode = mr(this.color);
  }
  getHash() {
    return this.light.uuid;
  }
  setupShadow(t) {
    let e = this.shadowNode;
    if (e === null) {
      md === null && (md = t.createNodeMaterial("MeshBasicNodeMaterial"));
      const i = this.light.shadow, n = t.getRenderTarget(i.mapSize.width, i.mapSize.height), o = new Dh();
      o.minFilter = cs, o.magFilter = cs, o.image.width = i.mapSize.width, o.image.height = i.mapSize.height, o.compareFunction = Zv, n.depthTexture = o, i.camera.updateProjectionMatrix();
      const r = ba("bias", "float", i), a = ba("normalBias", "float", i);
      let g = mr(i.matrix).mul(RM.add(wM.mul(a)));
      g = g.xyz.div(g.w);
      const c = g.x.greaterThanEqual(0).and(g.x.lessThanEqual(1)).and(g.y.greaterThanEqual(0)).and(g.y.lessThanEqual(1)).and(g.z.lessThanEqual(1));
      t.renderer.coordinateSystem === Uv ? g = Tt(
        g.x,
        g.y.oneMinus(),
        g.z.add(r).mul(2).sub(1)
      ) : g = Tt(
        g.x,
        g.y,
        g.z.add(r)
      ), e = ((h, d, C) => Sa(h, d).compare(C))(o, g.xy, g.z), this.rtt = n, this.colorNode = this.colorNode.mul(c.mix(1, e)), this.shadowNode = e, this.updateBeforeType = Kt.RENDER;
    }
  }
  setup(t) {
    this.light.castShadow && this.setupShadow(t);
  }
  updateShadow(t) {
    const { rtt: e, light: i } = this, { renderer: n, scene: o } = t;
    o.overrideMaterial = md, e.setSize(i.shadow.mapSize.width, i.shadow.mapSize.height), i.shadow.updateMatrices(i), n.setRenderTarget(e), n.render(o, i.shadow.camera), n.setRenderTarget(null), o.overrideMaterial = null;
  }
  updateBefore(t) {
    const { light: e } = this;
    e.castShadow && this.updateShadow(t);
  }
  update() {
    const { light: t } = this;
    this.color.copy(t.color).multiplyScalar(t.intensity);
  }
}
const ZM = DB;
Le("AnalyticLightNode", DB);
const Df = /* @__PURE__ */ new WeakMap(), UM = (s) => s.sort((t, e) => t.id - e.id);
class OM extends ct {
  constructor(t = []) {
    super("vec3"), this.totalDiffuseNode = Tt().temp("totalDiffuse"), this.totalSpecularNode = Tt().temp("totalSpecular"), this.outgoingLightNode = Tt().temp("outgoingLight"), this.lightNodes = t, this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  setup(t) {
    const e = t.context, i = e.lightingModel;
    let n = this.outgoingLightNode;
    if (i) {
      const { lightNodes: o, totalDiffuseNode: r, totalSpecularNode: a } = this;
      e.outgoingLight = n;
      const g = t.addStack();
      i.start(e, g, t);
      for (const b of o)
        b.build(t);
      i.indirectDiffuse(e, g, t), i.indirectSpecular(e, g, t), i.ambientOcclusion(e, g, t);
      const { backdrop: c, backdropAlpha: l } = e, { directDiffuse: h, directSpecular: d, indirectDiffuse: C, indirectSpecular: p } = e.reflectedLight;
      let m = h.add(C);
      c !== null && (m = Tt(l !== null ? l.mix(m, c) : c)), r.assign(m), a.assign(d.add(p)), n.assign(r.add(a)), i.finish(e, g, t), n = n.bypass(t.removeStack());
    }
    return n;
  }
  getHash(t) {
    if (this._hash === null) {
      let e = "";
      const i = this.lightNodes;
      for (const n of i)
        e += n.getHash(t) + " ";
      this._hash = e;
    }
    return this._hash;
  }
  getLightNodeByHash(t) {
    const e = this.lightNodes;
    for (const i of e)
      if (i.light.uuid === t)
        return i;
    return null;
  }
  fromLights(t = []) {
    const e = [];
    t = UM(t);
    for (const i of t) {
      let n = this.getLightNodeByHash(i.uuid);
      if (n === null) {
        const o = i.constructor, r = Df.has(o) ? Df.get(o) : ZM;
        n = Xe(new r(i));
      }
      e.push(n);
    }
    return this.lightNodes = e, this._hash = null, this;
  }
}
const QM = de(OM);
class KB extends hC {
  constructor(t = null) {
    super(), this.aoNode = t;
  }
  setup(t) {
    const i = this.aoNode.x.sub(1).mul(1).add(1);
    t.context.ambientOcclusion.mulAssign(i);
  }
}
const YM = KB;
Le("AONode", KB);
class HB extends nC {
  constructor(t, e = null, i = null, n = null) {
    super(t), this.lightingModel = e, this.backdropNode = i, this.backdropAlphaNode = n, this._context = null;
  }
  getContext() {
    const { backdropNode: t, backdropAlphaNode: e } = this, i = Tt().temp("directDiffuse"), n = Tt().temp("directSpecular"), o = Tt().temp("indirectDiffuse"), r = Tt().temp("indirectSpecular"), a = {
      directDiffuse: i,
      directSpecular: n,
      indirectDiffuse: o,
      indirectSpecular: r
    };
    return {
      radiance: Tt().temp("radiance"),
      irradiance: Tt().temp("irradiance"),
      iblIrradiance: Tt().temp("iblIrradiance"),
      ambientOcclusion: Do(1).temp("ambientOcclusion"),
      reflectedLight: a,
      backdrop: t,
      backdropAlpha: e
    };
  }
  setup(t) {
    return this.context = this._context || (this._context = this.getContext()), this.context.lightingModel = this.lightingModel || t.context.lightingModel, super.setup(t);
  }
}
const PB = de(HB);
ne("lightingContext", PB);
Le("LightingContextNode", HB);
class NB extends vr {
  constructor(t = SB) {
    super("vec2"), this.dirNode = t;
  }
  setup() {
    const t = this.dirNode, e = t.z.atan2(t.x).mul(1 / (Math.PI * 2)).add(0.5), i = t.y.negate().clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return eC(e, i);
  }
}
const dC = de(NB);
Le("EquirectUVNode", NB);
class FB extends Yg {
  constructor(t) {
    super(0), this.textureNode = t, this.updateType = Kt.FRAME;
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const t = this.texture, e = t.images, i = e && e.length > 0 ? e[0] && e[0].image || e[0] : t.image;
    if (i && i.width !== void 0) {
      const { width: n, height: o } = i;
      this.value = Math.log2(Math.max(n, o));
    }
  }
}
const kB = de(FB);
Le("MaxMipLevelNode", FB);
class VB extends ct {
  constructor(t, e = null) {
    super("float"), this.textureNode = t, this.roughnessNode = e;
  }
  setup() {
    const { textureNode: t, roughnessNode: e } = this, i = kB(t), n = e.mul(e).mul(Math.PI).div(e.add(1));
    return i.add(n.log2()).clamp(0, i);
  }
}
const zB = de(VB);
Le("SpecularMIPLevelNode", VB);
const Kf = /* @__PURE__ */ new WeakMap();
class XB extends hC {
  constructor(t = null) {
    super(), this.envNode = t;
  }
  setup(t) {
    let e = this.envNode;
    if (e.isTextureNode && e.value.isCubeTexture !== !0) {
      let g = Kf.get(e.value);
      if (g === void 0) {
        const c = e.value, l = t.renderer, h = t.getCubeRenderTarget(512).fromEquirectangularTexture(l, c);
        g = lC(h.texture), Kf.set(e.value, g);
      }
      e = g;
    }
    const i = ba("envMapIntensity", "float", t.material), n = Vs(e, Hf(eG, Ng)).mul(i), o = Vs(e, jM(_M)).mul(Math.PI).mul(i), r = YI(n);
    t.context.radiance.addAssign(r), t.context.iblIrradiance.addAssign(o);
    const a = t.context.lightingModel.clearcoatRadiance;
    if (a) {
      const g = Vs(e, Hf(tG, xM)).mul(i), c = YI(g);
      a.addAssign(c);
    }
  }
}
const Hf = (s, t) => {
  let e = null, i = null;
  return {
    getUVNode: (n) => {
      let o = null;
      return e === null && (e = bB.negate().reflect(t), e = s.mul(s).mix(e, t).normalize(), e = e.transformDirection(Ea)), n.isCubeTextureNode ? o = e : n.isTextureNode && (i === null && (i = dC(e)), o = i), o;
    },
    getSamplerLevelNode: () => s,
    getMIPLevelAlgorithmNode: (n, o) => zB(n, o)
  };
}, jM = (s) => {
  let t = null;
  return {
    getUVNode: (e) => {
      let i = null;
      return e.isCubeTextureNode ? i = s : e.isTextureNode && (t === null && (t = dC(s), t = eC(t.x, t.y.oneMinus())), i = t), i;
    },
    getSamplerLevelNode: () => Do(1),
    getMIPLevelAlgorithmNode: (e, i) => zB(e, i)
  };
}, JM = XB;
Le("EnvironmentNode", XB);
const $I = /* @__PURE__ */ new Map();
class uC extends ze {
  constructor() {
    super(), this.isNodeMaterial = !0, this.type = this.constructor.type, this.forceSinglePass = !1, this.unlit = this.constructor === uC.prototype.constructor, this.fog = !0, this.lights = !0, this.normals = !0, this.colorSpace = !0, this.lightsNode = null, this.envNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.positionNode = null, this.outputNode = null, this.vertexNode = null;
  }
  customProgramCacheKey() {
    return this.type + OA(this);
  }
  build(t) {
    this.setup(t);
  }
  setup(t) {
    t.addStack(), t.stack.outputNode = this.setupPosition(t), t.addFlow("vertex", t.removeStack()), t.addStack();
    let e;
    if (this.unlit === !1) {
      this.normals === !0 && this.setupNormal(t), this.setupDiffuseColor(t), this.setupVariants(t);
      const i = this.setupLighting(t);
      e = this.setupOutput(t, Kn(i, Er.a)), iG.assign(e), this.outputNode !== null && (e = this.outputNode);
    } else
      e = this.setupOutput(t, this.outputNode || Kn(0, 0, 0, 1));
    t.stack.outputNode = e, t.addFlow("fragment", t.removeStack());
  }
  setupPosition(t) {
    const e = t.object, i = e.geometry;
    return t.addStack(), (i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color) && XM(e).append(), e.isSkinnedMesh === !0 && zM(e).append(), e.instanceMatrix && e.instanceMatrix.isInstancedBufferAttribute === !0 && t.isAvailable("instance") === !0 && NM(e).append(), this.positionNode !== null && Pn.assign(this.positionNode), t.context.vertex = t.removeStack(), this.vertexNode || DM();
  }
  setupDiffuseColor({ geometry: t }) {
    let e = this.colorNode ? Kn(this.colorNode) : TM;
    this.vertexColors === !0 && t.hasAttribute("color") && (e = Kn(e.xyz.mul(ya("color")), e.a)), Er.assign(e);
    const i = this.opacityNode ? Do(this.opacityNode) : GM;
    if (Er.a.assign(Er.a.mul(i)), this.alphaTestNode !== null || this.alphaTest > 0) {
      const n = this.alphaTestNode !== null ? Do(this.alphaTestNode) : vM;
      Er.a.lessThanEqual(n).discard();
    }
  }
  setupVariants() {
  }
  setupNormal() {
    if (this.flatShading === !0) {
      const t = qI.dFdx().cross(qI.dFdy()).normalize();
      Ng.assign(t);
    } else {
      const t = this.normalNode ? Tt(this.normalNode) : MM;
      Ng.assign(t);
    }
  }
  getEnvNode(t) {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap ? e = this.envMap.isCubeTexture ? lC(this.envMap) : Sa(this.envMap) : t.environmentNode && (e = t.environmentNode), e;
  }
  setupLights(t) {
    const e = this.getEnvNode(t), i = [];
    e && i.push(new JM(e)), t.material.aoMap && i.push(new YM(Sa(t.material.aoMap)));
    let n = this.lightsNode || t.lightsNode;
    return i.length > 0 && (n = QM([...n.lightNodes, ...i])), n;
  }
  setupLightingModel() {
  }
  setupLighting(t) {
    const { material: e } = t, { backdropNode: i, backdropAlphaNode: n, emissiveNode: o } = this, a = this.lights === !0 || this.lightsNode !== null ? this.setupLights(t) : null;
    let g = Er.rgb;
    if (a && a.hasLight !== !1) {
      const c = this.setupLightingModel(t);
      g = PB(a, c, i, n);
    } else
      i !== null && (g = Tt(n !== null ? Zh(g, i, n) : i));
    return (o && o.isNode === !0 || e.emissive && e.emissive.isColor === !0) && (g = g.add(Tt(o || LM))), g;
  }
  setupOutput(t, e) {
    const i = t.renderer, n = t.toneMappingNode;
    if (n && (e = Kn(n.context({ color: e.rgb }), e.a)), this.fog === !0) {
      const o = t.fogNode;
      o && (e = Kn(o.mixAssign(e.rgb), e.a));
    }
    if (this.colorSpace === !0) {
      const o = i.getRenderTarget();
      let r;
      o !== null ? Array.isArray(o.texture) ? r = o.texture[0].colorSpace : r = o.texture.colorSpace : r = i.outputColorSpace, r !== Vi && r !== Yl && (e = e.linearToColorSpace(r));
    }
    return e;
  }
  setDefaultValues(t) {
    for (const i in t) {
      const n = t[i];
      this[i] === void 0 && (this[i] = n, n && n.clone && (this[i] = n.clone()));
    }
    Object.assign(this.defines, t.defines);
    const e = Object.getOwnPropertyDescriptors(t.constructor.prototype);
    for (const i in e)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, i) === void 0 && e[i].get !== void 0 && Object.defineProperty(this.constructor.prototype, i, e[i]);
  }
  toJSON(t) {
    const e = t === void 0 || typeof t == "string";
    e && (t = {
      textures: {},
      images: {},
      nodes: {}
    });
    const i = ks.prototype.toJSON.call(this, t), n = nh(this);
    i.inputNodes = {};
    for (const { property: r, childNode: a } of n)
      i.inputNodes[r] = a.toJSON(t).uuid;
    function o(r) {
      const a = [];
      for (const g in r) {
        const c = r[g];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (e) {
      const r = o(t.textures), a = o(t.images), g = o(t.nodes);
      r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a), g.length > 0 && (i.nodes = g);
    }
    return i;
  }
  copy(t) {
    return this.lightsNode = t.lightsNode, this.envNode = t.envNode, this.colorNode = t.colorNode, this.normalNode = t.normalNode, this.opacityNode = t.opacityNode, this.backdropNode = t.backdropNode, this.backdropAlphaNode = t.backdropAlphaNode, this.alphaTestNode = t.alphaTestNode, this.positionNode = t.positionNode, this.outputNode = t.outputNode, this.vertexNode = t.vertexNode, super.copy(t);
  }
  static fromMaterial(t) {
    if (t.isNodeMaterial === !0)
      return t;
    const e = t.type.replace("Material", "NodeMaterial"), i = IC(e);
    if (i === void 0)
      throw new Error(`NodeMaterial: Material "${t.type}" is not compatible.`);
    for (const n in t)
      i[n] = t[n];
    return i;
  }
}
function qM(s, t) {
  if (typeof t != "function" || !s)
    throw new Error(`Node material ${s} is not a class`);
  if ($I.has(s))
    throw new Error(`Redefinition of node material ${s}`);
  $I.set(s, t), t.type = s;
}
function IC(s) {
  const t = $I.get(s);
  if (t !== void 0)
    return new t();
}
qM("NodeMaterial", uC);
class Tr {
  constructor(t, e = null) {
    this.name = t, this.value = e, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  setValue(t) {
    this.value = t;
  }
  getValue() {
    return this.value;
  }
}
class $M extends Tr {
  constructor(t, e = 0) {
    super(t, e), this.isFloatUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class e1 extends Tr {
  constructor(t, e = new Z()) {
    super(t, e), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class t1 extends Tr {
  constructor(t, e = new B()) {
    super(t, e), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class i1 extends Tr {
  constructor(t, e = new Me()) {
    super(t, e), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class n1 extends Tr {
  constructor(t, e = new Ce()) {
    super(t, e), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class s1 extends Tr {
  constructor(t, e = new qe()) {
    super(t, e), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class o1 extends Tr {
  constructor(t, e = new J()) {
    super(t, e), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class r1 extends $M {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class a1 extends e1 {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class g1 extends t1 {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class c1 extends i1 {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class l1 extends n1 {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class h1 extends s1 {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class d1 extends o1 {
  constructor(t) {
    super(t.name, t.value), this.nodeUniform = t;
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class WB extends ct {
  constructor(t, e, i = null) {
    super(), this.condNode = t, this.ifNode = e, this.elseNode = i;
  }
  getNodeType(t) {
    const e = this.ifNode.getNodeType(t);
    if (this.elseNode !== null) {
      const i = this.elseNode.getNodeType(t);
      if (t.getTypeLength(i) > t.getTypeLength(e))
        return i;
    }
    return e;
  }
  generate(t) {
    const e = this.getNodeType(t), i = { tempWrite: !1 }, { ifNode: n, elseNode: o } = this, r = n.getNodeType(t) !== "void" || o && o.getNodeType(t) !== "void", a = r ? oC(e).build(t) : "", g = Vs(this.condNode).build(t, "bool");
    t.addFlowCode(`
${t.tab}if ( ${g} ) {

`).addFlowTab();
    let c = Vs(this.ifNode, i).build(t, e);
    if (c = r ? a + " = " + c + ";" : c, t.removeFlowTab().addFlowCode(t.tab + "	" + c + `

` + t.tab + "}"), o !== null) {
      t.addFlowCode(` else {

`).addFlowTab();
      let l = Vs(o, i).build(t, e);
      l = a ? a + " = " + l + ";" : l, t.removeFlowTab().addFlowCode(t.tab + "	" + l + `

` + t.tab + `}

`);
    } else
      t.addFlowCode(`

`);
    return a;
  }
}
const eA = de(WB);
ne("cond", eA);
Le("CondNode", WB);
class ZB extends ct {
  constructor(t = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = t, this._currentCond = null, this.isStackNode = !0;
  }
  getNodeType(t) {
    return this.outputNode ? this.outputNode.getNodeType(t) : "void";
  }
  add(t) {
    return this.nodes.push(t), this;
  }
  if(t, e) {
    const i = new xg(e);
    return this._currentCond = eA(t, i), this.add(this._currentCond);
  }
  elseif(t, e) {
    const i = new xg(e), n = eA(t, i);
    return this._currentCond.elseNode = n, this._currentCond = n, this;
  }
  else(t) {
    return this._currentCond.elseNode = new xg(t), this;
  }
  build(t, ...e) {
    const i = $b();
    sh(this);
    for (const n of this.nodes)
      n.build(t, "void");
    return sh(i), this.outputNode ? this.outputNode.build(t, ...e) : super.build(t, ...e);
  }
}
const Pf = de(ZB);
Le("StackNode", ZB);
class u1 extends ib {
  constructor(t = 1, e = {}) {
    super(t, e), this.isCubeRenderTarget = !0;
  }
  fromEquirectangularTexture(t, e) {
    const i = e.minFilter, n = e.generateMipmaps;
    e.generateMipmaps = !0, this.texture.type = e.type, this.texture.colorSpace = e.colorSpace, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
    const o = new Nt(5, 5, 5), r = dC(SB), a = IC("MeshBasicNodeMaterial");
    a.colorNode = Sa(e, r, 0), a.side = Ov, a.blending = jl;
    const g = new le(o, a), c = new Kh();
    return c.add(g), e.minFilter === wr && (e.minFilter = Gt), new nb(1, 10, this).update(t, c), e.minFilter = i, e.currentGenerateMipmaps = n, g.geometry.dispose(), g.material.dispose(), this;
  }
}
const I1 = u1, A1 = /* @__PURE__ */ new Map([
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), C1 = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), f1 = /* @__PURE__ */ new Set([Int32Array, Uint32Array, Float32Array]), oc = (s) => (s = Number(s), s + (s % 1 ? "" : ".0"));
class p1 {
  constructor(t, e, i, n = null, o = null) {
    this.object = t, this.material = o || t && t.material || null, this.geometry = t && t.geometry || null, this.renderer = e, this.parser = i, this.scene = n, this.nodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.hashNodes = {}, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.toneMappingNode = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: [] }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: [], fragment: [], compute: [] }, this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 }, this.bindingsArray = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.flow = { code: "" }, this.chaining = [], this.stack = Pf(), this.stacks = [], this.tab = "	", this.context = {
      keywords: new $L(),
      material: this.material,
      getMIPLevelAlgorithmNode: (r, a) => a.mul(kB(r))
    }, this.cache = new nB(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null;
  }
  getRenderTarget(t, e, i) {
    return new Qv(t, e, i);
  }
  getCubeRenderTarget(t, e) {
    return new I1(t, e);
  }
  includes(t) {
    return this.nodes.includes(t);
  }
  getBindings() {
    let t = this.bindingsArray;
    if (t === null) {
      const e = this.bindings;
      this.bindingsArray = t = this.material !== null ? [...e.vertex, ...e.fragment] : e.compute;
    }
    return t;
  }
  setHashNode(t, e) {
    this.hashNodes[e] = t;
  }
  addNode(t) {
    this.nodes.includes(t) === !1 && (this.nodes.push(t), this.setHashNode(t, t.getHash(this)));
  }
  buildUpdateNodes() {
    for (const t of this.nodes) {
      const e = t.getUpdateType(), i = t.getUpdateBeforeType();
      e !== Kt.NONE && this.updateNodes.push(t.getSelf()), i !== Kt.NONE && this.updateBeforeNodes.push(t);
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(t) {
    this.chaining.push(t);
  }
  removeChain(t) {
    if (this.chaining.pop() !== t)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(t) {
    return t;
  }
  getNodeFromHash(t) {
    return this.hashNodes[t];
  }
  addFlow(t, e) {
    return this.flowNodes[t].push(e), e;
  }
  setContext(t) {
    this.context = t;
  }
  getContext() {
    return this.context;
  }
  setCache(t) {
    this.cache = t;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  getConst(t, e = null) {
    if (e === null && (t === "float" || t === "int" || t === "uint" ? e = 0 : t === "bool" ? e = !1 : t === "color" ? e = new Ce() : t === "vec2" ? e = new Z() : t === "vec3" ? e = new B() : t === "vec4" && (e = new Me())), t === "float")
      return oc(e);
    if (t === "int")
      return `${Math.round(e)}`;
    if (t === "uint")
      return e >= 0 ? `${Math.round(e)}u` : "0u";
    if (t === "bool")
      return e ? "true" : "false";
    if (t === "color")
      return `${this.getType("vec3")}( ${oc(e.r)}, ${oc(e.g)}, ${oc(e.b)} )`;
    const i = this.getTypeLength(t), n = this.getComponentType(t), o = (r) => this.getConst(n, r);
    if (i === 2)
      return `${this.getType(t)}( ${o(e.x)}, ${o(e.y)} )`;
    if (i === 3)
      return `${this.getType(t)}( ${o(e.x)}, ${o(e.y)}, ${o(e.z)} )`;
    if (i === 4)
      return `${this.getType(t)}( ${o(e.x)}, ${o(e.y)}, ${o(e.z)}, ${o(e.w)} )`;
    if (i > 4 && e && (e.isMatrix3 || e.isMatrix4))
      return `${this.getType(t)}( ${e.elements.map(o).join(", ")} )`;
    if (i > 4)
      return `${this.getType(t)}()`;
    throw new Error(`NodeBuilder: Type '${t}' not found in generate constant attempt.`);
  }
  getType(t) {
    return t === "color" ? "vec3" : t;
  }
  generateMethod(t) {
    return t;
  }
  hasGeometryAttribute(t) {
    return this.geometry && this.geometry.getAttribute(t) !== void 0;
  }
  getAttribute(t, e) {
    const i = this.attributes;
    for (const o of i)
      if (o.name === t)
        return o;
    const n = new Lf(t, e);
    return i.push(n), n;
  }
  getPropertyName(t) {
    return t.name;
  }
  isVector(t) {
    return /vec\d/.test(t);
  }
  isMatrix(t) {
    return /mat\d/.test(t);
  }
  isReference(t) {
    return t === "void" || t === "property" || t === "sampler" || t === "texture" || t === "cubeTexture";
  }
  needsColorSpaceToLinear() {
    return !1;
  }
  getTextureEncodingFromMap(t) {
    return console.warn("THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."), this.getTextureColorSpaceFromMap(t) === gt ? Yv : jv;
  }
  getTextureColorSpaceFromMap(t) {
    let e;
    return t && t.isTexture ? e = t.colorSpace : t && t.isWebGLRenderTarget ? e = t.texture.colorSpace : e = Yl, e;
  }
  getComponentType(t) {
    if (t = this.getVectorType(t), t === "float" || t === "bool" || t === "int" || t === "uint")
      return t;
    const e = /(b|i|u|)(vec|mat)([2-4])/.exec(t);
    return e === null ? null : e[1] === "b" ? "bool" : e[1] === "i" ? "int" : e[1] === "u" ? "uint" : "float";
  }
  getVectorType(t) {
    return t === "color" ? "vec3" : t === "texture" ? "vec4" : t;
  }
  getTypeFromLength(t, e = "float") {
    if (t === 1)
      return e;
    const i = A1.get(t);
    return (e === "float" ? "" : e[0]) + i;
  }
  getTypeFromArray(t) {
    return C1.get(t.constructor);
  }
  getTypeFromAttribute(t) {
    let e = t;
    t.isInterleavedBufferAttribute && (e = t.data);
    const i = e.array, n = f1.has(i.constructor) ? t.itemSize : e.stride || t.itemSize, o = t.normalized;
    let r;
    return !(t instanceof Jv) && o !== !0 && (r = this.getTypeFromArray(i)), this.getTypeFromLength(n, r);
  }
  getTypeLength(t) {
    const e = this.getVectorType(t), i = /vec([2-4])/.exec(e);
    return i !== null ? Number(i[1]) : e === "float" || e === "bool" || e === "int" || e === "uint" ? 1 : /mat3/.test(t) === !0 ? 9 : /mat4/.test(t) === !0 ? 16 : 0;
  }
  getVectorFromMatrix(t) {
    return t.replace("mat", "vec");
  }
  changeComponentType(t, e) {
    return this.getTypeFromLength(this.getTypeLength(t), e);
  }
  getIntegerType(t) {
    const e = this.getComponentType(t);
    return e === "int" || e === "uint" ? t : this.changeComponentType(t, "int");
  }
  addStack() {
    return this.stack = Pf(this.stack), this.stacks.push($b() || this.stack), sh(this.stack), this.stack;
  }
  removeStack() {
    const t = this.stack;
    return this.stack = t.parent, sh(this.stacks.pop()), t;
  }
  getDataFromNode(t, e = this.shaderStage) {
    const i = t.isGlobal(this) ? this.globalCache : this.cache;
    let n = i.getNodeData(t);
    return n === void 0 && (n = {}, i.setNodeData(t, n)), n[e] === void 0 && (n[e] = {}), n[e];
  }
  getNodeProperties(t, e = "any") {
    const i = this.getDataFromNode(t, e);
    return i.properties || (i.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(t, e) {
    const i = this.getDataFromNode(t);
    let n = i.bufferAttribute;
    if (n === void 0) {
      const o = this.uniforms.index++;
      n = new Lf("nodeAttribute" + o, e, t), this.bufferAttributes.push(n), i.bufferAttribute = n;
    }
    return n;
  }
  getStructTypeFromNode(t, e = this.shaderStage, i = null) {
    const n = this.getDataFromNode(t, e);
    if (n.structType === void 0) {
      const r = this.structs.index++;
      t.name = `StructType${r}`, this.structs[e].push(t), n.structType = t;
    }
    return t;
  }
  getUniformFromNode(t, e, i = this.shaderStage, n = null) {
    const o = this.getDataFromNode(t, i);
    let r = o.uniform;
    if (r === void 0) {
      const a = this.uniforms.index++;
      r = new UL(n || "nodeUniform" + a, e, t), this.uniforms[i].push(r), o.uniform = r;
    }
    return r;
  }
  getVarFromNode(t, e = null, i = t.getNodeType(this), n = this.shaderStage) {
    const o = this.getDataFromNode(t, n);
    let r = o.variable;
    if (r === void 0) {
      const a = this.vars[n] || (this.vars[n] = []);
      e === null && (e = "nodeVar" + a.length), r = new aB(e, i), a.push(r), o.variable = r;
    }
    return r;
  }
  getVaryingFromNode(t, e) {
    const i = this.getDataFromNode(t, "any");
    let n = i.varying;
    if (n === void 0) {
      const o = this.varyings, r = o.length;
      n = new YL("nodeVarying" + r, e), o.push(n), i.varying = n;
    }
    return n;
  }
  getCodeFromNode(t, e, i = this.shaderStage) {
    const n = this.getDataFromNode(t);
    let o = n.code;
    if (o === void 0) {
      const r = this.codes[i] || (this.codes[i] = []), a = r.length;
      o = new JL("nodeCode" + a, e), r.push(o), n.code = o;
    }
    return o;
  }
  addLineFlowCode(t) {
    return t === "" ? this : (t = this.tab + t, /;\s*$/.test(t) || (t = t + `;
`), this.flow.code += t, this);
  }
  addFlowCode(t) {
    return this.flow.code += t, this;
  }
  addFlowTab() {
    return this.tab += "	", this;
  }
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  getFlowData(t) {
    return this.flowsData.get(t);
  }
  flowNode(t) {
    const e = t.getNodeType(this), i = this.flowChildNode(t, e);
    return this.flowsData.set(t, i), i;
  }
  flowShaderNode(t) {
    const e = t.layout;
    let i;
    if (t.isArrayInput) {
      i = [];
      for (const r of e.inputs)
        i.push(new Gf(r.type, r.name));
    } else {
      i = {};
      for (const r of e.inputs)
        i[r.name] = new Gf(r.type, r.name);
    }
    t.layout = null;
    const n = t.call(i), o = this.flowStagesNode(n, e.type);
    return t.layout = e, o;
  }
  flowStagesNode(t, e = null) {
    const i = this.flow, n = this.vars, o = this.buildStage, r = {
      code: ""
    };
    this.flow = r, this.vars = {};
    for (const a of Bf)
      this.setBuildStage(a), r.result = t.build(this, e);
    return r.vars = this.getVars(this.shaderStage), this.flow = i, this.vars = n, this.setBuildStage(o), r;
  }
  flowChildNode(t, e = null) {
    const i = this.flow, n = {
      code: ""
    };
    return this.flow = n, n.result = t.build(this, e), this.flow = i, n;
  }
  flowNodeFromShaderStage(t, e, i = null, n = null) {
    const o = this.shaderStage;
    this.setShaderStage(t);
    const r = this.flowChildNode(e, i);
    return n !== null && (r.code += `${this.tab + n} = ${r.result};
`), this.flowCode[t] = this.flowCode[t] + r.code, this.setShaderStage(o), r;
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(t, e) {
    return `${this.getType(t)} ${e}`;
  }
  getVars(t) {
    let e = "";
    const i = this.vars[t];
    if (i !== void 0)
      for (const n of i)
        e += `${this.getVar(n.type, n.name)}; `;
    return e;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(t) {
    const e = this.codes[t];
    let i = "";
    if (e !== void 0)
      for (const n of e)
        i += n.code + `
`;
    return i;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(t) {
    this.shaderStage = t;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(t) {
    this.buildStage = t;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const t of Bf) {
      this.setBuildStage(t), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const e of qT) {
        this.setShaderStage(e);
        const i = this.flowNodes[e];
        for (const n of i)
          t === "generate" ? this.flowNode(n) : n.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  getNodeUniform(t, e) {
    if (e === "float")
      return new r1(t);
    if (e === "vec2")
      return new a1(t);
    if (e === "vec3")
      return new g1(t);
    if (e === "vec4")
      return new c1(t);
    if (e === "color")
      return new l1(t);
    if (e === "mat3")
      return new h1(t);
    if (e === "mat4")
      return new d1(t);
    throw new Error(`Uniform "${e}" not declared.`);
  }
  createNodeMaterial(t) {
    return IC(t);
  }
  getPrimitiveType(t) {
    let e;
    return t[0] === "i" ? e = "int" : t[0] === "u" ? e = "uint" : e = "float", e;
  }
  format(t, e, i) {
    if (e = this.getVectorType(e), i = this.getVectorType(i), e === i || i === null || this.isReference(i))
      return t;
    const n = this.getTypeLength(e), o = this.getTypeLength(i);
    return n > 4 || o > 4 || o === 0 ? t : n === o ? `${this.getType(i)}( ${t} )` : n > o ? this.format(`${t}.${"xyz".slice(0, o)}`, this.getTypeFromLength(o, this.getComponentType(e)), i) : o === 4 && n > 1 ? `${this.getType(i)}( ${this.format(t, e, "vec3")}, 1.0 )` : n === 2 ? `${this.getType(i)}( ${this.format(t, e, "vec2")}, 0.0 )` : (n === 1 && o > 1 && e[0] !== i[0] && (t = `${this.getType(this.getPrimitiveType(i))}( ${t} )`), `${this.getType(i)}( ${t} )`);
  }
  getSignature() {
    return `// Three.js r${Hh} - NodeMaterial System
`;
  }
}
const m1 = p1;
class y1 {
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.startTime = null, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  _getMaps(t, e) {
    let i = t.get(e);
    return i === void 0 && (i = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, t.set(e, i)), i;
  }
  updateBeforeNode(t) {
    const e = t.getUpdateBeforeType(), i = t.updateReference(this), { frameMap: n, renderMap: o } = this._getMaps(this.updateBeforeMap, i);
    e === Kt.FRAME ? n.get(t) !== this.frameId && (n.set(t, this.frameId), t.updateBefore(this)) : e === Kt.RENDER ? (o.get(t) !== this.renderId || n.get(t) !== this.frameId) && (o.set(t, this.renderId), n.set(t, this.frameId), t.updateBefore(this)) : e === Kt.OBJECT && t.updateBefore(this);
  }
  updateNode(t) {
    const e = t.getUpdateType(), i = t.updateReference(this), { frameMap: n, renderMap: o } = this._getMaps(this.updateMap, i);
    e === Kt.FRAME ? n.get(t) !== this.frameId && (n.set(t, this.frameId), t.update(this)) : e === Kt.RENDER ? (o.get(t) !== this.renderId || n.get(t) !== this.frameId) && (o.set(t, this.renderId), n.set(t, this.frameId), t.update(this)) : e === Kt.OBJECT && t.update(this);
  }
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
const UB = y1;
class OB {
  constructor(t, e, i = null, n = "", o = !1) {
    this.type = t, this.name = e, this.count = i, this.qualifier = n, this.isConst = o;
  }
}
OB.isNodeFunctionInput = !0;
const S1 = OB;
class b1 {
  parseFunction() {
    console.warn("Abstract function.");
  }
}
const B1 = b1;
class QB {
  constructor(t, e, i = "", n = "") {
    this.type = t, this.inputs = e, this.name = i, this.presicion = n;
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
QB.isNodeFunction = !0;
const w1 = QB, _1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, x1 = /[a-z_0-9]+/ig, Nf = "#pragma main", v1 = (s) => {
  s = s.trim();
  const t = s.indexOf(Nf), e = t !== -1 ? s.slice(t + Nf.length) : s, i = e.match(_1);
  if (i !== null && i.length === 5) {
    const n = i[4], o = [];
    let r = null;
    for (; (r = x1.exec(n)) !== null; )
      o.push(r);
    const a = [];
    let g = 0;
    for (; g < o.length; ) {
      const p = o[g][0] === "const";
      p === !0 && g++;
      let m = o[g][0];
      m === "in" || m === "out" || m === "inout" ? g++ : m = "";
      const b = o[g++][0];
      let S = Number.parseInt(o[g][0]);
      Number.isNaN(S) === !1 ? g++ : S = null;
      const A = o[g++][0];
      a.push(new S1(b, A, S, m, p));
    }
    const c = e.substring(i[0].length), l = i[3] !== void 0 ? i[3] : "", h = i[2], d = i[1] !== void 0 ? i[1] : "", C = t !== -1 ? s.slice(0, t) : "";
    return {
      type: h,
      inputs: a,
      name: l,
      presicion: d,
      inputsCode: n,
      blockCode: c,
      headerCode: C
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class T1 extends w1 {
  constructor(t) {
    const { type: e, inputs: i, name: n, presicion: o, inputsCode: r, blockCode: a, headerCode: g } = v1(t);
    super(e, i, n, o), this.inputsCode = r, this.blockCode = a, this.headerCode = g;
  }
  getCode(t = this.name) {
    let e;
    const i = this.blockCode;
    if (i !== "") {
      const { type: n, inputsCode: o, headerCode: r, presicion: a } = this;
      let g = `${n} ${t} ( ${o.trim()} )`;
      a !== "" && (g = `${a} ${g}`), e = r + g + i;
    } else
      e = "";
    return e;
  }
}
const L1 = T1;
class G1 extends B1 {
  parseFunction(t) {
    return new L1(t);
  }
}
const M1 = G1;
class E1 extends ct {
  constructor(t) {
    super(t.nodeType), this.node = null, this.source = null, this.target = null, this.inclusionType = "replace", Object.assign(this, t);
  }
  generate(t) {
    return this.node.build(t, this.getNodeType(t));
  }
}
const ft = E1, Ml = new UB();
Ml.camera = new Ys();
const Ff = {
  LineBasicNodeMaterial: fo.basic,
  MeshBasicNodeMaterial: fo.basic,
  PointsNodeMaterial: fo.points,
  MeshStandardNodeMaterial: fo.standard,
  MeshPhysicalNodeMaterial: fo.physical,
  MeshPhongNodeMaterial: fo.phong
}, R1 = {
  [mG.ATAN2]: "atan"
}, D1 = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
function Is(s) {
  return `#include <${s}>`;
}
function Pa(s) {
  return `${s}Shader`;
}
class kf extends m1 {
  constructor(t, e, i, n = null) {
    super(t, e, new M1(), null, n), this.shader = i, this.slots = { vertex: [], fragment: [] }, this._parseShaderLib(), this._parseInclude("fragment", "lights_physical_fragment", "clearcoat_normal_fragment_begin", "transmission_fragment"), this._parseObject(), this._sortSlotsToFlow();
  }
  getMethod(t) {
    return R1[t] || t;
  }
  addSlot(t, e) {
    this.slots[t].push(e);
  }
  _parseShaderLib() {
    const t = this.material;
    let e = t.type;
    if (t.isMeshPhysicalNodeMaterial ? e = "MeshPhysicalNodeMaterial" : t.isMeshStandardNodeMaterial ? e = "MeshStandardNodeMaterial" : t.isMeshPhongNodeMaterial ? e = "MeshPhongNodeMaterial" : t.isMeshBasicNodeMaterial ? e = "MeshBasicNodeMaterial" : t.isPointsNodeMaterial ? e = "PointsNodeMaterial" : t.isLineBasicNodeMaterial && (e = "LineBasicNodeMaterial"), Ff[e] !== void 0) {
      const i = Ff[e], n = this.shader;
      n.vertexShader = i.vertexShader, n.fragmentShader = i.fragmentShader, n.uniforms = we.merge([i.uniforms, Xt.lights]);
    }
  }
  _parseObject() {
    const { material: t, renderer: e } = this;
    this.addSlot("fragment", new ft({
      node: oh,
      nodeType: "vec3",
      source: Is("clipping_planes_fragment"),
      target: "vec3 TransformedNormalView = %RESULT%;",
      inclusionType: "append"
    })), e.toneMappingNode && e.toneMappingNode.isNode === !0 && this.addSlot("fragment", new ft({
      node: t.colorNode,
      nodeType: "vec4",
      source: Is("tonemapping_fragment"),
      target: ""
    })), t.colorNode && t.colorNode.isNode && this.addSlot("fragment", new ft({
      node: t.colorNode,
      nodeType: "vec4",
      source: "vec4 diffuseColor = vec4( diffuse, opacity );",
      target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;"
    })), t.opacityNode && t.opacityNode.isNode && this.addSlot("fragment", new ft({
      node: t.opacityNode,
      nodeType: "float",
      source: Is("alphatest_fragment"),
      target: "diffuseColor.a = %RESULT%;",
      inclusionType: "append"
    })), t.normalNode && t.normalNode.isNode && this.addSlot("fragment", new ft({
      node: t.normalNode,
      nodeType: "vec3",
      source: Is("normal_fragment_begin"),
      target: "normal = %RESULT%;",
      inclusionType: "append"
    })), t.emissiveNode && t.emissiveNode.isNode && this.addSlot("fragment", new ft({
      node: t.emissiveNode,
      nodeType: "vec3",
      source: Is("emissivemap_fragment"),
      target: "totalEmissiveRadiance = %RESULT%;",
      inclusionType: "append"
    })), t.isMeshStandardNodeMaterial && (t.metalnessNode && t.metalnessNode.isNode && this.addSlot("fragment", new ft({
      node: t.metalnessNode,
      nodeType: "float",
      source: Is("metalnessmap_fragment"),
      target: "metalnessFactor = %RESULT%;",
      inclusionType: "append"
    })), t.roughnessNode && t.roughnessNode.isNode && this.addSlot("fragment", new ft({
      node: t.roughnessNode,
      nodeType: "float",
      source: Is("roughnessmap_fragment"),
      target: "roughnessFactor = %RESULT%;",
      inclusionType: "append"
    })), t.isMeshPhysicalNodeMaterial && (t.clearcoatNode && t.clearcoatNode.isNode ? (this.addSlot("fragment", new ft({
      node: t.clearcoatNode,
      nodeType: "float",
      source: "material.clearcoat = clearcoat;",
      target: "material.clearcoat = %RESULT%;"
    })), t.clearcoatRoughnessNode && t.clearcoatRoughnessNode.isNode && this.addSlot("fragment", new ft({
      node: t.clearcoatRoughnessNode,
      nodeType: "float",
      source: "material.clearcoatRoughness = clearcoatRoughness;",
      target: "material.clearcoatRoughness = %RESULT%;"
    })), t.clearcoatNormalNode && t.clearcoatNormalNode.isNode && this.addSlot("fragment", new ft({
      node: t.clearcoatNormalNode,
      nodeType: "vec3",
      source: "vec3 clearcoatNormal = nonPerturbedNormal;",
      target: "vec3 clearcoatNormal = %RESULT%;"
    })), t.defines.USE_CLEARCOAT = "") : delete t.defines.USE_CLEARCOAT, t.sheenNode && t.sheenNode.isNode ? (this.addSlot("fragment", new ft({
      node: t.sheenNode,
      nodeType: "vec3",
      source: "material.sheenColor = sheenColor;",
      target: "material.sheenColor = %RESULT%;"
    })), t.sheenRoughnessNode && t.sheenRoughnessNode.isNode && this.addSlot("fragment", new ft({
      node: t.sheenRoughnessNode,
      nodeType: "float",
      source: "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
      target: "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );"
    })), t.defines.USE_SHEEN = "") : delete t.defines.USE_SHEEN, t.iridescenceNode && t.iridescenceNode.isNode ? (this.addSlot("fragment", new ft({
      node: t.iridescenceNode,
      nodeType: "float",
      source: "material.iridescence = iridescence;",
      target: "material.iridescence = %RESULT%;"
    })), t.iridescenceIORNode && t.iridescenceIORNode.isNode && this.addSlot("fragment", new ft({
      node: t.iridescenceIORNode,
      nodeType: "float",
      source: "material.iridescenceIOR = iridescenceIOR;",
      target: "material.iridescenceIOR = %RESULT%;"
    })), t.iridescenceThicknessNode && t.iridescenceThicknessNode.isNode && this.addSlot("fragment", new ft({
      node: t.iridescenceThicknessNode,
      nodeType: "float",
      source: "material.iridescenceThickness = iridescenceThicknessMaximum;",
      target: "material.iridescenceThickness = %RESULT%;"
    })), t.defines.USE_IRIDESCENCE = "") : delete t.defines.USE_IRIDESCENCE, t.iorNode && t.iorNode.isNode && this.addSlot("fragment", new ft({
      node: t.iorNode,
      nodeType: "float",
      source: "material.ior = ior;",
      target: "material.ior = %RESULT%;"
    })), t.specularColorNode && t.specularColorNode.isNode && this.addSlot("fragment", new ft({
      node: t.specularColorNode,
      nodeType: "vec3",
      source: "vec3 specularColorFactor = specularColor;",
      target: "vec3 specularColorFactor = %RESULT%;"
    })), t.specularIntensityNode && t.specularIntensityNode.isNode && this.addSlot("fragment", new ft({
      node: t.specularIntensityNode,
      nodeType: "float",
      source: "float specularIntensityFactor = specularIntensity;",
      target: "float specularIntensityFactor = %RESULT%;"
    })), t.transmissionNode && t.transmissionNode.isNode ? (this.addSlot("fragment", new ft({
      node: t.transmissionNode,
      nodeType: "float",
      source: "material.transmission = transmission;",
      target: "material.transmission = %RESULT%;"
    })), t.thicknessNode && t.thicknessNode.isNode && this.addSlot("fragment", new ft({
      node: t.thicknessNode,
      nodeType: "float",
      source: "material.thickness = thickness;",
      target: "material.thickness = %RESULT%;"
    })), t.attenuationDistanceNode && t.attenuationDistanceNode.isNode && this.addSlot("fragment", new ft({
      node: t.attenuationDistanceNode,
      nodeType: "float",
      source: "material.attenuationDistance = attenuationDistance;",
      target: "material.attenuationDistance = %RESULT%;"
    })), t.attenuationColorNode && t.attenuationColorNode.isNode && this.addSlot("fragment", new ft({
      node: t.attenuationColorNode,
      nodeType: "vec3",
      source: "material.attenuationColor = attenuationColor;",
      target: "material.attenuationColor = %RESULT%;"
    })), t.transmission = 1, t.defines.USE_TRANSMISSION = "") : (t.transmission = 0, delete t.defines.USE_TRANSMISSION))), t.positionNode && t.positionNode.isNode && this.addSlot("vertex", new ft({
      node: t.positionNode,
      nodeType: "vec3",
      source: Is("begin_vertex"),
      target: "transformed = %RESULT%;",
      inclusionType: "append"
    })), t.sizeNode && t.sizeNode.isNode && this.addSlot("vertex", new ft({
      node: t.sizeNode,
      nodeType: "float",
      source: "gl_PointSize = size;",
      target: "gl_PointSize = %RESULT%;"
    }));
  }
  getTexture(t, e, i) {
    return t.isTextureCube ? `textureCube( ${e}, ${i} )` : `texture2D( ${e}, ${i} )`;
  }
  getTextureBias(t, e, i, n) {
    return this.material.extensions !== void 0 && (this.material.extensions.shaderTextureLOD = !0), `textureLod( ${e}, ${i}, ${n} )`;
  }
  getUniforms(t) {
    const e = this.uniforms[t];
    let i = "";
    for (const n of e) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name))
        continue;
      let o = null;
      n.type === "texture" ? o = `sampler2D ${n.name}; ` : n.type === "cubeTexture" ? o = `samplerCube ${n.name}; ` : o = `${this.getVectorType(n.type)} ${n.name}; `;
      const r = n.node.precision;
      r !== null ? o = "uniform " + D1[r] + " " + o : o = "uniform " + o, i += o;
    }
    return i;
  }
  getAttributes(t) {
    let e = "";
    if (t === "vertex") {
      const i = this.attributes;
      for (const n of i)
        /^(position|normal|uv[1-3]?)$/.test(n.name) || (e += `attribute ${n.type} ${n.name}; `);
    }
    return e;
  }
  getVaryings(t) {
    let e = "";
    const i = this.varyings;
    if (t === "vertex")
      for (const n of i)
        e += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${n.name}; `;
    else if (t === "fragment")
      for (const n of i)
        n.needsInterpolation && (e += `varying ${n.type} ${n.name}; `);
    return e;
  }
  addCode(t, e, i, n = this) {
    const o = Pa(t);
    let r = n[o];
    const a = r.indexOf(e);
    if (a !== -1) {
      const g = r.substring(0, a + e.length), c = r.substring(a + e.length);
      r = `${g}
${i}
${c}`;
    }
    n[o] = r;
  }
  replaceCode(t, e, i, n = this) {
    const o = Pa(t);
    n[o] = n[o].replaceAll(e, i);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const t = {};
    for (const e of Ag) {
      const i = this.getUniforms(e), n = this.getAttributes(e), o = this.getVaryings(e), r = this.getVars(e), a = this.getCodes(e);
      t[e] = `${this.getSignature()}
// <node_builder>

// uniforms
${i}

// attributes
${n}

// varyings
${o}

// vars
${r}

// codes
${a}

// </node_builder>

${this.shader[Pa(e)]}
`;
    }
    this.vertexShader = t.vertex, this.fragmentShader = t.fragment;
  }
  build() {
    return super.build(), this._addSnippets(), this._addUniforms(), this._updateUniforms(), this.shader.vertexShader = this.vertexShader, this.shader.fragmentShader = this.fragmentShader, this;
  }
  _parseInclude(t, ...e) {
    for (const i of e) {
      const n = Is(i), o = Ee[i], r = Pa(t);
      this.shader[r] = this.shader[r].replaceAll(n, o);
    }
  }
  _sortSlotsToFlow() {
    for (const t of Ag) {
      const e = this.shader[Pa(t)], i = this.slots[t].sort((n, o) => e.indexOf(n.source) > e.indexOf(o.source) ? 1 : -1);
      for (const n of i)
        this.addFlow(t, n);
    }
  }
  _addSnippets() {
    for (const t of Ag) {
      for (const e of this.slots[t]) {
        const i = this.getFlowData(e), n = e.inclusionType, o = e.source, r = i.code + `
	` + e.target.replace("%RESULT%", i.result);
        n === "append" ? this.addCode(t, o, r) : n === "replace" ? this.replaceCode(t, o, r) : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(
        t,
        "main() {",
        `
	` + this.flowCode[t]
      );
    }
  }
  _addUniforms() {
    for (const t of Ag)
      for (const e of this.uniforms[t])
        this.shader.uniforms[e.name] = e;
  }
  _updateUniforms() {
    Ml.object = this.object, Ml.renderer = this.renderer;
    for (const t of this.updateNodes)
      Ml.updateNode(t);
  }
}
const tA = /* @__PURE__ */ new WeakMap(), ia = new UB();
ks.prototype.onBuild = function(s, t, e) {
  if (Array.isArray(s.material))
    for (const i of s.material)
      i.isNodeMaterial === !0 && tA.set(i, new kf(s, e, t, i).build());
  else
    s.material.isNodeMaterial === !0 && tA.set(s.material, new kf(s, e, t).build());
};
ks.prototype.onBeforeRender = function(s, t, e, i, n) {
  const o = tA.get(this);
  if (o !== void 0) {
    ia.material = this, ia.camera = e, ia.object = n, ia.renderer = s;
    const r = o.updateNodes;
    if (r.length > 0) {
      s.state.useProgram(null);
      for (const a of r)
        ia.updateNode(a);
    }
  }
};
const K1 = `#define GLSLIFY 1
uniform float zoomUnits;

// position\u4E3Aworld coord
float getPixelSize(vec3 position) {
    if (isOrthographic) {
        return zoomUnits;
    }
    else {
        // projectionMatrix\u7B2C5\u4F4D\u542B\u4E49\u4E3Atan(fov / 2) = 2 * near / (top - bottom)
        return 0.2 * projectionMatrix[1][1] / resolution.y * distance(cameraPosition, position);
    }
}
`, H1 = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
attribute float objectIndex;
uniform float selectedObjectIndex;
varying float isSelected;
#endif`, P1 = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (objectIndex == selectedObjectIndex) {
	isSelected = 1.0;
} else {
	isSelected = 0.0;
}
#endif`, N1 = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
varying float isSelected;
uniform vec4 selectedObjectColor;
uniform float selectedObjectColorMode;
#endif`, F1 = `#define GLSLIFY 1
#ifdef MVT_ENABLE_SELECTIVE
if (isSelected == 1.0) {
	if (selectedObjectColorMode == 1.) {
		gl_FragColor = selectedObjectColor;
	} else {
		gl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);
	}
	
}
#endif`, k1 = `#define GLSLIFY 1
uniform bool keepSize;
uniform float pixelRatio;
uniform vec2 resolution;
`, V1 = `#define GLSLIFY 1
vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));
float pixelSize = getPixelSize(worldPosition.xyz);
if (keepSize) {
    transformed *= pixelSize;
}
`, z1 = `#define GLSLIFY 1
`, X1 = `#define GLSLIFY 1
#define MVT_EMISSIVE_SHADER

uniform vec3 emissive;`, W1 = `#define GLSLIFY 1
#ifdef MVT_EMISSIVE_SHADER
    vec4 out_emissive = vec4(emissive.rgb, 1.0);
#endif`, Z1 = `#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif`, U1 = `#define GLSLIFY 1
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	// emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

    
#endif

if (isEmissive) {
    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);
	#if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}`, O1 = `#define GLSLIFY 1
#ifdef USE_COLOR

	varying vec3 vColor;

#endif`, Q1 = `#define GLSLIFY 1
if (isEmissive) {
    gl_FragColor = vec4(emissive, 1.0);
    #if defined( TONE_MAPPING )
	    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
    #endif
    return;
}
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif`, Y1 = `#define GLSLIFY 1
#ifdef ENABLE_ANIMATION_ROTATE
    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;
    if (animationPeriodOffset) {
        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);
    }
    float rotation = rotateRatio * 6.28;
    vec2 rotatedPosition;
    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;
    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;
    transformed.xy = rotatedPosition;
#endif

#ifdef ENABLE_ANIMATION_JUMP
    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;
    if (animationPeriodOffset) {
        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);
    }
    if (jumpRatio <= 0.5) {
        jumpRatio *= 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    } else {
        jumpRatio = (1.0 - jumpRatio) * 2.0;
        jumpRatio = jumpRatio * jumpRatio * jumpRatio;
    }
    #ifdef USE_SIZE3
        transformed.z += jumpRatio * animationJumpHeight / size3.z;
    #else
        transformed.z += jumpRatio * animationJumpHeight / size;
    #endif
#endif

#ifdef ENABLE_ANIMATION_SCALE
    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;
    if (animationPeriodOffset) {
        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);
    }

    vScale *= 1.0 + (targetScale - 1.0) * scaleRatio;

    if (opacityGradient) {
        if (targetScale > 1.0) {
            opacityRatio = 1.0 - (targetScale - 1.0) * scaleRatio;
        } else {
            opacityRatio = 1.0 + (targetScale - 1.0) * scaleRatio;
        }
    }

#endif

#ifdef ENABLE_ANIMATION_BREATH
    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;
    if (animationPeriodOffset) {
        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);
    }
    float repeatNum = scaleRatio / 0.25;
    float scaleFactor = mod(scaleRatio, 0.25) / 0.25;
    float scaleNum = scaleFactor * (maxScale - 1.0);
    float balance = (maxScale + minScale) / 2.0;

    if (repeatNum > 1.0 && repeatNum < 3.0) {
        // \u4E0B\u964D
        if (repeatNum < 2.0) {
            scaleNum = (1.0 - scaleFactor) * (maxScale - balance);
        } else {
            scaleNum = -scaleFactor * (balance - minScale);
        }
    } else if (repeatNum >= 3.0) {
        scaleNum = -(1.0 - scaleFactor) * (balance - minScale);
    }

    vScale *= balance + scaleNum;

    if (opacityGradient) {
        opacityRatio = (balance + scaleNum) / maxScale;
    }

#endif`, j1 = `#define GLSLIFY 1
uniform bool animationPeriodOffset;

#ifdef ENABLE_ANIMATION_ROTATE
uniform float animationRotatePeriod;
#endif

#ifdef ENABLE_ANIMATION_JUMP
uniform float animationJumpPeriod;
uniform float animationJumpHeight;
#endif

#ifdef ENABLE_ANIMATION_SCALE
uniform float animationPeriod;
uniform float targetScale;
uniform bool opacityGradient;
#endif

#ifdef ENABLE_ANIMATION_BREATH
uniform float animationPeriod;
uniform float maxScale;
uniform float minScale;
uniform bool opacityGradient;
#endif`, J1 = `#define GLSLIFY 1
#ifndef DISABLE_MRT
    // layout(location = 1) out highp vec4 pc_fragColor1;
    // layout(location = 2) out highp vec4 pc_fragColor2;
    // layout(location = 3) out highp vec4 pc_fragColor3;
    // layout(location = 4) out highp vec4 pc_fragColor4;
    // layout(location = 5) out highp vec4 pc_fragColor5;
    // layout(location = 6) out highp vec4 pc_fragColor6;
    // layout(location = 7) out highp vec4 pc_fragColor7;
    #if defined(MVT_MRT_OUT_EMISSIVE)
        layout(location = MVT_MRT_OUT_EMISSIVE) out highp vec4 mvt_pc_emissive;
    #endif

    #if defined(MVT_MRT_OUT_NORMAL)
        layout(location = MVT_MRT_OUT_NORMAL) out highp vec4 mvt_pc_normal;
    #endif

    #if defined(MVT_MRT_OUT_METALLICROUGH)
        layout(location = MVT_MRT_OUT_METALLICROUGH) out highp vec4 mvt_pc_metallicRough;
    #endif
#endif

#if defined(MVT_EMISSIVE_UNIFORM)
// \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif`, q1 = `#define GLSLIFY 1
#ifndef DISABLE_MRT
    // \u81EA\u5B9A\u4E49\u53D1\u5149\u989C\u8272\uFF0C\u5B8C\u5168\u7531\u7740\u8272\u5668\u63A7\u5236 \u5728\u7740\u8272\u5668\u4E2D\u8F93\u51FA vec4 out_emissive;
    #ifdef MVT_MRT_OUT_EMISSIVE
        #if defined(MVT_EMISSIVE_SHADER)
            mvt_pc_emissive = out_emissive;
        #elif defined(STANDARD)
            mvt_pc_emissive.rgb = totalEmissiveRadiance;
            mvt_pc_emissive.a = pc_fragColor.a;
        #elif defined(PHONG)
            mvt_pc_emissive.rgb = totalEmissiveRadiance;
            mvt_pc_emissive.a = pc_fragColor.a;
        #elif defined(BASIC)
            mvt_pc_emissive.rgb = emissive;
            mvt_pc_emissive.a = pc_fragColor.a;
        // \u901A\u8FC7\u4F20\u5165\u7684uniform\u53D8\u91CF\u989C\u8272\u81EA\u53D1\u5149
        #elif defined(MVT_EMISSIVE_UNIFORM)
            // \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
            #if defined(MVT_EMISSIVE_COLOR)
                mvt_pc_emissive.rgb = mvt_emissive * mvt_emissiveIntensity;
                mvt_pc_emissive.a = pc_fragColor.a;
            #else  
                mvt_pc_emissive = pc_fragColor * mvt_emissiveIntensity;
            #endif
        #else
            mvt_pc_emissive = vec4(0.0, 0.0, 0.0, 0.0);
        #endif  
    #endif

    #ifdef MVT_MRT_OUT_NORMAL
        #if defined(STANDARD)
            #ifndef FLAT_SHADED
                mvt_pc_normal = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);
            #else
                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);
            #endif
        #else
            #if defined(MVT_FRAG_NORMAL)
                mvt_pc_normal = vec4(packNormalToRGB(mvt_frag_normal), 1.0);
            #else
                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);
            #endif
        #endif
    #endif

    #ifdef MVT_MRT_OUT_METALLICROUGH
        #if defined(STANDARD)
            mvt_pc_metallicRough = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);
        #else
            float temp_reflectionFactor = 0.0;
            #if defined(MVT_FRAG_REFLECTION_FACTOR)
                temp_reflectionFactor = mvt_frag_reflectionFactor;
            #endif
            mvt_pc_metallicRough = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);
        #endif
    #endif
    
    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);
    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);
    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);
#endif
`, $1 = `#define GLSLIFY 1
#if defined(MVT_EMISSIVE_UNIFORM)
    // \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
    #if defined(MVT_EMISSIVE_COLOR)
        uniform vec3 mvt_emissive;
    #endif  
    uniform float mvt_emissiveIntensity;
#endif
uniform bool isEmissive;`, eE = `#define GLSLIFY 1
// if (isEmissive) {
#if defined(MVT_MODE_EMISSIVE)
    #if defined(MVT_EMISSIVE_SHADER)
        gl_FragColor = out_emissive;
    #elif defined(STANDARD)
        gl_FragColor.rgb = totalEmissiveRadiance;
    #elif defined(PHONG)
        gl_FragColor.rgb = totalEmissiveRadiance;
    #elif defined(BASIC)
        gl_FragColor.rgb = emissive;
    // \u901A\u8FC7\u4F20\u5165\u7684uniform\u53D8\u91CF\u989C\u8272\u81EA\u53D1\u5149
    #elif defined(MVT_EMISSIVE_UNIFORM)
        // \u53D1\u5149\u989C\u8272\u81EA\u5B9A\u4E49
        #if defined(MVT_EMISSIVE_COLOR)
            gl_FragColor.rgb = mvt_emissive * mvt_emissiveIntensity;
        #else
            gl_FragColor = gl_FragColor * mvt_emissiveIntensity;
        #endif
    #else
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
    #endif
#endif
//}`, tE = `#define GLSLIFY 1
#define BASIC
uniform vec3 emissive;`, iE = `#define GLSLIFY 1
#ifdef USE_CLIP
    varying vec3 clip_position;
    varying mat4 clip_modelMat4;
    #ifdef IS_INSTANCE
        varying mat4 clip_instanceMat4;
    #endif
#endif`, nE = `#define GLSLIFY 1
#ifdef USE_CLIP
    clip_position = position;
    clip_modelMat4 = modelMatrix;
    #ifdef IS_INSTANCE
        clip_instanceMat4 = instanceMatrix;
    #endif
#endif
`, sE = `#define GLSLIFY 1
#ifdef USE_CLIP

    varying vec3 clip_position;
    varying mat4 clip_modelMat4;
    #ifdef IS_INSTANCE
        varying mat4 clip_instanceMat4;
    #endif

    struct ClipParameters {
        vec2 u_polygon[20];
        vec4 polygonBounds;
        int clip_type;
        bool clip_inside;
        vec2 clip_point;
        float clip_radius;
        float clip_maxDiff;
        vec2 clip_size;
    };

    uniform ClipParameters mvt_clipParameters;

    int areIntersecting(
        float v1x1, float v1y1, float v1x2, float v1y2,
        float v2x1, float v2y1, float v2x2, float v2y2
    ) {
        float d1, d2;
        float a1, a2, b1, b2, c1, c2;

        a1 = v1y2 - v1y1;
        b1 = v1x1 - v1x2;
        c1 = (v1x2 * v1y1) - (v1x1 * v1y2);

        d1 = (a1 * v2x1) + (b1 * v2y1) + c1;
        d2 = (a1 * v2x2) + (b1 * v2y2) + c1;

        if (d1 > 0.0 && d2 > 0.0) return 0;
        if (d1 <= 0.0 && d2 <= 0.0) return 0;

        a2 = v2y2 - v2y1;
        b2 = v2x1 - v2x2;
        c2 = (v2x2 * v2y1) - (v2x1 * v2y2);

        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;
        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;

        if (d1 > 0.0 && d2 > 0.0) return 0;
        if (d1 < 0.0 && d2 < 0.0) return 0;

        if ((a1 * b2) - (a2 * b1) == 0.0) return 2;

        return 1;
    }

    bool pointInPolygon(vec2 p) {
        vec4 polygonBounds = mvt_clipParameters.polygonBounds;
        float minX = polygonBounds.x;
        float minY = polygonBounds.y;
        float maxX = polygonBounds.z;
        float maxY = polygonBounds.w;
        if (p.x > maxX || p.x < minX || p.y > maxY || p.y < minY)
        {
            return false;
        }

        vec2 points[20] = mvt_clipParameters.u_polygon;
        float maxDiff = mvt_clipParameters.clip_maxDiff;
        int intersectCount = 0;

        #ifdef USE_CLIPCOUNT
            for (int i = 0; i < USE_CLIPCOUNT; i++) {
                vec2 vertex = points[i];

                vec2 vertex2;
                if (i == USE_CLIPCOUNT - 1) {
                    vertex2 = points[0];
                }
                else {
                    vertex2 = points[i + 1];
                }

                bool intersection = areIntersecting(p.x, p.y, p.x + maxDiff * 2.0, p.y, vertex.x, vertex.y, vertex2.x, vertex2.y) != 0;
                if (intersection) {
                    intersectCount++;
                }
            }
            return (intersectCount % 2) == 1;
        #else
            return false;
        #endif
    }

    bool pointInCircle(vec2 point) {
        float distance = length(point - mvt_clipParameters.clip_point);
        return distance < mvt_clipParameters.clip_radius;
    }

    bool pointInRect(vec2 point) {
        return (point.x > mvt_clipParameters.clip_point.x 
            && point.x < mvt_clipParameters.clip_point.x + mvt_clipParameters.clip_size.x
            && point.y > mvt_clipParameters.clip_point.y 
            && point.y < mvt_clipParameters.clip_point.y + mvt_clipParameters.clip_size.y);
    }

#endif`, oE = `#define GLSLIFY 1
#ifdef USE_CLIP
    vec4 worldCoord;

    #ifdef CUSTOM_WORLD_COORD
        worldCoord = vec4(vMP, 1.0);
    #else
        #ifdef IS_INSTANCE
            worldCoord = clip_modelMat4 * clip_instanceMat4 * vec4(clip_position, 1.0);
        #else
            worldCoord = clip_modelMat4 * vec4(clip_position, 1.0);
        #endif
    #endif
    bool isInside = false;
    if (mvt_clipParameters.clip_type == 0) {
        isInside = pointInPolygon(worldCoord.xy / worldCoord.w);
    }
    else if (mvt_clipParameters.clip_type == 1) {
        isInside = pointInCircle(worldCoord.xy / worldCoord.w);
    }
    else if (mvt_clipParameters.clip_type == 2) {
        isInside = pointInRect(worldCoord.xy / worldCoord.w);
    }
    
    bool clipInside = mvt_clipParameters.clip_inside;
    if (clipInside) {
        if (isInside) {
            discard;
        }
    }
    else {
        if (!isInside) {
            discard;
        }
    }
#endif`, rE = `#define GLSLIFY 1
float mvt_linearize_depth(in float depth, in float cameraNear, in float cameraFar){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float mvt_reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float mvtGetDepthFromTexture(sampler2D tDepth, vec2 uv, in float cameraNear, in float cameraFar) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        return mvt_linearize_depth(mvt_reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);
    #else
        return texture2D(tDepth, uv).x;
    #endif
}
vec3 mvtGetWorldPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix, mat4 viewInverseMatrix) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;
    
    // viewSpacePosition /= viewSpacePosition.w;
    // return viewSpacePosition.xyz;
    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

vec3 mvtGetViewPositionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);

    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];
    // clipSpacePosition *= clipW;
    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;
    
    viewSpacePosition /= viewSpacePosition.w;
    return viewSpacePosition.xyz;

}
`, aE = `#define GLSLIFY 1
#ifdef MVT_USE_DEPTH_RANGE

uniform vec2 depthRange;

layout(location = 1) out highp vec4 pc_fragColor1;

float mvt_remapDepth(float depth) {
    return depth * (depthRange.y - depthRange.x) + depthRange.x;
}
#endif

#ifdef MVT_USE_VERTEX_ZINDEX
    varying float vLayerIndex;
#endif

`, gE = `#define GLSLIFY 1
#ifdef MVT_USE_DEPTH_RANGE
    #ifdef OPAQUE
        pc_fragColor1 = packDepthToRGBA(gl_FragDepthEXT);
        // pc_fragColor1 = vec4(gl_FragDepthEXT, 0., 0., 1);
    #else
        // \u7981\u6B62\u534A\u900F\u660E\u533A\u57DF\u6DF7\u5408\u6DF1\u5EA6
        pc_fragColor1 = vec4(1., 1., 1., 0);
    #endif
    // pc_fragColor = packDepthToRGBA(gl_FragDepthEXT);
    #ifdef MVT_USE_VERTEX_ZINDEX
        gl_FragDepthEXT = mvt_remapDepth(gl_FragDepthEXT - vLayerIndex * 0.01);
    #else
        gl_FragDepthEXT = mvt_remapDepth(gl_FragDepthEXT);
    #endif
#endif`, cE = `#define GLSLIFY 1
uniform bool srgbTransformer;
uniform bool isLinearToneMapping;
uniform bool isReinhardToneMapping;
uniform bool isCineonToneMapping;
uniform bool isACESFilmicToneMapping;`, lE = `#define GLSLIFY 1
if (isLinearToneMapping) {
    gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
}
else if (isReinhardToneMapping) {
    gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
}
else if (isCineonToneMapping) {
    gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );
}
else if (isACESFilmicToneMapping) {
    gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
}

if (srgbTransformer) {
    gl_FragColor = sRGBTransferOETF( gl_FragColor );
}`, hE = (s) => {
  let t = `#include <mvt_nmrt_output_pars_fragment>
`, e = `#include <mvt_nmrt_output_fragment>
`, i = s;
  i = i.replace(
    "void main() {",
    t + "void main() {"
  );
  const n = i.lastIndexOf("}");
  return i = i.substring(0, n), i += e + "}", i;
}, YB = (s, t, e, i) => {
  if ((t || e) && (s = s.replace(
    "void main()",
    (t || "") + `void main()
` + (e || "")
  )), i) {
    const n = s.lastIndexOf("}");
    s = s.substring(0, n), s += i + "}";
  }
  return s;
}, dE = `
attribute float _tileEditableValue;
`, uE = `
if (_tileEditableValue == 1.0) {
    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);
}
`, IE = (s) => YB(
  s,
  dE,
  null,
  uE
), AE = (s) => {
  const t = "void main()";
  s = s.replace(
    t,
    `#include <mvt_clip_pars_vertex>
` + t
  );
  const e = s.indexOf(t), i = s.slice(e + t.length), n = e + t.length + i.indexOf("{") + 1;
  return s = s.slice(0, n) + `
    #include <mvt_clip_vertex>
` + s.slice(n), s;
}, CE = (s) => {
  const t = "void main()";
  s = s.replace(
    t,
    `#include <mvt_clip_pars_fragment>
` + t
  );
  const e = s.indexOf(t), i = s.slice(e + t.length), n = e + t.length + i.indexOf("{") + 1;
  return s = s.slice(0, n) + `
    #include <mvt_clip_fragment>
` + s.slice(n), s;
}, fE = () => {
  _t.prototype.emissiveIntensity = 1, fo.basic.uniforms.emissive = { value: new Ce(0) }, fo.basic.uniforms.isEmissive = { value: !1 };
}, pE = () => {
  Ee.mvt_uniform_zoomunits_pars = z1, Ee.mvt_extra_vertex_utils = K1, Ee.mvt_selective_pars_vertex = H1, Ee.mvt_selective_vertex = P1, Ee.mvt_selective_pars_fragment = N1, Ee.mvt_selective_fragment = F1, Ee.mvt_keepsize_pars_vertex = k1, Ee.mvt_keepsize_vertex = V1, Ee.mvt_emissive_pars_fragment = X1, Ee.mvt_emissive_fragment = W1, Ee.mvt_override_standard_emissivemap_pars_fragment = Z1, Ee.mvt_override_standard_emissivemap_fragment = U1, Ee.mvt_override_basic_color_pars_fragment = O1, Ee.mvt_override_basic_color_fragment = Q1, Ee.mvt_animation_pars_vertex = j1, Ee.mvt_animation_vertex = Y1, Ee.mvt_mrt_output_pars_fragment = J1, Ee.mvt_mrt_output_fragment = q1, Ee.mvt_nmrt_output_pars_fragment = $1, Ee.mvt_nmrt_output_fragment = eE, Ee.mvt_extra_meshbasic_frag_pars = tE, Ee.mvt_clip_pars_vertex = iE, Ee.mvt_clip_vertex = nE, Ee.mvt_clip_pars_fragment = sE, Ee.mvt_clip_fragment = oE, Ee.mvt_depth_packing = rE, Ee.mvt_depth_range_pars_fragment = aE, Ee.mvt_depth_range_fragment = gE, Ee.output_fragment = lE, Ee.output_pars_fragment = cE;
}, mE = function() {
  pE(), fE();
};
var Ir = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, jB = { exports: {} };
(function(s) {
  (function(t, e, i) {
    s.exports ? s.exports = i() : e[t] = i();
  })("urljoin", Ir, function() {
    function t(e) {
      var i = [];
      if (e.length === 0)
        return "";
      if (typeof e[0] != "string")
        throw new TypeError("Url must be a string. Received " + e[0]);
      if (e[0].match(/^[^/:]+:\/*$/) && e.length > 1) {
        var n = e.shift();
        e[0] = n + e[0];
      }
      e[0].match(/^file:\/\/\//) ? e[0] = e[0].replace(/^([^/:]+):\/*/, "$1:///") : e[0] = e[0].replace(/^([^/:]+):\/*/, "$1://");
      for (var o = 0; o < e.length; o++) {
        var r = e[o];
        if (typeof r != "string")
          throw new TypeError("Url must be a string. Received " + r);
        r !== "" && (o > 0 && (r = r.replace(/^[\/]+/, "")), o < e.length - 1 ? r = r.replace(/[\/]+$/, "") : r = r.replace(/[\/]+$/, "/"), i.push(r));
      }
      var a = i.join("/");
      a = a.replace(/\/(\?|&|#[^!])/g, "$1");
      var g = a.split("?");
      return a = g.shift() + (g.length > 0 ? "?" : "") + g.join("&"), a;
    }
    return function() {
      var e;
      return typeof arguments[0] == "object" ? e = arguments[0] : e = [].slice.call(arguments), t(e);
    };
  });
})(jB);
const yE = jB.exports;
var JB = { exports: {} }, rc = { exports: {} };
/*! https://mths.be/punycode v1.4.0 by @mathias */
var Vf;
function SE() {
  return Vf || (Vf = 1, function(s, t) {
    (function(e) {
      var i = t && !t.nodeType && t, n = s && !s.nodeType && s, o = typeof Ir == "object" && Ir;
      (o.global === o || o.window === o || o.self === o) && (e = o);
      var r, a = 2147483647, g = 36, c = 1, l = 26, h = 38, d = 700, C = 72, p = 128, m = "-", b = /^xn--/, S = /[^\x20-\x7E]/, A = /[\x2E\u3002\uFF0E\uFF61]/g, u = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, y = g - c, I = Math.floor, M = String.fromCharCode, G;
      function x(N) {
        throw new RangeError(u[N]);
      }
      function L(N, z) {
        for (var O = N.length, Q = []; O--; )
          Q[O] = z(N[O]);
        return Q;
      }
      function E(N, z) {
        var O = N.split("@"), Q = "";
        O.length > 1 && (Q = O[0] + "@", N = O[1]), N = N.replace(A, ".");
        var U = N.split("."), $ = L(U, z).join(".");
        return Q + $;
      }
      function T(N) {
        for (var z = [], O = 0, Q = N.length, U, $; O < Q; )
          U = N.charCodeAt(O++), U >= 55296 && U <= 56319 && O < Q ? ($ = N.charCodeAt(O++), ($ & 64512) == 56320 ? z.push(((U & 1023) << 10) + ($ & 1023) + 65536) : (z.push(U), O--)) : z.push(U);
        return z;
      }
      function R(N) {
        return L(N, function(z) {
          var O = "";
          return z > 65535 && (z -= 65536, O += M(z >>> 10 & 1023 | 55296), z = 56320 | z & 1023), O += M(z), O;
        }).join("");
      }
      function w(N) {
        return N - 48 < 10 ? N - 22 : N - 65 < 26 ? N - 65 : N - 97 < 26 ? N - 97 : g;
      }
      function v(N, z) {
        return N + 22 + 75 * (N < 26) - ((z != 0) << 5);
      }
      function D(N, z, O) {
        var Q = 0;
        for (N = O ? I(N / d) : N >> 1, N += I(N / z); N > y * l >> 1; Q += g)
          N = I(N / y);
        return I(Q + (y + 1) * N / (N + h));
      }
      function K(N) {
        var z = [], O = N.length, Q, U = 0, $ = p, ee = C, se, ie, Y, Ie, xe, fe, be, pe, Te;
        for (se = N.lastIndexOf(m), se < 0 && (se = 0), ie = 0; ie < se; ++ie)
          N.charCodeAt(ie) >= 128 && x("not-basic"), z.push(N.charCodeAt(ie));
        for (Y = se > 0 ? se + 1 : 0; Y < O; ) {
          for (Ie = U, xe = 1, fe = g; Y >= O && x("invalid-input"), be = w(N.charCodeAt(Y++)), (be >= g || be > I((a - U) / xe)) && x("overflow"), U += be * xe, pe = fe <= ee ? c : fe >= ee + l ? l : fe - ee, !(be < pe); fe += g)
            Te = g - pe, xe > I(a / Te) && x("overflow"), xe *= Te;
          Q = z.length + 1, ee = D(U - Ie, Q, Ie == 0), I(U / Q) > a - $ && x("overflow"), $ += I(U / Q), U %= Q, z.splice(U++, 0, $);
        }
        return R(z);
      }
      function P(N) {
        var z, O, Q, U, $, ee, se, ie, Y, Ie, xe, fe = [], be, pe, Te, ge;
        for (N = T(N), be = N.length, z = p, O = 0, $ = C, ee = 0; ee < be; ++ee)
          xe = N[ee], xe < 128 && fe.push(M(xe));
        for (Q = U = fe.length, U && fe.push(m); Q < be; ) {
          for (se = a, ee = 0; ee < be; ++ee)
            xe = N[ee], xe >= z && xe < se && (se = xe);
          for (pe = Q + 1, se - z > I((a - O) / pe) && x("overflow"), O += (se - z) * pe, z = se, ee = 0; ee < be; ++ee)
            if (xe = N[ee], xe < z && ++O > a && x("overflow"), xe == z) {
              for (ie = O, Y = g; Ie = Y <= $ ? c : Y >= $ + l ? l : Y - $, !(ie < Ie); Y += g)
                ge = ie - Ie, Te = g - Ie, fe.push(
                  M(v(Ie + ge % Te, 0))
                ), ie = I(ge / Te);
              fe.push(M(v(ie, 0))), $ = D(O, pe, Q == U), O = 0, ++Q;
            }
          ++O, ++z;
        }
        return fe.join("");
      }
      function k(N) {
        return E(N, function(z) {
          return b.test(z) ? K(z.slice(4).toLowerCase()) : z;
        });
      }
      function V(N) {
        return E(N, function(z) {
          return S.test(z) ? "xn--" + P(z) : z;
        });
      }
      if (r = {
        version: "1.3.2",
        ucs2: {
          decode: T,
          encode: R
        },
        decode: K,
        encode: P,
        toASCII: V,
        toUnicode: k
      }, i && n)
        if (s.exports == i)
          n.exports = r;
        else
          for (G in r)
            r.hasOwnProperty(G) && (i[G] = r[G]);
      else
        e.punycode = r;
    })(Ir);
  }(rc, rc.exports)), rc.exports;
}
var yd = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var zf;
function bE() {
  return zf || (zf = 1, function(s) {
    (function(t, e) {
      s.exports ? s.exports = e() : t.IPv6 = e(t);
    })(Ir, function(t) {
      var e = t && t.IPv6;
      function i(o) {
        var r = o.toLowerCase(), a = r.split(":"), g = a.length, c = 8;
        a[0] === "" && a[1] === "" && a[2] === "" ? (a.shift(), a.shift()) : a[0] === "" && a[1] === "" ? a.shift() : a[g - 1] === "" && a[g - 2] === "" && a.pop(), g = a.length, a[g - 1].indexOf(".") !== -1 && (c = 7);
        var l;
        for (l = 0; l < g && a[l] !== ""; l++)
          ;
        if (l < c)
          for (a.splice(l, 1, "0000"); a.length < c; )
            a.splice(l, 0, "0000");
        for (var h, d = 0; d < c; d++) {
          h = a[d].split("");
          for (var C = 0; C < 3 && (h[0] === "0" && h.length > 1); C++)
            h.splice(0, 1);
          a[d] = h.join("");
        }
        var p = -1, m = 0, b = 0, S = -1, A = !1;
        for (d = 0; d < c; d++)
          A ? a[d] === "0" ? b += 1 : (A = !1, b > m && (p = S, m = b)) : a[d] === "0" && (A = !0, S = d, b = 1);
        b > m && (p = S, m = b), m > 1 && a.splice(p, m, ""), g = a.length;
        var u = "";
        for (a[0] === "" && (u = ":"), d = 0; d < g && (u += a[d], d !== g - 1); d++)
          u += ":";
        return a[g - 1] === "" && (u += ":"), u;
      }
      function n() {
        return t.IPv6 === this && (t.IPv6 = e), this;
      }
      return {
        best: i,
        noConflict: n
      };
    });
  }(yd)), yd.exports;
}
var Sd = { exports: {} };
/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
var Xf;
function BE() {
  return Xf || (Xf = 1, function(s) {
    (function(t, e) {
      s.exports ? s.exports = e() : t.SecondLevelDomains = e(t);
    })(Ir, function(t) {
      var e = t && t.SecondLevelDomains, i = {
        list: {
          ac: " com gov mil net org ",
          ae: " ac co gov mil name net org pro sch ",
          af: " com edu gov net org ",
          al: " com edu gov mil net org ",
          ao: " co ed gv it og pb ",
          ar: " com edu gob gov int mil net org tur ",
          at: " ac co gv or ",
          au: " asn com csiro edu gov id net org ",
          ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          bb: " biz co com edu gov info net org store tv ",
          bh: " biz cc com edu gov info net org ",
          bn: " com edu gov net org ",
          bo: " com edu gob gov int mil net org tv ",
          br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          bs: " com edu gov net org ",
          bz: " du et om ov rg ",
          ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          ck: " biz co edu gen gov info net org ",
          cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          co: " com edu gov mil net nom org ",
          cr: " ac c co ed fi go or sa ",
          cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          do: " art com edu gob gov mil net org sld web ",
          dz: " art asso com edu gov net org pol ",
          ec: " com edu fin gov info med mil net org pro ",
          eg: " com edu eun gov mil name net org sci ",
          er: " com edu gov ind mil net org rochest w ",
          es: " com edu gob nom org ",
          et: " biz com edu gov info name net org ",
          fj: " ac biz com info mil name net org pro ",
          fk: " ac co gov net nom org ",
          fr: " asso com f gouv nom prd presse tm ",
          gg: " co net org ",
          gh: " com edu gov mil org ",
          gn: " ac com gov net org ",
          gr: " com edu gov mil net org ",
          gt: " com edu gob ind mil net org ",
          gu: " com edu gov net org ",
          hk: " com edu gov idv net org ",
          hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          id: " ac co go mil net or sch web ",
          il: " ac co gov idf k12 muni net org ",
          in: " ac co edu ernet firm gen gov i ind mil net nic org res ",
          iq: " com edu gov i mil net org ",
          ir: " ac co dnssec gov i id net org sch ",
          it: " edu gov ",
          je: " co net org ",
          jo: " com edu gov mil name net org sch ",
          jp: " ac ad co ed go gr lg ne or ",
          ke: " ac co go info me mobi ne or sc ",
          kh: " com edu gov mil net org per ",
          ki: " biz com de edu gov info mob net org tel ",
          km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          kn: " edu gov net org ",
          kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          kw: " com edu gov net org ",
          ky: " com edu gov net org ",
          kz: " com edu gov mil net org ",
          lb: " com edu gov net org ",
          lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          lr: " com edu gov net org ",
          lv: " asn com conf edu gov id mil net org ",
          ly: " com edu gov id med net org plc sch ",
          ma: " ac co gov m net org press ",
          mc: " asso tm ",
          me: " ac co edu gov its net org priv ",
          mg: " com edu gov mil nom org prd tm ",
          mk: " com edu gov inf name net org pro ",
          ml: " com edu gov net org presse ",
          mn: " edu gov org ",
          mo: " com edu gov net org ",
          mt: " com edu gov net org ",
          mv: " aero biz com coop edu gov info int mil museum name net org pro ",
          mw: " ac co com coop edu gov int museum net org ",
          mx: " com edu gob net org ",
          my: " com edu gov mil name net org sch ",
          nf: " arts com firm info net other per rec store web ",
          ng: " biz com edu gov mil mobi name net org sch ",
          ni: " ac co com edu gob mil net nom org ",
          np: " com edu gov mil net org ",
          nr: " biz com edu gov info net org ",
          om: " ac biz co com edu gov med mil museum net org pro sch ",
          pe: " com edu gob mil net nom org sld ",
          ph: " com edu gov i mil net ngo org ",
          pk: " biz com edu fam gob gok gon gop gos gov net org web ",
          pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          pr: " ac biz com edu est gov info isla name net org pro prof ",
          ps: " com edu gov net org plo sec ",
          pw: " belau co ed go ne or ",
          ro: " arts com firm info nom nt org rec store tm www ",
          rs: " ac co edu gov in org ",
          sb: " com edu gov net org ",
          sc: " com edu gov net org ",
          sh: " co com edu gov net nom org ",
          sl: " com edu gov net org ",
          st: " co com consulado edu embaixada gov mil net org principe saotome store ",
          sv: " com edu gob org red ",
          sz: " ac co org ",
          tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          tw: " club com ebiz edu game gov idv mil net org ",
          mu: " ac co com gov net or org ",
          mz: " ac co edu gov org ",
          na: " co com ",
          nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          pa: " abo ac com edu gob ing med net nom org sld ",
          pt: " com edu gov int net nome org publ ",
          py: " com edu gov mil net org ",
          qa: " com edu gov mil net org ",
          re: " asso com nom ",
          ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          rw: " ac co com edu gouv gov int mil net ",
          sa: " com edu gov med net org pub sch ",
          sd: " com edu gov info med net org tv ",
          se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          sg: " com edu gov idn net org per ",
          sn: " art com edu gouv org perso univ ",
          sy: " com edu gov mil net news org ",
          th: " ac co go in mi net or ",
          tj: " ac biz co com edu go gov info int mil name net nic org test web ",
          tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          tz: " ac co go ne or ",
          ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          ug: " ac co go ne or org sc ",
          uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          us: " dni fed isa kids nsn ",
          uy: " com edu gub mil net org ",
          ve: " co com edu gob info mil net org web ",
          vi: " co com k12 net org ",
          vn: " ac biz com edu gov health info int name net org pro ",
          ye: " co com gov ltd me net org plc ",
          yu: " ac co edu gov org ",
          za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          zm: " ac co com edu gov net org sch ",
          com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          net: "gb jp se uk ",
          org: "ae",
          de: "com "
        },
        has: function(n) {
          var o = n.lastIndexOf(".");
          if (o <= 0 || o >= n.length - 1)
            return !1;
          var r = n.lastIndexOf(".", o - 1);
          if (r <= 0 || r >= o - 1)
            return !1;
          var a = i.list[n.slice(o + 1)];
          return a ? a.indexOf(" " + n.slice(r + 1, o) + " ") >= 0 : !1;
        },
        is: function(n) {
          var o = n.lastIndexOf(".");
          if (o <= 0 || o >= n.length - 1)
            return !1;
          var r = n.lastIndexOf(".", o - 1);
          if (r >= 0)
            return !1;
          var a = i.list[n.slice(o + 1)];
          return a ? a.indexOf(" " + n.slice(0, o) + " ") >= 0 : !1;
        },
        get: function(n) {
          var o = n.lastIndexOf(".");
          if (o <= 0 || o >= n.length - 1)
            return null;
          var r = n.lastIndexOf(".", o - 1);
          if (r <= 0 || r >= o - 1)
            return null;
          var a = i.list[n.slice(o + 1)];
          return !a || a.indexOf(" " + n.slice(r + 1, o) + " ") < 0 ? null : n.slice(r + 1);
        },
        noConflict: function() {
          return t.SecondLevelDomains === this && (t.SecondLevelDomains = e), this;
        }
      };
      return i;
    });
  }(Sd)), Sd.exports;
}
/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.11
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function(s) {
  (function(t, e) {
    s.exports ? s.exports = e(SE(), bE(), BE()) : t.URI = e(t.punycode, t.IPv6, t.SecondLevelDomains, t);
  })(Ir, function(t, e, i, n) {
    var o = n && n.URI;
    function r(w, v) {
      var D = arguments.length >= 1, K = arguments.length >= 2;
      if (!(this instanceof r))
        return D ? K ? new r(w, v) : new r(w) : new r();
      if (w === void 0) {
        if (D)
          throw new TypeError("undefined is not a valid argument for URI");
        typeof location < "u" ? w = location.href + "" : w = "";
      }
      if (w === null && D)
        throw new TypeError("null is not a valid argument for URI");
      return this.href(w), v !== void 0 ? this.absoluteTo(v) : this;
    }
    function a(w) {
      return /^[0-9]+$/.test(w);
    }
    r.version = "1.19.11";
    var g = r.prototype, c = Object.prototype.hasOwnProperty;
    function l(w) {
      return w.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    }
    function h(w) {
      return w === void 0 ? "Undefined" : String(Object.prototype.toString.call(w)).slice(8, -1);
    }
    function d(w) {
      return h(w) === "Array";
    }
    function C(w, v) {
      var D = {}, K, P;
      if (h(v) === "RegExp")
        D = null;
      else if (d(v))
        for (K = 0, P = v.length; K < P; K++)
          D[v[K]] = !0;
      else
        D[v] = !0;
      for (K = 0, P = w.length; K < P; K++) {
        var k = D && D[w[K]] !== void 0 || !D && v.test(w[K]);
        k && (w.splice(K, 1), P--, K--);
      }
      return w;
    }
    function p(w, v) {
      var D, K;
      if (d(v)) {
        for (D = 0, K = v.length; D < K; D++)
          if (!p(w, v[D]))
            return !1;
        return !0;
      }
      var P = h(v);
      for (D = 0, K = w.length; D < K; D++)
        if (P === "RegExp") {
          if (typeof w[D] == "string" && w[D].match(v))
            return !0;
        } else if (w[D] === v)
          return !0;
      return !1;
    }
    function m(w, v) {
      if (!d(w) || !d(v) || w.length !== v.length)
        return !1;
      w.sort(), v.sort();
      for (var D = 0, K = w.length; D < K; D++)
        if (w[D] !== v[D])
          return !1;
      return !0;
    }
    function b(w) {
      var v = /^\/+|\/+$/g;
      return w.replace(v, "");
    }
    r._parts = function() {
      return {
        protocol: null,
        username: null,
        password: null,
        hostname: null,
        urn: null,
        port: null,
        path: null,
        query: null,
        fragment: null,
        preventInvalidHostname: r.preventInvalidHostname,
        duplicateQueryParameters: r.duplicateQueryParameters,
        escapeQuerySpace: r.escapeQuerySpace
      };
    }, r.preventInvalidHostname = !1, r.duplicateQueryParameters = !1, r.escapeQuerySpace = !0, r.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, r.idn_expression = /[^a-z0-9\._-]/i, r.punycode_expression = /(xn--)/i, r.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, r.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, r.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig, r.findUri = {
      start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
      end: /[\s\r\n]|$/,
      trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
      parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
    }, r.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, r.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g, r.defaultPorts = {
      http: "80",
      https: "443",
      ftp: "21",
      gopher: "70",
      ws: "80",
      wss: "443"
    }, r.hostProtocols = [
      "http",
      "https"
    ], r.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/, r.domAttributes = {
      a: "href",
      blockquote: "cite",
      link: "href",
      base: "href",
      script: "src",
      form: "action",
      img: "src",
      area: "href",
      iframe: "src",
      embed: "src",
      source: "src",
      track: "src",
      input: "src",
      audio: "src",
      video: "src"
    }, r.getDomAttribute = function(w) {
      if (!(!w || !w.nodeName)) {
        var v = w.nodeName.toLowerCase();
        if (!(v === "input" && w.type !== "image"))
          return r.domAttributes[v];
      }
    };
    function S(w) {
      return escape(w);
    }
    function A(w) {
      return encodeURIComponent(w).replace(/[!'()*]/g, S).replace(/\*/g, "%2A");
    }
    r.encode = A, r.decode = decodeURIComponent, r.iso8859 = function() {
      r.encode = escape, r.decode = unescape;
    }, r.unicode = function() {
      r.encode = A, r.decode = decodeURIComponent;
    }, r.characters = {
      pathname: {
        encode: {
          expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
          map: {
            "%24": "$",
            "%26": "&",
            "%2B": "+",
            "%2C": ",",
            "%3B": ";",
            "%3D": "=",
            "%3A": ":",
            "%40": "@"
          }
        },
        decode: {
          expression: /[\/\?#]/g,
          map: {
            "/": "%2F",
            "?": "%3F",
            "#": "%23"
          }
        }
      },
      reserved: {
        encode: {
          expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
          map: {
            "%3A": ":",
            "%2F": "/",
            "%3F": "?",
            "%23": "#",
            "%5B": "[",
            "%5D": "]",
            "%40": "@",
            "%21": "!",
            "%24": "$",
            "%26": "&",
            "%27": "'",
            "%28": "(",
            "%29": ")",
            "%2A": "*",
            "%2B": "+",
            "%2C": ",",
            "%3B": ";",
            "%3D": "="
          }
        }
      },
      urnpath: {
        encode: {
          expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
          map: {
            "%21": "!",
            "%24": "$",
            "%27": "'",
            "%28": "(",
            "%29": ")",
            "%2A": "*",
            "%2B": "+",
            "%2C": ",",
            "%3B": ";",
            "%3D": "=",
            "%40": "@"
          }
        },
        decode: {
          expression: /[\/\?#:]/g,
          map: {
            "/": "%2F",
            "?": "%3F",
            "#": "%23",
            ":": "%3A"
          }
        }
      }
    }, r.encodeQuery = function(w, v) {
      var D = r.encode(w + "");
      return v === void 0 && (v = r.escapeQuerySpace), v ? D.replace(/%20/g, "+") : D;
    }, r.decodeQuery = function(w, v) {
      w += "", v === void 0 && (v = r.escapeQuerySpace);
      try {
        return r.decode(v ? w.replace(/\+/g, "%20") : w);
      } catch {
        return w;
      }
    };
    var u = { encode: "encode", decode: "decode" }, y, I = function(w, v) {
      return function(D) {
        try {
          return r[v](D + "").replace(r.characters[w][v].expression, function(K) {
            return r.characters[w][v].map[K];
          });
        } catch {
          return D;
        }
      };
    };
    for (y in u)
      r[y + "PathSegment"] = I("pathname", u[y]), r[y + "UrnPathSegment"] = I("urnpath", u[y]);
    var M = function(w, v, D) {
      return function(K) {
        var P;
        D ? P = function(z) {
          return r[v](r[D](z));
        } : P = r[v];
        for (var k = (K + "").split(w), V = 0, N = k.length; V < N; V++)
          k[V] = P(k[V]);
        return k.join(w);
      };
    };
    r.decodePath = M("/", "decodePathSegment"), r.decodeUrnPath = M(":", "decodeUrnPathSegment"), r.recodePath = M("/", "encodePathSegment", "decode"), r.recodeUrnPath = M(":", "encodeUrnPathSegment", "decode"), r.encodeReserved = I("reserved", "encode"), r.parse = function(w, v) {
      var D;
      return v || (v = {
        preventInvalidHostname: r.preventInvalidHostname
      }), w = w.replace(r.leading_whitespace_expression, ""), w = w.replace(r.ascii_tab_whitespace, ""), D = w.indexOf("#"), D > -1 && (v.fragment = w.substring(D + 1) || null, w = w.substring(0, D)), D = w.indexOf("?"), D > -1 && (v.query = w.substring(D + 1) || null, w = w.substring(0, D)), w = w.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://"), w = w.replace(/^[/\\]{2,}/i, "//"), w.substring(0, 2) === "//" ? (v.protocol = null, w = w.substring(2), w = r.parseAuthority(w, v)) : (D = w.indexOf(":"), D > -1 && (v.protocol = w.substring(0, D) || null, v.protocol && !v.protocol.match(r.protocol_expression) ? v.protocol = void 0 : w.substring(D + 1, D + 3).replace(/\\/g, "/") === "//" ? (w = w.substring(D + 3), w = r.parseAuthority(w, v)) : (w = w.substring(D + 1), v.urn = !0))), v.path = w, v;
    }, r.parseHost = function(w, v) {
      w || (w = ""), w = w.replace(/\\/g, "/");
      var D = w.indexOf("/"), K, P;
      if (D === -1 && (D = w.length), w.charAt(0) === "[")
        K = w.indexOf("]"), v.hostname = w.substring(1, K) || null, v.port = w.substring(K + 2, D) || null, v.port === "/" && (v.port = null);
      else {
        var k = w.indexOf(":"), V = w.indexOf("/"), N = w.indexOf(":", k + 1);
        N !== -1 && (V === -1 || N < V) ? (v.hostname = w.substring(0, D) || null, v.port = null) : (P = w.substring(0, D).split(":"), v.hostname = P[0] || null, v.port = P[1] || null);
      }
      return v.hostname && w.substring(D).charAt(0) !== "/" && (D++, w = "/" + w), v.preventInvalidHostname && r.ensureValidHostname(v.hostname, v.protocol), v.port && r.ensureValidPort(v.port), w.substring(D) || "/";
    }, r.parseAuthority = function(w, v) {
      return w = r.parseUserinfo(w, v), r.parseHost(w, v);
    }, r.parseUserinfo = function(w, v) {
      var D = w, K = w.indexOf("\\");
      K !== -1 && (w = w.replace(/\\/g, "/"));
      var P = w.indexOf("/"), k = w.lastIndexOf("@", P > -1 ? P : w.length - 1), V;
      return k > -1 && (P === -1 || k < P) ? (V = w.substring(0, k).split(":"), v.username = V[0] ? r.decode(V[0]) : null, V.shift(), v.password = V[0] ? r.decode(V.join(":")) : null, w = D.substring(k + 1)) : (v.username = null, v.password = null), w;
    }, r.parseQuery = function(w, v) {
      if (!w)
        return {};
      if (w = w.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""), !w)
        return {};
      for (var D = {}, K = w.split("&"), P = K.length, k, V, N, z = 0; z < P; z++)
        k = K[z].split("="), V = r.decodeQuery(k.shift(), v), N = k.length ? r.decodeQuery(k.join("="), v) : null, V !== "__proto__" && (c.call(D, V) ? ((typeof D[V] == "string" || D[V] === null) && (D[V] = [D[V]]), D[V].push(N)) : D[V] = N);
      return D;
    }, r.build = function(w) {
      var v = "", D = !1;
      return w.protocol && (v += w.protocol + ":"), !w.urn && (v || w.hostname) && (v += "//", D = !0), v += r.buildAuthority(w) || "", typeof w.path == "string" && (w.path.charAt(0) !== "/" && D && (v += "/"), v += w.path), typeof w.query == "string" && w.query && (v += "?" + w.query), typeof w.fragment == "string" && w.fragment && (v += "#" + w.fragment), v;
    }, r.buildHost = function(w) {
      var v = "";
      if (w.hostname)
        r.ip6_expression.test(w.hostname) ? v += "[" + w.hostname + "]" : v += w.hostname;
      else
        return "";
      return w.port && (v += ":" + w.port), v;
    }, r.buildAuthority = function(w) {
      return r.buildUserinfo(w) + r.buildHost(w);
    }, r.buildUserinfo = function(w) {
      var v = "";
      return w.username && (v += r.encode(w.username)), w.password && (v += ":" + r.encode(w.password)), v && (v += "@"), v;
    }, r.buildQuery = function(w, v, D) {
      var K = "", P, k, V, N;
      for (k in w)
        if (k !== "__proto__" && c.call(w, k))
          if (d(w[k]))
            for (P = {}, V = 0, N = w[k].length; V < N; V++)
              w[k][V] !== void 0 && P[w[k][V] + ""] === void 0 && (K += "&" + r.buildQueryParameter(k, w[k][V], D), v !== !0 && (P[w[k][V] + ""] = !0));
          else
            w[k] !== void 0 && (K += "&" + r.buildQueryParameter(k, w[k], D));
      return K.substring(1);
    }, r.buildQueryParameter = function(w, v, D) {
      return r.encodeQuery(w, D) + (v !== null ? "=" + r.encodeQuery(v, D) : "");
    }, r.addQuery = function(w, v, D) {
      if (typeof v == "object")
        for (var K in v)
          c.call(v, K) && r.addQuery(w, K, v[K]);
      else if (typeof v == "string") {
        if (w[v] === void 0) {
          w[v] = D;
          return;
        } else
          typeof w[v] == "string" && (w[v] = [w[v]]);
        d(D) || (D = [D]), w[v] = (w[v] || []).concat(D);
      } else
        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
    }, r.setQuery = function(w, v, D) {
      if (typeof v == "object")
        for (var K in v)
          c.call(v, K) && r.setQuery(w, K, v[K]);
      else if (typeof v == "string")
        w[v] = D === void 0 ? null : D;
      else
        throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
    }, r.removeQuery = function(w, v, D) {
      var K, P, k;
      if (d(v))
        for (K = 0, P = v.length; K < P; K++)
          w[v[K]] = void 0;
      else if (h(v) === "RegExp")
        for (k in w)
          v.test(k) && (w[k] = void 0);
      else if (typeof v == "object")
        for (k in v)
          c.call(v, k) && r.removeQuery(w, k, v[k]);
      else if (typeof v == "string")
        D !== void 0 ? h(D) === "RegExp" ? !d(w[v]) && D.test(w[v]) ? w[v] = void 0 : w[v] = C(w[v], D) : w[v] === String(D) && (!d(D) || D.length === 1) ? w[v] = void 0 : d(w[v]) && (w[v] = C(w[v], D)) : w[v] = void 0;
      else
        throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
    }, r.hasQuery = function(w, v, D, K) {
      switch (h(v)) {
        case "String":
          break;
        case "RegExp":
          for (var P in w)
            if (c.call(w, P) && v.test(P) && (D === void 0 || r.hasQuery(w, P, D)))
              return !0;
          return !1;
        case "Object":
          for (var k in v)
            if (c.call(v, k) && !r.hasQuery(w, k, v[k]))
              return !1;
          return !0;
        default:
          throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
      }
      switch (h(D)) {
        case "Undefined":
          return v in w;
        case "Boolean":
          var V = Boolean(d(w[v]) ? w[v].length : w[v]);
          return D === V;
        case "Function":
          return !!D(w[v], v, w);
        case "Array":
          if (!d(w[v]))
            return !1;
          var N = K ? p : m;
          return N(w[v], D);
        case "RegExp":
          return d(w[v]) ? K ? p(w[v], D) : !1 : Boolean(w[v] && w[v].match(D));
        case "Number":
          D = String(D);
        case "String":
          return d(w[v]) ? K ? p(w[v], D) : !1 : w[v] === D;
        default:
          throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
      }
    }, r.joinPaths = function() {
      for (var w = [], v = [], D = 0, K = 0; K < arguments.length; K++) {
        var P = new r(arguments[K]);
        w.push(P);
        for (var k = P.segment(), V = 0; V < k.length; V++)
          typeof k[V] == "string" && v.push(k[V]), k[V] && D++;
      }
      if (!v.length || !D)
        return new r("");
      var N = new r("").segment(v);
      return (w[0].path() === "" || w[0].path().slice(0, 1) === "/") && N.path("/" + N.path()), N.normalize();
    }, r.commonPath = function(w, v) {
      var D = Math.min(w.length, v.length), K;
      for (K = 0; K < D; K++)
        if (w.charAt(K) !== v.charAt(K)) {
          K--;
          break;
        }
      return K < 1 ? w.charAt(0) === v.charAt(0) && w.charAt(0) === "/" ? "/" : "" : ((w.charAt(K) !== "/" || v.charAt(K) !== "/") && (K = w.substring(0, K).lastIndexOf("/")), w.substring(0, K + 1));
    }, r.withinString = function(w, v, D) {
      D || (D = {});
      var K = D.start || r.findUri.start, P = D.end || r.findUri.end, k = D.trim || r.findUri.trim, V = D.parens || r.findUri.parens, N = /[a-z0-9-]=["']?$/i;
      for (K.lastIndex = 0; ; ) {
        var z = K.exec(w);
        if (!z)
          break;
        var O = z.index;
        if (D.ignoreHtml) {
          var Q = w.slice(Math.max(O - 3, 0), O);
          if (Q && N.test(Q))
            continue;
        }
        for (var U = O + w.slice(O).search(P), $ = w.slice(O, U), ee = -1; ; ) {
          var se = V.exec($);
          if (!se)
            break;
          var ie = se.index + se[0].length;
          ee = Math.max(ee, ie);
        }
        if (ee > -1 ? $ = $.slice(0, ee) + $.slice(ee).replace(k, "") : $ = $.replace(k, ""), !($.length <= z[0].length) && !(D.ignore && D.ignore.test($))) {
          U = O + $.length;
          var Y = v($, O, U, w);
          if (Y === void 0) {
            K.lastIndex = U;
            continue;
          }
          Y = String(Y), w = w.slice(0, O) + Y + w.slice(U), K.lastIndex = O + Y.length;
        }
      }
      return K.lastIndex = 0, w;
    }, r.ensureValidHostname = function(w, v) {
      var D = !!w, K = !!v, P = !1;
      if (K && (P = p(r.hostProtocols, v)), P && !D)
        throw new TypeError("Hostname cannot be empty, if protocol is " + v);
      if (w && w.match(r.invalid_hostname_characters)) {
        if (!t)
          throw new TypeError('Hostname "' + w + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
        if (t.toASCII(w).match(r.invalid_hostname_characters))
          throw new TypeError('Hostname "' + w + '" contains characters other than [A-Z0-9.-:_]');
      }
    }, r.ensureValidPort = function(w) {
      if (!!w) {
        var v = Number(w);
        if (!(a(v) && v > 0 && v < 65536))
          throw new TypeError('Port "' + w + '" is not a valid port');
      }
    }, r.noConflict = function(w) {
      if (w) {
        var v = {
          URI: this.noConflict()
        };
        return n.URITemplate && typeof n.URITemplate.noConflict == "function" && (v.URITemplate = n.URITemplate.noConflict()), n.IPv6 && typeof n.IPv6.noConflict == "function" && (v.IPv6 = n.IPv6.noConflict()), n.SecondLevelDomains && typeof n.SecondLevelDomains.noConflict == "function" && (v.SecondLevelDomains = n.SecondLevelDomains.noConflict()), v;
      } else
        n.URI === this && (n.URI = o);
      return this;
    }, g.build = function(w) {
      return w === !0 ? this._deferred_build = !0 : (w === void 0 || this._deferred_build) && (this._string = r.build(this._parts), this._deferred_build = !1), this;
    }, g.clone = function() {
      return new r(this);
    }, g.valueOf = g.toString = function() {
      return this.build(!1)._string;
    };
    function G(w) {
      return function(v, D) {
        return v === void 0 ? this._parts[w] || "" : (this._parts[w] = v || null, this.build(!D), this);
      };
    }
    function x(w, v) {
      return function(D, K) {
        return D === void 0 ? this._parts[w] || "" : (D !== null && (D = D + "", D.charAt(0) === v && (D = D.substring(1))), this._parts[w] = D, this.build(!K), this);
      };
    }
    g.protocol = G("protocol"), g.username = G("username"), g.password = G("password"), g.hostname = G("hostname"), g.port = G("port"), g.query = x("query", "?"), g.fragment = x("fragment", "#"), g.search = function(w, v) {
      var D = this.query(w, v);
      return typeof D == "string" && D.length ? "?" + D : D;
    }, g.hash = function(w, v) {
      var D = this.fragment(w, v);
      return typeof D == "string" && D.length ? "#" + D : D;
    }, g.pathname = function(w, v) {
      if (w === void 0 || w === !0) {
        var D = this._parts.path || (this._parts.hostname ? "/" : "");
        return w ? (this._parts.urn ? r.decodeUrnPath : r.decodePath)(D) : D;
      } else
        return this._parts.urn ? this._parts.path = w ? r.recodeUrnPath(w) : "" : this._parts.path = w ? r.recodePath(w) : "/", this.build(!v), this;
    }, g.path = g.pathname, g.href = function(w, v) {
      var D;
      if (w === void 0)
        return this.toString();
      this._string = "", this._parts = r._parts();
      var K = w instanceof r, P = typeof w == "object" && (w.hostname || w.path || w.pathname);
      if (w.nodeName) {
        var k = r.getDomAttribute(w);
        w = w[k] || "", P = !1;
      }
      if (!K && P && w.pathname !== void 0 && (w = w.toString()), typeof w == "string" || w instanceof String)
        this._parts = r.parse(String(w), this._parts);
      else if (K || P) {
        var V = K ? w._parts : w;
        for (D in V)
          D !== "query" && c.call(this._parts, D) && (this._parts[D] = V[D]);
        V.query && this.query(V.query, !1);
      } else
        throw new TypeError("invalid input");
      return this.build(!v), this;
    }, g.is = function(w) {
      var v = !1, D = !1, K = !1, P = !1, k = !1, V = !1, N = !1, z = !this._parts.urn;
      switch (this._parts.hostname && (z = !1, D = r.ip4_expression.test(this._parts.hostname), K = r.ip6_expression.test(this._parts.hostname), v = D || K, P = !v, k = P && i && i.has(this._parts.hostname), V = P && r.idn_expression.test(this._parts.hostname), N = P && r.punycode_expression.test(this._parts.hostname)), w.toLowerCase()) {
        case "relative":
          return z;
        case "absolute":
          return !z;
        case "domain":
        case "name":
          return P;
        case "sld":
          return k;
        case "ip":
          return v;
        case "ip4":
        case "ipv4":
        case "inet4":
          return D;
        case "ip6":
        case "ipv6":
        case "inet6":
          return K;
        case "idn":
          return V;
        case "url":
          return !this._parts.urn;
        case "urn":
          return !!this._parts.urn;
        case "punycode":
          return N;
      }
      return null;
    };
    var L = g.protocol, E = g.port, T = g.hostname;
    g.protocol = function(w, v) {
      if (w && (w = w.replace(/:(\/\/)?$/, ""), !w.match(r.protocol_expression)))
        throw new TypeError('Protocol "' + w + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
      return L.call(this, w, v);
    }, g.scheme = g.protocol, g.port = function(w, v) {
      return this._parts.urn ? w === void 0 ? "" : this : (w !== void 0 && (w === 0 && (w = null), w && (w += "", w.charAt(0) === ":" && (w = w.substring(1)), r.ensureValidPort(w))), E.call(this, w, v));
    }, g.hostname = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w !== void 0) {
        var D = { preventInvalidHostname: this._parts.preventInvalidHostname }, K = r.parseHost(w, D);
        if (K !== "/")
          throw new TypeError('Hostname "' + w + '" contains characters other than [A-Z0-9.-]');
        w = D.hostname, this._parts.preventInvalidHostname && r.ensureValidHostname(w, this._parts.protocol);
      }
      return T.call(this, w, v);
    }, g.origin = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0) {
        var D = this.protocol(), K = this.authority();
        return K ? (D ? D + "://" : "") + this.authority() : "";
      } else {
        var P = r(w);
        return this.protocol(P.protocol()).authority(P.authority()).build(!v), this;
      }
    }, g.host = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0)
        return this._parts.hostname ? r.buildHost(this._parts) : "";
      var D = r.parseHost(w, this._parts);
      if (D !== "/")
        throw new TypeError('Hostname "' + w + '" contains characters other than [A-Z0-9.-]');
      return this.build(!v), this;
    }, g.authority = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0)
        return this._parts.hostname ? r.buildAuthority(this._parts) : "";
      var D = r.parseAuthority(w, this._parts);
      if (D !== "/")
        throw new TypeError('Hostname "' + w + '" contains characters other than [A-Z0-9.-]');
      return this.build(!v), this;
    }, g.userinfo = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0) {
        var D = r.buildUserinfo(this._parts);
        return D && D.substring(0, D.length - 1);
      } else
        return w[w.length - 1] !== "@" && (w += "@"), r.parseUserinfo(w, this._parts), this.build(!v), this;
    }, g.resource = function(w, v) {
      var D;
      return w === void 0 ? this.path() + this.search() + this.hash() : (D = r.parse(w), this._parts.path = D.path, this._parts.query = D.query, this._parts.fragment = D.fragment, this.build(!v), this);
    }, g.subdomain = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0) {
        if (!this._parts.hostname || this.is("IP"))
          return "";
        var D = this._parts.hostname.length - this.domain().length - 1;
        return this._parts.hostname.substring(0, D) || "";
      } else {
        var K = this._parts.hostname.length - this.domain().length, P = this._parts.hostname.substring(0, K), k = new RegExp("^" + l(P));
        if (w && w.charAt(w.length - 1) !== "." && (w += "."), w.indexOf(":") !== -1)
          throw new TypeError("Domains cannot contain colons");
        return w && r.ensureValidHostname(w, this._parts.protocol), this._parts.hostname = this._parts.hostname.replace(k, w), this.build(!v), this;
      }
    }, g.domain = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (typeof w == "boolean" && (v = w, w = void 0), w === void 0) {
        if (!this._parts.hostname || this.is("IP"))
          return "";
        var D = this._parts.hostname.match(/\./g);
        if (D && D.length < 2)
          return this._parts.hostname;
        var K = this._parts.hostname.length - this.tld(v).length - 1;
        return K = this._parts.hostname.lastIndexOf(".", K - 1) + 1, this._parts.hostname.substring(K) || "";
      } else {
        if (!w)
          throw new TypeError("cannot set domain empty");
        if (w.indexOf(":") !== -1)
          throw new TypeError("Domains cannot contain colons");
        if (r.ensureValidHostname(w, this._parts.protocol), !this._parts.hostname || this.is("IP"))
          this._parts.hostname = w;
        else {
          var P = new RegExp(l(this.domain()) + "$");
          this._parts.hostname = this._parts.hostname.replace(P, w);
        }
        return this.build(!v), this;
      }
    }, g.tld = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (typeof w == "boolean" && (v = w, w = void 0), w === void 0) {
        if (!this._parts.hostname || this.is("IP"))
          return "";
        var D = this._parts.hostname.lastIndexOf("."), K = this._parts.hostname.substring(D + 1);
        return v !== !0 && i && i.list[K.toLowerCase()] && i.get(this._parts.hostname) || K;
      } else {
        var P;
        if (w)
          if (w.match(/[^a-zA-Z0-9-]/))
            if (i && i.is(w))
              P = new RegExp(l(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(P, w);
            else
              throw new TypeError('TLD "' + w + '" contains characters other than [A-Z0-9]');
          else {
            if (!this._parts.hostname || this.is("IP"))
              throw new ReferenceError("cannot set TLD on non-domain host");
            P = new RegExp(l(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(P, w);
          }
        else
          throw new TypeError("cannot set TLD empty");
        return this.build(!v), this;
      }
    }, g.directory = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0 || w === !0) {
        if (!this._parts.path && !this._parts.hostname)
          return "";
        if (this._parts.path === "/")
          return "/";
        var D = this._parts.path.length - this.filename().length - 1, K = this._parts.path.substring(0, D) || (this._parts.hostname ? "/" : "");
        return w ? r.decodePath(K) : K;
      } else {
        var P = this._parts.path.length - this.filename().length, k = this._parts.path.substring(0, P), V = new RegExp("^" + l(k));
        return this.is("relative") || (w || (w = "/"), w.charAt(0) !== "/" && (w = "/" + w)), w && w.charAt(w.length - 1) !== "/" && (w += "/"), w = r.recodePath(w), this._parts.path = this._parts.path.replace(V, w), this.build(!v), this;
      }
    }, g.filename = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (typeof w != "string") {
        if (!this._parts.path || this._parts.path === "/")
          return "";
        var D = this._parts.path.lastIndexOf("/"), K = this._parts.path.substring(D + 1);
        return w ? r.decodePathSegment(K) : K;
      } else {
        var P = !1;
        w.charAt(0) === "/" && (w = w.substring(1)), w.match(/\.?\//) && (P = !0);
        var k = new RegExp(l(this.filename()) + "$");
        return w = r.recodePath(w), this._parts.path = this._parts.path.replace(k, w), P ? this.normalizePath(v) : this.build(!v), this;
      }
    }, g.suffix = function(w, v) {
      if (this._parts.urn)
        return w === void 0 ? "" : this;
      if (w === void 0 || w === !0) {
        if (!this._parts.path || this._parts.path === "/")
          return "";
        var D = this.filename(), K = D.lastIndexOf("."), P, k;
        return K === -1 ? "" : (P = D.substring(K + 1), k = /^[a-z0-9%]+$/i.test(P) ? P : "", w ? r.decodePathSegment(k) : k);
      } else {
        w.charAt(0) === "." && (w = w.substring(1));
        var V = this.suffix(), N;
        if (V)
          w ? N = new RegExp(l(V) + "$") : N = new RegExp(l("." + V) + "$");
        else {
          if (!w)
            return this;
          this._parts.path += "." + r.recodePath(w);
        }
        return N && (w = r.recodePath(w), this._parts.path = this._parts.path.replace(N, w)), this.build(!v), this;
      }
    }, g.segment = function(w, v, D) {
      var K = this._parts.urn ? ":" : "/", P = this.path(), k = P.substring(0, 1) === "/", V = P.split(K);
      if (w !== void 0 && typeof w != "number" && (D = v, v = w, w = void 0), w !== void 0 && typeof w != "number")
        throw new Error('Bad segment "' + w + '", must be 0-based integer');
      if (k && V.shift(), w < 0 && (w = Math.max(V.length + w, 0)), v === void 0)
        return w === void 0 ? V : V[w];
      if (w === null || V[w] === void 0)
        if (d(v)) {
          V = [];
          for (var N = 0, z = v.length; N < z; N++)
            !v[N].length && (!V.length || !V[V.length - 1].length) || (V.length && !V[V.length - 1].length && V.pop(), V.push(b(v[N])));
        } else
          (v || typeof v == "string") && (v = b(v), V[V.length - 1] === "" ? V[V.length - 1] = v : V.push(v));
      else
        v ? V[w] = b(v) : V.splice(w, 1);
      return k && V.unshift(""), this.path(V.join(K), D);
    }, g.segmentCoded = function(w, v, D) {
      var K, P, k;
      if (typeof w != "number" && (D = v, v = w, w = void 0), v === void 0) {
        if (K = this.segment(w, v, D), !d(K))
          K = K !== void 0 ? r.decode(K) : void 0;
        else
          for (P = 0, k = K.length; P < k; P++)
            K[P] = r.decode(K[P]);
        return K;
      }
      if (!d(v))
        v = typeof v == "string" || v instanceof String ? r.encode(v) : v;
      else
        for (P = 0, k = v.length; P < k; P++)
          v[P] = r.encode(v[P]);
      return this.segment(w, v, D);
    };
    var R = g.query;
    return g.query = function(w, v) {
      if (w === !0)
        return r.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      if (typeof w == "function") {
        var D = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace), K = w.call(this, D);
        return this._parts.query = r.buildQuery(K || D, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!v), this;
      } else
        return w !== void 0 && typeof w != "string" ? (this._parts.query = r.buildQuery(w, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!v), this) : R.call(this, w, v);
    }, g.setQuery = function(w, v, D) {
      var K = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      if (typeof w == "string" || w instanceof String)
        K[w] = v !== void 0 ? v : null;
      else if (typeof w == "object")
        for (var P in w)
          c.call(w, P) && (K[P] = w[P]);
      else
        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
      return this._parts.query = r.buildQuery(K, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof w != "string" && (D = v), this.build(!D), this;
    }, g.addQuery = function(w, v, D) {
      var K = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return r.addQuery(K, w, v === void 0 ? null : v), this._parts.query = r.buildQuery(K, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof w != "string" && (D = v), this.build(!D), this;
    }, g.removeQuery = function(w, v, D) {
      var K = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return r.removeQuery(K, w, v), this._parts.query = r.buildQuery(K, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof w != "string" && (D = v), this.build(!D), this;
    }, g.hasQuery = function(w, v, D) {
      var K = r.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      return r.hasQuery(K, w, v, D);
    }, g.setSearch = g.setQuery, g.addSearch = g.addQuery, g.removeSearch = g.removeQuery, g.hasSearch = g.hasQuery, g.normalize = function() {
      return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build();
    }, g.normalizeProtocol = function(w) {
      return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!w)), this;
    }, g.normalizeHostname = function(w) {
      return this._parts.hostname && (this.is("IDN") && t ? this._parts.hostname = t.toASCII(this._parts.hostname) : this.is("IPv6") && e && (this._parts.hostname = e.best(this._parts.hostname)), this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!w)), this;
    }, g.normalizePort = function(w) {
      return typeof this._parts.protocol == "string" && this._parts.port === r.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!w)), this;
    }, g.normalizePath = function(w) {
      var v = this._parts.path;
      if (!v)
        return this;
      if (this._parts.urn)
        return this._parts.path = r.recodeUrnPath(this._parts.path), this.build(!w), this;
      if (this._parts.path === "/")
        return this;
      v = r.recodePath(v);
      var D, K = "", P, k;
      for (v.charAt(0) !== "/" && (D = !0, v = "/" + v), (v.slice(-3) === "/.." || v.slice(-2) === "/.") && (v += "/"), v = v.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), D && (K = v.substring(1).match(/^(\.\.\/)+/) || "", K && (K = K[0])); P = v.search(/\/\.\.(\/|$)/), P !== -1; ) {
        if (P === 0) {
          v = v.substring(3);
          continue;
        }
        k = v.substring(0, P).lastIndexOf("/"), k === -1 && (k = P), v = v.substring(0, k) + v.substring(P + 3);
      }
      return D && this.is("relative") && (v = K + v.substring(1)), this._parts.path = v, this.build(!w), this;
    }, g.normalizePathname = g.normalizePath, g.normalizeQuery = function(w) {
      return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(r.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, this.build(!w)), this;
    }, g.normalizeFragment = function(w) {
      return this._parts.fragment || (this._parts.fragment = null, this.build(!w)), this;
    }, g.normalizeSearch = g.normalizeQuery, g.normalizeHash = g.normalizeFragment, g.iso8859 = function() {
      var w = r.encode, v = r.decode;
      r.encode = escape, r.decode = decodeURIComponent;
      try {
        this.normalize();
      } finally {
        r.encode = w, r.decode = v;
      }
      return this;
    }, g.unicode = function() {
      var w = r.encode, v = r.decode;
      r.encode = A, r.decode = unescape;
      try {
        this.normalize();
      } finally {
        r.encode = w, r.decode = v;
      }
      return this;
    }, g.readable = function() {
      var w = this.clone();
      w.username("").password("").normalize();
      var v = "";
      if (w._parts.protocol && (v += w._parts.protocol + "://"), w._parts.hostname && (w.is("punycode") && t ? (v += t.toUnicode(w._parts.hostname), w._parts.port && (v += ":" + w._parts.port)) : v += w.host()), w._parts.hostname && w._parts.path && w._parts.path.charAt(0) !== "/" && (v += "/"), v += w.path(!0), w._parts.query) {
        for (var D = "", K = 0, P = w._parts.query.split("&"), k = P.length; K < k; K++) {
          var V = (P[K] || "").split("=");
          D += "&" + r.decodeQuery(V[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), V[1] !== void 0 && (D += "=" + r.decodeQuery(V[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"));
        }
        v += "?" + D.substring(1);
      }
      return v += r.decodeQuery(w.hash(), !0), v;
    }, g.absoluteTo = function(w) {
      var v = this.clone(), D = ["protocol", "username", "password", "hostname", "port"], K, P, k;
      if (this._parts.urn)
        throw new Error("URNs do not have any generally defined hierarchical components");
      if (w instanceof r || (w = new r(w)), v._parts.protocol || (v._parts.protocol = w._parts.protocol, this._parts.hostname))
        return v;
      for (P = 0; k = D[P]; P++)
        v._parts[k] = w._parts[k];
      return v._parts.path ? (v._parts.path.substring(-2) === ".." && (v._parts.path += "/"), v.path().charAt(0) !== "/" && (K = w.directory(), K = K || (w.path().indexOf("/") === 0 ? "/" : ""), v._parts.path = (K ? K + "/" : "") + v._parts.path, v.normalizePath())) : (v._parts.path = w._parts.path, v._parts.query || (v._parts.query = w._parts.query)), v.build(), v;
    }, g.relativeTo = function(w) {
      var v = this.clone().normalize(), D, K, P, k, V;
      if (v._parts.urn)
        throw new Error("URNs do not have any generally defined hierarchical components");
      if (w = new r(w).normalize(), D = v._parts, K = w._parts, k = v.path(), V = w.path(), k.charAt(0) !== "/")
        throw new Error("URI is already relative");
      if (V.charAt(0) !== "/")
        throw new Error("Cannot calculate a URI relative to another relative URI");
      if (D.protocol === K.protocol && (D.protocol = null), D.username !== K.username || D.password !== K.password || D.protocol !== null || D.username !== null || D.password !== null)
        return v.build();
      if (D.hostname === K.hostname && D.port === K.port)
        D.hostname = null, D.port = null;
      else
        return v.build();
      if (k === V)
        return D.path = "", v.build();
      if (P = r.commonPath(k, V), !P)
        return v.build();
      var N = K.path.substring(P.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
      return D.path = N + D.path.substring(P.length) || "./", v.build();
    }, g.equals = function(w) {
      var v = this.clone(), D = new r(w), K = {}, P = {}, k = {}, V, N, z;
      if (v.normalize(), D.normalize(), v.toString() === D.toString())
        return !0;
      if (V = v.query(), N = D.query(), v.query(""), D.query(""), v.toString() !== D.toString() || V.length !== N.length)
        return !1;
      K = r.parseQuery(V, this._parts.escapeQuerySpace), P = r.parseQuery(N, this._parts.escapeQuerySpace);
      for (z in K)
        if (c.call(K, z)) {
          if (d(K[z])) {
            if (!m(K[z], P[z]))
              return !1;
          } else if (K[z] !== P[z])
            return !1;
          k[z] = !0;
        }
      for (z in P)
        if (c.call(P, z) && !k[z])
          return !1;
      return !0;
    }, g.preventInvalidHostname = function(w) {
      return this._parts.preventInvalidHostname = !!w, this;
    }, g.duplicateQueryParameters = function(w) {
      return this._parts.duplicateQueryParameters = !!w, this;
    }, g.escapeQuerySpace = function(w) {
      return this._parts.escapeQuerySpace = !!w, this;
    }, r;
  });
})(JB);
const Zs = JB.exports;
function El(s) {
  return s && typeof s == "object" && !Array.isArray(s);
}
function iA(s) {
  return !isNaN(s) && s !== null && !Array.isArray(s);
}
function H(s) {
  return s != null;
}
function W(s, t) {
  return s != null ? s : t;
}
function rh(s, ...t) {
  if (!t.length)
    return s;
  const e = t.shift();
  if (El(s) && El(e))
    for (const i in e)
      El(e[i]) && e[i].constructor === Object ? (s[i] || Object.assign(s, {
        [i]: {}
      }), rh(s[i], e[i])) : Object.assign(s, {
        [i]: e[i]
      });
  return rh(s, ...t);
}
function dt(s, t = !1) {
  if (s === null || typeof s != "object")
    return s;
  const e = new s.constructor();
  for (const i in s)
    if (s.hasOwnProperty(i)) {
      let n = s[i];
      t && (n = dt(n, t)), e[i] = n;
    }
  return e;
}
function ah(s, t, e) {
  e = W(e, !1);
  const i = {}, n = H(s), o = H(t);
  let r, a, g;
  if (n)
    for (r in s)
      s.hasOwnProperty(r) && (a = s[r], o && e && typeof a == "object" && t.hasOwnProperty(r) ? (g = t[r], typeof g == "object" ? i[r] = ah(a, g, e) : i[r] = a) : i[r] = a);
  if (o)
    for (r in t)
      t.hasOwnProperty(r) && !i.hasOwnProperty(r) && (g = t[r], i[r] = g);
  return i;
}
const pY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isObject: El,
  isNumber: iA,
  defined: H,
  defaultValue: W,
  deepMerge: rh,
  clone: dt,
  combine: ah
}, Symbol.toStringTag, { value: "Module" }));
let bd = null;
function qB() {
  if (bd !== null)
    return bd;
  let s = "";
  if (typeof MAPV_BASE_URL == "string" ? s = MAPV_BASE_URL : s = _E(), !s)
    throw new Error("Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL.");
  return bd = s, s;
}
const wE = /((?:.*\/)|^)mapvthree(\.bmap)?\.(es|umd)\.js(?:\?|\#|$)/;
function _E() {
  let s = document.getElementsByTagName("script");
  for (let t = 0, e = s.length; t < e; ++t) {
    let i = s[t].getAttribute("src"), n = wE.exec(i);
    if (n !== null)
      return n[1];
  }
}
function pt(...s) {
  return yE(qB(), ...s);
}
function AC(s, t) {
  let e;
  if (typeof document < "u" && (e = document), !H(t)) {
    if (typeof e > "u")
      return s;
    t = W(e.baseURI, e.location.href);
  }
  const i = new Zs(s);
  return i.scheme() !== "" ? i.toString() : i.absoluteTo(t).toString();
}
function $B(s) {
  const t = new Zs(s);
  t.normalize();
  let e = t.path(), i = e.lastIndexOf("/");
  return i !== -1 && (e = e.substr(i + 1)), i = e.lastIndexOf("."), i === -1 ? e = "" : e = e.substr(i + 1), e;
}
function ew(s, t) {
  let e = "";
  const i = s.lastIndexOf("/");
  return i !== -1 && (e = s.substring(0, i + 1)), t && (s = new Zs(s), s.query().length !== 0 && (e += `?${s.query()}`), s.fragment().length !== 0 && (e += `#${s.fragment()}`)), e;
}
const mY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getBaseUrl: qB,
  getAssetUrl: pt,
  getAbsoluteUri: AC,
  getExtensionFromUri: $B,
  getBaseUri: ew
}, Symbol.toStringTag, { value: "Module" }));
class nA {
  constructor(t) {
    if (!t || t.length === 0)
      throw new Error("points is required");
    const e = t[0][1];
    e.isColor ? this._isColorFormat = !0 : e.isVector3 && (this._isVectorFormat = !0), this._points = t;
  }
  lerp(t, e) {
    if (t <= 0)
      return this._points[0][1];
    if (t >= 1)
      return this._points[this._points.length - 1][1];
    let i = 0;
    for (; i < this._points.length && !(t <= this._points[i][0]); i++)
      ;
    if (t > this._points[this._points.length - 1][0])
      return this._points[this._points.length - 1][1];
    const [n, o] = this._points[i - 1], [r, a] = this._points[i], g = (t - n) / (r - n);
    if (this._isVectorFormat) {
      const c = o.x + (a.x - o.x) * g, l = o.y + (a.y - o.y) * g, h = o.z + (a.z - o.z) * g;
      return e || (e = new B()), e.set(c, l, h), e;
    } else if (this._isColorFormat) {
      const c = o.r + (a.r - o.r) * g, l = o.g + (a.g - o.g) * g, h = o.b + (a.b - o.b) * g;
      return e || (e = new Ce()), e.set(c, l, h), e;
    }
    return o + (a - o) * g;
  }
}
class gh extends mt {
  constructor(e = {}) {
    super();
    f(this, "isEmptySky", !0);
    f(this, "_addDefaultEnvMap", !1);
    f(this, "_time", 3600 * 10);
    f(this, "_timeRatio", 10 / 24);
    f(this, "_startTimestamp", new Date().getTime());
    f(this, "_timeAnimation", !1);
    f(this, "_timeAnimationSpeed", 1);
    f(this, "_skyLightIntensity", 0.1);
    f(this, "_sunLightIntensity", 5.5);
    f(this, "_skyLightAttenuationRatio", 0.2);
    f(this, "_sunIntensityBias", 0);
    f(this, "_sunIntensityScale", 0.8);
    f(this, "_envLightIntensity", 0.2);
    f(this, "_weather", "partlyCloudy");
    f(this, "_timeChangedListeners", []);
    f(this, "_sunDirection", new B());
    f(this, "_localSunDirection", new B());
    f(this, "_sunLightColorDay", new Ce(16777215));
    f(this, "_sunLightColorSunset", new Ce(15090944));
    f(this, "_sunLightColorCurrent", new Ce(16777215));
    f(this, "_sunRadian", null);
    f(this, "_skyLightColorDay", new Ce(16777215));
    f(this, "_skyLightColorNight", new Ce(16777215));
    f(this, "_groundLightColorDay", new Ce(16777215));
    f(this, "_groundLightColorNight", new Ce(16758093));
    f(this, "_lightNeedsUpdate", !0);
    f(this, "_sunNeedsUpdate", !1);
    f(this, "_affectWorld", !1);
    f(this, "updateSunLightShadowCamera", () => {
      const e = this.engine;
      if (!e.renderer.shadowMap.enabled) {
        const i = this.sunLight;
        i.position.copy(this._sunDirection), i.target.position.set(0, 0, 0), i.updateMatrix(), i.updateMatrixWorld(), i.target.updateMatrix(), i.target.updateMatrixWorld();
        return;
      }
      e.rendering.shadow.updateShadow(this.sunLight, this._sunDirection, this);
    });
    const i = this.sunLight = new Ph(16777215, 0.6), n = this.skyLight = new qv(16755200, this._skyLightIntensity);
    n.position.set(0, 0, 1), i.castShadow = !0, i.shadow.mapSize = new Z(1024, 1024), i.shadow.bias = -1e-4, this.add(i), this.add(i.target), this.add(n), i.matrixAutoUpdate = !1, i.target.matrixAutoUpdate = !1, this.renderOrder = -100, this._sunLightGradientColorLerp = new nA([
      [0, new Ce("#395e8c")],
      [5.5 / 24, new Ce("#395e8c")],
      [6 / 24, new Ce("#ff0000")],
      [6.5 / 24, new Ce("#fad277")],
      [7.5 / 24, new Ce("#ffffff")],
      [12 / 24, new Ce("#ffffff")]
    ]), this.envLightIntensity = 0.1, e.time !== void 0 && (this._time = e.time);
  }
  afterAddToEngine(e) {
    if (this.engine = e, !this.isDynamicSky && !this.isStaticSky && this._addDefaultEnvMap) {
      const n = new Ot().load(pt("assets/textures/sky/partlyCloudy_default.jpg"));
      n.mapping = $v, n.colorSpace = gt, e.rendering.scene.environment = n;
    }
    this.envLightIntensity = this._envLightIntensity, this.time = this._time;
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  tickTime() {
    const e = new Date().getTime() - this._startTimestamp, i = 86400 / this._timeAnimationSpeed;
    this.time = e % i / i * 86400;
  }
  onBeforeScenePrepareRender() {
    if (this._timeAnimation && this.tickTime(), (this._timeChanged || this._lightNeedsUpdate) && (this.updateLight(), this._lightNeedsUpdate = !1), this.updateSunLightShadowCamera(), this._timeChanged) {
      this.onTimeChanged(this._time);
      for (const e of this._timeChangedListeners)
        e(this.time);
      this._timeChanged = !1;
    }
  }
  updateLight() {
    this.sunLight.intensity = this._sunLightIntensity, this.isCustomStaticSky ? this.skyLight.intensity = 0 : (this.skyLight.intensity = this._skyLightIntensity, this.skyLight.color.copy(this._skyLightColorDay)), this._sunLightColorCurrent = this._sunLightGradientColorLerp.lerp(this._timeRatio > 0.5 ? 1 - this._timeRatio : this._timeRatio), this.sunLight.color.copy(this._sunLightColorCurrent);
  }
  addTimeChangedListener(e) {
    this._timeChangedListeners.indexOf(e) === -1 && this._timeChangedListeners.push(e);
  }
  removeTimeChangedListener(e) {
    const i = this._timeChangedListeners.indexOf(e);
    i !== -1 && this._timeChangedListeners.splice(i, 1);
  }
  onTimeChanged(e) {
  }
  onWeatherChanged(e) {
  }
  dispose() {
  }
  get time() {
    return this._time;
  }
  set time(e) {
    if (this._time = e, this._timeRatio = e / 24 / 3600, this.engine && this.engine.map.isGlobe) {
      const n = this._sunRadian = (e / 86400 + 0.25) * Math.PI * 2, o = Math.cos(n), r = Math.sin(n);
      this._sunDirection.set(o, -r, 0), this._localSunDirection.set(-o, -r, 0);
    } else {
      const n = (e / 86400 - 0.25) * Math.PI * 2, o = Math.cos(n), r = Math.sin(n);
      this._localSunDirection.set(o, r, 0), this._sunDirection.set(o, 0, r), r < -0.1 && this._sunDirection.negate();
    }
    this._timeChanged = !0;
  }
  get weather() {
    return this._weather;
  }
  set weather(e) {
    this._weather = e, this.onWeatherChanged(e);
  }
  get timeAnimation() {
    return this._timeAnimation;
  }
  set timeAnimation(e) {
    e && (this._startTimestamp = new Date().getTime() - this.time / 86400 * (86400 / this._timeAnimationSpeed)), this._timeAnimation = e;
  }
  get timeAnimationSpeed() {
    return this._timeAnimationSpeed;
  }
  set timeAnimationSpeed(e) {
    this._timeAnimationSpeed = e;
  }
  get sunIntensityBias() {
    return this._sunIntensityBias;
  }
  set sunIntensityBias(e) {
    this._sunIntensityBias = e, this._lightNeedsUpdate = !0;
  }
  get sunIntensityScale() {
    return this._sunIntensityScale;
  }
  set sunIntensityScale(e) {
    this._sunIntensityScale = e, this._lightNeedsUpdate = !0;
  }
  get sunLightIntensity() {
    return this._sunLightIntensity;
  }
  set sunLightIntensity(e) {
    this._sunLightIntensity = e, this._lightNeedsUpdate = !0;
  }
  get skyLightIntensity() {
    return this._skyLightIntensity;
  }
  set skyLightIntensity(e) {
    this._skyLightIntensity = e, this._lightNeedsUpdate = !0;
  }
  get skyLightAttenuationRatio() {
    return this._skyLightAttenuationRatio;
  }
  set skyLightAttenuationRatio(e) {
    this._skyLightAttenuationRatio = e, this._lightNeedsUpdate = !0;
  }
  get sunDirection() {
    return this._sunDirection;
  }
  get localSunDirection() {
    return this._localSunDirection;
  }
  get affectWorld() {
    return this._affectWorld;
  }
  get envLightIntensity() {
    return this._envLightIntensity;
  }
  set envLightIntensity(e) {
    this._envLightIntensity = e, this.engine && (this.engine.renderer.envMapIntensity = e);
  }
}
class Xi {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const xE = new Zg(-1, 1, 1, -1, 0, 1);
class vE extends Qe {
  constructor() {
    super(), this.setAttribute("position", new ae([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new ae([0, 2, 0, 0, 2, 0], 2));
  }
}
const TE = new vE();
class Ut {
  constructor(t) {
    this._mesh = new le(TE, t);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(t) {
    t.render(this._mesh, xE);
  }
  get material() {
    return this._mesh.material;
  }
  set material(t) {
    this._mesh.material = t;
  }
}
const Ht = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
}, CC = `#define GLSLIFY 1
varying vec2 vUv;
void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`, LE = `#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);
    vWorldPosition = normalize(vec3(position.x, position.y, position.z));
    // vWorldPosition = normalize(position);
    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.z = gl_Position.w;
}
`, Ra = `#define GLSLIFY 1
const float PI = 3.14159265358;

// Units are in megameters.
const float groundRadiusMM = 6.371 * 1.0;
const float atmosphereRadiusMM = 6.471 * 1.0;
const float maxSampleLength = 2.267;

const vec2 tLUTRes = vec2(256.0, 64.0)*1.;
const vec2 msLUTRes = vec2(32.0, 32.0)*1.;
const vec2 skyLUTRes = vec2(200.0, 200.0)*2.;

const vec3 groundAlbedo = vec3(0.1);

// These are per megameter.
const vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);
const float rayleighAbsorptionBase = 0.0;

const float mieScatteringBase = 3.996;
const float mieAbsorptionBase = 4.4;

const vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);

// Quality
const float sunTransmittanceSteps = 40.0;
const float mulScattSteps = 20.0;
const int sqrtSamples = 8;

const int numScatteringSteps = 16;

uniform float altitude;
uniform float viewHeight;
/*
 * Animates the sun movement.
 */
float getSunAltitude(float time)
{
    const float periodSec = 10.0;
    return (PI)*time/periodSec - PI/24.;
}
vec3 getSunDir(float time)
{
    // float altitude = getSunAltitude(time);
    // altitude = 2.8;
    return normalize(vec3(cos(altitude), sin(altitude), 0.0));
    // return normalize(vec3(0.0, sin(altitude), -cos(altitude)));

}

/* Animate camera */
vec3 getViewPos(float time){

    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0000 + viewHeight, 0.0);

    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution
    float alt_range = 50.0;

    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;

    return viewPos;
}

float getMiePhase(float cosTheta) {
    const float g = 0.8;
    const float scale = 3.0/(8.0*PI);

    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);
    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);

    return scale*num/denom;
}

float getRayleighPhase(float cosTheta) {
    const float k = 3.0/(16.0*PI);
    return k*(1.0+cosTheta*cosTheta);
}

void getScatteringValues(vec3 pos,
                         out vec3 rayleighScattering,
                         out float mieScattering,
                         out vec3 extinction) {
    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;
    // Note: Paper gets these switched up.
    float rayleighDensity = exp(-altitudeKM/8.0);
    float mieDensity = exp(-altitudeKM/1.2);

    rayleighScattering = rayleighScatteringBase*rayleighDensity;
    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;

    mieScattering = mieScatteringBase*mieDensity;
    float mieAbsorption = mieAbsorptionBase*mieDensity;

    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);

    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;
}

float safeacos(const float x) {
    return acos(clamp(x, -1.0, 1.0));
}

// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.
float rayIntersectSphere(vec3 ro, vec3 rd, float rad) {
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0 && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

// From https://www.shadertoy.com/view/wlBXWK
vec2 rayIntersectSphere2D(
    vec3 start, // starting position of the ray
    vec3 dir, // the direction of the ray
    float radius // and the sphere radius
) {
    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, start);
    float c = dot(start, start) - (radius * radius);
    float d = (b*b) - 4.0*a*c;
    if (d < 0.0) return vec2(1e5,-1e5);
    return vec2(
        (-b - sqrt(d))/(2.0*a),
        (-b + sqrt(d))/(2.0*a)
    );
}

/*
 * Same parameterization here.
 */
vec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    // return pos;
    return texture2D(tex, uv).rgb;
}
vec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {
    float height = length(pos);
    vec3 up = pos / height;
	float sunCosZenithAngle = dot(sunDir, up);
    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),
                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));
    uv /= bufferRes;
    return texture2D(tex, uv).rgb;
}

/* 
 * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere
*/

vec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,
                              vec3 viewPos,
                              vec3 rayDir,
                              vec3 sunDir,
                              float numSteps,
                              float maxDistance) {
                              
                              
    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);
    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);

    float mindist, maxdist;

    if (atmos_intercept.x < atmos_intercept.y){
        // there is an atmosphere intercept!
        // start at the closest atmosphere intercept
        // trace the distance between the closest and farthest intercept
        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;
		maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;
    } else {
        // no atmosphere intercept means no atmosphere!
        return vec3(0.0);
    }

    // if in the atmosphere start at the camera
    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;

    // if there's a terra intercept that's closer than the atmosphere one,
    // use that instead!
    if (terra_intercept > 0.0){ // confirm valid intercepts			
        maxdist = terra_intercept;
    }

    // start marching at the min dist
    vec3 pos = viewPos + mindist * rayDir;

    float cosTheta = dot(rayDir, sunDir);

	float miePhaseValue = getMiePhase(cosTheta);
	float rayleighPhaseValue = getRayleighPhase(-cosTheta);

    float diff = maxdist - mindist;

    diff = min((maxDistance - mindist), diff);

    vec3 lum = vec3(0.0);
    vec3 transmittance = vec3(1.0);
    float t = 0.0;

    // \u6700\u5C0F\u91C7\u6837\u6570\u8BBE\u7F6E\u4E3AnumSteps / 2.0,\u56E0\u4E3A\u91C7\u6837\u6570\u8D8A\u5C0F,\u589E\u52A0\u91C7\u6837\u70B9\u6548\u679C\u53D8\u5316\u8D8A\u5927
    float steps = max(numSteps / 2.0, floor(numSteps * (diff / maxSampleLength)));
    for (int fi = 0; fi < 100; fi++) {
        float i = float(fi);
        if (i >= steps) break;

        float newT = ((i + 0.3)/steps)*diff;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*rayDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        vec3 sampleTransmittance = exp(-dt*extinction);

        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);
        vec3 psiMS = getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);

        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);
        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);
        vec3 inScattering = (rayleighInScattering + mieInScattering);

        // Integrated scattering within path segment.
        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

        lum += scatteringIntegral*transmittance;

        transmittance *= sampleTransmittance;
    }
    return lum;
}

vec3 getValFromSkyLUT(sampler2D viewTexture, vec3 viewPos, vec3 rayDir, vec3 sunDir) {

    float height = length(viewPos);
    vec3 up = viewPos / height;

    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);
    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2
    float azimuthAngle; // Between 0 and 2*PI

    vec3 right = cross(sunDir, up);
    vec3 forward = cross(up, right);

    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));
    float sinTheta = dot(projectedDir, right);
    float cosTheta = dot(projectedDir, forward);
    azimuthAngle = atan(sinTheta, cosTheta) + PI;

    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.
    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);
    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);
    // uv *= skyLUTRes;
    // uv /= viewResolution.xy;

    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;
    return texture2D(viewTexture, uv).rgb;
}

vec3 jodieReinhardTonemap(vec3 c) {
    // From: https://www.shadertoy.com/view/tdSXzD
    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));
    vec3 tc = c / (c + 1.0);
    return mix(c / (l + 1.0), tc, tc);
}

vec4 toLinear(vec4 sRGB) {
    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
    vec4 lower = sRGB/vec4(12.92);

    // return mix(higher, lower, cutoff);
    // \u4F7F\u7528\u6761\u4EF6\u64CD\u4F5C\u7B26\u66FF\u4EE3 mix \u51FD\u6570
    return vec4(
        cutoff.x ? lower.x : higher.x,
        cutoff.y ? lower.y : higher.y,
        cutoff.z ? lower.z : higher.z,
        cutoff.w ? lower.w : higher.w
    );
}

vec4 colorSpaceTransform(vec4 color) {
    #ifdef USE_OPAQUE_POST_STAGE
        return toLinear(color);
    #else
        return color;
    #endif
}`, GE = `#define GLSLIFY 1
/*
 * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW 
 * implementation of Sebastian Hillare's Unreal engine sky-atmosphere
 * ... still doesn't implement aerial perspective lut, just makes space views possible
 * TODO: replace sunflare with something new that works
        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)
 */

/*
 * Final output basically looks up the value from the skyLUT, and then adds a sun on top,
 * does some tonemapping.
 */
#include <common>
varying vec2 vUv;
varying vec3 vWorldPosition;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
uniform sampler2D viewTexture;
uniform vec2 viewResolution;
uniform sampler2D scatteringTexture;
uniform vec2 scatteringResolution;
uniform vec2 iResolution;
uniform vec3 cameraDirection;
uniform vec3 upDirection;
uniform float uTime;
uniform bool uStarVisible;
uniform sampler2D uMoonMap;

const int star_iterations = 10;
const vec3 col_star = vec3( .8, 0.8, 0.7 );

const vec3 grayColor = vec3(0.5, 0.5, 0.5);

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
    const float sunSolidAngle = 0.01*PI/180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, sunDir);
    if (cosTheta >= minSunCosTheta) return vec3(1.0);

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset*50000.0)*0.5;
    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;
    return vec3(gaussianBloom+invBloom);
}

float hash( float n ) { return fract(sin(n)*123.456789); }

vec2 rotate( in vec2 uv, float a) {
    float c = cos( a );
    float s = sin( a );
    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );
}

float noise( in vec3 p ) {
    vec3 fl = floor( p );
    vec3 fr = fract( p );
    fr = fr * fr * ( 3.0 - 2.0 * fr );

    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;
    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),
                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),
                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),
                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );
}

float fbm( in vec2 p, float t ) {
    float f;
    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;
    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;
    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;
    f += 0.0625 * noise( vec3( p, t ) );
    return f;
}

float fbmByTexture( vec2 p ) {
    return 0.5000 * texture2D( uMoonMap, p * 1.00 ).x + 
        0.2500 * texture2D( uMoonMap, p * 2.02 ).x + 
        0.1250 * texture2D( uMoonMap, p * 4.03 ).x + 
        0.0625 * texture2D( uMoonMap, p * 8.04 ).x;
}

// moon
vec3 moonWithBloom(vec3 rayDir, vec3 moonDir) {
    const float sunSolidAngle = .6 * PI / 180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, moonDir);
    vec3 differ = rayDir - moonDir;
    if (cosTheta >= minSunCosTheta) {
        vec3 moon = vec3(0.98,0.97,0.95);
        // \u6708\u7403\u8000\u6591
        moon *= (0.30 + 0.4 * fbmByTexture(vec2(1.0) + vec2(0.2 + differ.xz + differ.yx)));

        return moon;
    }

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset * 50000.0) * 0.5;
    float invBloom = 1.0 / (0.05 + offset * 300.0) * 0.01;
    return vec3(gaussianBloom+invBloom);
}

// \u661F\u7A7A\u80CC\u666F
vec3 doBackgroundStars( in vec3 dir ) {
    vec3 n  = abs( dir );
    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: 
            ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:
                                        dir.xy / dir.z;
    
    float f = 0.0;
    
    for( int i = 0 ; i < star_iterations; ++i ) {
        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );
        
        float t = 10. * uv.x * uv.y + uTime;
        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );
        f += smoothstep( 0.534, 0.535, u.x * u.y );
    }
    
    return f * col_star;
}

vec3 render( in vec2 uv, mat3 m ) {
    //create view ray
    vec3 rd  = m * normalize( vec3( uv, 1.0 ) );
    
    // background stars
    vec3 c = doBackgroundStars( rd );
    return c;
}

// vec4 toLinear(vec4 sRGB) {
//     bvec4 cutoff = lessThan(sRGB, vec4(0.04045));
//     vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));
//     vec4 lower = sRGB/vec4(12.92);

//     // return mix(higher, lower, cutoff);
//     // \u4F7F\u7528\u6761\u4EF6\u64CD\u4F5C\u7B26\u66FF\u4EE3 mix \u51FD\u6570
//     return vec4(
//         cutoff.x ? lower.x : higher.x,
//         cutoff.y ? lower.y : higher.y,
//         cutoff.z ? lower.z : higher.z,
//         cutoff.w ? lower.w : higher.w
//     );
// }

void main() {
    vec3 sunDir = getSunDir(0.);
    vec3 viewPos = getViewPos(0.);

    vec3 camDir = normalize(cameraDirection);
    float camFOVWidth = PI/3.0;
    // vec2 iResolution = vec2(1102, 1246);
    float camWidthScale = 2.0*tan(camFOVWidth/2.0);
    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;

    vec3 camRight = normalize(cross(camDir, upDirection));
    vec3 camUp = normalize(cross(camRight, camDir));

    // camRight = viewMatrix[0].xzy;
    // camUp = viewMatrix[1].xzy;
    // camDir = viewMatrix[2].xzy;
    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;
    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;
    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);
    vec3 rayDir = normalize(vWorldPosition.xzy);
    vec3 lum;

    if (length(viewPos) < atmosphereRadiusMM * 1.0){
        lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);
    } else {
    
        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere
        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                                scatteringTexture, scatteringResolution.xy,
                                viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);
        
        // This little bit of red helps to debug when the rendering switches to pure raymarching
        // lum += vec3(1e-3,0.0,0.0);
    }

    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.
    lum *= 100.0;
    lum = jodieReinhardTonemap(lum);
    lum = pow(lum, vec3(1.0/2.2));

    // lum += sunWithBloom(rayDir, sunDir);
    // Bloom should be added at the end, but this is subtle and works well.
    vec3 sunLum = sunWithBloom(rayDir, sunDir);
    // Use smoothstep to limit the effect, so it drops off to actual zero.
    sunLum = smoothstep(0.002, 1.0, sunLum);
    if (length(sunLum) > 0.0) {
        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {
            sunLum *= 0.0;
        } else {
            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.
            sunLum *= getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, viewPos, sunDir);
        }
    }
    lum += sunLum;

    if (sunDir.y < 0.0) {
        vec2 uv = vUv - vec2(0.5);
        
        vec3 ww = normalize(vec3(1.04, 0.0, 2.628));
        vec3 uu = normalize( cross( ww, vec3( 0.0, 1.0, 0.0 ) ) );
        vec3 vv = normalize( cross( uu, ww ) );
        mat3 m = mat3( uu, vv, ww );

        // \u661F\u7A7A
        if (rayDir.y > 0.0 && uStarVisible) {
            // \u80CC\u666F\u521D\u59CB\u5316\u989C\u8272\uFF0C\u6E10\u53D8\u84DD\u9ED1\u8272
            lum += vec3( 0.035, 0.055, 0.085 );
            lum += vec3( 0.02, 0.05, 0.15 ) * (1. - rayDir.y);

            vec3 c = render( fract(uv * 30.0), m );

            // c = pow( c, vec3( 0.4545 ) );

            // \u661F\u7A7A\u95EA\u70C1
            float time = uTime / 20000.0;
            float twinkle = sin((uv.x-time+cos(uv.y*20.+time))*20.);
            twinkle *= cos((uv.y*.234-time*3.24+sin(uv.x*12.3+time*.243))*7.34);
            twinkle = (twinkle + 1.)/2.;
            lum += c * twinkle * (rayDir.y * 10.0) * (1.0 - pow(max(0.0, abs(-sunDir.y - 1.0) * 2.0 - 1.0), 2.0));
        }

        // \u6708\u4EAE
        vec3 moonLum = moonWithBloom(rayDir, -sunDir) * 2.0;
        if (length(moonLum) > 0.0) {
            float alpha = clamp(smoothstep(0.0, 0.2, rayDir.y), 0.01, 1.0);
            moonLum *= alpha;
        }
        lum += moonLum;

    }

    gl_FragColor = vec4(lum, 1.0);
    gl_FragColor = toLinear(gl_FragColor);

    // gl_FragColor.rgb = vWorldPosition;
    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));
    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);
    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));
    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;
    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;
    // gl_FragColor.z += cloudDensity;
    // Peek at the Transmittance LUT
    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {
        // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);
    // }
    // fragColor = vec4(100.*texture(transmittanceTexture, fragCoord.xy/iResolution.xy).rgb,1.0);

    // Peek at the Sky View LUT
    // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);

    // Peek at the Multiscattering LUT
    // fragColor = vec4(100.*texture(scatteringTexture, fragCoord.xy/iResolution.xy).rgb,1.0);
    // if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {
    //     gl_FragColor = vec4(100.*texture(scatteringTexture, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);
    // }
    // gl_FragColor = vec4(100.*texture(transmittanceTexture, gl_FragCoord.xy/transmittanceResolution * 0.1).rgb,1.0);
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`, ME = `#define GLSLIFY 1
// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the transmittance from that point to sun, through the atmosphere.
varying vec2 vUv;
vec3 getSunTransmittance(vec3 pos, vec3 sunDir) {
    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {
        return vec3(0.0);
    }

    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);
    float t = 0.0;

    vec3 transmittance = vec3(1.0);
    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {
        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;
        float dt = newT - t;
        t = newT;

        vec3 newPos = pos + t*sunDir;

        vec3 rayleighScattering, extinction;
        float mieScattering;
        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

        transmittance *= exp(-dt*extinction);
    }
    return transmittance;
}

void main() {
    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;
    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);
}
`, EE = `#define GLSLIFY 1
// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and
// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).
varying vec2 vUv;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
vec3 getSphericalDir(float theta, float phi) {
     float cosPhi = cos(phi);
     float sinPhi = sin(phi);
     float cosTheta = cos(theta);
     float sinTheta = sin(theta);
     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);
}

// Calculates Equation (5) and (7) from the paper.
void getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {
    lumTotal = vec3(0.0);
    fms = vec3(0.0);

    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);
    for (int i = 0; i < sqrtSamples; i++) {
        for (int j = 0; j < sqrtSamples; j++) {
            // This integral is symmetric about theta = 0 (or theta = PI), so we
            // only need to integrate from zero to PI, not zero to 2*PI.
            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);
            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));
            vec3 rayDir = getSphericalDir(theta, phi);

            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);
            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);
            float tMax = atmoDist;
            if (groundDist > 0.0) {
                tMax = groundDist;
            }

            float cosTheta = dot(rayDir, sunDir);

            float miePhaseValue = getMiePhase(cosTheta);
            float rayleighPhaseValue = getRayleighPhase(-cosTheta);

            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);
            float t = 0.0;
            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {
                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;
                float dt = newT - t;
                t = newT;

                vec3 newPos = pos + t*rayDir;

                vec3 rayleighScattering, extinction;
                float mieScattering;
                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);

                vec3 sampleTransmittance = exp(-dt*extinction);

                // Integrate within each segment.
                vec3 scatteringNoPhase = rayleighScattering + mieScattering;
                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;
                lumFactor += transmittance*scatteringF;

                // This is slightly different from the paper, but I think the paper has a mistake?
                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).
                vec3 sunTransmittance = getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, newPos, sunDir);

                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;
                float mieInScattering = mieScattering*miePhaseValue;
                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;

                // Integrated scattering within path segment.
                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;

                lum += scatteringIntegral*transmittance;
                transmittance *= sampleTransmittance;
            }

            if (groundDist > 0.0) {
                vec3 hitPos = pos + groundDist*rayDir;
                if (dot(pos, sunDir) > 0.0) {
                    hitPos = normalize(hitPos)*groundRadiusMM;
                    lum += transmittance*groundAlbedo*getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, hitPos, sunDir);
                }
            }

            fms += lumFactor*invSamples;
            lumTotal += lum*invSamples;
        }
    }
}

void main() {
    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;

    float sunCosTheta = 2.0*u - 1.0;
    float sunTheta = safeacos(sunCosTheta);
    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);

    vec3 pos = vec3(0.0, height, 0.0);
    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));

    vec3 lum, f_ms;
    getMulScattValues(pos, sunDir, lum, f_ms);

    // Equation 10 from the paper.
    vec3 psi = lum  / (1.0 - f_ms);
    gl_FragColor = vec4(1. * psi, 1.0);
    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);
}
`, RE = `#define GLSLIFY 1
// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),
// but the latitude/altitude is non-linear to get more resolution near the horizon.
varying vec2 vUv;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
uniform sampler2D scatteringTexture;
uniform vec2 scatteringResolution;
uniform float mixGrayFactor;

void main() {
    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {
    //     return;
    // }
    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;
    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;

    float azimuthAngle = (u - 0.5)*2.0*PI;

    // Non-linear mapping of altitude. See Section 5.3 of the paper.

    float adjV;
    if (v < 0.5) {
		float coord = 1.0 - 2.0*v;
		adjV = -coord*coord;
	} else {
		float coord = v*2.0 - 1.0;
		adjV = coord*coord;
	}

    vec3 viewPos = getViewPos(0.);

    float height = length(viewPos); vec3 up = viewPos / height;
    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;
    float altitudeAngle = adjV*0.5*PI - horizonAngle;

    float cosAltitude = cos(altitudeAngle);
    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));

    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));
    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));

    vec3 lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                                  scatteringTexture, scatteringResolution.xy,
                                  viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);
    gl_FragColor = vec4(lum, 1.0);

    if (mixGrayFactor > 0.0) {
        lum = gl_FragColor.xyz;
        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);
        lum = mix(lum, gray, mixGrayFactor);
        gl_FragColor = vec4(lum, 1.0);
    }
}
`, DE = `#define GLSLIFY 1
#include <mvt_depth_packing>
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
#if defined(MVT_USE_NORMAL_TEXTURE)
    uniform sampler2D tNormal;
#endif
uniform sampler2D tAtmosphere;
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewInverseMatrix;
uniform mat4 mvt_viewMatrix;
uniform sampler2D transmittanceTexture;
uniform vec2 transmittanceResolution;
uniform sampler2D viewTexture;
uniform vec2 viewResolution;
uniform sampler2D scatteringTexture;
uniform vec2 scatteringResolution;
uniform vec2 resolution;
uniform vec3 cameraDirection;
uniform vec3 sunDirection;
uniform bool isGlobe;
// uniform vec3 upDirection;
uniform vec2 fogDepthRange;
uniform mat3 rotationMatrix;

vec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {
    const float sunSolidAngle = 0.01*PI/180.0;
    const float minSunCosTheta = cos(sunSolidAngle);

    float cosTheta = dot(rayDir, sunDir);
    if (cosTheta >= minSunCosTheta) return vec3(1.0);

    float offset = minSunCosTheta - cosTheta;
    float gaussianBloom = exp(-offset*50000.0)*0.5;
    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;
    return vec3(gaussianBloom+invBloom);
}

void main() {
    vec4 diffuse = texelFetch(tDiffuse, ivec2(gl_FragCoord.xy), 0);
    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).x;
    // gl_FragColor = diffuse;
    // return;
    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);
    bool isTranslucent = diffuse.a < 1.0;
    if (diffuse.a < 1.0) {
        // // \u900F\u660E\u5EA6\u5C0F\u4E8E0.99\uFF0C\u4F7F\u7528\u6DF1\u5EA6\u503C
        // depthValue = 1.0;
        // depth = 1.0;
    }
    vec3 worldPosition = mvtGetWorldPositionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix); 
    vec3 viewPosition = mvtGetViewPositionByDepth(depth, vUv, projectionInverseMatrix);
    float viewDistance = length(viewPosition) / 100000.0;
    vec3 viewFrom = vec3(cameraPosition);

    vec3 viewTo = vec3(worldPosition.xy, 0.002);

    vec3 viewDir = normalize(viewTo - viewFrom);

    vec3 sunDir = sunDirection;
    vec3 viewPos = getViewPos(0.);

    float maxDistance = length(viewPosition) / 1000000.0;

    float camFOVWidth = 35.0 / 180.0 * PI;

    float camHeightScale = tan(camFOVWidth / 2.0);
    float camWidthScale = camHeightScale * resolution.x / resolution.y;

    vec3 camRight   = vec3( viewInverseMatrix[0][0],  viewInverseMatrix[0][1],  viewInverseMatrix[0][2]);
    vec3 camUp      = vec3( viewInverseMatrix[1][0],  viewInverseMatrix[1][1],  viewInverseMatrix[1][2]);
	vec3 camDir = vec3(-viewInverseMatrix[2][0], -viewInverseMatrix[2][1], -viewInverseMatrix[2][2]);

    vec2 nxy = vUv.xy * 2.0 - 1.0;
    vec3 rayDir = normalize(camDir + camRight * nxy.x * camWidthScale  + camUp * nxy.y * camHeightScale).xzy;

    vec3 lum;
    bool isInSpace = length(viewPos) > atmosphereRadiusMM * 1.0;
    float atmoFactor = 0.0;
    if (length(viewPos) < atmosphereRadiusMM * 1.0){
        // \u7981\u6B62\u534A\u900F\u660E\u50CF\u7D20\u53C2\u4E0E\u8BA1\u7B97raymarching
        if (depthValue < 0.99 && !isTranslucent) {
            lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                        scatteringTexture, scatteringResolution.xy,
                        viewPos, rayDir, sunDir, float(numScatteringSteps), maxDistance);
        }
        else {
            lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);
        }
        
    } else {
        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere
        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,
                                scatteringTexture, scatteringResolution.xy,
                                viewPos, rayDir, sunDir, float(numScatteringSteps), 10e5);
        atmoFactor = clamp(lum.x * 30.0, 0.0, 1.0);
    }
    atmoFactor = clamp(lum.x * 30.0, 0.0, 1.0);
    lum *= 20.0;
    lum = jodieReinhardTonemap(lum);
    lum = pow(lum, vec3(1.0/2.2));

    if (depthValue > 0.99) {
        vec3 sunLum = vec3(0.0);
        sunLum = sunWithBloom(rayDir, sunDir);
        // Use smoothstep to limit the effect, so it drops off to actual zero.
        sunLum = smoothstep(0.002, 1.0, sunLum);
        if (length(sunLum) > 0.0) {
            if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {
                sunLum *= 0.0;
            }
        }
        lum += sunLum;
    }

    vec4 atmo = colorSpaceTransform(vec4(lum, 1.0));
    gl_FragColor = atmo;
 
    // \u4ECE50km\u9AD8\u5EA6\u5230100km\u9AD8\u5EA6\uFF0C\u5927\u6C14\u5C42\u9010\u6E10\u53D8\u6DE1
    float cameraHeight = cameraPosition.z;
    if (isGlobe) {
        cameraHeight = length(cameraPosition) - 6371000.0;
    }
    float ratio = 1.0 - clamp((cameraHeight - 50000.0) / 50000.0, 0.0, 1.0);
    ratio = 1.0;

    float viewRatio = 1.0;
    if (!isGlobe){
        viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));
        viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);
    }

    float depthThreshold = mix(0.996, 0.992, clamp(cameraHeight / 100000.0, 0.0, 1.0));
    if (depthValue < depthThreshold && ratio > 0.0 && !isTranslucent) {

        float fogDepth = depthValue;
        float fogDensity = 1.;
        float fogStart = mix(0.8, 0.95, ratio);
        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);
        
        float atmoFinalFactor = 0.0;
        if (isGlobe) {
            if (isInSpace) {
                atmoFinalFactor = atmoFactor;
            }
            else {
                float heightRatio = 1.0 - clamp(viewHeight * 10.0, 0.0, 1.0);
                heightRatio = heightRatio * heightRatio;
                float viewDepth = clamp((depthValue - fogDepthRange.x) / (fogDepthRange.y - fogDepthRange.x), 0.0, 1.0);
                viewDepth = 1.0 - exp(- 2.0 * viewDepth * viewDepth);
                atmoFinalFactor = mix(atmoFactor, viewDepth, heightRatio);
            }
        }
        else {
            atmoFinalFactor = fogDepth * ratio * viewRatio;
        }
        #if defined(MVT_DEBUG_INTENSITY)
            gl_FragColor = vec4(atmoFinalFactor, 0.0, 0.0, 1.0);
        #else
            gl_FragColor = mix(diffuse, atmo, atmoFinalFactor);
        #endif
    } 
    else {
        // \u6709\u989C\u8272\u7684\u533A\u57DF\u5FC5\u987B\u90FD\u5C1D\u8BD5\u53BB\u6DF7\u5408\uFF0C\u9700\u8981\u8003\u8651\u90E8\u5206depthTest\u5173\u95ED\u7684\u7269\u4F53\u4E5F\u9700\u8981\u663E\u793A
        if (diffuse.a > 0.001) {
            #if defined(MVT_DEBUG_INTENSITY)
                gl_FragColor = vec4(diffuse.a, 0.0, 0.0, 1.0);
            #else
                gl_FragColor.rgb = mix(gl_FragColor.rgb, diffuse.rgb / diffuse.a, diffuse.a);
            #endif
            // gl_FragColor.a = diffuse.a;
            // gl_FragColor = vec4(0.0, 1.0, 0.0, diffuse.a);
            // gl_FragColor = vec4(lum, 1.0);
        }
        else {
            // gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
        
    }
}`, KE = `#define GLSLIFY 1
#include <mvt_depth_packing>
#include <packing>

uniform vec3 highColor;
uniform vec3 color;
varying vec2 vUv;
uniform float cameraNear;
uniform float cameraFar;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform vec2 resolution;
uniform bool isGlobe;
uniform vec2 fogDepthRange;
uniform mat4 viewInverseMatrix;
uniform mat4 projectionInverseMatrix;
void main() {
    // float depthValue = texture2D(tDepth, vUv).x;
    // \u6309\u50CF\u7D20\u7CBE\u786E\u91C7\u6837\u6DF1\u5EA6\u503C
    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).x;
    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);
    vec3 viewPosition = mvtGetViewPositionByDepth(depth, vUv, projectionInverseMatrix);

    float maxDistance = length(viewPosition) / 1000000.0;
    vec4 diffuse = texture2D(tDiffuse, vUv);
    bool isTranslucent = diffuse.a < 1.0;

    vec3 viewPos = getViewPos(0.);

    float cameraHeight = cameraPosition.z;

    float camFOVWidth = 35.0 / 180.0 * PI;
    float camHeightScale = tan(camFOVWidth / 2.0);
    float camWidthScale = camHeightScale * resolution.x / resolution.y;

    vec3 camRight   = vec3( viewInverseMatrix[0][0],  viewInverseMatrix[0][1],  viewInverseMatrix[0][2]);
    vec3 camUp      = vec3( viewInverseMatrix[1][0],  viewInverseMatrix[1][1],  viewInverseMatrix[1][2]);
	vec3 camDir = vec3(-viewInverseMatrix[2][0], -viewInverseMatrix[2][1], -viewInverseMatrix[2][2]);

    vec2 nxy = vUv.xy * 2.0 - 1.0;
    vec3 rayDir = normalize(camDir + camRight * nxy.x * camWidthScale  + camUp * nxy.y * camHeightScale).xzy;

    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);
    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);

    float mindist, maxdist;
    float dist = 0.0;
    if (atmos_intercept.x < atmos_intercept.y){
        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;
        maxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;
    }
    float height = length(viewPos);
    if (height < atmosphereRadiusMM) mindist=0.0;
    if (terra_intercept > 0.0){ // confirm valid intercepts			
        maxdist = terra_intercept;
    }

    float depthThreshold = mix(0.996, 0.992, clamp(cameraHeight / 100000.0, 0.0, 1.0));
    float diff = maxdist - mindist;

    float cosTheta = groundRadiusMM / atmosphereRadiusMM;
    float cosRadians = acos(cosTheta);
    float maxAtmosphereDist = atmosphereRadiusMM * sin(cosRadians);

    float horizonDist = sqrt(height * height - groundRadiusMM * groundRadiusMM);
    // float factor = diff / horizonDist;

    // ratio\u7528\u4E8E\u53D6\u8FC7\u6E21\u989C\u8272
    // remappedRatio\u7528\u4E8E\u8BBE\u7F6E\u900F\u660E\u5EA6(\u7EBF\u6027\u8FC7\u6E21\u989C\u8272\u53D8\u5316\u592A\u5927,\u7528\u975E\u7EBF\u6027\u53D8\u5316)
    // https://www.desmos.com/calculator/raytthuk1q?lang=zh-CN
    float ratio;
    float factor;
    bool isInSpace = false;
    float remappedRatio;
    if (height < atmosphereRadiusMM) {
        if (depthValue < depthThreshold && !isTranslucent) {
            diff = min(maxDistance, maxdist) - mindist;
        }
        // \u901A\u8FC7\u7A7F\u8FC7\u5927\u6C14\u7684\u8DEF\u5F84\u548C\u4ECE\u5F53\u524D\u89C6\u70B9\u51FA\u53D1\u80FD\u591F\u7ECF\u8FC7\u7684\u6700\u957F\u8DEF\u5F84\u7684\u6BD4\u503C\u4F5C\u4E3Aratio
        ratio = clamp(1.0 - cos((PI / 2.0) * (diff / (maxAtmosphereDist + horizonDist))), 0.0, 1.0);
        remappedRatio = 1.0 - exp(-50.0 * ratio);
        if (terra_intercept > 0.0) factor = diff / horizonDist;
    }
    else {
        // \u901A\u8FC7\u7A7F\u8FC7\u5927\u6C14\u7684\u8DEF\u5F84\u8BA1\u7B97\u9AD8\u5EA6\uFF0C\u5229\u7528\u9AD8\u5EA6\u5F97\u5230ratio
        isInSpace = true;
        float halfDiff = diff * 0.5;
        float sinTheta = halfDiff / atmosphereRadiusMM;
        float sinRadians = asin(sinTheta);
        float atmospherHeight = atmosphereRadiusMM - groundRadiusMM;
        ratio = 1.0 - cos((PI / 2.0) * (diff / (maxAtmosphereDist * 2.0)));

        float ratioScale = min(max((atmospherHeight / viewHeight), 0.8), 1.0);
        float ratioScaled = (1.0 - ratioScale) * ratio + ratioScale;

        // \u968F\u7740\u9AD8\u5EA6\u7684\u4E0A\u5347\u900F\u660E\u5EA6\u4ECE\u975E\u7EBF\u6027\u53D8\u4E3A\u7EBF\u6027\u8FC7\u6E21
        float unlinearRatio = (1.0 - exp(-(10.0) * ratio));
        float h = min(max(((atmospherHeight * 2.0 - viewHeight) / atmospherHeight), 0.0) ,1.0);
        remappedRatio = (unlinearRatio * h + ratio * (1.0 - h)) * ratioScaled;
        if (terra_intercept > 0.0) factor = diff / maxAtmosphereDist;
    }

    float ratioValue = 1.0 - ratio;
    vec3 outColor;
    if (ratioValue <= 0.0) {
        outColor = color;
    }
    else if (ratioValue < 0.3) {
        float t = smoothstep(0.0, 1.0, (ratioValue / 0.3));
        outColor = mix(color, highColor, t);
    }
    else {
        outColor = highColor;
    }

    vec3 outputColor;
    if (terra_intercept > 0.0) {
        // \u5982\u679C\u548C\u5730\u7403\u76F8\u4EA4\uFF0C\u4F7F\u7528\u5E95\u90E8\u989C\u8272
        outputColor = color * factor;
    }
    else {
        outputColor = outColor * remappedRatio;
    }

    float viewRatio = 1.0;
    if (isGlobe) {
        // viewRatio = 1.0 - clamp(dot(normalize(vec3(viewInverseMatrix[2])), upDirection), 0.0, 1.0);
        // viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);
        // viewRatio = 1.;
    }
    else {
        viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));
        viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);
    }

    outputColor = colorSpaceTransform(vec4(outputColor, 1.0)).rgb;

    float atmoFactor = diff / maxAtmosphereDist;
    if (depthValue < depthThreshold && ratio >= 0.0 && !isTranslucent) {
        vec4 atmo = colorSpaceTransform(vec4(color, 1.0));
        float fogDepth = depthValue;

        float fogDensity = 1.;
        float fogStart = mix(0.8, 0.95, ratio);
        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);

        float atmoFinalFactor = 0.0;
        if (isGlobe) {
            if (isInSpace) {
                atmoFinalFactor = atmoFactor;
            }
            else {
                float heightRatio = 1.0 - clamp(viewHeight * 10.0, 0.0, 1.0);
                heightRatio = heightRatio * heightRatio;
                // float maxDistance = 0.5 + heightRatio * 2.0;
                float viewDepth = clamp((depthValue - fogDepthRange.x) / (fogDepthRange.y - fogDepthRange.x), 0.0, 1.0);
                viewDepth = 1.0 - exp(- 2.0 * viewDepth * viewDepth);
                atmoFinalFactor = mix(atmoFactor, viewDepth, heightRatio);
            }
        }
        else {
            atmoFinalFactor = fogDepth * ratio * viewRatio;
        }

        atmoFinalFactor *= atmoFinalFactor;

        gl_FragColor = mix(diffuse, atmo, atmoFinalFactor);
    }
    else {
        gl_FragColor = vec4(outputColor, 1.0);

        float t = abs(dot(rayDir, -viewPos));
        float distanceToGlobeCenter = sqrt(height * height - t * t);
        
        if (rayDir.y < 0.0 && distanceToGlobeCenter < groundRadiusMM) {
            gl_FragColor = colorSpaceTransform(vec4(color, 1.0)); 
        }

        if (diffuse.a > 0.001) {
            gl_FragColor.rgb = mix(gl_FragColor.rgb, diffuse.rgb / diffuse.a, diffuse.a);
        }
    }

    gl_FragColor.a = 1.0;

}`, Bd = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    scatteringTexture: {
      value: null
    },
    scatteringResolution: {
      value: [256, 256]
    },
    viewTexture: {
      value: null
    },
    viewResolution: {
      value: [256, 256]
    },
    cameraDirection: {
      value: new B(0, 0.27, -1)
    },
    viewHeight: {
      value: 2e-4
    },
    upDirection: {
      value: new B(0, 1, 0)
    },
    tWeather: {
      value: null
    },
    mixGrayFactor: {
      value: 0
    },
    isEmissive: {
      value: !1
    },
    uTime: {
      value: null
    },
    uStarVisible: {
      value: !0
    },
    uMoonMap: {
      value: null
    },
    isGlobe: {
      value: !1
    }
  },
  vertexShader: LE,
  fragmentShader: Ra + `
` + GE
}, wd = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    viewHeight: {
      value: 2e-4
    }
  },
  vertexShader: CC,
  fragmentShader: Ra + `
` + ME
}, _d = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    viewHeight: {
      value: 2e-4
    }
  },
  vertexShader: CC,
  fragmentShader: Ra + `
` + EE
}, xd = {
  uniforms: {
    altitude: {
      value: 2.8
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    scatteringTexture: {
      value: null
    },
    scatteringResolution: {
      value: [256, 256]
    },
    viewHeight: {
      value: 2e-4
    },
    mixGrayFactor: {
      value: 0
    }
  },
  vertexShader: CC,
  fragmentShader: Ra + `
` + RE
}, Wf = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    tNormal: {
      value: null
    },
    tAtmosphere: {
      value: null
    },
    cameraNear: {
      value: 0.1
    },
    cameraFar: {
      value: 1e3
    },
    projectionInverseMatrix: {
      value: new J()
    },
    viewInverseMatrix: {
      value: new J()
    },
    mvt_viewMatrix: {
      value: new J()
    },
    cameraPosition: {
      value: new B()
    },
    altitude: {
      value: 2.8
    },
    viewHeight: {
      value: 2e-4
    },
    transmittanceTexture: {
      value: null
    },
    transmittanceResolution: {
      value: [256, 256]
    },
    scatteringTexture: {
      value: null
    },
    scatteringResolution: {
      value: [256, 256]
    },
    viewTexture: {
      value: null
    },
    viewResolution: {
      value: [256, 256]
    },
    resolution: {
      value: [256, 256]
    },
    cameraDirection: {
      value: new B(0, 0.27, -1)
    },
    sunDirection: {
      value: new B(0, 1, 0)
    },
    upDirection: {
      value: new B(0, 0, 1)
    },
    isGlobe: {
      value: !1
    },
    fogDepthRange: {
      value: new Z(0, 1)
    },
    rotationMatrix: {
      value: new qe()
    }
  },
  fragmentShader: Ra + `
` + DE
}, Zf = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    tDepth: {
      value: null
    },
    cameraNear: {
      value: 0.1
    },
    cameraFar: {
      value: 1e3
    },
    viewInverseMatrix: {
      value: new J()
    },
    cameraPosition: {
      value: new B()
    },
    viewHeight: {
      value: 2e-4
    },
    resolution: {
      value: [256, 256]
    },
    cameraDirection: {
      value: new B(0, 0.27, -1)
    },
    sunDirection: {
      value: new B(0, 1, 0)
    },
    isGlobe: {
      value: !1
    },
    fogDepthRange: {
      value: new Z(0, 1)
    },
    rotationMatrix: {
      value: new qe()
    },
    projectionInverseMatrix: {
      value: new J()
    },
    color: {
      value: new Ce()
    },
    highColor: {
      value: new Ce()
    }
  },
  fragmentShader: Ra + `
` + KE
}, HE = new B(), PE = new B();
function tw(s, t, e, i, n) {
  const o = s.x, r = s.y, a = s.z, g = t.x, c = t.y, l = t.z, h = o * o * g * g, d = r * r * c * c, C = a * a * l * l, p = h + d + C, m = Math.sqrt(1 / p), b = HE.copy(s).multiplyScalar(m);
  if (p < i)
    return n || (n = new B()), isFinite(m) ? n.copy(b) : void 0;
  const S = e.x, A = e.y, u = e.z, y = PE;
  y.x = b.x * S * 2, y.y = b.y * A * 2, y.z = b.z * u * 2;
  let I = (1 - m) * s.length() / (0.5 * y.length()), M = 0, G, x, L, E, T, R, w, v, D, K, P;
  do {
    I -= M, L = 1 / (1 + I * S), E = 1 / (1 + I * A), T = 1 / (1 + I * u), R = L * L, w = E * E, v = T * T, D = R * L, K = w * E, P = v * T, G = h * R + d * w + C * v - 1, x = h * D * S + d * K * A + C * P * u;
    let k = -2 * x;
    M = G / k;
  } while (Math.abs(G) > 1e-12);
  return n ? (n.x = o * L, n.y = r * E, n.z = a * T, n) : new B(
    o * L,
    r * E,
    a * T
  );
}
function F(s) {
  return s != null;
}
function he(s, t) {
  return s != null ? s : t;
}
he.EMPTY_OBJECT = Object.freeze({});
function re(s) {
  this.name = "DeveloperError", this.message = s;
  let t;
  try {
    throw new Error();
  } catch (e) {
    t = e.stack;
  }
  this.stack = t;
}
F(Object.create) && (re.prototype = Object.create(Error.prototype), re.prototype.constructor = re);
re.prototype.toString = function() {
  let s = this.name + ": " + this.message;
  return F(this.stack) && (s += `
` + this.stack.toString()), s;
};
re.throwInstantiationError = function() {
  throw new re(
    "This function defines an interface and should not be called directly."
  );
};
const ci = class {
  static equalsEpsilon(t, e, i, n) {
    i = he(i, 0), n = he(n, i);
    const o = Math.abs(t - e);
    return o <= n || o <= i * Math.max(Math.abs(t), Math.abs(e));
  }
  static toRadians(t) {
    return ce.degToRad(t);
  }
  static clamp(t, e, i) {
    return t < e ? e : t > i ? i : t;
  }
  static acosClamped(t) {
    return Math.acos(ci.clamp(t, -1, 1));
  }
  static asinClamped(t) {
    return Math.asin(ci.clamp(t, -1, 1));
  }
  static sign(t) {
    return Math.sign(t);
  }
  static zeroToTwoPi(t) {
    if (t >= 0 && t <= ci.TWO_PI)
      return t;
    const e = ci.mod(t, ci.TWO_PI);
    return Math.abs(e) < ci.EPSILON14 && Math.abs(t) > ci.EPSILON14 ? ci.TWO_PI : e;
  }
  static mod(t, e) {
    return ci.sign(t) === ci.sign(e) && Math.abs(t) < Math.abs(e) ? t : (t % e + e) % e;
  }
  static chordLength(t, e) {
    return 2 * e * Math.sin(t * 0.5);
  }
  static negativePiToPi(t) {
    if (!F(t))
      throw new re("angle is required.");
    return t >= -ci.PI && t <= ci.PI ? t : ci.zeroToTwoPi(t + ci.PI) - ci.PI;
  }
  static normalize(t, e, i) {
    return i = Math.max(i - e, 0), i === 0 ? 0 : ci.clamp((t - e) / i, 0, 1);
  }
};
let X = ci;
f(X, "EPSILON1", 0.1), f(X, "EPSILON2", 0.01), f(X, "EPSILON3", 1e-3), f(X, "EPSILON4", 1e-4), f(X, "EPSILON5", 1e-5), f(X, "EPSILON6", 1e-6), f(X, "EPSILON7", 1e-7), f(X, "EPSILON8", 1e-8), f(X, "EPSILON9", 1e-9), f(X, "EPSILON10", 1e-10), f(X, "EPSILON11", 1e-11), f(X, "EPSILON12", 1e-12), f(X, "EPSILON13", 1e-13), f(X, "EPSILON14", 1e-14), f(X, "EPSILON15", 1e-15), f(X, "EPSILON16", 1e-16), f(X, "EPSILON17", 1e-17), f(X, "EPSILON18", 1e-18), f(X, "EPSILON19", 1e-19), f(X, "EPSILON20", 1e-20), f(X, "EPSILON21", 1e-21), f(X, "PI", Math.PI), f(X, "ONE_OVER_PI", 1 / Math.PI), f(X, "PI_OVER_TWO", Math.PI / 2), f(X, "PI_OVER_THREE", Math.PI / 3), f(X, "PI_OVER_FOUR", Math.PI / 4), f(X, "PI_OVER_SIX", Math.PI / 6), f(X, "THREE_PI_OVER_TWO", 3 * Math.PI / 2), f(X, "TWO_PI", 2 * Math.PI), f(X, "ONE_OVER_TWO_PI", 1 / (2 * Math.PI)), f(X, "RADIANS_PER_DEGREE", Math.PI / 180);
const NE = new B();
let rn = new B(), Rr = new B();
const FE = new B(
  6378137 * 6378137,
  6378137 * 6378137,
  6356752314245179e-9 * 6356752314245179e-9
), ac = new B(), vd = new B(), Bt = class {
  constructor() {
    f(this, "COLUMN0ROW0", 0);
    f(this, "COLUMN0ROW1", 1);
    f(this, "COLUMN0ROW2", 2);
    f(this, "COLUMN1ROW0", 3);
    f(this, "COLUMN1ROW1", 4);
    f(this, "COLUMN1ROW2", 5);
    f(this, "COLUMN2ROW0", 6);
    f(this, "COLUMN2ROW1", 7);
    f(this, "COLUMN2ROW2", 8);
  }
  static clone(t, e) {
    if (!!t)
      return e.copy(t), e;
  }
  static equals(t, e) {
    return F(t) && F(e) ? t.equals(e) : !1;
  }
  static normalize(t, e) {
    return t === e ? (t.normalize(), t) : (e.copy(t), e.normalize(), e);
  }
  static add(t, e, i) {
    return i || (i = new B()), i.addVectors(t, e);
  }
  static dot(t, e) {
    return t.dot(e);
  }
  static cross(t, e, i) {
    return i || (i = new B()), i.crossVectors(t, e), i;
  }
  static magnitudeSquared(t) {
    return t.lengthSq();
  }
  static multiplyByScalar(t, e, i) {
    return i || (i = new B()), i.copy(t).multiplyScalar(e), i;
  }
  static divideByScalar(t, e, i) {
    return i || (i = new B()), i.x = t.x / e, i.y = t.y / e, i.z = t.z / e, i;
  }
  static subtract(t, e, i) {
    return i || (i = new B()), i.subVectors(t, e), i;
  }
  static distance(t, e) {
    return t.distanceTo(e);
  }
  static negate(t, e) {
    return e || (e = new B()), e.copy(t), e.negate(), e;
  }
  static multiplyComponents(t, e, i) {
    return i || (i = new B()), i.multiplyVectors(t, e), i;
  }
  static magnitude(t) {
    return t.length();
  }
  static equalsEpsilon(t, e, i, n) {
    return t === e || F(t) && F(e) && X.equalsEpsilon(
      t.x,
      e.x,
      i,
      n
    ) && X.equalsEpsilon(
      t.y,
      e.y,
      i,
      n
    ) && X.equalsEpsilon(
      t.z,
      e.z,
      i,
      n
    );
  }
  static fromCartesian4(t, e) {
    return e || (e = new B()), e.set(t.x, t.y, t.z), e;
  }
  static fromElements(t, e, i, n) {
    return n || (n = new B()), n.set(t, e, i), n;
  }
  static fromRadians(t, e, i, n, o) {
    i = he(i, 0);
    const r = F(n) ? n.radiiSquared : FE, a = Math.cos(e);
    rn.x = a * Math.cos(t), rn.y = a * Math.sin(t), rn.z = Math.sin(e), rn = Bt.normalize(rn, rn), Bt.multiplyComponents(r, rn, Rr);
    const g = Math.sqrt(Bt.dot(rn, Rr));
    return Rr = Bt.divideByScalar(Rr, g, Rr), rn = Bt.multiplyByScalar(rn, i, rn), F(o) || (o = new B()), Bt.add(Rr, rn, o);
  }
  static angleBetween(t, e) {
    Bt.normalize(t, ac), Bt.normalize(e, vd);
    const i = Bt.dot(ac, vd), n = Bt.magnitude(
      Bt.cross(
        ac,
        vd,
        ac
      )
    );
    return Math.atan2(n, i);
  }
  static fromDegrees(t, e, i, n, o) {
    return t = X.toRadians(t), e = X.toRadians(e), Bt.fromRadians(t, e, i, n, o);
  }
};
let _ = Bt;
f(_, "ZERO", Object.freeze(new B())), f(_, "UNIT_X", Object.freeze(new B(1, 0, 0))), f(_, "UNIT_Y", Object.freeze(new B(0, 1, 0))), f(_, "UNIT_Z", Object.freeze(new B(0, 0, 1))), f(_, "abs", function(t, e) {
  return e.x = Math.abs(t.x), e.y = Math.abs(t.y), e.z = Math.abs(t.z), e;
}), f(_, "mostOrthogonalAxis", function(t, e) {
  const i = Bt.normalize(t, NE);
  return Bt.abs(i, i), i.x <= i.y ? i.x <= i.z ? e = Bt.clone(Bt.UNIT_X, e) : e = Bt.clone(Bt.UNIT_Z, e) : i.y <= i.z ? e = Bt.clone(Bt.UNIT_Y, e) : e = Bt.clone(Bt.UNIT_Z, e), e;
});
const Uf = new B(), kE = new B();
class De {
  constructor(t, e, i) {
    this._radii = new B(t, e, i), this._radiiSquared = new B(t * t, e * e, i * i), this._radiiToTheFourth = new B(
      t * t * t * t,
      e * e * e * e,
      i * i * i * i
    ), this._oneOverRadii = new B(
      t === 0 ? 0 : 1 / t,
      e === 0 ? 0 : 1 / e,
      i === 0 ? 0 : 1 / i
    ), this._oneOverRadiiSquared = new B(
      t === 0 ? 0 : 1 / (t * t),
      e === 0 ? 0 : 1 / (e * e),
      i === 0 ? 0 : 1 / (i * i)
    ), this._minimumRadius = Math.min(t, e, i), this._maximumRadius = Math.max(t, e, i), this._centerToleranceSquared = 0.1, this._radiiSquared.z !== 0 && (this._squaredXOverSquaredZ = this._radiiSquared.x / this._radiiSquared.z);
  }
  static fromCartesian3(t) {
    return new De(t.x, t.y, t.z);
  }
  geodeticSurfaceNormalCartographic(t, e) {
    e || (e = new B());
    const i = t.x, n = t.y, o = Math.cos(n), r = o * Math.cos(i), a = o * Math.sin(i), g = Math.sin(n);
    return e.set(r, a, g), e.normalize(), e;
  }
  cartographicDegreeToCartesian(t, e) {
    return Uf.set(
      ce.degToRad(t.x),
      ce.degToRad(t.y),
      t.z
    ), this.cartographicToCartesian(Uf, e);
  }
  cartographicToCartesian(t, e) {
    const i = this.geodeticSurfaceNormalCartographic(t);
    e || (e = new B()), e.multiplyVectors(this._radiiSquared, i);
    const n = Math.sqrt(i.clone().dot(e));
    return e.divideScalar(n), i.multiplyScalar(t.z), e.add(i), e;
  }
  cartesianToCartographicDegree(t, e) {
    const i = this.cartesianToCartographic(t, e);
    if (!!i)
      return e = i, e.x = ce.radToDeg(e.x), e.y = ce.radToDeg(e.y), e;
  }
  scaleToGeodeticSurface(t, e) {
    return tw(
      t,
      this._oneOverRadii,
      this._oneOverRadiiSquared,
      this._centerToleranceSquared,
      e
    );
  }
  scaleToGeocentricSurface(t, e) {
    e || (e = new B());
    const i = t.x, n = t.y, o = t.z, r = this._oneOverRadiiSquared, a = 1 / Math.sqrt(
      i * i * r.x + n * n * r.y + o * o * r.z
    );
    return e.copy(t).multiplyScalar(a);
  }
  cartesianToCartographic(t, e) {
    const i = this.scaleToGeodeticSurface(
      t,
      kE
    );
    if (!i)
      return;
    const n = this.geodeticSurfaceNormal(i), o = t.clone();
    o.sub(i);
    const r = Math.atan2(n.y, n.x), a = Math.asin(n.z), g = Math.sign(o.dot(t)) * o.length();
    return e || (e = new B()), e.set(r, a, g), e;
  }
  geodeticSurfaceNormal(t, e) {
    return F(e) || (e = new B()), e.multiplyVectors(t, this._oneOverRadiiSquared), e.normalize(), e;
  }
  getSurfaceNormalIntersectionWithZAxis(t, e, i) {
    e = he(e, 0);
    const n = this._squaredXOverSquaredZ;
    if (F(i) || (i = new B()), i.x = 0, i.y = 0, i.z = t.z * (1 - n), !(Math.abs(i.z) >= this._radii.z - e))
      return i;
  }
  transformPositionToScaledSpace(t, e) {
    return _.multiplyComponents(t, this._oneOverRadii, e);
  }
  static clone(t, e) {
    if (!t)
      return;
    const i = t._radii;
    return e ? (_.clone(i, e._radii), _.clone(t._radiiSquared, e._radiiSquared), _.clone(t._radiiToTheFourth, e._radiiToTheFourth), _.clone(t._oneOverRadii, e._oneOverRadii), _.clone(t._oneOverRadiiSquared, e._oneOverRadiiSquared), e._minimumRadius = t._minimumRadius, e._maximumRadius = t._maximumRadius, e._centerToleranceSquared = t._centerToleranceSquared, e) : new De(i.x, i.y, i.z);
  }
  get radii() {
    return this._radii;
  }
  get radiiSquared() {
    return this._radiiSquared;
  }
  get radiiToTheFourth() {
    return this.radiiToTheFourth;
  }
  get oneOverRadii() {
    return this._oneOverRadii;
  }
  get oneOverRadiiSquared() {
    return this._oneOverRadiiSquared;
  }
  get maximumRadius() {
    return this._maximumRadius;
  }
  get minimumRadius() {
    return this._minimumRadius;
  }
}
De.WGS84 = Object.freeze(
  new De(6378137, 6378137, 6356752314245179e-9)
);
function Da(s) {
  this._ellipsoid = he(s, De.WGS84), this._semimajorAxis = this._ellipsoid.maximumRadius, this._oneOverSemimajorAxis = 1 / this._semimajorAxis;
}
Object.defineProperties(Da.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  }
});
Da.prototype.project = function(s, t) {
  const e = this._semimajorAxis, i = s.x * e, n = s.y * e, o = s.z;
  return F(t) ? (t.x = i, t.y = n, t.z = o, t) : new B(i, n, o);
};
Da.prototype.unproject = function(s, t) {
  if (!F(s))
    throw new re("cartesian is required");
  const e = this._oneOverSemimajorAxis, i = s.x * e, n = s.y * e, o = s.z;
  return F(t) ? (t.x = i, t.y = n, t.z = o, t) : new B(i, n, o);
};
const Of = new Z(), Qf = new Z(), Dg = class {
  static clone(t, e) {
    return e.copy(t), e;
  }
  static fromElements(t, e, i) {
    return i || (i = new Z()), i.set(t, e), i;
  }
  static lerp(t, e, i, n) {
    return n || (n = new Z()), n.lerpVectors(t, e, i), n;
  }
  static equalsEpsilon(t, e, i, n) {
    return t === e || F(t) && F(e) && X.equalsEpsilon(
      t.x,
      e.x,
      i,
      n
    ) && X.equalsEpsilon(
      t.y,
      e.y,
      i,
      n
    );
  }
  static equals(t, e) {
    return t.equals(e);
  }
  static dot(t, e) {
    return t.dot(e);
  }
  static normalize(t, e) {
    return t === e ? (t.normalize(), t) : (e.copy(t), e.normalize(), e);
  }
  static add(t, e, i) {
    return i || (i = new Z()), i.addVectors(t, e);
  }
  static multiplyByScalar(t, e, i) {
    return i || (i = new Z()), i.copy(t).multiplyScalar(e), i;
  }
  static subtract(t, e, i) {
    return i || (i = new Z()), i.subVectors(t, e), i;
  }
  static distance(t, e) {
    return t.distanceTo(e);
  }
  static angleBetween(t, e) {
    return Dg.normalize(t, Of), Dg.normalize(e, Qf), X.acosClamped(
      Dg.dot(Of, Qf)
    );
  }
};
let oe = Dg;
f(oe, "ZERO", new Z());
oe.fromCartesian3 = oe.clone;
oe.fromCartesian4 = oe.clone;
class Ae {
  static fromQuaternion(t, e) {
    const i = t.x * t.x, n = t.x * t.y, o = t.x * t.z, r = t.x * t.w, a = t.y * t.y, g = t.y * t.z, c = t.y * t.w, l = t.z * t.z, h = t.z * t.w, d = t.w * t.w, C = i - a - l + d, p = 2 * (n - h), m = 2 * (o + c), b = 2 * (n + h), S = -i + a - l + d, A = 2 * (g - r), u = 2 * (o - c), y = 2 * (g + r), I = -i - a + l + d;
    return e || (e = new qe()), e.set(C, p, m, b, S, A, u, y, I), e;
  }
  static getColumn(t, e, i) {
    const n = t.elements, o = e * 3, r = n[o], a = n[o + 1], g = n[o + 2];
    return i.x = r, i.y = a, i.z = g, i;
  }
  static multiplyByVector(t, e, i) {
    return i || (i = new B()), i.copy(e), i.applyMatrix3(t), i;
  }
  static multiplyByScale(t, e, i) {
    i || (i = new qe());
    const n = i.elements, o = t.elements;
    return n[0] = o[0] * e.x, n[1] = o[1] * e.x, n[2] = o[2] * e.x, n[3] = o[3] * e.y, n[4] = o[4] * e.y, n[5] = o[5] * e.y, n[6] = o[6] * e.z, n[7] = o[7] * e.z, n[8] = o[8] * e.z, i;
  }
  static transpose(t, e) {
    return e || (e = new qe()), e.copy(t).transpose(), e;
  }
  static fromScale(t, e) {
    e || (e = new qe());
    const i = e.elements;
    return i[0] = t.x, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = t.y, i[5] = 0, i[6] = 0, i[7] = 0, i[8] = t.z, e;
  }
  static multiply(t, e, i) {
    i || (i = new qe());
    const n = t.elements, o = e.elements, r = i.elements, a = n[0], g = n[3], c = n[6], l = n[1], h = n[4], d = n[7], C = n[2], p = n[5], m = n[8], b = o[0], S = o[3], A = o[6], u = o[1], y = o[4], I = o[7], M = o[2], G = o[5], x = o[8];
    return r[0] = a * b + g * u + c * M, r[3] = a * S + g * y + c * G, r[6] = a * A + g * I + c * x, r[1] = l * b + h * u + d * M, r[4] = l * S + h * y + d * G, r[7] = l * A + h * I + d * x, r[2] = C * b + p * u + m * M, r[5] = C * S + p * y + m * G, r[8] = C * A + p * I + m * x, i;
  }
  static clone(t, e) {
    if (!!F(t))
      return F(e) ? (e.clone(t), e) : new qe(
        t[0],
        t[3],
        t[6],
        t[1],
        t[4],
        t[7],
        t[2],
        t[5],
        t[8]
      );
  }
  static setColumn(t, e, i, n) {
    n = Ae.clone(t, n);
    const o = n.elements, r = e * 3;
    return o[r] = i.x, o[r + 1] = i.y, o[r + 2] = i.z, n;
  }
}
Ae.ZERO = qe.ZERO = Object.freeze(
  new qe(0, 0, 0, 0, 0, 0, 0, 0, 0)
);
Ae.COLUMN0ROW0 = 0;
Ae.COLUMN0ROW1 = 1;
Ae.COLUMN0ROW2 = 2;
Ae.COLUMN1ROW0 = 3;
Ae.COLUMN1ROW1 = 4;
Ae.COLUMN1ROW2 = 5;
Ae.COLUMN2ROW0 = 6;
Ae.COLUMN2ROW1 = 7;
Ae.COLUMN2ROW2 = 8;
class _e {
  static clone(t, e) {
    return e.copy(t), e;
  }
  static inverseTransformation(t, e) {
    return e.copy(t).invert(), e;
  }
  static multiplyByPoint(t, e, i) {
    const n = t.elements, o = e.x, r = e.y, a = e.z, g = n[0] * o + n[4] * r + n[8] * a + n[12], c = n[1] * o + n[5] * r + n[9] * a + n[13], l = n[2] * o + n[6] * r + n[10] * a + n[14];
    return i.x = g, i.y = c, i.z = l, i;
  }
  static multiplyByPointAsVector(t, e, i) {
    const n = t.elements, o = e.x, r = e.y, a = e.z, g = n[0] * o + n[4] * r + n[8] * a, c = n[1] * o + n[5] * r + n[9] * a, l = n[2] * o + n[6] * r + n[10] * a;
    return i.x = g, i.y = c, i.z = l, i;
  }
  static computeViewportTransformation(t, e, i, n) {
    F(n) || (n = new J()), t = he(t, he.EMPTY_OBJECT);
    const o = he(t.x, 0), r = he(t.y, 0), a = he(t.width, 0), g = he(t.height, 0);
    e = he(e, 0), i = he(i, 1);
    const c = a * 0.5, l = g * 0.5, h = (i - e) * 0.5, d = c, C = l, p = h, m = o + c, b = r + l, S = e + h, A = 1, u = n.elements;
    return u[0] = d, u[1] = 0, u[2] = 0, u[3] = 0, u[4] = 0, u[5] = C, u[6] = 0, u[7] = 0, u[8] = 0, u[9] = 0, u[10] = p, u[11] = 0, u[12] = m, u[13] = b, u[14] = S, u[15] = A, n;
  }
  static equals(t, e) {
    return t.equals(e);
  }
  static multiplyByVector(t, e, i) {
    return i || (i = new Me()), i.copy(e), i.applyMatrix4(t), i;
  }
  static getColumn(t, e, i) {
    const n = t.elements, o = e * 4, r = n[o], a = n[o + 1], g = n[o + 2], c = n[o + 3];
    return i.x = r, i.y = a, i.z = g, i.w = c, i;
  }
  static fromTranslationQuaternionRotationScale(t, e, i, n) {
    n || (n = new J());
    const o = i.x, r = i.y, a = i.z, g = e.x * e.x, c = e.x * e.y, l = e.x * e.z, h = e.x * e.w, d = e.y * e.y, C = e.y * e.z, p = e.y * e.w, m = e.z * e.z, b = e.z * e.w, S = e.w * e.w, A = g - d - m + S, u = 2 * (c - b), y = 2 * (l + p), I = 2 * (c + b), M = -g + d - m + S, G = 2 * (C - h), x = 2 * (l - p), L = 2 * (C + h), E = -g - d + m + S, T = n.elements;
    return T[0] = A * o, T[1] = I * o, T[2] = x * o, T[3] = 0, T[4] = u * r, T[5] = M * r, T[6] = L * r, T[7] = 0, T[8] = y * a, T[9] = G * a, T[10] = E * a, T[11] = 0, T[12] = t.x, T[13] = t.y, T[14] = t.z, T[15] = 1, n;
  }
}
f(_e, "IDENTITY", Object.freeze(new J()));
_e.ZERO = Object.freeze(
  new J(
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  )
);
let Yf = new Ye(), jf = new Ye(), Td = new Ye(), Jf = new Ye(), Ld = new B();
class wi {
  static fromAxisAngle(t, e, i) {
    return i || (i = new Ye()), Ld.copy(t), Ld.normalize(), i.setFromAxisAngle(Ld, e), i;
  }
  static multiply(t, e, i) {
    return i || (i = new Ye()), i.multiplyQuaternions(t, e), i;
  }
  static fromHeadingPitchRoll(t, e) {
    return Jf = wi.fromAxisAngle(
      _.UNIT_X,
      t.roll,
      Yf
    ), Td = wi.fromAxisAngle(
      _.UNIT_Y,
      -t.pitch,
      e
    ), e = wi.multiply(
      Td,
      Jf,
      Td
    ), jf = wi.fromAxisAngle(
      _.UNIT_Z,
      -t.heading,
      Yf
    ), wi.multiply(jf, e, e);
  }
}
class Oe {
  constructor(t, e, i, n) {
    this.west = t || 0, this.south = e || 0, this.east = i || 0, this.north = n || 0;
  }
  get width() {
    return Oe.computeWidth(this);
  }
  get height() {
    return Oe.computeHeight(this);
  }
}
Oe.fromDegrees = function(s, t, e, i, n) {
  return s = ce.degToRad(he(s, 0)), t = ce.degToRad(he(t, 0)), e = ce.degToRad(he(e, 0)), i = ce.degToRad(he(i, 0)), F(n) ? (n.west = s, n.south = t, n.east = e, n.north = i, n) : new Oe(s, t, e, i);
};
Oe.computeWidth = function(s) {
  let t = s.east;
  const e = s.west;
  return t < e && (t += X.TWO_PI), t - e;
};
Oe.computeHeight = function(s) {
  return s.north - s.south;
};
Oe.clone = function(s, t) {
  if (!!F(s))
    return F(t) ? (t.west = s.west, t.south = s.south, t.east = s.east, t.north = s.north, t) : new Oe(s.west, s.south, s.east, s.north);
};
Oe.southwest = function(s, t) {
  return F(t) ? (t.x = s.west, t.y = s.south, t.z = 0, t) : new B(s.west, s.south);
};
Oe.northeast = function(s, t) {
  return F(t) ? (t.x = s.east, t.y = s.north, t.z = 0, t) : new B(s.east, s.north);
};
Oe.southeast = function(s, t) {
  return F(t) ? (t.x = s.east, t.y = s.south, t.z = 0, t) : new B(s.east, s.south);
};
Oe.northwest = function(s, t) {
  return F(t) ? (t.x = s.west, t.y = s.north, t.z = 0, t) : new B(s.west, s.north);
};
Oe.center = function(s, t) {
  let e = s.east;
  const i = s.west;
  e < i && (e += X.TWO_PI);
  const n = X.negativePiToPi((i + e) * 0.5), o = (s.south + s.north) * 0.5;
  return F(t) ? (t.x = n, t.y = o, t.z = 0, t) : new B(n, o);
};
Oe.contains = function(s, t) {
  let e = t.x;
  const i = t.y, n = s.west;
  let o = s.east;
  return o < n && (o += X.TWO_PI, e < 0 && (e += X.TWO_PI)), (e > n || X.equalsEpsilon(e, n, X.EPSILON14)) && (e < o || X.equalsEpsilon(e, o, X.EPSILON14)) && i >= s.south && i <= s.north;
};
const qf = Math.PI + 1e-5, $f = -Math.PI - 1e-5, ep = X.PI_OVER_TWO + 1e-5, tp = -X.PI_OVER_TWO - 1e-5;
Oe.fromBox = function(s, t, e = !1) {
  const i = s.min, n = s.max;
  let o = i.x / 180 * Math.PI, r = i.y / 180 * Math.PI, a = n.x / 180 * Math.PI, g = n.y / 180 * Math.PI;
  return e && (o < $f && (o = -Math.PI), o > qf && (o = Math.PI), r < tp && (r = -X.PI_OVER_TWO), r > ep && (r = X.PI_OVER_TWO), a > qf && (a = Math.PI), a < $f && (a = -Math.PI), g > ep && (g = X.PI_OVER_TWO), g < tp && (g = -X.PI_OVER_TWO)), F(t) ? (t.west = o, t.south = r, t.east = a, t.north = g, t) : new Oe(o, r, a, g);
};
Oe.MAX_VALUE = Object.freeze(
  new Oe(
    -Math.PI,
    -X.PI_OVER_TWO,
    Math.PI,
    X.PI_OVER_TWO
  )
);
class fC {
  constructor(t, e, i) {
    this.heading = he(t, 0), this.pitch = he(e, 0), this.range = he(i, 0);
  }
  clone(t, e) {
    if (!!F(t))
      return F(e) || (e = new fC()), e.heading = t.heading, e.pitch = t.pitch, e.range = t.range, e;
  }
}
const Ze = {}, VE = new Ye(), zE = new B(1, 1, 1), XE = new J(), Gd = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
};
let Dr = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, Md = {}, Di = {
  east: new B(),
  north: new B(),
  up: new B(),
  west: new B(),
  south: new B(),
  down: new B()
}, zo = new B(), Xo = new B(), Wo = new B();
const Rl = (s) => s !== void 0, WE = new B(), ZE = (s) => (s = +s, s === 0 ? s : s > 0 ? 1 : -1), $s = new B(), gc = new B(), iw = function(s, t, e = 0, i) {
  const n = new B(
    40680631590769,
    40680631590769,
    40408299984661445e-3
  ), o = Math.cos(t);
  $s.x = o * Math.cos(s), $s.y = o * Math.sin(s), $s.z = Math.sin(t), $s.normalize(), gc.multiplyVectors(n, $s);
  const r = Math.sqrt($s.dot(gc));
  return gc.divideScalar(r), $s.multiplyScalar(e), Rl(i) || (i = new B()), i.addVectors(gc, $s);
}, UE = (s, t, e = 0, i) => iw(s * Math.PI / 180, t * Math.PI / 180, e, i);
Ze.lnglatToEcef = UE;
Ze.radianToEcef = iw;
Ze.localFrameToFixedFrameGenerator = function(s, t) {
  if (!Gd.hasOwnProperty(s) || !Gd[s].hasOwnProperty(t))
    throw new Error(
      "firstAxis and secondAxis must be east, north, up, west, south or down."
    );
  let e = Gd[s][t], i, n = s + t;
  return Rl(Md[n]) ? i = Md[n] : (i = function(o, r, a) {
    if (!Rl(o))
      throw new Error("origin is required.");
    if (Rl(a) || (a = new J()), o.equals(WE))
      zo.fromArray(Dr[s]), Xo.fromArray(Dr[t]), Wo.fromArray(Dr[e]);
    else if (Math.abs(o.x) < 1e-14 && Math.abs(o.y) < 1e-14) {
      let c = ZE(o.z);
      zo.fromArray(Dr[s]), s !== "east" && s !== "west" && zo.multiplyScalar(c), Xo.fromArray(Dr[t]), t !== "east" && t !== "west" && Xo.multiplyScalar(c), Wo.fromArray(Dr[e]), e !== "east" && e !== "west" && Wo.multiplyScalar(c);
    } else {
      r = r || De.WGS84, r.geodeticSurfaceNormal(o, Di.up);
      let c = Di.up, l = Di.east;
      l.x = -o.y, l.y = o.x, l.z = 0, Di.east.copy(l).normalize(), Di.north.crossVectors(c, l), Di.down.copy(Di.up).multiplyScalar(-1), Di.west.copy(Di.east).multiplyScalar(-1), Di.south.copy(Di.north).multiplyScalar(-1), zo = Di[s], Xo = Di[t], Wo = Di[e];
    }
    const g = a.elements;
    return g[0] = zo.x, g[1] = zo.y, g[2] = zo.z, g[3] = 0, g[4] = Xo.x, g[5] = Xo.y, g[6] = Xo.z, g[7] = 0, g[8] = Wo.x, g[9] = Wo.y, g[10] = Wo.z, g[11] = 0, g[12] = o.x, g[13] = o.y, g[14] = o.z, g[15] = 1, a;
  }, Md[n] = i), i;
};
Ze.eastNorthUpToFixedFrame = Ze.localFrameToFixedFrameGenerator(
  "east",
  "north"
);
Ze.headingPitchRollToFixedFrame = function(s, t, e, i, n) {
  i = i || Ze.eastNorthUpToFixedFrame;
  const o = wi.fromHeadingPitchRoll(
    t,
    VE
  ), r = _e.fromTranslationQuaternionRotationScale(
    _.ZERO,
    o,
    zE,
    XE
  );
  return n = i(s, e, n), n.multiply(r);
};
Ze.northEastDownToFixedFrame = Ze.localFrameToFixedFrameGenerator(
  "north",
  "east"
);
Ze.northUpEastToFixedFrame = Ze.localFrameToFixedFrameGenerator(
  "north",
  "up"
);
Ze.northWestUpToFixedFrame = Ze.localFrameToFixedFrameGenerator(
  "north",
  "west"
);
function Cg(s, t) {
  this.start = he(s, 0), this.stop = he(t, 0);
}
var Nn = {};
Nn.computeDiscriminant = function(s, t, e) {
  if (typeof s != "number")
    throw new re("a is a required number.");
  if (typeof t != "number")
    throw new re("b is a required number.");
  if (typeof e != "number")
    throw new re("c is a required number.");
  var i = t * t - 4 * s * e;
  return i;
};
function ip(s, t, e) {
  var i = s + t;
  return X.sign(s) !== X.sign(t) && Math.abs(i / Math.max(Math.abs(s), Math.abs(t))) < e ? 0 : i;
}
Nn.computeRealRoots = function(s, t, e) {
  if (typeof s != "number")
    throw new re("a is a required number.");
  if (typeof t != "number")
    throw new re("b is a required number.");
  if (typeof e != "number")
    throw new re("c is a required number.");
  var i;
  if (s === 0)
    return t === 0 ? [] : [-e / t];
  if (t === 0) {
    if (e === 0)
      return [0, 0];
    var n = Math.abs(e), o = Math.abs(s);
    if (n < o && n / o < X.EPSILON14)
      return [0, 0];
    if (n > o && o / n < X.EPSILON14)
      return [];
    if (i = -e / s, i < 0)
      return [];
    var r = Math.sqrt(i);
    return [-r, r];
  } else if (e === 0)
    return i = -t / s, i < 0 ? [i, 0] : [0, i];
  var a = t * t, g = 4 * s * e, c = ip(a, -g, X.EPSILON14);
  if (c < 0)
    return [];
  var l = -0.5 * ip(
    t,
    X.sign(t) * Math.sqrt(c),
    X.EPSILON14
  );
  return t > 0 ? [l / s, e / l] : [e / l, l / s];
};
var jg = {};
jg.computeDiscriminant = function(s, t, e, i) {
  if (typeof s != "number")
    throw new re("a is a required number.");
  if (typeof t != "number")
    throw new re("b is a required number.");
  if (typeof e != "number")
    throw new re("c is a required number.");
  if (typeof i != "number")
    throw new re("d is a required number.");
  var n = s * s, o = t * t, r = e * e, a = i * i, g = 18 * s * t * e * i + o * r - 27 * n * a - 4 * (s * r * e + o * t * i);
  return g;
};
function Ed(s, t, e, i) {
  var n = s, o = t / 3, r = e / 3, a = i, g = n * r, c = o * a, l = o * o, h = r * r, d = n * r - l, C = n * a - o * r, p = o * a - h, m = 4 * d * p - C * C, b, S;
  if (m < 0) {
    var A, u, y;
    l * c >= g * h ? (A = n, u = d, y = -2 * o * d + n * C) : (A = a, u = p, y = -a * C + 2 * r * p);
    var I = y < 0 ? -1 : 1, M = -I * Math.abs(A) * Math.sqrt(-m);
    S = -y + M;
    var G = S / 2, x = G < 0 ? -Math.pow(-G, 1 / 3) : Math.pow(G, 1 / 3), L = S === M ? -x : -u / x;
    return b = u <= 0 ? x + L : -y / (x * x + L * L + u), l * c >= g * h ? [(b - o) / n] : [-a / (b + r)];
  }
  var E = d, T = -2 * o * d + n * C, R = p, w = -a * C + 2 * r * p, v = Math.sqrt(m), D = Math.sqrt(3) / 2, K = Math.abs(Math.atan2(n * v, -T) / 3);
  b = 2 * Math.sqrt(-E);
  var P = Math.cos(K);
  S = b * P;
  var k = b * (-P / 2 - D * Math.sin(K)), V = S + k > 2 * o ? S - o : k - o, N = n, z = V / N;
  K = Math.abs(Math.atan2(a * v, -w) / 3), b = 2 * Math.sqrt(-R), P = Math.cos(K), S = b * P, k = b * (-P / 2 - D * Math.sin(K));
  var O = -a, Q = S + k < 2 * r ? S + r : k + r, U = O / Q, $ = N * Q, ee = -V * Q - N * O, se = V * O, ie = (r * ee - o * se) / (-o * ee + r * $);
  return z <= ie ? z <= U ? ie <= U ? [z, ie, U] : [z, U, ie] : [U, z, ie] : z <= U ? [ie, z, U] : ie <= U ? [ie, U, z] : [U, ie, z];
}
jg.computeRealRoots = function(s, t, e, i) {
  if (typeof s != "number")
    throw new re("a is a required number.");
  if (typeof t != "number")
    throw new re("b is a required number.");
  if (typeof e != "number")
    throw new re("c is a required number.");
  if (typeof i != "number")
    throw new re("d is a required number.");
  var n, o;
  if (s === 0)
    return Nn.computeRealRoots(t, e, i);
  if (t === 0) {
    if (e === 0) {
      if (i === 0)
        return [0, 0, 0];
      o = -i / s;
      var r = o < 0 ? -Math.pow(-o, 1 / 3) : Math.pow(o, 1 / 3);
      return [r, r, r];
    } else if (i === 0)
      return n = Nn.computeRealRoots(s, 0, e), n.Length === 0 ? [0] : [n[0], 0, n[1]];
    return Ed(s, 0, e, i);
  } else {
    if (e === 0)
      return i === 0 ? (o = -t / s, o < 0 ? [o, 0, 0] : [0, 0, o]) : Ed(s, t, 0, i);
    if (i === 0)
      return n = Nn.computeRealRoots(s, t, e), n.length === 0 ? [0] : n[1] <= 0 ? [n[0], n[1], 0] : n[0] >= 0 ? [0, n[0], n[1]] : [n[0], 0, n[1]];
  }
  return Ed(s, t, e, i);
};
var pC = {};
pC.computeDiscriminant = function(s, t, e, i, n) {
  if (typeof s != "number")
    throw new re("a is a required number.");
  if (typeof t != "number")
    throw new re("b is a required number.");
  if (typeof e != "number")
    throw new re("c is a required number.");
  if (typeof i != "number")
    throw new re("d is a required number.");
  if (typeof n != "number")
    throw new re("e is a required number.");
  var o = s * s, r = o * s, a = t * t, g = a * t, c = e * e, l = c * e, h = i * i, d = h * i, C = n * n, p = C * n, m = a * c * h - 4 * g * d - 4 * s * l * h + 18 * s * t * e * d - 27 * o * h * h + 256 * r * p + n * (18 * g * e * i - 4 * a * l + 16 * s * c * c - 80 * s * t * c * i - 6 * s * a * h + 144 * o * e * h) + C * (144 * s * a * e - 27 * a * a - 128 * o * c - 192 * o * t * i);
  return m;
};
function Tn(s, t, e, i) {
  var n = s * s, o = t - 3 * n / 8, r = e - t * s / 2 + n * s / 8, a = i - e * s / 4 + t * n / 16 - 3 * n * n / 256, g = jg.computeRealRoots(
    1,
    2 * o,
    o * o - 4 * a,
    -r * r
  );
  if (g.length > 0) {
    var c = -s / 4, l = g[g.length - 1];
    if (Math.abs(l) < X.EPSILON14) {
      var h = Nn.computeRealRoots(1, o, a);
      if (h.length === 2) {
        var d = h[0], C = h[1], p;
        if (d >= 0 && C >= 0) {
          var m = Math.sqrt(d), b = Math.sqrt(C);
          return [c - b, c - m, c + m, c + b];
        } else {
          if (d >= 0 && C < 0)
            return p = Math.sqrt(d), [c - p, c + p];
          if (d < 0 && C >= 0)
            return p = Math.sqrt(C), [c - p, c + p];
        }
      }
      return [];
    } else if (l > 0) {
      var S = Math.sqrt(l), A = (o + l - r / S) / 2, u = (o + l + r / S) / 2, y = Nn.computeRealRoots(1, S, A), I = Nn.computeRealRoots(1, -S, u);
      return y.length !== 0 ? (y[0] += c, y[1] += c, I.length !== 0 ? (I[0] += c, I[1] += c, y[1] <= I[0] ? [y[0], y[1], I[0], I[1]] : I[1] <= y[0] ? [I[0], I[1], y[0], y[1]] : y[0] >= I[0] && y[1] <= I[1] ? [I[0], y[0], y[1], I[1]] : I[0] >= y[0] && I[1] <= y[1] ? [y[0], I[0], I[1], y[1]] : y[0] > I[0] && y[0] < I[1] ? [I[0], y[0], I[1], y[1]] : [y[0], I[0], y[1], I[1]]) : y) : I.length !== 0 ? (I[0] += c, I[1] += c, I) : [];
    }
  }
  return [];
}
function Na(s, t, e, i) {
  var n = e * e, o = t * t, r = s * s, a = -2 * t, g = e * s + o - 4 * i, c = r * i - e * t * s + n, l = jg.computeRealRoots(1, a, g, c);
  if (l.length > 0) {
    var h = l[0], d = t - h, C = d * d, p = s / 2, m = d / 2, b = C - 4 * i, S = C + 4 * Math.abs(i), A = r - 4 * h, u = r + 4 * Math.abs(h), y, I;
    if (h < 0 || b * u < A * S) {
      var M = Math.sqrt(A);
      y = M / 2, I = M === 0 ? 0 : (s * m - e) / M;
    } else {
      var G = Math.sqrt(b);
      y = G === 0 ? 0 : (s * m - e) / G, I = G / 2;
    }
    var x, L;
    p === 0 && y === 0 ? (x = 0, L = 0) : X.sign(p) === X.sign(y) ? (x = p + y, L = h / x) : (L = p - y, x = h / L);
    var E, T;
    m === 0 && I === 0 ? (E = 0, T = 0) : X.sign(m) === X.sign(I) ? (E = m + I, T = i / E) : (T = m - I, E = i / T);
    var R = Nn.computeRealRoots(1, x, E), w = Nn.computeRealRoots(1, L, T);
    if (R.length !== 0)
      return w.length !== 0 ? R[1] <= w[0] ? [R[0], R[1], w[0], w[1]] : w[1] <= R[0] ? [w[0], w[1], R[0], R[1]] : R[0] >= w[0] && R[1] <= w[1] ? [w[0], R[0], R[1], w[1]] : w[0] >= R[0] && w[1] <= R[1] ? [R[0], w[0], w[1], R[1]] : R[0] > w[0] && R[0] < w[1] ? [w[0], R[0], w[1], R[1]] : [R[0], w[0], R[1], w[1]] : R;
    if (w.length !== 0)
      return w;
  }
  return [];
}
pC.computeRealRoots = function(s, t, e, i, n) {
  if (typeof s != "number")
    throw new re("a is a required number.");
  if (typeof t != "number")
    throw new re("b is a required number.");
  if (typeof e != "number")
    throw new re("c is a required number.");
  if (typeof i != "number")
    throw new re("d is a required number.");
  if (typeof n != "number")
    throw new re("e is a required number.");
  if (Math.abs(s) < X.EPSILON15)
    return jg.computeRealRoots(t, e, i, n);
  var o = t / s, r = e / s, a = i / s, g = n / s, c = o < 0 ? 1 : 0;
  switch (c += r < 0 ? c + 1 : c, c += a < 0 ? c + 1 : c, c += g < 0 ? c + 1 : c, c) {
    case 0:
      return Tn(o, r, a, g);
    case 1:
      return Na(o, r, a, g);
    case 2:
      return Na(o, r, a, g);
    case 3:
      return Tn(o, r, a, g);
    case 4:
      return Tn(o, r, a, g);
    case 5:
      return Na(o, r, a, g);
    case 6:
      return Tn(o, r, a, g);
    case 7:
      return Tn(o, r, a, g);
    case 8:
      return Na(o, r, a, g);
    case 9:
      return Tn(o, r, a, g);
    case 10:
      return Tn(o, r, a, g);
    case 11:
      return Na(o, r, a, g);
    case 12:
      return Tn(o, r, a, g);
    case 13:
      return Tn(o, r, a, g);
    case 14:
      return Tn(o, r, a, g);
    case 15:
      return Tn(o, r, a, g);
    default:
      return;
  }
};
var We = {};
We.rayPlane = function(s, t, e) {
  if (!F(s))
    throw new re("ray is required.");
  if (!F(t))
    throw new re("plane is required.");
  F(e) || (e = new B());
  var i = s.origin, n = s.direction, o = t.normal, r = _.dot(o, n);
  if (!(Math.abs(r) < X.EPSILON15)) {
    var a = (-t.constant - _.dot(o, i)) / r;
    if (!(a < 0))
      return e = _.multiplyByScalar(n, a, e), _.add(i, e, e);
  }
};
var OE = new B(), QE = new B(), nw = new B(), np = new B(), sp = new B();
We.rayTriangleParametric = function(s, t, e, i, n) {
  if (!F(s))
    throw new re("ray is required.");
  if (!F(t))
    throw new re("p0 is required.");
  if (!F(e))
    throw new re("p1 is required.");
  if (!F(i))
    throw new re("p2 is required.");
  n = he(n, !1);
  var o = s.origin, r = s.direction, a = _.subtract(e, t, OE), g = _.subtract(i, t, QE), c = _.cross(r, g, nw), l = _.dot(a, c), h, d, C, p, m;
  if (n) {
    if (l < X.EPSILON6 || (h = _.subtract(o, t, np), C = _.dot(h, c), C < 0 || C > l) || (d = _.cross(h, a, sp), p = _.dot(r, d), p < 0 || C + p > l))
      return;
    m = _.dot(g, d) / l;
  } else {
    if (Math.abs(l) < X.EPSILON6)
      return;
    var b = 1 / l;
    if (h = _.subtract(o, t, np), C = _.dot(h, c) * b, C < 0 || C > 1 || (d = _.cross(h, a, sp), p = _.dot(r, d) * b, p < 0 || C + p > 1))
      return;
    m = _.dot(g, d) * b;
  }
  return m;
};
We.rayTriangle = function(s, t, e, i, n, o) {
  var r = We.rayTriangleParametric(
    s,
    t,
    e,
    i,
    n
  );
  if (!(!F(r) || r < 0))
    return F(o) || (o = new B()), _.multiplyByScalar(s.direction, r, o), _.add(s.origin, o, o);
};
var YE = new yt();
We.lineSegmentTriangle = function(s, t, e, i, n, o, r) {
  if (!F(s))
    throw new re("v0 is required.");
  if (!F(t))
    throw new re("v1 is required.");
  if (!F(e))
    throw new re("p0 is required.");
  if (!F(i))
    throw new re("p1 is required.");
  if (!F(n))
    throw new re("p2 is required.");
  var a = YE;
  _.clone(s, a.origin), _.subtract(t, s, a.direction), _.normalize(a.direction, a.direction);
  var g = We.rayTriangleParametric(
    a,
    e,
    i,
    n,
    o
  );
  if (!(!F(g) || g < 0 || g > _.distance(s, t)))
    return F(r) || (r = new B()), _.multiplyByScalar(a.direction, g, r), _.add(a.origin, r, r);
};
function jE(s, t, e, i) {
  var n = t * t - 4 * s * e;
  if (!(n < 0)) {
    if (n > 0) {
      var o = 1 / (2 * s), r = Math.sqrt(n), a = (-t + r) * o, g = (-t - r) * o;
      return a < g ? (i.root0 = a, i.root1 = g) : (i.root0 = g, i.root1 = a), i;
    }
    var c = -t / (2 * s);
    if (c !== 0)
      return i.root0 = i.root1 = c, i;
  }
}
var JE = {
  root0: 0,
  root1: 0
};
function sw(s, t, e) {
  F(e) || (e = new Cg());
  var i = s.origin, n = s.direction, o = t.center, r = t.radius * t.radius, a = _.subtract(i, o, nw), g = _.dot(n, n), c = 2 * _.dot(n, a), l = _.magnitudeSquared(a) - r, h = jE(g, c, l, JE);
  if (!!F(h))
    return e.start = h.root0, e.stop = h.root1, e;
}
We.raySphere = function(s, t, e) {
  if (!F(s))
    throw new re("ray is required.");
  if (!F(t))
    throw new re("sphere is required.");
  if (e = sw(s, t, e), !(!F(e) || e.stop < 0))
    return e.start = Math.max(e.start, 0), e;
};
var qE = new yt();
We.lineSegmentSphere = function(s, t, e, i) {
  if (!F(s))
    throw new re("p0 is required.");
  if (!F(t))
    throw new re("p1 is required.");
  if (!F(e))
    throw new re("sphere is required.");
  var n = qE;
  _.clone(s, n.origin);
  var o = _.subtract(t, s, n.direction), r = _.magnitude(o);
  if (_.normalize(o, o), i = sw(n, e, i), !(!F(i) || i.stop < 0 || i.start > r))
    return i.start = Math.max(i.start, 0), i.stop = Math.min(i.stop, r), i;
};
var $E = new B(), eR = new B();
We.rayEllipsoid = function(s, t) {
  if (!F(s))
    throw new re("ray is required.");
  if (!F(t))
    throw new re("ellipsoid is required.");
  var e = t.oneOverRadii, i = _.multiplyComponents(e, s.origin, $E), n = _.multiplyComponents(e, s.direction, eR), o = _.magnitudeSquared(i), r = _.dot(i, n), a, g, c, l, h;
  if (o > 1) {
    if (r >= 0)
      return;
    var d = r * r;
    if (a = o - 1, g = _.magnitudeSquared(n), c = g * a, d < c)
      return;
    if (d > c) {
      l = r * r - c, h = -r + Math.sqrt(l);
      var C = h / g, p = a / h;
      return C < p ? new Cg(C, p) : {
        start: p,
        stop: C
      };
    }
    var m = Math.sqrt(a / g);
    return new Cg(m, m);
  } else if (o < 1)
    return a = o - 1, g = _.magnitudeSquared(n), c = g * a, l = r * r - c, h = -r + Math.sqrt(l), new Cg(0, h / g);
  if (r < 0)
    return g = _.magnitudeSquared(n), new Cg(0, -r / g);
};
function Zo(s, t, e) {
  var i = s + t;
  return X.sign(s) !== X.sign(t) && Math.abs(i / Math.max(Math.abs(s), Math.abs(t))) < e ? 0 : i;
}
function tR(s, t, e, i, n) {
  var o = i * i, r = n * n, a = (s[Ae.COLUMN1ROW1] - s[Ae.COLUMN2ROW2]) * r, g = n * (i * Zo(
    s[Ae.COLUMN1ROW0],
    s[Ae.COLUMN0ROW1],
    X.EPSILON15
  ) + t.y), c = s[Ae.COLUMN0ROW0] * o + s[Ae.COLUMN2ROW2] * r + i * t.x + e, l = r * Zo(
    s[Ae.COLUMN2ROW1],
    s[Ae.COLUMN1ROW2],
    X.EPSILON15
  ), h = n * (i * Zo(s[Ae.COLUMN2ROW0], s[Ae.COLUMN0ROW2]) + t.z), d, C = [];
  if (h === 0 && l === 0) {
    if (d = Nn.computeRealRoots(a, g, c), d.length === 0)
      return C;
    var p = d[0], m = Math.sqrt(Math.max(1 - p * p, 0));
    if (C.push(new B(i, n * p, n * -m)), C.push(new B(i, n * p, n * m)), d.length === 2) {
      var b = d[1], S = Math.sqrt(Math.max(1 - b * b, 0));
      C.push(new B(i, n * b, n * -S)), C.push(new B(i, n * b, n * S));
    }
    return C;
  }
  var A = h * h, u = l * l, y = a * a, I = h * l, M = y + u, G = 2 * (g * a + I), x = 2 * c * a + g * g - u + A, L = 2 * (c * g - I), E = c * c - A;
  if (M === 0 && G === 0 && x === 0 && L === 0)
    return C;
  d = pC.computeRealRoots(M, G, x, L, E);
  var T = d.length;
  if (T === 0)
    return C;
  for (var R = 0; R < T; ++R) {
    var w = d[R], v = w * w, D = Math.max(1 - v, 0), K = Math.sqrt(D), P;
    X.sign(a) === X.sign(c) ? P = Zo(
      a * v + c,
      g * w,
      X.EPSILON12
    ) : X.sign(c) === X.sign(g * w) ? P = Zo(
      a * v,
      g * w + c,
      X.EPSILON12
    ) : P = Zo(
      a * v + g * w,
      c,
      X.EPSILON12
    );
    var k = Zo(l * w, h, X.EPSILON15), V = P * k;
    V < 0 ? C.push(new B(i, n * w, n * K)) : V > 0 ? C.push(new B(i, n * w, n * -K)) : K !== 0 ? (C.push(new B(i, n * w, n * -K)), C.push(new B(i, n * w, n * K)), ++R) : C.push(new B(i, n * w, n * K));
  }
  return C;
}
var Rd = new B(), op = new B(), rp = new B(), cc = new B(), iR = new B(), nR = new qe(), sR = new qe(), oR = new qe(), rR = new qe(), aR = new qe(), ap = new qe(), gp = new qe(), cp = new B(), gR = new B(), cR = new B();
We.grazingAltitudeLocation = function(s, t) {
  if (!F(s))
    throw new re("ray is required.");
  if (!F(t))
    throw new re("ellipsoid is required.");
  var e = s.origin, i = s.direction;
  if (!_.equals(e, _.ZERO)) {
    var n = t.geodeticSurfaceNormal(e, Rd);
    if (_.dot(i, n) >= 0)
      return e;
  }
  var o = F(this.rayEllipsoid(s, t)), r = t.transformPositionToScaledSpace(i, Rd), a = _.normalize(r, r), g = _.mostOrthogonalAxis(r, cc), c = _.normalize(
    _.cross(g, a, op),
    op
  ), l = _.normalize(
    _.cross(a, c, rp),
    rp
  ), h = nR;
  h[0] = a.x, h[1] = a.y, h[2] = a.z, h[3] = c.x, h[4] = c.y, h[5] = c.z, h[6] = l.x, h[7] = l.y, h[8] = l.z;
  var d = Ae.transpose(h, sR), C = Ae.fromScale(t.radii, oR), p = Ae.fromScale(t.oneOverRadii, rR), m = aR;
  m[0] = 0, m[1] = -i.z, m[2] = i.y, m[3] = i.z, m[4] = 0, m[5] = -i.x, m[6] = -i.y, m[7] = i.x, m[8] = 0;
  var b = Ae.multiply(
    Ae.multiply(d, p, ap),
    m,
    ap
  ), S = Ae.multiply(Ae.multiply(b, C, gp), h, gp), A = Ae.multiplyByVector(b, e, iR), u = tR(
    S,
    _.negate(A, Rd),
    0,
    0,
    1
  ), y, I, M = u.length;
  if (M > 0) {
    for (var G = _.clone(_.ZERO, gR), x = Number.NEGATIVE_INFINITY, L = 0; L < M; ++L) {
      y = Ae.multiplyByVector(
        C,
        Ae.multiplyByVector(h, u[L], cp),
        cp
      );
      var E = _.normalize(
        _.subtract(y, e, cc),
        cc
      ), T = _.dot(E, i);
      T > x && (x = T, G = _.clone(y, G));
    }
    var R = t.cartesianToCartographic(
      G,
      cR
    );
    return x = X.clamp(x, 0, 1), I = _.magnitude(
      _.subtract(G, e, cc)
    ) * Math.sqrt(1 - x * x), I = o ? -I : I, R.z = I, t.cartographicToCartesian(R, new B());
  }
};
var lR = new B();
We.lineSegmentPlane = function(s, t, e, i) {
  if (!F(s))
    throw new re("endPoint0 is required.");
  if (!F(t))
    throw new re("endPoint1 is required.");
  if (!F(e))
    throw new re("plane is required.");
  F(i) || (i = new B());
  var n = _.subtract(
    t,
    s,
    lR
  ), o = e.normal, r = _.dot(o, n);
  if (!(Math.abs(r) < X.EPSILON6)) {
    var a = _.dot(o, s), g = -(e.constant + a) / r;
    if (!(g < 0 || g > 1))
      return _.multiplyByScalar(n, g, i), _.add(s, i, i), i;
  }
};
We.trianglePlaneIntersection = function(s, t, e, i) {
  if (!F(s) || !F(t) || !F(e) || !F(i))
    throw new re("p0, p1, p2, and plane are required.");
  var n = i.normal, o = i.constant, r = _.dot(n, s) + o < 0, a = _.dot(n, t) + o < 0, g = _.dot(n, e) + o < 0, c = 0;
  c += r ? 1 : 0, c += a ? 1 : 0, c += g ? 1 : 0;
  var l, h;
  if ((c === 1 || c === 2) && (l = new B(), h = new B()), c === 1) {
    if (r)
      return We.lineSegmentPlane(s, t, i, l), We.lineSegmentPlane(s, e, i, h), {
        positions: [s, t, e, l, h],
        indices: [
          0,
          3,
          4,
          1,
          2,
          4,
          1,
          4,
          3
        ]
      };
    if (a)
      return We.lineSegmentPlane(t, e, i, l), We.lineSegmentPlane(t, s, i, h), {
        positions: [s, t, e, l, h],
        indices: [
          1,
          3,
          4,
          2,
          0,
          4,
          2,
          4,
          3
        ]
      };
    if (g)
      return We.lineSegmentPlane(e, s, i, l), We.lineSegmentPlane(e, t, i, h), {
        positions: [s, t, e, l, h],
        indices: [
          2,
          3,
          4,
          0,
          1,
          4,
          0,
          4,
          3
        ]
      };
  } else if (c === 2)
    if (r)
      if (a) {
        if (!g)
          return We.lineSegmentPlane(s, e, i, l), We.lineSegmentPlane(t, e, i, h), {
            positions: [s, t, e, l, h],
            indices: [
              0,
              1,
              4,
              0,
              4,
              3,
              2,
              3,
              4
            ]
          };
      } else
        return We.lineSegmentPlane(e, t, i, l), We.lineSegmentPlane(s, t, i, h), {
          positions: [s, t, e, l, h],
          indices: [
            2,
            0,
            4,
            2,
            4,
            3,
            1,
            3,
            4
          ]
        };
    else
      return We.lineSegmentPlane(t, s, i, l), We.lineSegmentPlane(e, s, i, h), {
        positions: [s, t, e, l, h],
        indices: [
          1,
          2,
          4,
          1,
          4,
          3,
          0,
          3,
          4
        ]
      };
};
class yr {
  static getPoint(t, e, i) {
    return i || (i = new B()), i.copy(t.direction).multiplyScalar(e).add(t.origin), i;
  }
}
const Ge = {
  MORPHING: 0,
  COLUMBUS_VIEW: 1,
  SCENE2D: 2,
  SCENE3D: 3
};
Ge.getMorphTime = function(s) {
  return s === Ge.SCENE3D ? 1 : s === Ge.MORPHING ? void 0 : 0;
};
const Dt = Object.freeze(Ge), ow = {
  ROTATE: 0,
  INFINITE_SCROLL: 1
};
Object.freeze(ow);
const hR = new B(), dR = new B(), uR = new B(), IR = new B(
  1 / 6378137,
  1 / 6378137,
  1 / 6356752314245179e-9
), AR = new B(
  1 / (6378137 * 6378137),
  1 / (6378137 * 6378137),
  1 / (6356752314245179e-9 * 6356752314245179e-9)
), CR = X.EPSILON1, Mh = class {
  static fromRadians(t, e, i, n) {
    return i = he(i, 0), F(n) ? (n.x = t, n.y = e, n.z = i, n) : new B(t, e, i);
  }
  static fromDegrees(t, e, i, n) {
    return t = X.toRadians(t), e = X.toRadians(e), Mh.fromRadians(t, e, i, n);
  }
  static fromCartesian(t, e, i) {
    const n = F(e) ? e.oneOverRadii : IR, o = F(e) ? e.oneOverRadiiSquared : AR, r = F(e) ? e._centerToleranceSquared : CR, a = tw(
      t,
      n,
      o,
      r,
      dR
    );
    if (!F(a))
      return;
    let g = _.multiplyComponents(
      a,
      o,
      hR
    );
    g = _.normalize(g, g);
    const c = _.subtract(t, a, uR), l = Math.atan2(g.y, g.x), h = Math.asin(g.z), d = X.sign(_.dot(c, t)) * _.magnitude(c);
    return F(i) ? (i.x = l, i.y = h, i.z = d, i) : new B(l, h, d);
  }
  static toCartesian(t, e, i) {
    return _.fromRadians(
      t.x,
      t.y,
      t.z,
      e,
      i
    );
  }
  static clone(t, e) {
    if (!!F(t))
      return F(e) ? (e.x = t.x, e.y = t.y, e.z = t.z, e) : new B(
        t.x,
        t.y,
        t.z
      );
  }
  static equals(t, e) {
    return t === e || F(t) && F(e) && t.x === e.x && t.y === e.y && t.z === e.z;
  }
  static equalsEpsilon(t, e, i) {
    return i = he(i, 0), t === e || F(t) && F(e) && X.equalsEpsilon(t.x, e.x, i) && X.equalsEpsilon(t.y, e.y, i) && X.equalsEpsilon(t.z, e.z, i);
  }
};
let qi = Mh;
f(qi, "fromRadians", function(t, e, i, n) {
  return i = he(i, 0), F(n) ? (n.x = t, n.y = e, n.z = i, n) : new B(t, e, i);
}), f(qi, "fromDegrees", function(t, e, i, n) {
  return t = X.toRadians(t), e = X.toRadians(e), Mh.fromRadians(t, e, i, n);
}), f(qi, "ZERO", Object.freeze(new B(0, 0, 0)));
function fR(s) {
  const t = s._uSquared, e = s._ellipsoid.maximumRadius, i = s._ellipsoid.minimumRadius, n = (e - i) / e, o = Math.cos(s._startHeading), r = Math.sin(s._startHeading), a = (1 - n) * Math.tan(s._start.y), g = 1 / Math.sqrt(1 + a * a), c = g * a, l = Math.atan2(a, o), h = g * r, d = h * h, C = 1 - d, p = Math.sqrt(C), m = t / 4, b = m * m, S = b * m, A = b * b, u = 1 + m - 3 * b / 4 + 5 * S / 4 - 175 * A / 64, y = 1 - m + 15 * b / 8 - 35 * S / 8, I = 1 - 3 * m + 35 * b / 4, M = 1 - 5 * m, G = u * l - y * Math.sin(2 * l) * m / 2 - I * Math.sin(4 * l) * b / 16 - M * Math.sin(6 * l) * S / 48 - Math.sin(8 * l) * 5 * A / 512, x = s._constants;
  x.a = e, x.b = i, x.f = n, x.cosineHeading = o, x.sineHeading = r, x.tanU = a, x.cosineU = g, x.sineU = c, x.sigma = l, x.sineAlpha = h, x.sineSquaredAlpha = d, x.cosineSquaredAlpha = C, x.cosineAlpha = p, x.u2Over4 = m, x.u4Over16 = b, x.u6Over64 = S, x.u8Over256 = A, x.a0 = u, x.a1 = y, x.a2 = I, x.a3 = M, x.distanceRatio = G;
}
function pR(s, t) {
  return s * t * (4 + s * (4 - 3 * t)) / 16;
}
function rw(s, t, e, i, n, o, r) {
  const a = pR(s, e);
  return (1 - a) * s * t * (i + a * n * (r + a * o * (2 * r * r - 1)));
}
function mR(s, t, e, i, n, o, r) {
  const a = (t - e) / t, g = o - i, c = Math.atan((1 - a) * Math.tan(n)), l = Math.atan((1 - a) * Math.tan(r)), h = Math.cos(c), d = Math.sin(c), C = Math.cos(l), p = Math.sin(l), m = h * C, b = h * p, S = d * p, A = d * C;
  let u = g, y = X.TWO_PI, I = Math.cos(u), M = Math.sin(u), G, x, L, E, T;
  do {
    I = Math.cos(u), M = Math.sin(u);
    const N = b - A * I;
    L = Math.sqrt(
      C * C * M * M + N * N
    ), x = S + m * I, G = Math.atan2(L, x);
    let z;
    L === 0 ? (z = 0, E = 1) : (z = m * M / L, E = 1 - z * z), y = u, T = x - 2 * S / E, isFinite(T) || (T = 0), u = g + rw(
      a,
      z,
      E,
      G,
      L,
      x,
      T
    );
  } while (Math.abs(u - y) > X.EPSILON12);
  const R = E * (t * t - e * e) / (e * e), w = 1 + R * (4096 + R * (R * (320 - 175 * R) - 768)) / 16384, v = R * (256 + R * (R * (74 - 47 * R) - 128)) / 1024, D = T * T, K = v * L * (T + v * (x * (2 * D - 1) - v * T * (4 * L * L - 3) * (4 * D - 3) / 6) / 4), P = e * w * (G - K), k = Math.atan2(
    C * M,
    b - A * I
  ), V = Math.atan2(h * M, b * I - A);
  s._distance = P, s._startHeading = k, s._endHeading = V, s._uSquared = R;
}
const yR = new B(), Dd = new B();
function aw(s, t, e, i) {
  _.normalize(
    i.cartographicToCartesian(t, Dd),
    yR
  ), _.normalize(
    i.cartographicToCartesian(e, Dd),
    Dd
  ), mR(
    s,
    i.maximumRadius,
    i.minimumRadius,
    t.x,
    t.y,
    e.x,
    e.y
  ), s._start = qi.clone(
    t,
    s._start
  ), s._end = qi.clone(e, s._end), s._start.z = 0, s._end.z = 0, fR(s);
}
function Lr(s, t, e) {
  const i = he(e, De.WGS84);
  this._ellipsoid = i, this._start = new B(), this._end = new B(), this._constants = {}, this._startHeading = void 0, this._endHeading = void 0, this._distance = void 0, this._uSquared = void 0, F(s) && F(t) && aw(this, s, t, i);
}
Object.defineProperties(Lr.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  surfaceDistance: {
    get: function() {
      return this._distance;
    }
  },
  start: {
    get: function() {
      return this._start;
    }
  },
  end: {
    get: function() {
      return this._end;
    }
  },
  startHeading: {
    get: function() {
      return this._startHeading;
    }
  },
  endHeading: {
    get: function() {
      return this._endHeading;
    }
  }
});
Lr.prototype.setEndPoints = function(s, t) {
  aw(this, s, t, this._ellipsoid);
};
Lr.prototype.interpolateUsingFraction = function(s, t) {
  return this.interpolateUsingSurfaceDistance(
    this._distance * s,
    t
  );
};
Lr.prototype.interpolateUsingSurfaceDistance = function(s, t) {
  const e = this._constants, i = e.distanceRatio + s / e.b, n = Math.cos(2 * i), o = Math.cos(4 * i), r = Math.cos(6 * i), a = Math.sin(2 * i), g = Math.sin(4 * i), c = Math.sin(6 * i), l = Math.sin(8 * i), h = i * i, d = i * h, C = e.u8Over256, p = e.u2Over4, m = e.u6Over64, b = e.u4Over16;
  let S = 2 * d * C * n / 3 + i * (1 - p + 7 * b / 4 - 15 * m / 4 + 579 * C / 64 - (b - 15 * m / 4 + 187 * C / 16) * n - (5 * m / 4 - 115 * C / 16) * o - 29 * C * r / 16) + (p / 2 - b + 71 * m / 32 - 85 * C / 16) * a + (5 * b / 16 - 5 * m / 4 + 383 * C / 96) * g - h * ((m - 11 * C / 2) * a + 5 * C * g / 2) + (29 * m / 96 - 29 * C / 16) * c + 539 * C * l / 1536;
  const A = Math.asin(Math.sin(S) * e.cosineAlpha), u = Math.atan(e.a / e.b * Math.tan(A));
  S = S - e.sigma;
  const y = Math.cos(2 * e.sigma + S), I = Math.sin(S), M = Math.cos(S), G = e.cosineU * M, x = e.sineU * I, E = Math.atan2(
    I * e.sineHeading,
    G - x * e.cosineHeading
  ) - rw(
    e.f,
    e.sineAlpha,
    e.cosineSquaredAlpha,
    S,
    I,
    M,
    y
  );
  return F(t) ? (t.x = this._start.x + E, t.y = u, t.z = 0, t) : new B(this._start.x + E, u, 0);
};
const ch = {
  LINEAR: (s) => s,
  QUINTIC_IN_OUT: (s) => (s *= 2) < 1 ? 0.5 * s * s * s * s * s : 0.5 * ((s -= 2) * s * s * s * s + 2),
  CUBIC_OUT: (s) => --s * s * s + 1
}, SR = new B();
new B();
const lp = new B();
new B();
new Nh();
const Ar = {};
function bR(s, t, e) {
  let i, n, o;
  const r = Math.tan(0.5 * X.toRadians(s.fov));
  return i = s.near, n = s.near * r, o = s.aspect * n, Math.max(t * i / o, e * i / n);
}
function lh(s, t) {
  return X.equalsEpsilon(
    s,
    X.TWO_PI,
    X.EPSILON11
  ) && (s = 0), t > s + Math.PI ? s += X.TWO_PI : t < s - Math.PI && (s -= X.TWO_PI), s;
}
const BR = new B(), wR = new B();
function mC(s, t, e, i, n, o) {
  let r = n;
  const a = Math.max(e, i);
  if (!r)
    if (o) {
      const g = s.position, c = t, l = s.up, h = s.right, d = s.frustum, C = lp.subVectors(c, g), p = BR.copy(l).multiplyScalar(l.dot(C)).length(), m = wR.copy(h).multiplyScalar(h.dot(C)).length();
      r = Math.min(
        bR(d, p, m) * 0.2,
        1e9
      );
    } else {
      const g = s.position, c = t, l = lp.subVectors(c, g);
      r = Math.hypot(l.x, l.y) * 0.2;
    }
  if (a < r) {
    const l = -Math.pow((r - e) * 1e6, 0.125), h = Math.pow((r - i) * 1e6, 1 / 8);
    return function(d) {
      const C = d * (h - l) + l;
      return -Math.pow(C, 8) / 1e6 + r;
    };
  }
  return function(g) {
    return (1 - g) * e + g * i;
  };
}
function gw(s, t, e, i) {
  const n = e(0.5);
  if (F(i) && e(0.5) > i) {
    const o = e(0), r = e(1), a = n - o, g = n - r;
    return function(c) {
      const l = e(c);
      if (c < 0.5) {
        const d = (l - o) / a;
        return (1 - d) * s + d * -X.PI_OVER_TWO;
      }
      const h = (l - r) / g;
      return (1 - h) * -X.PI_OVER_TWO + h * t;
    };
  }
  return function(o) {
    return (1 - o) * s + o * t;
  };
}
function _R(s, t) {
  const e = s.x - t.x;
  e < -X.PI ? s.x += X.TWO_PI : e > X.PI && (t.x += X.TWO_PI);
}
const cw = new B();
function lw(s, t, e, i, n, o, r, a, g, c) {
  const l = s._ellipsoidCamera, h = cw.copy(l.position), d = lh(l.heading, i), C = l.frustum.right - l.frustum.left, p = mC(
    l,
    e,
    C,
    e.z,
    r
  );
  function m(b) {
    const S = b.time / t;
    l.setView({
      orientation: {
        heading: X.lerp(d, i, S)
      }
    }), oe.lerp(h, e, S, l.position);
    const A = p(S), u = l.frustum, y = u.top / u.right, I = (A - (u.right - u.left)) / 2;
    u.right += I, u.left -= I, u.top = u.right * y, u.bottom = -u.top;
  }
  return m;
}
function hw(s, t, e, i, n, o, r, a, g, c) {
  const l = s._ellipsoidCamera, d = s.mapProjection.ellipsoid, C = SR.copy(l.positionCartographic), p = l.pitch, m = lh(l.heading, i), b = lh(l.roll, o), S = d.cartesianToCartographic(e);
  C.x = X.zeroToTwoPi(C.x), S.x = X.zeroToTwoPi(S.x), _R(C, S);
  const A = mC(
    l,
    e,
    C.z,
    S.z,
    r,
    !0
  ), u = gw(
    p,
    n,
    A,
    c
  );
  function y() {
    const I = C.x, M = S.x, G = C.y, x = S.y;
    return function(E) {
      const T = E.easingFunction;
      let R = E.time / t;
      T && (R = T(R));
      const w = _.fromRadians(
        ce.lerp(I, M, R),
        ce.lerp(G, x, R),
        A(R),
        d
      );
      l.setView({
        destination: w,
        orientation: {
          heading: ce.lerp(m, i, R),
          pitch: u(R),
          roll: ce.lerp(b, o, R)
        }
      });
    };
  }
  return y();
}
function sA(s, t, e, i, n, o, r, a, g, c) {
  const l = s._engine, h = l.camera, d = cw.copy(h.position), C = ce.degToRad(s.getPitch()), p = lh(ce.degToRad(s.getHeading()), i), m = mC(
    h,
    e,
    d.z,
    e.z,
    r,
    !1
  ), b = gw(
    C,
    n,
    m,
    c
  );
  function S() {
    const A = d.x, u = e.x, y = d.y, I = e.y;
    function M(G) {
      const x = G.easingFunction;
      let L = G.time / t;
      x && (L = x(L));
      const E = new B(
        ce.lerp(A, u, L),
        ce.lerp(y, I, L),
        m(L)
      );
      s.lookAt(l.map.unprojectArrayCoordinate(E.toArray()), {
        heading: ce.radToDeg(ce.lerp(p, i, L)),
        pitch: ce.radToDeg(b(L))
      });
    }
    return M;
  }
  return S();
}
function hp(s) {
  function t() {
    typeof s == "function" && s();
  }
  return t;
}
function dp(s, t) {
  function e() {
    typeof t == "function" && t(), s.enableInputs = !0;
  }
  return e;
}
function hh(s, t) {
  return {
    startObject: {},
    stopObject: {},
    duration: 0,
    complete: s,
    cancel: t
  };
}
Ar.createTweenColumbus = function(s, t) {
  t = t || he.EMPTY_OBJECT;
  let e = t.destination;
  const i = s.mode;
  if (i === Dt.MORPHING)
    return hh();
  const n = t.maximumHeight, o = t.flyOverLongitude, r = t.flyOverLongitudeWeight, a = t.pitchAdjustHeight;
  let g = t.easingFunction;
  const c = s._engine.camera;
  let l = t.duration;
  l || (l = Math.ceil(_.distance(c.position, e) / 1e6) + 2, l = Math.min(l, 3) * 1e3);
  const h = he(t.heading, 0), d = he(t.pitch, 0), C = hp(t.complete), p = hp(t.cancel);
  let m = _.equalsEpsilon(
    e,
    c.position,
    X.EPSILON10
  );
  const b = ce.degToRad(s.getHeading()), S = ce.degToRad(s.getPitch());
  if (m = m && X.equalsEpsilon(
    X.negativePiToPi(h),
    X.negativePiToPi(b),
    X.EPSILON10
  ) && X.equalsEpsilon(
    X.negativePiToPi(d),
    X.negativePiToPi(S),
    X.EPSILON10
  ), m)
    return hh(C, p);
  const A = new Array(4);
  A[Dt.SCENE2D] = lw, A[Dt.SCENE3D] = hw, A[Dt.COLUMBUS_VIEW] = sA;
  const u = sA(
    s,
    l,
    e,
    h,
    d,
    0,
    n,
    o,
    r,
    a
  );
  if (!F(g)) {
    const y = c.position.z, I = i === e.z;
    y > I && y > 11500 ? g = ch.CUBIC_OUT : g = ch.QUINTIC_IN_OUT;
  }
  return {
    duration: l,
    easingFunction: g,
    startObject: {
      time: 0
    },
    stopObject: {
      time: l
    },
    update: u,
    complete: C,
    cancel: p
  };
};
Ar.createTween = function(s, t) {
  return s.mode === Dt.SCENE3D ? Ar.createTween3D(s, t) : Ar.createTweenColumbus(s, t);
};
Ar.createTween3D = function(s, t) {
  t = t || he.EMPTY_OBJECT;
  let e = t.destination;
  const i = s.mode;
  if (i === Dt.MORPHING)
    return hh();
  he(t.convert, !0);
  const o = s.mapProjection.ellipsoid, r = t.maximumHeight, a = t.flyOverLongitude, g = t.flyOverLongitudeWeight, c = t.pitchAdjustHeight;
  let l = t.easingFunction;
  const h = s.camera, d = s._ellipsoidCamera;
  let C = t.duration;
  C || (C = Math.ceil(_.distance(h.position, e) / 1e6) + 2, C = Math.min(C, 3) * 1e3);
  const p = he(t.heading, 0), m = he(t.pitch, -X.PI_OVER_TWO), b = he(t.roll, 0), S = s._controller;
  S.enableInputs = !1;
  const A = dp(S, t.complete), u = dp(S, t.cancel);
  d.frustum;
  let y = i === Dt.SCENE2D;
  if (y = y && oe.equalsEpsilon(h.position, e, X.EPSILON6), y = y || i !== Dt.SCENE2D && _.equalsEpsilon(
    e,
    h.position,
    X.EPSILON10
  ), y = y && X.equalsEpsilon(
    X.negativePiToPi(p),
    X.negativePiToPi(d.heading),
    X.EPSILON10
  ) && X.equalsEpsilon(
    X.negativePiToPi(m),
    X.negativePiToPi(d.pitch),
    X.EPSILON10
  ) && X.equalsEpsilon(
    X.negativePiToPi(b),
    X.negativePiToPi(d.roll),
    X.EPSILON10
  ), y)
    return hh(A, u);
  const I = new Array(4);
  I[Dt.SCENE2D] = lw, I[Dt.SCENE3D] = hw, I[Dt.COLUMBUS_VIEW] = sA;
  const M = I[s.mode](
    s,
    C,
    e,
    p,
    m,
    b,
    r,
    a,
    g,
    c
  );
  if (!F(l)) {
    const G = d.positionCartographic.z, x = i === Dt.SCENE3D ? o.cartesianToCartographic(e).z : e.z;
    G > x && G > 11500 ? l = ch.CUBIC_OUT : l = ch.QUINTIC_IN_OUT;
  }
  return {
    duration: C,
    easingFunction: l,
    startObject: {
      time: 0
    },
    stopObject: {
      time: C
    },
    update: M,
    complete: A,
    cancel: u
  };
};
function Kd() {
}
function xR(s, t, e, i, n) {
  const o = n.elements;
  return o[0] = i.x, o[1] = e.x, o[2] = -t.x, o[3] = 0, o[4] = i.y, o[5] = e.y, o[6] = -t.y, o[7] = 0, o[8] = i.z, o[9] = e.z, o[10] = -t.z, o[11] = 0, o[12] = -i.dot(s), o[13] = -e.dot(s), o[14] = t.dot(s), o[15] = 1, n;
}
function dw(s) {
  xR(
    s._position,
    s._direction,
    s._up,
    s._right,
    s._viewMatrix
  ), s._viewMatrix.multiplyMatrices(s._viewMatrix, s._actualInvTransform), s._invViewMatrix.copy(s._viewMatrix).invert();
}
const up = new B();
function an(s) {
  let e = s._position;
  const i = !_.equals(e, s.position) || !1;
  i && (e = _.clone(s.position, s._position));
  let n = s._direction;
  const o = !_.equals(n, s.direction);
  o && (s.direction.normalize(), n = _.clone(s.direction, s._direction));
  let r = s._up;
  const a = !_.equals(r, s.up);
  a && (_.normalize(s.up, s.up), r = _.clone(s.up, s._up));
  let g = s._right;
  const c = !_.equals(g, s.right);
  c && (_.normalize(s.right, s.right), g = _.clone(s.right, s._right));
  const l = s._transformChanged;
  s._transformChanged = !1, l && (_e.inverseTransformation(s._transform, s._invTransform), _e.clone(s._transform, s._actualTransform), _e.inverseTransformation(
    s._actualTransform,
    s._actualInvTransform
  ));
  const h = s._actualTransform;
  if ((i || l) && (s._positionWC = _e.multiplyByPoint(
    h,
    e,
    s._positionWC
  ), s._positionCartographic = s._ellipsoid.cartesianToCartographic(
    s._positionWC,
    s._positionCartographic
  )), o || a || c) {
    const d = _.dot(
      n,
      _.cross(r, g, up)
    );
    if (Math.abs(1 - d) > 0.02) {
      const C = 1 / _.magnitudeSquared(r), p = _.dot(r, n) * C, m = _.multiplyByScalar(n, p, up);
      r = _.normalize(
        _.subtract(r, m, s._up),
        s._up
      ), _.clone(r, s.up), g = _.cross(n, r, s._right), _.clone(g, s.right);
    }
  }
  (o || l) && (s._directionWC = _e.multiplyByPointAsVector(
    h,
    n,
    s._directionWC
  ), _.normalize(s._directionWC, s._directionWC)), (a || l) && (s._upWC = _e.multiplyByPointAsVector(h, r, s._upWC), _.normalize(s._upWC, s._upWC)), (c || l) && (s._rightWC = _e.multiplyByPointAsVector(
    h,
    g,
    s._rightWC
  ), _.normalize(s._rightWC, s._rightWC)), (i || o || a || c || l) && dw(s);
}
function uw(s, t) {
  let e;
  return X.equalsEpsilon(Math.abs(s.z), 1, X.EPSILON3) ? e = Math.atan2(t.y, t.x) - X.PI_OVER_TWO : e = Math.atan2(s.y, s.x) - X.PI_OVER_TWO, X.TWO_PI - X.zeroToTwoPi(e);
}
function Iw(s) {
  return X.PI_OVER_TWO - X.acosClamped(s.z);
}
function Aw(s, t, e) {
  let i = 0;
  return X.equalsEpsilon(Math.abs(s.z), 1, X.EPSILON3) || (i = Math.atan2(-e.z, t.z), i = X.zeroToTwoPi(i + X.TWO_PI)), i;
}
const fg = new J(), pg = new J(), vR = new B(), TR = new B(), LR = new B(), dh = new B(), yC = new J(), GR = new J(), SC = new Ye(), bC = new qe(), Cw = new B();
function MR(s, t, e) {
  const i = _e.clone(
    s.transform,
    yC
  ), n = Ze.eastNorthUpToFixedFrame(
    t,
    s._ellipsoid,
    GR
  );
  s._setTransform(n), _.clone(_.ZERO, s.position), e.heading = e.heading - X.PI_OVER_TWO;
  const o = wi.fromHeadingPitchRoll(e, SC), r = Ae.fromQuaternion(o, bC);
  Ae.getColumn(r, 0, s.direction), Ae.getColumn(r, 2, s.up), _.cross(s.direction, s.up, s.right), s._setTransform(i);
}
function ER(s, t, e, i) {
  const n = _e.clone(
    s.transform,
    yC
  );
  if (s._setTransform(_e.IDENTITY), !_.equals(t, s.positionWC)) {
    if (i) {
      const a = s._projection, g = a.ellipsoid.cartesianToCartographic(
        t,
        Cw
      );
      t = a.project(g, dh);
    }
    _.clone(t, s.position);
  }
  e.heading = e.heading - X.PI_OVER_TWO;
  const o = Ye.fromHeadingPitchRoll(
    e,
    SC
  ), r = Ae.fromQuaternion(o, bC);
  Ae.getColumn(r, 0, s.direction), Ae.getColumn(r, 2, s.up), _.cross(s.direction, s.up, s.right), s._setTransform(n);
}
function RR(s, t, e, i) {
  const n = _e.clone(
    s.transform,
    yC
  );
  if (s._setTransform(_e.IDENTITY), !_.equals(t, s.positionWC)) {
    if (i) {
      const g = s._projection, c = g.ellipsoid.cartesianToCartographic(
        t,
        Cw
      );
      t = g.project(c, dh);
    }
    oe.clone(t, s.position);
    const o = -t.z * 0.5, r = -o, a = s.frustum;
    if (r > o) {
      const g = a.top / a.right;
      a.right = r, a.left = o, a.top = a.right * g, a.bottom = -a.top;
    }
  }
  if (s._scene.mapMode2D === ow.ROTATE) {
    e.heading = e.heading - X.PI_OVER_TWO, e.pitch = -X.PI_OVER_TWO, e.roll = 0;
    const o = Ye.fromHeadingPitchRoll(
      e,
      SC
    ), r = Ae.fromQuaternion(o, bC);
    Ae.getColumn(r, 2, s.up), _.cross(s.direction, s.up, s.right);
  }
  s._setTransform(n);
}
const DR = new J(), KR = new J(), HR = new B(), PR = new Ye(), NR = new Ye(), FR = new qe();
function kR(s, t, e) {
  t = X.clamp(
    t,
    -X.PI_OVER_TWO,
    X.PI_OVER_TWO
  ), s = X.zeroToTwoPi(s) - X.PI_OVER_TWO;
  const i = wi.fromAxisAngle(
    _.UNIT_Y,
    -t,
    PR
  ), n = wi.fromAxisAngle(
    _.UNIT_Z,
    -s,
    NR
  ), o = wi.multiply(n, i, n), r = Ae.fromQuaternion(
    o,
    FR
  ), a = _.clone(
    _.UNIT_X,
    HR
  );
  return Ae.multiplyByVector(r, a, a), _.negate(a, a), _.multiplyByScalar(a, e, a), a;
}
const VR = new B(), zR = new B(), XR = new B();
function Ip(s, t, e, i) {
  const n = _.clone(
    e.direction,
    VR
  ), o = _.clone(e.up, zR), r = s._ellipsoid, a = Ze.eastNorthUpToFixedFrame(
    t,
    r,
    fg
  ), g = _e.inverseTransformation(
    a,
    pg
  );
  _e.multiplyByPointAsVector(g, n, n), _e.multiplyByPointAsVector(g, o, o);
  const c = _.cross(n, o, XR);
  return i.heading = uw(n, o), i.pitch = Iw(n), i.roll = Aw(n, o, c), i;
}
const WR = new B(), Yt = {
  destination: void 0,
  heading: void 0,
  pitch: void 0,
  roll: void 0,
  duration: void 0,
  complete: void 0,
  cancel: void 0,
  endTransform: void 0,
  maximumHeight: void 0,
  easingFunction: void 0
}, Hd = {
  destination: void 0,
  orientation: {
    direction: void 0,
    up: void 0,
    heading: void 0,
    pitch: void 0,
    roll: void 0
  },
  convert: void 0,
  endTransform: void 0
}, Kr = {}, Ap = new B();
var ZR = new B(), UR = new B(), OR = new B();
function QR(s, t, e) {
  var i = s._scene.canvas, n = i.clientWidth, o = i.clientHeight, r = Math.tan(ce.degToRad(s._camera.fov) * 0.5), a = s._camera.aspect * r, g = s._camera.near, c = 2 / n * t.x - 1, l = 2 / o * (o - t.y) - 1, h = s.positionWC;
  _.clone(h, e.origin);
  var d = _.multiplyByScalar(
    s.directionWC,
    g,
    ZR
  );
  _.add(h, d, d);
  var C = _.multiplyByScalar(
    s.rightWC,
    c * g * a,
    UR
  ), p = _.multiplyByScalar(
    s.upWC,
    l * g * r,
    OR
  ), m = _.add(d, C, e.direction);
  return _.add(m, p, m), _.subtract(m, h, m), _.normalize(m, m), e;
}
function YR(s, t) {
  s.move(s.direction, t);
}
var jR = new yt();
function JR(s, t, e, i) {
  e = he(e, De.WGS84);
  var n = s.getPickRay(t, jR), o = We.rayEllipsoid(n, e);
  if (!!o) {
    var r = o.start > 0 ? o.start : o.stop;
    return yr.getPoint(n, r, i);
  }
}
var Cp = new Ye(), fp = new qe(), qR = new Ye(), $R = new qe(), eD = new B(), tD = new B(), iD = new B(), pp = new B();
function mp(s, t) {
  var e = s.position;
  if (F(s.constrainedAxis) && !_.equalsEpsilon(
    s.position,
    _.ZERO,
    X.EPSILON2
  )) {
    var i = _.normalize(e, eD), n = _.equalsEpsilon(
      i,
      s.constrainedAxis,
      X.EPSILON2
    ), o = _.equalsEpsilon(
      i,
      _.negate(s.constrainedAxis, pp),
      X.EPSILON2
    );
    if (!n && !o) {
      var r = _.normalize(
        s.constrainedAxis,
        tD
      ), a = _.dot(i, r), g = X.acosClamped(a);
      t > 0 && t > g && (t = g - X.EPSILON4), a = _.dot(
        i,
        _.negate(r, pp)
      ), g = X.acosClamped(a), t < 0 && -t > g && (t = -g + X.EPSILON4);
      var c = _.cross(r, i, iD);
      s.rotate(c, t);
    } else
      (n && t < 0 || o && t > 0) && s.rotate(s.right, t);
  } else
    s.rotate(s.right, t);
}
function yp(s, t) {
  F(s.constrainedAxis) ? s.rotate(s.constrainedAxis, t) : s.rotate(s.up, t);
}
const Bo = class {
  constructor(t) {
    f(this, "_setTransform", (t) => {
      const e = _.clone(this.positionWC, vR), i = _.clone(this.upWC, TR), n = _.clone(this.directionWC, LR);
      _e.clone(t, this._transform), this._transformChanged = !0, an(this);
      const o = this._actualInvTransform;
      _e.multiplyByPoint(o, e, this.position), _e.multiplyByPointAsVector(o, n, this.direction), _e.multiplyByPointAsVector(o, i, this.up), _.cross(this.direction, this.up, this.right), an(this);
    });
    this._scene = t, this._camera = t.camera, this._ellipsoid = t._ellipsoid, this._transform = new J(), this._invTransform = new J(), this._actualTransform = new J(), this._actualInvTransform = new J(), this._transformChanged = !1, this.position = new B(), this._position = new B(), this._positionWC = new B(), this._positionCartographic = new B(), this._oldPositionWC = void 0, this.positionWCDeltaMagnitude = 0, this.positionWCDeltaMagnitudeLastFrame = 0, this.timeSinceMoved = 0, this._lastMovedTimestamp = 0, this.direction = new B(), this._direction = new B(), this._directionWC = new B(), this.up = new B(), this._up = new B(), this._upWC = new B(), this.right = new B(), this._right = new B(), this._rightWC = new B(), this.defaultMoveAmount = 1e5, this.defaultLookAmount = Math.PI / 60, this.defaultRotateAmount = Math.PI / 3600, this.defaultZoomAmount = 1e5, this.constrainedAxis = void 0, this.maximumZoomFactor = 1.5, this._moveStart = new Kd(), this._moveEnd = new Kd(), this._changed = new Kd(), this._changedPosition = void 0, this._changedDirection = void 0, this._changedFrustum = void 0, this.percentageChanged = 0.5, this._viewMatrix = new J(), this._invViewMatrix = new J(), dw(this), this._mode = Ge.SCENE3D, this._modeChanged = !0;
    const e = t.mapProjection;
    this._projection = e, this._maxCoord = e.project(
      new B(Math.PI, X.PI_OVER_TWO, 0)
    ), this._max2Dfrustum = void 0, bp(
      this,
      Bo.DEFAULT_VIEW_RECTANGLE,
      this.position,
      !0
    );
    let i = _.magnitude(this.position);
    i += i * Bo.DEFAULT_VIEW_FACTOR, _.normalize(this.position, this.position), _.multiplyByScalar(this.position, i, this.position);
  }
  canPreloadFlight() {
    return F(this._currentFlight);
  }
  setView(t) {
    t = he(t, {});
    let e = he(
      t.orientation,
      he.EMPTY_OBJECT
    );
    const i = this._mode;
    if (i === Ge.MORPHING)
      return;
    F(t.endTransform) && this._setTransform(t.endTransform);
    let n = he(t.convert, !0), o = he(
      t.destination,
      _.clone(this.positionWC, dh)
    );
    F(o) && F(o.west) && (o = this.getRectangleCameraCoordinates(
      o,
      dh
    ), n = !1), F(e.direction) && (e = Ip(
      this,
      o,
      e,
      Hd.orientation
    )), Kr.heading = he(e.heading, 0), Kr.pitch = he(e.pitch, -X.PI_OVER_TWO), Kr.roll = he(e.roll, 0), i === Ge.SCENE3D ? MR(this, o, Kr) : i === Ge.SCENE2D ? RR(this, o, Kr, n) : ER(this, o, Kr, n);
  }
  lookAt(t, e) {
    if (!F(t))
      throw new re("target is required");
    if (!F(e))
      throw new re("offset is required");
    if (this._mode === Ge.MORPHING)
      throw new re("lookAt is not supported while morphing.");
    e = he(e, he.EMPTY_OBJECT), e.heading = he(e.heading, 0), e.pitch = he(e.pitch, -X.PI_OVER_TWO), e.range = e.range || 0.01;
    const i = _e.clone(
      this.transform,
      DR
    );
    var n = Ze.eastNorthUpToFixedFrame(
      t,
      De.WGS84,
      KR
    );
    this.lookAtTransform(n, e), this._mode === Ge.SCENE3D && this._setTransform(i);
  }
  lookAtTransform(t, e) {
    if (!F(t))
      throw new re("transform is required");
    if (this._mode === Ge.MORPHING)
      throw new re(
        "lookAtTransform is not supported while morphing."
      );
    if (this._setTransform(t), !F(e))
      return;
    let i;
    if (F(e.heading) ? i = kR(
      e.heading,
      e.pitch,
      e.range
    ) : i = e, this._mode === Ge.SCENE2D) {
      oe.clone(oe.ZERO, this.position), _.negate(i, this.up), this.up.z = 0, _.magnitudeSquared(this.up) < X.EPSILON10 && _.clone(_.UNIT_Y, this.up), _.normalize(this.up, this.up), this._setTransform(_e.IDENTITY), _.negate(_.UNIT_Z, this.direction), _.cross(this.direction, this.up, this.right), _.normalize(this.right, this.right);
      const n = this.frustum, o = n.top / n.right;
      n.right = _.magnitude(i) * 0.5, n.left = -n.right, n.top = o * n.right, n.bottom = -n.top, this._setTransform(t);
      return;
    }
    _.clone(i, this.position), _.negate(this.position, this.direction), _.normalize(this.direction, this.direction), _.cross(this.direction, _.UNIT_Z, this.right), _.magnitudeSquared(this.right) < X.EPSILON10 && _.clone(_.UNIT_X, this.right), _.normalize(this.right, this.right), _.cross(this.right, this.direction, this.up), _.normalize(this.up, this.up);
  }
  move(t, e) {
    const i = this.position;
    _.multiplyByScalar(t, e, Ap), _.add(i, Ap, i);
  }
  moveForward(t) {
    t = he(t, this.defaultMoveAmount), this.move(this.direction, t);
  }
  moveBackward(t) {
    t = he(t, this.defaultMoveAmount), this.move(this.direction, -t);
  }
  moveUp(t) {
    t = he(t, this.defaultMoveAmount), this.move(this.up, t);
  }
  moveDown(t) {
    t = he(t, this.defaultMoveAmount), this.move(this.up, -t);
  }
  moveRight(t) {
    t = he(t, this.defaultMoveAmount), this.move(this.right, t);
  }
  moveLeft(t) {
    t = he(t, this.defaultMoveAmount), this.move(this.right, -t);
  }
  rotateAroundPoint(t, e, i) {
    const n = new B();
    _.subtract(this.position, t, n);
    const o = he(i, this.defaultRotateAmount), r = wi.fromAxisAngle(e, -o, Cp), a = Ae.fromQuaternion(r, fp);
    Ae.multiplyByVector(a, n, n), Ae.multiplyByVector(a, this.direction, this.direction), Ae.multiplyByVector(a, this.up, this.up), Ae.multiplyByVector(a, this.right, this.right), _.add(n, t, this.position);
  }
  zoomIn(t) {
    t = he(t, this.defaultZoomAmount), YR(this, t);
  }
  rotate(t, e) {
    var i = he(e, this.defaultRotateAmount), n = wi.fromAxisAngle(
      t,
      -i,
      Cp
    ), o = Ae.fromQuaternion(n, fp);
    Ae.multiplyByVector(o, this.position, this.position), Ae.multiplyByVector(o, this.direction, this.direction), Ae.multiplyByVector(o, this.up, this.up), _.cross(this.direction, this.up, this.right), _.cross(this.right, this.direction, this.up);
  }
  rotateDown(t) {
    t = he(t, this.defaultRotateAmount), mp(this, t);
  }
  rotateUp(t) {
    t = he(t, this.defaultRotateAmount), mp(this, -t);
  }
  rotateRight(t) {
    t = he(t, this.defaultRotateAmount), yp(this, -t);
  }
  rotateLeft(t) {
    t = he(t, this.defaultRotateAmount), yp(this, t);
  }
  look(t, e) {
    var i = he(e, this.defaultLookAmount), n = wi.fromAxisAngle(
      t,
      -i,
      qR
    ), o = Ae.fromQuaternion(n, $R), r = this.direction, a = this.up, g = this.right;
    Ae.multiplyByVector(o, r, r), Ae.multiplyByVector(o, a, a), Ae.multiplyByVector(o, g, g);
  }
  lookLeft(t) {
    t = he(t, this.defaultLookAmount), this._mode !== Ge.SCENE2D && this.look(this.up, -t);
  }
  lookRight(t) {
    t = he(t, this.defaultLookAmount), this._mode !== Ge.SCENE2D && this.look(this.up, t);
  }
  lookUp(t) {
    t = he(t, this.defaultLookAmount), this._mode !== Ge.SCENE2D && this.look(this.right, -t);
  }
  lookDown(t) {
    t = he(t, this.defaultLookAmount), this._mode !== Ge.SCENE2D && this.look(this.right, t);
  }
  getPickRay(t, e) {
    if (!F(t))
      throw new re("windowPosition is required.");
    return F(e) || (e = new yt()), QR(this, t, e);
  }
  pickEllipsoid(t, e, i) {
    return F(i) || (i = new B()), e = he(e, De.WGS84), i = JR(this, t, e, i), i;
  }
  worldToCameraCoordinates(t, e) {
    return F(e) || (e = new Me(0, 0, 0, 0)), an(this), _e.multiplyByVector(this._actualInvTransform, t, e);
  }
  worldToCameraCoordinatesPoint(t, e) {
    if (!F(t))
      throw new re("cartesian is required.");
    return F(e) || (e = new B()), an(this), _e.multiplyByPoint(this._actualInvTransform, t, e);
  }
  cancelFlight() {
    if (F(this._currentFlight)) {
      const t = this._currentFlight.listener;
      this._scene._engine.removePrepareRenderListener(t), this._currentFlight = void 0;
    }
  }
  completeFlight() {
    if (F(this._currentFlight)) {
      const t = this._currentFlight.listener;
      this._scene._engine.removePrepareRenderListener(t);
      const i = {
        destination: void 0,
        orientation: {
          heading: void 0,
          pitch: void 0,
          roll: void 0
        }
      };
      i.destination = Yt.destination, i.orientation.heading = Yt.heading, i.orientation.pitch = Yt.pitch, i.orientation.roll = Yt.roll, this.setView(i), F(this._currentFlight.complete) && this._currentFlight.complete(), this._currentFlight = void 0;
    }
  }
  flyTo(t) {
    t = he(t, {});
    let e = t.destination;
    if (this._mode === Ge.MORPHING)
      return;
    this.cancelFlight();
    const n = e instanceof Oe;
    n && (e = this.getRectangleCameraCoordinates(
      e,
      WR
    ));
    let o = he(
      t.orientation,
      he.EMPTY_OBJECT
    );
    if (F(o.direction) && (o = Ip(
      this,
      e,
      o,
      Hd.orientation
    )), F(t.duration) && t.duration <= 0) {
      const d = Hd;
      d.destination = t.destination, d.orientation.heading = o.heading, d.orientation.pitch = o.pitch, d.orientation.roll = o.roll, d.convert = t.convert, d.endTransform = t.endTransform, this.setView(d), typeof t.complete == "function" && t.complete();
      return;
    }
    const r = this;
    Yt.destination = e, Yt.heading = o.heading, Yt.pitch = o.pitch, Yt.roll = o.roll, Yt.duration = t.duration, Yt.complete = function() {
      r._currentFlight = void 0, F(t.complete) && t.complete();
    }, Yt.cancel = t.cancel, Yt.endTransform = t.endTransform, Yt.convert = n ? !1 : t.convert, Yt.maximumHeight = t.maximumHeight, Yt.pitchAdjustHeight = t.pitchAdjustHeight, Yt.flyOverLongitude = t.flyOverLongitude, Yt.flyOverLongitudeWeight = t.flyOverLongitudeWeight, Yt.easingFunction = t.easingFunction;
    const a = this._scene, g = Ar.createTween(a, Yt);
    if (g.duration === 0) {
      typeof g.complete == "function" && g.complete();
      return;
    }
    const c = a._engine;
    let l = performance.now();
    function h(d) {
      const p = performance.now() - l, {
        duration: m,
        complete: b,
        update: S,
        easingFunction: A
      } = g;
      if (p >= m) {
        S({
          time: m,
          easingFunction: A
        }), c.removePrepareRenderListener(h), b();
        return;
      }
      S({
        time: p,
        easingFunction: A
      }), c.map.map._syncFromEllipsoidCamera(), c.requestRender();
    }
    c.addPrepareRenderListener(h), g.listener = h, this._currentFlight = g;
  }
  flyHome(t) {
    let e = new B(), i = this._mode;
    if (i === Ge.MORPHING && this._scene.completeMorph(), i === Ge.SCENE2D)
      this.flyTo({
        destination: Bo.DEFAULT_VIEW_RECTANGLE,
        duration: t,
        endTransform: _e.IDENTITY
      });
    else if (i === Ge.SCENE3D) {
      let n = this.getRectangleCameraCoordinates(
        Bo.DEFAULT_VIEW_RECTANGLE
      ), o = _.magnitude(n);
      o += o * Bo.DEFAULT_VIEW_FACTOR, _.normalize(n, n), _.multiplyByScalar(n, o, n), this.flyTo({
        destination: n,
        duration: t,
        endTransform: _e.IDENTITY
      }), this._scene._engine.requestRender();
    } else if (i === Ge.COLUMBUS_VIEW) {
      let n = this._projection.ellipsoid.maximumRadius, o = new B(0, -1, 1);
      o = _.multiplyByScalar(
        _.normalize(o, o),
        5 * n,
        o
      ), this.flyTo({
        destination: o,
        duration: t,
        orientation: {
          heading: 0,
          pitch: -Math.acos(_.normalize(o, e).z),
          roll: 0
        },
        endTransform: _e.IDENTITY,
        convert: !1
      });
    }
  }
  getRectangleCameraCoordinates(t, e) {
    const i = this._mode;
    if (F(e) || (e = new B()), i === Ge.SCENE3D)
      return bp(this, t, e);
  }
  update() {
  }
  _adjustOrthographicFrustum(t) {
  }
  clone(t, e) {
    return F(e) || (e = new Bo(t._scene)), _.clone(t.position, e.position), _.clone(t.direction, e.direction), _.clone(t.up, e.up), _.clone(t.right, e.right), _e.clone(t._transform, e.transform), e._transformChanged = !0, e.frustum = t.frustum.clone(), e;
  }
  getLocalTransform() {
    const t = this._ellipsoid, e = _e.clone(this._transform, fg), i = Ze.eastNorthUpToFixedFrame(
      this.positionWC,
      t,
      pg
    );
    this._setTransform(i);
    const n = new J();
    return n.set(
      this.right.x,
      this.up.x,
      -this.direction.x,
      0,
      this.right.y,
      this.up.y,
      -this.direction.y,
      0,
      this.right.z,
      this.up.z,
      -this.direction.z,
      0,
      0,
      0,
      0,
      1
    ), this._setTransform(e), n;
  }
  get transform() {
    return this._transform;
  }
  get inverseTransform() {
    return an(this), this._invTransform;
  }
  get viewMatrix() {
    return an(this), this._viewMatrix;
  }
  get inverseViewMatrix() {
    return an(this), this._invViewMatrix;
  }
  get positionCartographic() {
    return an(this), this._positionCartographic;
  }
  get positionWC() {
    return an(this), this._positionWC;
  }
  get directionWC() {
    return an(this), this._directionWC;
  }
  get upWC() {
    return an(this), this._upWC;
  }
  get rightWC() {
    return an(this), this._rightWC;
  }
  get heading() {
    const t = this._ellipsoid, e = _e.clone(this._transform, fg), i = Ze.eastNorthUpToFixedFrame(
      this.positionWC,
      t,
      pg
    );
    this._setTransform(i);
    const n = uw(this.direction, this.up);
    return this._setTransform(e), n;
  }
  get pitch() {
    const t = this._ellipsoid, e = _e.clone(this._transform, fg), i = Ze.eastNorthUpToFixedFrame(
      this.positionWC,
      t,
      pg
    );
    this._setTransform(i);
    const n = Iw(this.direction);
    return this._setTransform(e), n;
  }
  get roll() {
    const t = this._ellipsoid, e = _e.clone(this._transform, fg), i = Ze.eastNorthUpToFixedFrame(
      this.positionWC,
      t,
      pg
    );
    this._setTransform(i);
    const n = Aw(this.direction, this.up, this.right);
    return this._setTransform(e), n;
  }
  get moveStart() {
    return this._moveStart;
  }
  get moveEnd() {
    return this._moveEnd;
  }
  get changed() {
    return this._changed;
  }
};
let _o = Bo;
f(_o, "DEFAULT_VIEW_RECTANGLE", Oe.fromDegrees(
  73,
  -5,
  140,
  70
)), f(_o, "DEFAULT_VIEW_FACTOR", 0.5), f(_o, "DEFAULT_OFFSET", new fC(
  0,
  Math.PI / 4,
  0
));
const Fa = new B(), nD = new B(), sD = new B(), oD = new B(), rD = new B(), aD = new B(), gD = new B(), cD = new B(), lD = new B(), Pd = new B(), hD = {
  direction: new B(),
  right: new B(),
  up: new B()
};
let Sp;
function yi(s, t, e, i) {
  return Math.abs(_.dot(t, e)) / i - _.dot(s, e);
}
function bp(s, t, e, i) {
  const n = s._projection.ellipsoid, o = i ? s : hD, r = t.north, a = t.south;
  let g = t.east;
  const c = t.west;
  c > g && (g += X.TWO_PI);
  const l = (c + g) * 0.5;
  let h;
  if (a < -X.PI_OVER_TWO + X.RADIANS_PER_DEGREE && r > X.PI_OVER_TWO - X.RADIANS_PER_DEGREE)
    h = 0;
  else {
    const T = Fa;
    T.x = l, T.y = r, T.z = 0;
    const R = nD;
    R.x = l, R.y = a, R.z = 0;
    let w = Sp;
    (!F(w) || w.ellipsoid !== n) && (Sp = w = new Lr(
      void 0,
      void 0,
      n
    )), w.setEndPoints(T, R), h = w.interpolateUsingFraction(
      0.5,
      Fa
    ).y;
  }
  const d = Fa;
  d.x = l, d.y = h, d.z = 0;
  const C = n.cartographicToCartesian(
    d,
    lD
  ), p = Fa;
  p.x = g, p.y = r;
  const m = n.cartographicToCartesian(
    p,
    sD
  );
  p.x = c;
  const b = n.cartographicToCartesian(
    p,
    rD
  );
  p.x = l;
  const S = n.cartographicToCartesian(
    p,
    gD
  );
  p.y = a;
  const A = n.cartographicToCartesian(
    p,
    cD
  );
  p.x = g;
  const u = n.cartographicToCartesian(
    p,
    aD
  );
  p.x = c;
  const y = n.cartographicToCartesian(
    p,
    oD
  );
  _.subtract(b, C, b), _.subtract(u, C, u), _.subtract(m, C, m), _.subtract(y, C, y), _.subtract(S, C, S), _.subtract(A, C, A);
  const I = n.geodeticSurfaceNormal(C, o.direction);
  _.negate(I, I);
  const M = _.cross(I, _.UNIT_Z, o.right);
  _.normalize(M, M);
  const G = _.cross(M, I, o.up);
  let x;
  const L = Math.tan(ce.degToRad(s._camera.fov) * 0.5), E = s._camera.aspect * L;
  if (x = Math.max(
    yi(I, G, b, L),
    yi(I, G, u, L),
    yi(I, G, m, L),
    yi(I, G, y, L),
    yi(I, G, S, L),
    yi(I, G, A, L),
    yi(I, M, b, E),
    yi(I, M, u, E),
    yi(I, M, m, E),
    yi(I, M, y, E),
    yi(I, M, S, E),
    yi(I, M, A, E)
  ), a < 0 && r > 0) {
    const T = Fa;
    T.x = c, T.y = 0, T.z = 0;
    let R = n.cartographicToCartesian(
      T,
      Pd
    );
    _.subtract(R, C, R), x = Math.max(
      x,
      yi(I, G, R, L),
      yi(I, M, R, E)
    ), T.x = g, R = n.cartographicToCartesian(
      T,
      Pd
    ), _.subtract(R, C, R), x = Math.max(
      x,
      yi(I, G, R, L),
      yi(I, M, R, E)
    );
  }
  return _.add(
    C,
    _.multiplyByScalar(I, -x, Pd),
    e
  );
}
const Bp = new B(), dD = new B(0, 0, 1);
class uD extends Xi {
  constructor() {
    super(), this.uniforms = we.clone(Zf.uniforms), this.material = new ze({
      defines: {
        MVT_USE_NORMAL_TEXTURE: !1
      },
      uniforms: this.uniforms,
      vertexShader: Ht.vertexShader,
      fragmentShader: Zf.fragmentShader,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.needsSwap = !0, this.fsQuad = new Ut(null), this.needsDepthTexture = !0, this.needsNormalTextureWhenMRT = !0;
  }
  render(t, e, i) {
    const n = this.sky;
    if (!n)
      return;
    const o = this.rendering, r = o.camera, a = o._engine, g = a.map.isGlobe, c = this.uniforms;
    c.tDiffuse.value = i.texture, c.tDepth.value = o.main.sceneRendering.depthTexture, c.isGlobe.value = g, c.viewInverseMatrix.value.copy(r.matrixWorld), c.projectionInverseMatrix.value.copy(r.projectionMatrixInverse), c.cameraNear.value = r.near, c.cameraFar.value = r.far, c.color.value.copy(n.color), c.highColor.value.copy(n.highColor), c.cameraPosition.value.copy(r.position);
    let l = a.map.getViewHeight();
    g ? l = Math.max(l / 1e6, 2e-4) : l = 2e-4, c.viewHeight.value = l, c.resolution = o.uniforms.resolution, c.sunDirection.value.copy(n.localSunDirection);
    let h = 0, d = 1;
    if (o._engine.map.mapType === "earth") {
      let b = o._engine.map._map._ellipsoidCamera;
      if (!this._sphereCamera) {
        const G = new De(6371e3, 6371e3, 6371e3);
        this._sphereCamera = new _o({
          _ellipsoid: G,
          mapProjection: new Da(G),
          camera: r
        });
      }
      const S = this._sphereCamera;
      S.position.copy(b.position), S.direction.copy(b.direction), S.up.copy(b.up), S.right.copy(b.right), b = S, c.viewInverseMatrix.value.copy(b.getLocalTransform());
      const A = c.viewInverseMatrix.value.elements;
      Bp.set(A[8], A[9], A[10]);
      const u = ce.clamp(Bp.dot(dD), 0.1, 1), y = c.viewHeight.value * 1e6 / u, I = ce.mapLinear(Math.sqrt(c.viewHeight.value * 10), 0, 1, 20, 2), M = Math.max(y + 100, y * I);
      h = o.renderState.getDepthByDistance(y), d = o.renderState.getDepthByDistance(M);
    }
    c.fogDepthRange.value.set(h, d);
    const C = t.autoClear, p = t.getRenderTarget();
    t.autoClear = !1, this.fsQuad.material = this.material, t.setRenderTarget(this.renderToScreen ? null : e), t.clear(!0, !1, !1), this.fsQuad.render(t), t.autoClear = C, t.setRenderTarget(p);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class ID extends gh {
  constructor() {
    super(...arguments);
    f(this, "isDefaultSky", !0);
    f(this, "name", "DefaultSky");
    f(this, "_postPass", null);
    f(this, "_engine", null);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), this._engine = e, this._color = new Ce(1, 1, 1, 1), this._highColor = new Ce(153 / 255, 204 / 255, 255 / 255), this.initEnv();
  }
  beforeRemoveFromEngine(e) {
    e.rendering.main.postprocessings.remove(this._postPass), super.beforeRemoveFromEngine(e);
  }
  initEnv() {
    const e = this._engine, i = this._postPass = new uD();
    i.renderOrder = 50, i.sky = this, e.rendering.main.opaquePostprocessings.add(i);
  }
  get highColor() {
    return this._highColor;
  }
  set highColor(e) {
    e.isColor && this._highColor.copy(e);
  }
  get color() {
    return this._color;
  }
  set color(e) {
    e.isColor && this._color.copy(e);
  }
  get enablePostPass() {
    return this._postPass.enabled || !1;
  }
  set enablePostPass(e) {
    this._postPass && (this._postPass.enabled = e);
  }
  dispose() {
    super.dispose();
  }
}
/*!
* Proton v1.1.4
* https://github.com/JackXie60/shader-particle-system
* Copyright 2022-2025, JackXie60
* Licensed under the MIT license
* http://www.opensource.org/licenses/mit-license
*
*/
var As, gn, te = { types: { Boolean: "boolean", STRING: "string", NUMBER: "number", OBJECT: "object" }, ensureTypedArg: function(s, t, e) {
  return typeof s === t ? s : e;
}, ensureArrayTypedArg: function(s, t, e) {
  if (Array.isArray(s)) {
    for (var i = s.length - 1; i >= 0; --i)
      if (typeof s[i] !== t)
        return e;
    return s;
  }
  return this.ensureTypedArg(s, t, e);
}, ensureInstanceOf: function(s, t, e) {
  return s !== void 0 ? s : e;
}, ensureArrayInstanceOf: function(s, t, e) {
  if (Array.isArray(s)) {
    for (var i = s.length - 1; i >= 0; --i)
      if (t !== void 0 && !(s[i] instanceof t))
        return e;
    return s;
  }
  return this.ensureInstanceOf(s, t, e);
}, ensureValueOverLifetimeCompliance: function(s, t, e) {
  t = t || 3, e = e || 3, Array.isArray(s._value) === !1 && (s._value = [s._value]), Array.isArray(s._spread) === !1 && (s._spread = [s._spread]);
  var i = this.clamp(s._value.length, t, e), n = this.clamp(s._spread.length, t, e), o = Math.max(i, n);
  s._value.length !== o && (s._value = this.interpolateArray(s._value, o)), s._spread.length !== o && (s._spread = this.interpolateArray(s._spread, o));
}, interpolateArray: function(s, t) {
  for (var e = s.length, i = [typeof s[0].clone == "function" ? s[0].clone() : s[0]], n = (e - 1) / (t - 1), o = 1; o < t - 1; ++o) {
    var r = o * n, a = Math.floor(r), g = Math.ceil(r), c = r - a;
    i[o] = this.lerpTypeAgnostic(s[a], s[g], c);
  }
  return i.push(typeof s[e - 1].clone == "function" ? s[e - 1].clone() : s[e - 1]), i;
}, clamp: function(s, t, e) {
  return Math.max(t, Math.min(s, e));
}, zeroToEpsilon: function(s, t) {
  var e = 1e-5, i = s;
  return i = t ? Math.random() * e * 10 : e, s < 0 && s > -1e-5 && (i = -i), i;
}, lerpTypeAgnostic: function(s, t, e) {
  var i, n = this.types;
  return typeof s === n.NUMBER && typeof t === n.NUMBER ? s + (t - s) * e : s instanceof Z && t instanceof Z ? ((i = s.clone()).x = this.lerp(s.x, t.x, e), i.y = this.lerp(s.y, t.y, e), i) : s instanceof B && t instanceof B ? ((i = s.clone()).x = this.lerp(s.x, t.x, e), i.y = this.lerp(s.y, t.y, e), i.z = this.lerp(s.z, t.z, e), i) : s instanceof Me && t instanceof Me ? ((i = s.clone()).x = this.lerp(s.x, t.x, e), i.y = this.lerp(s.y, t.y, e), i.z = this.lerp(s.z, t.z, e), i.w = this.lerp(s.w, t.w, e), i) : s instanceof Ce && t instanceof Ce ? ((i = s.clone()).r = this.lerp(s.r, t.r, e), i.g = this.lerp(s.g, t.g, e), i.b = this.lerp(s.b, t.b, e), i) : void console.warn("Invalid argument types, or argument types do not match:", s, t);
}, lerp: function(s, t, e) {
  return s + (t - s) * e;
}, roundToNearestMultiple: function(s, t) {
  var e;
  return t === 0 || (e = Math.abs(s) % t) === 0 ? s : s < 0 ? -(Math.abs(s) - e) : s + t - e;
}, arrayValuesAreEqual: function(s) {
  for (var t = 0; t < s.length - 1; ++t)
    if (s[t] !== s[t + 1])
      return !1;
  return !0;
}, randomFloat: function(s, t) {
  return s + t * (Math.random() - 0.5);
}, randomVector3: function(s, t, e, i, n) {
  var o = e.x + (Math.random() * i.x - 0.5 * i.x), r = e.y + (Math.random() * i.y - 0.5 * i.y), a = e.z + (Math.random() * i.z - 0.5 * i.z);
  n && (o = 0.5 * -n.x + this.roundToNearestMultiple(o, n.x), r = 0.5 * -n.y + this.roundToNearestMultiple(r, n.y), a = 0.5 * -n.z + this.roundToNearestMultiple(a, n.z)), s.typedArray.setVec3Components(t, o, r, a);
}, randomColor: function(s, t, e, i) {
  var n = e.r + Math.random() * i.x, o = e.g + Math.random() * i.y, r = e.b + Math.random() * i.z;
  n = this.clamp(n, 0, 1), o = this.clamp(o, 0, 1), r = this.clamp(r, 0, 1), s.typedArray.setVec3Components(t, n, o, r);
}, randomColorAsHex: (gn = new Ce(), function(s, t, e, i) {
  for (var n = e.length, o = [], r = 0; r < n; ++r) {
    var a = i[r];
    gn.copy(e[r]), gn.r += Math.random() * a.x - 0.5 * a.x, gn.g += Math.random() * a.y - 0.5 * a.y, gn.b += Math.random() * a.z - 0.5 * a.z, gn.r = this.clamp(gn.r, 0, 1), gn.g = this.clamp(gn.g, 0, 1), gn.b = this.clamp(gn.b, 0, 1), o.push(gn.getHex());
  }
  s.typedArray.setVec4Components(t, o[0], o[1], o[2], o[3]);
}), randomVector3OnLine: function(s, t, e, i) {
  var n = e.clone();
  n.lerp(i, Math.random()), s.typedArray.setVec3Components(t, n.x, n.y, n.z);
}, randomVector3OnSphere: function(s, t, e, i, n, o, r, a) {
  var g = 2 * Math.random() - 1, c = 6.2832 * Math.random(), l = Math.sqrt(1 - g * g), h = this.randomFloat(i, n), d = 0, C = 0, p = 0;
  r && (h = Math.round(h / r) * r), d = l * Math.cos(c) * h, C = l * Math.sin(c) * h, p = g * h, d *= o.x, C *= o.y, p *= o.z, d += e.x, C += e.y, p += e.z, s.typedArray.setVec3Components(t, d, C, p);
}, seededRandom: function(s) {
  var t = 1e4 * Math.sin(s);
  return t - (0 | t);
}, randomVector3OnDisc: function(s, t, e, i, n, o, r) {
  var a = 6.2832 * Math.random(), g = Math.abs(this.randomFloat(i, n)), c = 0, l = 0, h = 0;
  r && (g = Math.round(g / r) * r), c = Math.cos(a) * g, l = Math.sin(a) * g, c *= o.x, l *= o.y, c += e.x, l += e.y, h += e.z, s.typedArray.setVec3Components(t, c, l, h);
}, randomDirectionVector3OnSphere: (As = new B(), function(s, t, e, i, n, o, r, a) {
  As.copy(o), As.x -= e, As.y -= i, As.z -= n, As.normalize().multiplyScalar(-this.randomFloat(r, a)), s.typedArray.setVec3Components(t, As.x, As.y, As.z);
}), randomDirectionVector3OnDisc: function() {
  var s = new B();
  return function(t, e, i, n, o, r, a, g) {
    s.copy(r), s.x -= i, s.y -= n, s.z -= o, s.normalize().multiplyScalar(-this.randomFloat(a, g)), t.typedArray.setVec3Components(e, s.x, s.y, 0);
  };
}(), getPackedRotationAxis: function() {
  var s = new B(), t = new B(), e = new Ce(), i = new B(1, 1, 1);
  return function(n, o) {
    return s.copy(n).normalize(), t.copy(o).normalize(), s.x += 0.5 * -o.x + Math.random() * o.x, s.y += 0.5 * -o.y + Math.random() * o.y, s.z += 0.5 * -o.z + Math.random() * o.z, s.normalize().add(i).multiplyScalar(0.5), e.setRGB(s.x, s.y, s.z), e.getHex();
  };
}() }, na = { distributions: { BOX: 1, SPHERE: 2, DISC: 3, LINE: 4 }, valueOverLifetimeLength: 4 }, AD = function() {
  function s(e, i, n, o) {
    this.componentSize = n || 1, this.size = i || 1, this.TypedArrayConstructor = e || Float32Array, this.array = new e(i * this.componentSize), this.indexOffset = o || 0;
  }
  var t = s.prototype;
  return t.setSize = function(e, i) {
    var n = this.array.length;
    return i || (e *= this.componentSize), e < n ? this.shrink(e) : e > n ? this.grow(e) : void console.info("TypedArray is already of size:", e + ".", "Will not resize.");
  }, t.shrink = function(e) {
    return this.array = this.array.subarray(0, e), this.size = e, this;
  }, t.grow = function(e) {
    var i = new this.TypedArrayConstructor(e);
    return i.set(this.array), this.array = i, this.size = e, this;
  }, t.splice = function(e, i) {
    for (var n = e * this.componentSize, o = i * this.componentSize, r = [], a = this.array.length, g = 0; g < a; ++g)
      (g < n || g > o) && r.push(this.array[g]);
    return this.setFromArray(0, r), this;
  }, t.setFromArray = function(e, i) {
    var n = e + i.length;
    return n > this.array.length ? this.grow(n) : n < this.array.length && this.shrink(n), this.array.set(i, this.indexOffset + e), this;
  }, t.setVec2 = function(e, i) {
    return this.setVec2Components(e, i.x, i.y);
  }, t.setVec2Components = function(e, i, n) {
    var o = this.array, r = this.indexOffset + e * this.componentSize;
    return o[r] = i, o[r + 1] = n, this;
  }, t.setVec3 = function(e, i) {
    return this.setVec3Components(e, i.x, i.y, i.z);
  }, t.setVec3Components = function(e, i, n, o) {
    var r = this.array, a = this.indexOffset + e * this.componentSize;
    return r[a] = i, r[a + 1] = n, r[a + 2] = o, this;
  }, t.setVec4 = function(e, i) {
    return this.setVec4Components(e, i.x, i.y, i.z, i.w);
  }, t.setVec4Components = function(e, i, n, o, r) {
    var a = this.array, g = this.indexOffset + e * this.componentSize;
    return a[g] = i, a[g + 1] = n, a[g + 2] = o, a[g + 3] = r, this;
  }, t.setMat3 = function(e, i) {
    return this.setFromArray(this.indexOffset + e * this.componentSize, i.elements);
  }, t.setMat4 = function(e, i) {
    return this.setFromArray(this.indexOffset + e * this.componentSize, i.elements);
  }, t.setColor = function(e, i) {
    return this.setVec3Components(e, i.r, i.g, i.b);
  }, t.setNumber = function(e, i) {
    return this.array[this.indexOffset + e * this.componentSize] = i, this;
  }, t.getValueAtIndex = function(e) {
    return this.array[this.indexOffset + e];
  }, t.getComponentValueAtIndex = function(e) {
    return this.array.subarray(this.indexOffset + e * this.componentSize);
  }, s;
}(), En = function() {
  function s(e, i, n) {
    var o = s.typeSizeMap;
    this.type = typeof e == "string" && o.hasOwnProperty(e) ? e : "f", this.componentSize = o[this.type], this.arrayType = n || Float32Array, this.typedArray = null, this.bufferAttribute = null, this.dynamicBuffer = !!i, this.updateMin = 0, this.updateMax = 0;
  }
  var t = s.prototype;
  return t.setUpdateRange = function(e, i) {
    this.updateMin = Math.min(e * this.componentSize, this.updateMin * this.componentSize), this.updateMax = Math.max(i * this.componentSize, this.updateMax * this.componentSize);
  }, t.flagUpdate = function() {
    var e = this.bufferAttribute, i = e.updateRange;
    i.offset = this.updateMin, i.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length), e.needsUpdate = !0;
  }, t.resetUpdateRange = function() {
    this.updateMin = 0, this.updateMax = 0;
  }, t.resetDynamic = function() {
    this.bufferAttribute.useage = this.dynamicBuffer ? Ql : Tl;
  }, t.splice = function(e, i) {
    this.typedArray.splice(e, i), this.forceUpdateAll();
  }, t.forceUpdateAll = function() {
    this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.updateRange.offset = 0, this.bufferAttribute.updateRange.count = -1, this.bufferAttribute.usage = Tl, this.bufferAttribute.needsUpdate = !0;
  }, t._ensureTypedArray = function(e) {
    this.typedArray !== null && this.typedArray.size === e * this.componentSize || (this.typedArray !== null && this.typedArray.size !== e ? this.typedArray.setSize(e) : this.typedArray === null && (this.typedArray = new AD(this.arrayType, e, this.componentSize)));
  }, t._createBufferAttribute = function(e) {
    if (this._ensureTypedArray(e), this.bufferAttribute !== null)
      return this.bufferAttribute.array = this.typedArray.array, this.bufferAttribute.count = this.bufferAttribute.array.length / this.bufferAttribute.itemSize, void (this.bufferAttribute.needsUpdate = !0);
    this.bufferAttribute = new Fe(this.typedArray.array, this.componentSize), this.bufferAttribute.usage = this.dynamicBuffer ? Ql : Tl;
  }, t.getLength = function() {
    return this.typedArray === null ? 0 : this.typedArray.array.length;
  }, s;
}();
En.typeSizeMap = { f: 1, v2: 2, v3: 3, v4: 4, c: 3, m3: 9, m4: 16 };
var Si = { defines: ["#define PACKED_COLOR_SIZE 256.0", "#define PACKED_COLOR_DIVISOR 255.0"].join(`
`), uniforms: ["uniform float deltaTime;", "uniform float runTime;", "uniform sampler2D tex;", "uniform vec4 textureAnimation;", "uniform float scale;"].join(`
`), attributes: ["attribute vec4 acceleration;", "attribute vec3 velocity;", "attribute vec4 rotation;", "attribute vec3 rotationCenter;", "attribute vec4 params;", "attribute vec4 size;", "attribute vec4 angle;", "attribute vec4 color;", "attribute vec4 opacity;"].join(`
`), varyings: ["varying vec4 vColor;", "#ifdef SHOULD_ROTATE_TEXTURE", "    varying float vAngle;", "#endif", "#ifdef SHOULD_CALCULATE_SPRITE", "    varying vec4 vSpriteSheet;", "#endif"].join(`
`), branchAvoidanceFunctions: ["float when_gt(float x, float y) {", "    return max(sign(x - y), 0.0);", "}", "float when_lt(float x, float y) {", "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );", "}", "float when_eq( float x, float y ) {", "    return 1.0 - abs( sign( x - y ) );", "}", "float when_ge(float x, float y) {", "  return 1.0 - when_lt(x, y);", "}", "float when_le(float x, float y) {", "  return 1.0 - when_gt(x, y);", "}", "float and(float a, float b) {", "    return a * b;", "}", "float or(float a, float b) {", "    return min(a + b, 1.0);", "}"].join(`
`), unpackColor: ["vec3 unpackColor( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   return c;", "}"].join(`
`), unpackRotationAxis: ["vec3 unpackRotationAxis( in float hex ) {", "   vec3 c = vec3( 0.0 );", "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );", "   float b = mod( hex, PACKED_COLOR_SIZE );", "   c.r = r / PACKED_COLOR_DIVISOR;", "   c.g = g / PACKED_COLOR_DIVISOR;", "   c.b = b / PACKED_COLOR_DIVISOR;", "   c *= vec3( 2.0 );", "   c -= vec3( 1.0 );", "   return c;", "}"].join(`
`), floatOverLifetime: ["float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {", "    highp float value = 0.0;", "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );", "    float fIndex = 0.0;", "    float shouldApplyValue = 0.0;", "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );", "", "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {", "       fIndex = float( i );", "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );", "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );", "    }", "", "    return value;", "}"].join(`
`), colorOverLifetime: ["vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {", "    vec3 value = vec3( 0.0 );", "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );", "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );", "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );", "    return value;", "}"].join(`
`), paramFetchingFunctions: ["float getAlive() {", "   return params.x;", "}", "float getAge() {", "   return params.y;", "}", "float getMaxAge() {", "   return params.z;", "}", "float getWiggle() {", "   return params.w;", "}"].join(`
`), forceFetchingFunctions: ["vec4 getPosition( in float age ) {", "   return modelViewMatrix * vec4( position, 1.0 );", "}", "vec3 getVelocity( in float age ) {", "   return velocity * age;", "}", "vec3 getAcceleration( in float age ) {", "   return acceleration.xyz * age;", "}"].join(`
`), rotationFunctions: ["#ifdef SHOULD_ROTATE_PARTICLES", "   mat4 getRotationMatrix( in vec3 axis, in float angle) {", "       axis = normalize(axis);", "       float s = sin(angle);", "       float c = cos(angle);", "       float oc = 1.0 - c;", "", "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,", "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,", "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,", "                   0.0,                                0.0,                                0.0,                                1.0);", "   }", "", "   vec3 getRotation( in vec3 pos, in float positionInTime ) {", "      if( rotation.y == 0.0 ) {", "           return pos;", "      }", "", "      vec3 axis = unpackRotationAxis( rotation.x );", "      vec3 center = rotationCenter;", "      vec3 translated;", "      mat4 rotationMatrix;", "      float angle = 0.0;", "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;", "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );", "      translated = rotationCenter - pos;", "      rotationMatrix = getRotationMatrix( axis, angle );", "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );", "   }", "#endif"].join(`
`), rotateTexture: ["    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );", "", "    #ifdef SHOULD_ROTATE_TEXTURE", "       float x = gl_PointCoord.x - 0.5;", "       float y = 1.0 - gl_PointCoord.y - 0.5;", "       float c = cos( -vAngle );", "       float s = sin( -vAngle );", "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );", "    #endif", "", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = vSpriteSheet.x;", "        float framesY = vSpriteSheet.y;", "        float columnNorm = vSpriteSheet.z;", "        float rowNorm = vSpriteSheet.w;", "        vUv.x = gl_PointCoord.x * framesX + columnNorm;", "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);", "    #endif", "", "    vec4 rotatedTexture = texture2D( tex, vUv );"].join(`
`) }, wp = { vertex: [Si.defines, Si.uniforms, Si.attributes, Si.varyings, Ee.common, Ee.logdepthbuf_pars_vertex, Ee.fog_pars_fragment, Si.branchAvoidanceFunctions, Si.unpackColor, Si.unpackRotationAxis, Si.floatOverLifetime, Si.colorOverLifetime, Si.paramFetchingFunctions, Si.forceFetchingFunctions, Si.rotationFunctions, "void main() {", "    highp float age = getAge();", "    highp float alive = getAlive();", "    highp float maxAge = getMaxAge();", "    highp float positionInTime = (age / maxAge);", "    highp float isAlive = when_gt( alive, 0.0 );", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        float wiggleAmount = positionInTime * getWiggle();", "        float wiggleSin = isAlive * sin( wiggleAmount );", "        float wiggleCos = isAlive * cos( wiggleAmount );", "    #endif", "    vec3 vel = getVelocity( age );", "    vec3 accel = getAcceleration( age );", "    vec3 force = vec3( 0.0 );", "    vec3 pos = vec3( position );", "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;", "    force += vel;", "    force *= drag;", "    force += accel * age;", "    pos += force;", "    #ifdef SHOULD_WIGGLE_PARTICLES", "        pos.x += wiggleSin;", "        pos.y += wiggleCos;", "        pos.z += wiggleSin;", "    #endif", "    #ifdef SHOULD_ROTATE_PARTICLES", "        pos = getRotation( pos, positionInTime );", "    #endif", "    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );", "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;", "    #ifdef HAS_PERSPECTIVE", "        float perspective = scale / length( mvPosition.xyz );", "    #else", "        float perspective = 1.0;", "    #endif", "    float pointSizePerspective = pointSize * perspective;", "    #ifdef COLORIZE", "       vec3 c = isAlive * getColorOverLifetime(", "           positionInTime,", "           unpackColor( color.x ),", "           unpackColor( color.y ),", "           unpackColor( color.z ),", "           unpackColor( color.w )", "       );", "    #else", "       vec3 c = vec3(1.0);", "    #endif", "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );", "    vColor = vec4( c, o );", "    #ifdef SHOULD_ROTATE_TEXTURE", "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );", "    #endif", "    #ifdef SHOULD_CALCULATE_SPRITE", "        float framesX = textureAnimation.x;", "        float framesY = textureAnimation.y;", "        float loopCount = textureAnimation.w;", "        float totalFrames = textureAnimation.z;", "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );", "        float column = floor(mod( frameNumber, framesX ));", "        float row = floor( (frameNumber - column) / framesX );", "        float columnNorm = column / framesX;", "        float rowNorm = row / framesY;", "        vSpriteSheet.x = 1.0 / framesX;", "        vSpriteSheet.y = 1.0 / framesY;", "        vSpriteSheet.z = columnNorm;", "        vSpriteSheet.w = rowNorm;", "    #endif", "    gl_PointSize = pointSizePerspective;", "    gl_Position = projectionMatrix * mvPosition;", Ee.logdepthbuf_vertex, "}"].join(`
`), fragment: [Si.uniforms, Ee.common, Ee.fog_pars_fragment, Ee.logdepthbuf_pars_fragment, Si.varyings, Si.branchAvoidanceFunctions, "void main() {", "    vec3 outgoingLight = vColor.xyz;", "    ", "    #ifdef ALPHATEST", "       if ( vColor.w < float(ALPHATEST) ) discard;", "    #endif", Si.rotateTexture, Ee.logdepthbuf_fragment, "    outgoingLight = vColor.xyz * rotatedTexture.xyz;", "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );", Ee.fog_fragment, "}"].join(`
`) }, po = function() {
  function s(e) {
    var i = te.types, n = na.valueOverLifetimeLength;
    for (var o in (e = te.ensureTypedArg(e, i.OBJECT, {})).position = te.ensureTypedArg(e.position, i.OBJECT, {}), e.velocity = te.ensureTypedArg(e.velocity, i.OBJECT, {}), e.acceleration = te.ensureTypedArg(e.acceleration, i.OBJECT, {}), e.radius = te.ensureTypedArg(e.radius, i.OBJECT, {}), e.drag = te.ensureTypedArg(e.drag, i.OBJECT, {}), e.rotation = te.ensureTypedArg(e.rotation, i.OBJECT, {}), e.color = te.ensureTypedArg(e.color, i.OBJECT, {}), e.opacity = te.ensureTypedArg(e.opacity, i.OBJECT, {}), e.size = te.ensureTypedArg(e.size, i.OBJECT, {}), e.angle = te.ensureTypedArg(e.angle, i.OBJECT, {}), e.wiggle = te.ensureTypedArg(e.wiggle, i.OBJECT, {}), e.maxAge = te.ensureTypedArg(e.maxAge, i.OBJECT, {}), e.onParticleSpawn && console.warn("onParticleSpawn has been removed. Please set properties directly to alter values at runtime."), this.uuid = ce.generateUUID(), this.type = te.ensureTypedArg(e.type, i.NUMBER, na.distributions.BOX), this.position = { _value: te.ensureInstanceOf(e.position.value, B, new B()), _spread: te.ensureInstanceOf(e.position.spread, B, new B()), _spreadClamp: te.ensureInstanceOf(e.position.spreadClamp, B, new B()), _distribution: te.ensureTypedArg(e.position.distribution, i.NUMBER, this.type), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1), _radius: te.ensureTypedArg(e.position.radius, i.NUMBER, 10), _radiusScale: te.ensureInstanceOf(e.position.radiusScale, B, new B(1, 1, 1)), _distributionClamp: te.ensureTypedArg(e.position.distributionClamp, i.NUMBER, 0) }, this.velocity = { _value: te.ensureInstanceOf(e.velocity.value, B, new B()), _spread: te.ensureInstanceOf(e.velocity.spread, B, new B()), _distribution: te.ensureTypedArg(e.velocity.distribution, i.NUMBER, this.type), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.acceleration = { _value: te.ensureInstanceOf(e.acceleration.value, B, new B()), _spread: te.ensureInstanceOf(e.acceleration.spread, B, new B()), _distribution: te.ensureTypedArg(e.acceleration.distribution, i.NUMBER, this.type), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.drag = { _value: te.ensureTypedArg(e.drag.value, i.NUMBER, 0), _spread: te.ensureTypedArg(e.drag.spread, i.NUMBER, 0), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.wiggle = { _value: te.ensureTypedArg(e.wiggle.value, i.NUMBER, 0), _spread: te.ensureTypedArg(e.wiggle.spread, i.NUMBER, 0) }, this.rotation = { _axis: te.ensureInstanceOf(e.rotation.axis, B, new B(0, 1, 0)), _axisSpread: te.ensureInstanceOf(e.rotation.axisSpread, B, new B()), _angle: te.ensureTypedArg(e.rotation.angle, i.NUMBER, 0), _angleSpread: te.ensureTypedArg(e.rotation.angleSpread, i.NUMBER, 0), _static: te.ensureTypedArg(e.rotation.static, i.BOOLEAN, !1), _center: te.ensureInstanceOf(e.rotation.center, B, this.position._value.clone()), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.maxAge = { _value: te.ensureTypedArg(e.maxAge.value, i.NUMBER, 2), _spread: te.ensureTypedArg(e.maxAge.spread, i.NUMBER, 0) }, this.color = { _value: te.ensureArrayInstanceOf(e.color.value, Ce, new Ce()), _spread: te.ensureArrayInstanceOf(e.color.spread, B, new B()), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.opacity = { _value: te.ensureArrayTypedArg(e.opacity.value, i.NUMBER, 1), _spread: te.ensureArrayTypedArg(e.opacity.spread, i.NUMBER, 0), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.size = { _value: te.ensureArrayTypedArg(e.size.value, i.NUMBER, 1), _spread: te.ensureArrayTypedArg(e.size.spread, i.NUMBER, 0), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.angle = { _value: te.ensureArrayTypedArg(e.angle.value, i.NUMBER, 0), _spread: te.ensureArrayTypedArg(e.angle.spread, i.NUMBER, 0), _randomise: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) }, this.particleCount = te.ensureTypedArg(e.particleCount, i.NUMBER, 100), this.duration = te.ensureTypedArg(e.duration, i.NUMBER, null), this.isStatic = te.ensureTypedArg(e.isStatic, i.BOOLEAN, !1), this.activeMultiplier = te.ensureTypedArg(e.activeMultiplier, i.NUMBER, 1), this.direction = te.ensureTypedArg(e.direction, i.NUMBER, 1), this.alive = te.ensureTypedArg(e.alive, i.BOOLEAN, !0), this.particlesPerSecond = 0, this.activationIndex = 0, this.attributeOffset = 0, this.attributeEnd = 0, this.age = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.resetFlags = { position: te.ensureTypedArg(e.position.randomise, i.BOOLEAN, !1) || te.ensureTypedArg(e.radius.randomise, i.BOOLEAN, !1), velocity: te.ensureTypedArg(e.velocity.randomise, i.BOOLEAN, !1), acceleration: te.ensureTypedArg(e.acceleration.randomise, i.BOOLEAN, !1) || te.ensureTypedArg(e.drag.randomise, i.BOOLEAN, !1), rotation: te.ensureTypedArg(e.rotation.randomise, i.BOOLEAN, !1), rotationCenter: te.ensureTypedArg(e.rotation.randomise, i.BOOLEAN, !1), size: te.ensureTypedArg(e.size.randomise, i.BOOLEAN, !1), color: te.ensureTypedArg(e.color.randomise, i.BOOLEAN, !1), opacity: te.ensureTypedArg(e.opacity.randomise, i.BOOLEAN, !1), angle: te.ensureTypedArg(e.angle.randomise, i.BOOLEAN, !1) }, this.updateFlags = {}, this.updateCounts = {}, this.updateMap = { maxAge: "params", position: "position", velocity: "velocity", acceleration: "acceleration", drag: "acceleration", wiggle: "params", rotation: "rotation", size: "size", color: "color", opacity: "opacity", angle: "angle" }, this.updateMap)
      this.updateMap.hasOwnProperty(o) && (this.updateCounts[this.updateMap[o]] = 0, this.updateFlags[this.updateMap[o]] = !1, this._createGetterSetters(this[o], o));
    this.bufferUpdateRanges = {}, this.attributeKeys = null, this.attributeCount = 0, te.ensureValueOverLifetimeCompliance(this.color, n, n), te.ensureValueOverLifetimeCompliance(this.opacity, n, n), te.ensureValueOverLifetimeCompliance(this.size, n, n), te.ensureValueOverLifetimeCompliance(this.angle, n, n);
  }
  var t = s.prototype;
  return t._createGetterSetters = function(e, i) {
    var n = this;
    Object.keys(e).forEach(function(o) {
      var r = o.replace("_", "");
      Object.defineProperty(e, r, { get: function() {
        return this[o];
      }, set: function(a) {
        var g = n.updateMap[i], c = this[o], l = na.valueOverLifetimeLength;
        o === "_rotationCenter" ? (n.updateFlags.rotationCenter = !0, this.updateCounts.rotationCenter = 0) : o === "_randomise" ? n.resetFlags[g] = a : (n.updateFlags[g] = !0, n.updateCounts[g] = 0), n.group._updateDefines(), this[o] = a, Array.isArray(c) && te.ensureValueOverLifetimeCompliance(n[i], l, l);
      } });
    });
  }, t._setBufferUpdateRanges = function(e) {
    this.attributeKeys = e, this.attributeCount = e.length;
    for (var i = this.attributeCount - 1; i >= 0; --i)
      this.bufferUpdateRanges[e[i]] = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
  }, t._calculatePPSValue = function(e) {
    var i = this.particleCount;
    this.duration ? this.particlesPerSecond = i / (e < this.duration ? e : this.duration) : this.particlesPerSecond = i / e;
  }, t._setAttributeOffset = function(e) {
    this.attributeOffset = e, this.activationIndex = e, this.activationEnd = e + this.particleCount;
  }, t._assignValue = function(e, i) {
    switch (e) {
      case "position":
        this._assignPositionValue(i);
        break;
      case "velocity":
      case "acceleration":
        this._assignForceValue(i, e);
        break;
      case "size":
      case "opacity":
        this._assignAbsLifetimeValue(i, e);
        break;
      case "angle":
        this._assignAngleValue(i);
        break;
      case "params":
        this._assignParamsValue(i);
        break;
      case "rotation":
        this._assignRotationValue(i);
        break;
      case "color":
        this._assignColorValue(i);
    }
  }, t._assignPositionValue = function(e) {
    var i = na.distributions, n = this.position, o = this.attributes.position, r = n._value, a = n._spread;
    switch (n.distribution) {
      case i.BOX:
        te.randomVector3(o, e, r, a, n._spreadClamp);
        break;
      case i.SPHERE:
        te.randomVector3OnSphere(o, e, r, n._radius, n._spread.x, n._radiusScale, n._spreadClamp.x, n._distributionClamp || this.particleCount);
        break;
      case i.DISC:
        te.randomVector3OnDisc(o, e, r, n._radius, n._spread.x, n._radiusScale, n._spreadClamp.x);
        break;
      case i.LINE:
        te.randomVector3OnLine(o, e, r, a);
    }
  }, t._assignForceValue = function(e, i) {
    var n, o, r, a, g, c = na.distributions, l = this[i], h = l._value, d = l._spread;
    switch (l._distribution) {
      case c.BOX:
        te.randomVector3(this.attributes[i], e, h, d);
        break;
      case c.SPHERE:
        o = (n = this.attributes.position.typedArray.array)[g = 3 * e], r = n[g + 1], a = n[g + 2], te.randomDirectionVector3OnSphere(this.attributes[i], e, o, r, a, this.position._value, l._value.x, l._spread.x);
        break;
      case c.DISC:
        o = (n = this.attributes.position.typedArray.array)[g = 3 * e], r = n[g + 1], a = n[g + 2], te.randomDirectionVector3OnDisc(this.attributes[i], e, o, r, a, this.position._value, l._value.x, l._spread.x);
        break;
      case c.LINE:
        te.randomVector3OnLine(this.attributes[i], e, h, d);
    }
    if (i === "acceleration") {
      var C = te.clamp(te.randomFloat(this.drag._value, this.drag._spread), 0, 1);
      this.attributes.acceleration.typedArray.array[4 * e + 3] = C;
    }
  }, t._assignAbsLifetimeValue = function(e, i) {
    var n, o = this.attributes[i].typedArray, r = this[i];
    te.arrayValuesAreEqual(r._value) && te.arrayValuesAreEqual(r._spread) ? (n = Math.abs(te.randomFloat(r._value[0], r._spread[0])), o.setVec4Components(e, n, n, n, n)) : o.setVec4Components(e, Math.abs(te.randomFloat(r._value[0], r._spread[0])), Math.abs(te.randomFloat(r._value[1], r._spread[1])), Math.abs(te.randomFloat(r._value[2], r._spread[2])), Math.abs(te.randomFloat(r._value[3], r._spread[3])));
  }, t._assignAngleValue = function(e) {
    var i, n = this.attributes.angle.typedArray, o = this.angle;
    te.arrayValuesAreEqual(o._value) && te.arrayValuesAreEqual(o._spread) ? (i = te.randomFloat(o._value[0], o._spread[0]), n.setVec4Components(e, i, i, i, i)) : n.setVec4Components(e, te.randomFloat(o._value[0], o._spread[0]), te.randomFloat(o._value[1], o._spread[1]), te.randomFloat(o._value[2], o._spread[2]), te.randomFloat(o._value[3], o._spread[3]));
  }, t._assignParamsValue = function(e) {
    this.attributes.params.typedArray.setVec4Components(e, this.isStatic ? 1 : 0, 0, Math.abs(te.randomFloat(this.maxAge._value, this.maxAge._spread)), te.randomFloat(this.wiggle._value, this.wiggle._spread));
  }, t._assignRotationValue = function(e) {
    this.attributes.rotation.typedArray.setVec3Components(e, te.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), te.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1), this.attributes.rotationCenter.typedArray.setVec3(e, this.rotation._center);
  }, t._assignColorValue = function(e) {
    te.randomColorAsHex(this.attributes.color, e, this.color._value, this.color._spread);
  }, t._resetParticle = function(e) {
    for (var i, n, o = this.resetFlags, r = this.updateFlags, a = this.updateCounts, g = this.attributeKeys, c = this.attributeCount - 1; c >= 0; --c)
      n = r[i = g[c]], o[i] !== !0 && n !== !0 || (this._assignValue(i, e), this._updateAttributeUpdateRange(i, e), n === !0 && a[i] === this.particleCount ? (r[i] = !1, a[i] = 0) : n === !0 && ++a[i]);
  }, t._updateAttributeUpdateRange = function(e, i) {
    var n = this.bufferUpdateRanges[e];
    n.min = Math.min(i, n.min), n.max = Math.max(i, n.max);
  }, t._resetBufferRanges = function() {
    for (var e, i = this.bufferUpdateRanges, n = this.bufferUpdateKeys, o = this.bufferUpdateCount - 1; o >= 0; --o)
      i[e = n[o]].min = Number.POSITIVE_INFINITY, i[e].max = Number.NEGATIVE_INFINITY;
  }, t._onRemove = function() {
    this.particlesPerSecond = 0, this.attributeOffset = 0, this.activationIndex = 0, this.activeParticleCount = 0, this.group = null, this.attributes = null, this.paramsArray = null, this.age = 0;
  }, t._decrementParticleCount = function() {
    --this.activeParticleCount;
  }, t._incrementParticleCount = function() {
    ++this.activeParticleCount;
  }, t._checkParticleAges = function(e, i, n, o) {
    for (var r, a, g, c, l = i - 1; l >= e; --l)
      (c = n[r = 4 * l]) !== 0 && (g = n[r + 1], a = n[r + 2], this.direction === 1 ? (g += o) >= a && (g = 0, c = 0, this._decrementParticleCount()) : (g -= o) <= 0 && (g = a, c = 0, this._decrementParticleCount()), n[r] = c, n[r + 1] = g, this._updateAttributeUpdateRange("params", l));
  }, t._activateParticles = function(e, i, n, o) {
    for (var r, a, g = this.direction, c = e; c < i; ++c)
      n[r = 4 * c] !== 0 && this.particleCount !== 1 || (this._incrementParticleCount(), n[r] = 1, this._resetParticle(c), a = o * (c - e), n[r + 1] = g === -1 ? n[r + 2] - a : a, this._updateAttributeUpdateRange("params", c));
  }, t.update = function(e) {
    if (!this.isStatic) {
      this.paramsArray === null && (this.paramsArray = this.attributes.params.typedArray.array);
      var i = this.attributeOffset, n = i + this.particleCount, o = this.paramsArray, r = this.particlesPerSecond * this.activeMultiplier * e, a = this.activationIndex;
      if (this._resetBufferRanges(), this._checkParticleAges(i, n, o, e), this.alive !== !1) {
        if (this.duration !== null && this.age > this.duration)
          return this.alive = !1, void (this.age = 0);
        var g = this.particleCount === 1 ? a : 0 | a, c = Math.min(g + r, this.activationEnd), l = c - this.activationIndex | 0, h = l > 0 ? e / l : 0;
        this._activateParticles(g, c, o, h), this.activationIndex += r, this.activationIndex > n && (this.activationIndex = i), this.age += e;
      } else
        this.age = 0;
    }
  }, t.reset = function(e) {
    if (this.age = 0, this.alive = !1, e === !0) {
      for (var i, n = this.attributeOffset, o = n + this.particleCount, r = this.paramsArray, a = this.attributes.params.bufferAttribute, g = o - 1; g >= n; --g)
        r[i = 4 * g] = 0, r[i + 1] = 0;
      a.updateRange.offset = 0, a.updateRange.count = -1, a.needsUpdate = !0;
    }
    return this;
  }, t.enable = function() {
    return this.alive = !0, this;
  }, t.disable = function() {
    return this.alive = !1, this;
  }, t.remove = function() {
    return this.group !== null ? this.group.removeEmitter(this) : console.error("Emitter does not belong to a group, cannot remove."), this;
  }, s;
}(), fw = function() {
  function s(e) {
    var i = te.types;
    (e = te.ensureTypedArg(e, i.OBJECT, {})).texture = te.ensureTypedArg(e.texture, i.OBJECT, {}), this.uuid = ce.generateUUID(), this.fixedTimeStep = te.ensureTypedArg(e.fixedTimeStep, i.NUMBER, 0.0167), this.texture = e.texture.value || null, this.textureFrames = e.texture.frames || new Z(1, 1), this.textureFrameCount = te.ensureTypedArg(e.texture.frameCount, i.NUMBER, this.textureFrames.x * this.textureFrames.y), this.textureLoop = te.ensureTypedArg(e.texture.loop, i.NUMBER, 1), this.textureFrames.max(new Z(1, 1)), this.hasPerspective = te.ensureTypedArg(e.hasPerspective, i.BOOLEAN, !0), this.colorize = te.ensureTypedArg(e.colorize, i.BOOLEAN, !0), this.maxParticleCount = te.ensureTypedArg(e.maxParticleCount, i.NUMBER, null), this.blending = te.ensureTypedArg(e.blending, i.NUMBER, NA), this.transparent = te.ensureTypedArg(e.transparent, i.BOOLEAN, !0), this.alphaTest = parseFloat(te.ensureTypedArg(e.alphaTest, i.NUMBER, 0)), this.depthWrite = te.ensureTypedArg(e.depthWrite, i.BOOLEAN, !1), this.depthTest = te.ensureTypedArg(e.depthTest, i.BOOLEAN, !0), this.fog = te.ensureTypedArg(e.fog, i.BOOLEAN, !0), this.scale = te.ensureTypedArg(e.scale, i.NUMBER, 300), this.emitters = [], this.emitterIDs = [], this._pool = [], this._poolCreationSettings = null, this._createNewWhenPoolEmpty = 0, this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !1, this.particleCount = 0, this.uniforms = { tex: { type: "t", value: this.texture }, textureAnimation: { type: "v4", value: new Me(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1)) }, fogColor: { type: "c", value: this.fog ? new Ce() : null }, fogNear: { type: "f", value: 10 }, fogFar: { type: "f", value: 200 }, fogDensity: { type: "f", value: 0.5 }, deltaTime: { type: "f", value: 0 }, runTime: { type: "f", value: 0 }, scale: { type: "f", value: this.scale } }, this.defines = { HAS_PERSPECTIVE: this.hasPerspective, COLORIZE: this.colorize, VALUE_OVER_LIFETIME_LENGTH: na.valueOverLifetimeLength, SHOULD_ROTATE_TEXTURE: !1, SHOULD_ROTATE_PARTICLES: !1, SHOULD_WIGGLE_PARTICLES: !1, SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1 }, this.attributes = { position: new En("v3", !0), acceleration: new En("v4", !0), velocity: new En("v3", !0), rotation: new En("v4", !0), rotationCenter: new En("v3", !0), params: new En("v4", !0), size: new En("v4", !0), angle: new En("v4", !0), color: new En("v4", !0), opacity: new En("v4", !0) }, this.attributeKeys = Object.keys(this.attributes), this.attributeCount = this.attributeKeys.length, this.material = new ze({ uniforms: this.uniforms, vertexShader: wp.vertex, fragmentShader: wp.fragment, blending: this.blending, transparent: this.transparent, alphaTest: this.alphaTest, depthWrite: this.depthWrite, depthTest: this.depthTest, defines: this.defines, fog: this.fog }), this.geometry = new Qe(), this.mesh = new Ug(this.geometry, this.material), this.maxParticleCount === null && console.warn("Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.");
  }
  var t = s.prototype;
  return t._updateDefines = function() {
    for (var e, i = this.emitters, n = this.defines, o = i.length - 1; o >= 0; --o)
      e = i[o], n.SHOULD_CALCULATE_SPRITE || (n.SHOULD_ROTATE_TEXTURE = n.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, e.angle.value), Math.max.apply(null, e.angle.spread))), n.SHOULD_ROTATE_PARTICLES = n.SHOULD_ROTATE_PARTICLES || !!Math.max(e.rotation.angle, e.rotation.angleSpread), n.SHOULD_WIGGLE_PARTICLES = n.SHOULD_WIGGLE_PARTICLES || !!Math.max(e.wiggle.value, e.wiggle.spread);
    this.material.needsUpdate = !0;
  }, t._applyAttributesToGeometry = function() {
    var e, i, n = this.attributes, o = this.geometry, r = o.attributes;
    Object.keys(n).forEach(function(a) {
      e = n[a], (i = r[a]) ? i.array = e.typedArray.array : o.setAttribute(a, e.bufferAttribute), e.bufferAttribute.needsUpdate = !0;
    }), this.geometry.setDrawRange(0, this.particleCount);
  }, t.addEmitter = function(e) {
    if (e instanceof po)
      if (this.emitterIDs.indexOf(e.uuid) > -1)
        console.error("Emitter already exists in this group. Will not add again.");
      else {
        if (e.group === null) {
          var i = this.attributes, n = this.particleCount, o = n + e.particleCount;
          for (var r in this.particleCount = o, this.maxParticleCount !== null && this.particleCount > this.maxParticleCount && console.warn("Group: maxParticleCount exceeded. Requesting", this.particleCount, "particles, can support only", this.maxParticleCount), e._calculatePPSValue(e.maxAge._value + e.maxAge._spread), e._setBufferUpdateRanges(this.attributeKeys), e._setAttributeOffset(n), e.group = this, e.attributes = this.attributes, i)
            i.hasOwnProperty(r) && i[r]._createBufferAttribute(this.maxParticleCount !== null ? this.maxParticleCount : this.particleCount);
          for (var a = n; a < o; ++a)
            e._assignPositionValue(a), e._assignForceValue(a, "velocity"), e._assignForceValue(a, "acceleration"), e._assignAbsLifetimeValue(a, "opacity"), e._assignAbsLifetimeValue(a, "size"), e._assignAngleValue(a), e._assignRotationValue(a), e._assignParamsValue(a), e._assignColorValue(a);
          return this._applyAttributesToGeometry(), this.emitters.push(e), this.emitterIDs.push(e.uuid), this._updateDefines(e), this.material.needsUpdate = !0, this.geometry.needsUpdate = !0, this._attributesNeedRefresh = !0, this;
        }
        console.error("Emitter already belongs to another group. Will not add to requested group.");
      }
    else
      console.error("`emitter` argument must be instance of Emitter. Was provided with:", e);
  }, t.removeEmitter = function(e) {
    var i = this.emitterIDs.indexOf(e, this.uuid);
    if (e instanceof po)
      if (i !== -1) {
        for (var n = e.attributeOffset, o = n + e.particleCount, r = this.attributes.params.typedArray, a = n; a < o; ++a)
          r.array[4 * a] = 0, r.array[4 * a + 1] = 0;
        for (var g in this.emitters.splice(i, 1), this.emitterIDs.splice(i, 1), this.attributes)
          this.attributes.hasOwnProperty(g) && this.attributes[g].splice(n, o);
        this.particleCount -= e.particleCount, e._onRemove(), this._attributesNeedRefresh = !0;
      } else
        console.error("Emitter does not exist in this group. Will not remove.");
    else
      console.error("`emitter` argument must be instance of Emitter. Was provided with:", e);
  }, t.getFromPool = function() {
    var e = this._pool, i = this._createNewWhenPoolEmpty;
    if (e.length)
      return e.pop();
    if (i) {
      var n = new po(this._poolCreationSettings);
      return this.addEmitter(n), n;
    }
    return null;
  }, t.releaseIntoPool = function(e) {
    if (e instanceof po)
      return e.reset(), this._pool.unshift(e), this;
    console.error("Argument is not instanceof Emitter:", e);
  }, t.getPool = function() {
    return this._pool;
  }, t.addPool = function(e, i, n) {
    var o;
    this._poolCreationSettings = i, this._createNewWhenPoolEmpty = !!n;
    for (var r = 0; r < e; ++r)
      o = Array.isArray(i) ? new po(i[r]) : new po(i), this.addEmitter(o), this.releaseIntoPool(o);
    return this;
  }, t._triggerSingleEmitter = function(e) {
    var i = this.getFromPool(), n = this;
    if (i !== null)
      return e instanceof B && (i.position.value.copy(e), i.position.value = i.position.value), i.enable(), setTimeout(function() {
        i.disable(), n.releaseIntoPool(i);
      }, 1e3 * Math.max(i.duration, i.maxAge.value + i.maxAge.spread)), this;
    console.log("Group pool ran out.");
  }, t.triggerPoolEmitter = function(e, i) {
    if (typeof e == "number" && e > 1)
      for (var n = 0; n < e; ++n)
        this._triggerSingleEmitter(i);
    else
      this._triggerSingleEmitter(i);
    return this;
  }, t._updateUniforms = function(e) {
    this.uniforms.runTime.value += e, this.uniforms.deltaTime.value = e;
  }, t._resetBufferRanges = function() {
    for (var e = this.attributeKeys, i = this.attributes, n = this.attributeCount - 1; n >= 0; --n)
      i[e[n]].resetUpdateRange();
  }, t._updateBuffers = function(e) {
    for (var i, n, o, r = this.attributeKeys, a = this.attributes, g = e.bufferUpdateRanges, c = this.attributeCount - 1; c >= 0; --c)
      n = g[i = r[c]], (o = a[i]).setUpdateRange(n.min, n.max), o.flagUpdate();
  }, t.update = function(e) {
    var i, n = this.emitters, o = n.length, r = e || this.fixedTimeStep, a = this.attributeKeys, g = this.attributes;
    if (this._updateUniforms(r), this._resetBufferRanges(), o !== 0 || this._attributesNeedRefresh !== !1 || this._attributesNeedDynamicReset !== !1) {
      for (var c, l = 0; l < o; ++l)
        (c = n[l]).update(r), this._updateBuffers(c);
      if (this._attributesNeedDynamicReset === !0) {
        for (i = this.attributeCount - 1; i >= 0; --i)
          g[a[i]].resetDynamic();
        this._attributesNeedDynamicReset = !1;
      }
      if (this._attributesNeedRefresh === !0) {
        for (i = this.attributeCount - 1; i >= 0; --i)
          g[a[i]].forceUpdateAll();
        this._attributesNeedRefresh = !1, this._attributesNeedDynamicReset = !0;
      }
    }
  }, t.dispose = function() {
    return this.geometry.dispose(), this.material.dispose(), this;
  }, s;
}();
class CD extends Wt {
  constructor(e, i) {
    super();
    f(this, "update", () => {
      this._system.update(this._clock.getDelta());
    });
    f(this, "createSnow", () => new Ot().load(pt("assets/textures/sky/others/snow.png")));
    f(this, "createEmitter", () => new po({
      maxAge: {
        value: 10
      },
      position: {
        value: new B(0, 100, 150),
        spread: new B(1e3, 1e3, 500)
      },
      acceleration: {
        value: new B(0, 0, -10),
        spread: new B(3, 3, 0)
      },
      velocity: {
        value: new B(0, 0, -10),
        spread: new B(5, 5, 0)
      },
      size: {
        value: 10
      },
      particleCount: 1e4
    }));
    this._renderer = e, this._camera = i, this._clock = new sb();
    const n = this._system = new fw({
      texture: {
        value: this.createSnow()
      },
      maxParticleCount: 1e4
    }), o = this._emitter = this.createEmitter(i, e);
    n.addEmitter(o), this.add(n.mesh);
  }
  dispose() {
  }
}
class fD extends Wt {
  constructor(e, i) {
    super();
    f(this, "update", () => {
      this._system.update(this._clock.getDelta());
    });
    f(this, "createRain", () => new Ot().load(pt("assets/textures/sky/others/trace_01.png")));
    f(this, "createEmitter", () => new po({
      maxAge: {
        value: 10
      },
      position: {
        value: new B(0, 100, 250),
        spread: new B(1e3, 1e3, 500)
      },
      acceleration: {
        value: new B(0, 0, -50),
        spread: new B(3, 3, 0)
      },
      velocity: {
        value: new B(0, 10, -50),
        spread: new B(3, 3, 0)
      },
      size: {
        value: 60
      },
      particleCount: 2e4
    }));
    this._clock = new sb();
    const n = this._system = new fw({
      texture: {
        value: this.createRain()
      },
      maxParticleCount: 2e4
    }), o = this._emitter = this.createEmitter(i, e);
    n.addEmitter(o), this.add(n.mesh);
  }
  dispose() {
  }
}
class _p extends Wt {
  constructor(e) {
    super();
    f(this, "_engine");
    f(this, "_sky");
    f(this, "_snow");
    f(this, "_rain");
    f(this, "_weather", "");
    f(this, "_currentConverageTextureType", null);
    f(this, "_tCoverageIntensity", null);
    f(this, "_skyGroundColorBlue", new Ce(1657983));
    f(this, "_skyGroundColorGray", new Ce(11184810));
    f(this, "_weatherChangedListeners", []);
    f(this, "_sunLightScale", 1);
    f(this, "_skyLightScale", 1);
    f(this, "transitionDuration", 1e3);
    f(this, "_transitionStartTime", 0);
    f(this, "_transitionStartState", {});
    f(this, "_transitionEndState", {});
    f(this, "_inTransition", !1);
    f(this, "_modifyCount", 0);
    f(this, "beforeRemoveFromEngine", (e) => {
      this._sky.sunLightIntensity = 1, this._sky.skyLightIntensity = 0.5, this._sky.cloudIntensity = 0.2, this._sky.mixGrayFactor = 0, this._engine.rendering.fog.density = 0, this._engine.rendering.composition.coverageIntensity = 0, e.removePrepareRenderListener(this.handleBeforeRender);
    });
    f(this, "handleBeforeRender", (e) => {
      if (this._snow) {
        const i = this._engine.camera.position;
        this._snow.position.copy(i), this._snow.update();
      }
      if (this._rain) {
        const i = this._engine.camera.position;
        this._rain.position.copy(i), this._rain.update();
      }
      if (this._modifyCount > 0 && (this._modifyCount = 0, this._transitionStartTime = Date.now(), this._inTransition = !0, this._transitionStartState = {
        sunLightIntensity: this._sky.sunLightIntensity / this._sunLightScale,
        cloudIntensity: this._sky.cloudIntensity,
        skyLightIntensity: this._sky.skyLightIntensity / this._skyLightScale,
        coverageIntensity: 0,
        fogDensity: this._engine.rendering.fog.density,
        mixGrayFactor: this._sky.mixGrayFactor
      }), this._inTransition) {
        const i = (Date.now() - this._transitionStartTime) / this.transitionDuration;
        i > 1 && (this._inTransition = !1), this._updateWeatherTransitionState(i), e.requestRender();
      }
    });
    f(this, "_updateWeatherTransitionState", (e) => {
      e < 0 && (e = 0), e > 1 && (e = 1);
      const i = this._transitionStartState, n = this._transitionEndState;
      this._sky.sunLightIntensity = ce.lerp(
        i.sunLightIntensity,
        n.sunLightIntensity,
        e
      ) * this._sunLightScale, this._sky.skyLightIntensity = ce.lerp(
        i.skyLightIntensity,
        n.skyLightIntensity,
        e
      ) * this._skyLightScale, this._sky.cloudCoverage = ce.lerp(
        i.cloudIntensity,
        n.cloudIntensity,
        e
      ), this._engine.rendering.fog.density = ce.lerp(
        i.fogDensity,
        n.fogDensity,
        e
      ), this._sky.mixGrayFactor = ce.lerp(
        i.mixGrayFactor,
        n.mixGrayFactor,
        e
      ), this._engine.rendering.composition.coverageIntensity = ce.lerp(
        i.coverageIntensity,
        n.coverageIntensity,
        e
      );
    });
    this._sky = e;
  }
  get weather() {
    return this._weather;
  }
  set weather(e) {
    if (!(!e || e === this._weather)) {
      this._weather = e, this.updateWeather(e);
      for (const i of this._weatherChangedListeners)
        i(e);
    }
  }
  afterAddToEngine(e) {
    this._engine = e, e.addPrepareRenderListener(this.handleBeforeRender), this.updateWeather(this._weather);
  }
  getCoverageTexture(e) {
    if (this._tCoverageIntensity === null || e !== this._currentConverageTextureType) {
      this._tCoverageIntensity && this._tCoverageIntensity.dispose();
      let i = "assets/textures/realistic/TexturesCom_Snow_Plain_3x3_512_noise.jpg";
      e === "rain" && (i = "assets/textures/realistic/TexturesCom_Ground_MudWet_512_roughness.jpg"), this._tCoverageIntensity = new Ot().load(
        pt(i),
        () => {
          this._engine.requestRender();
        }
      );
    }
    return this._tCoverageIntensity;
  }
  updateWeather(e) {
    const i = this._engine;
    let n = 1, o = 0.2, r = 0.5, a = 0, g = null, c = 0, l = 0, h = !1, d = !1;
    if (this._transitionStartState = {
      sunLightIntensity: this._sky.sunLightIntensity / this._sunLightScale,
      cloudIntensity: this._sky.cloudCoverage,
      skyLightIntensity: this._sky.skyLightIntensity / this._skyLightScale,
      coverageIntensity: 0,
      fogDensity: this._engine.rendering.fog.density,
      mixGrayFactor: this._sky.mixGrayFactor
    }, this._transitionEndState = this._transitionStartState, e === "clear")
      n = 1.2, o = 0, r = 0.8, c = 0, l = 0.1;
    else if (e === "partlyCloudy")
      n = 1, o = 0.46, r = 0.9, c = 0.05, l = 0.2;
    else if (e === "cloudy")
      n = 0, o = 0.53, r = 1, c = 0.5, l = 0.3;
    else if (e === "overcast")
      n = 0, o = 0.7, r = 0.4, c = 0.75, l = 0.4;
    else if (e === "foggy")
      n = 0, o = 0, r = 0.4, c = 1, l = 1;
    else if (e === "rainy")
      n = 0, o = 0, r = 0.4, d = !0, c = 1, l = 0.5;
    else if (e === "snowy")
      n = 0, o = 0, r = 0.4, a = 1, g = this.getCoverageTexture("snow"), h = !0, c = 1, l = 0.5;
    else
      return;
    if (this._transitionEndState = {
      sunLightIntensity: n,
      cloudIntensity: o,
      skyLightIntensity: r,
      coverageIntensity: a,
      fogDensity: l,
      mixGrayFactor: c
    }, this.tCoverageIntensity = g, this._sky.isStaticSky && (["overcast", "foggy", "rainy", "snowy"].includes(e) ? this._sky.weather = "overcast" : this._sky.weather = e), h) {
      if (!this._snow) {
        const C = this._snow = new CD(i.renderer, i.camera);
        this.add(C);
      }
    } else
      this._snow && (this.remove(this._snow), this._snow.dispose(), this._snow = null);
    if (d) {
      if (!this._rain) {
        const C = this._rain = new fD(i.renderer, i.camera);
        this.add(C);
      }
    } else
      this._rain && (this.remove(this._rain), this._rain.dispose(), this._rain = null);
    this.transitionDuration <= 0 ? this._updateWeatherTransitionState(1) : (this._transitionStartTime = Date.now(), this._inTransition = !0, i.requestRender());
  }
  addWeatherChangedListener(e) {
    this._weatherChangedListeners.indexOf(e) === -1 && this._weatherChangedListeners.push(e);
  }
  removeWeatherChangedListener(e) {
    const i = this._weatherChangedListeners.indexOf(e);
    i !== -1 && this._weatherChangedListeners.splice(i, 1);
  }
  get sunLightIntensity() {
    return this._transitionEndState.sunLightIntensity;
  }
  set sunLightIntensity(e) {
    this._modifyCount++, this._transitionEndState.sunLightIntensity = e;
  }
  get cloudIntensity() {
    return this._transitionEndState.cloudIntensity;
  }
  set cloudIntensity(e) {
    this._modifyCount++, this._transitionEndState.cloudIntensity = e;
  }
  get skyLightIntensity() {
    return this._transitionEndState.skyLightIntensity;
  }
  set skyLightIntensity(e) {
    this._modifyCount++, this._transitionEndState.skyLightIntensity = e;
  }
  get groundColor() {
    return this._sky.groundColor;
  }
  set groundColor(e) {
    this._sky.groundColor = e;
  }
  get mixGrayFactor() {
    return this._transitionEndState.mixGrayFactor;
  }
  set mixGrayFactor(e) {
    this._modifyCount++, this._transitionEndState.mixGrayFactor = e;
  }
  get coverageIntensity() {
    return this._transitionEndState.coverageIntensity;
  }
  set coverageIntensity(e) {
    this._modifyCount++, this._transitionEndState.coverageIntensity = e;
  }
  get tCoverageIntensity() {
    return this._engine.rendering.composition.tCoverageIntensity;
  }
  set tCoverageIntensity(e) {
    this._engine.rendering.composition.tCoverageIntensity = e;
  }
  get tRelectionEnhancement() {
    return this._engine.rendering.ssr.tEnhancement;
  }
  set tRelectionEnhancement(e) {
    this._engine.rendering.ssr.tEnhancement = e;
  }
  set fogDensity(e) {
    this._modifyCount++, this._transitionEndState.fogDensity = e;
  }
  get fogDensity() {
    return this._transitionEndState.fogDensity;
  }
  get skyLightScale() {
    return this._skyLightScale;
  }
  set skyLightScale(e) {
    this._skyLightScale = e;
  }
  get sunLightScale() {
    return this._sunLightScale;
  }
  set sunLightScale(e) {
    this._sunLightScale = e;
  }
}
const pD = [
  [0, -0.33333333333333337],
  [-0.5, 0.33333333333333326],
  [0.5, -0.7777777777777778],
  [-0.75, -0.11111111111111116],
  [0.25, 0.5555555555555554],
  [-0.25, -0.5555555555555556],
  [0.75, 0.11111111111111116],
  [-0.875, 0.7777777777777777],
  [0.125, -0.9259259259259259],
  [-0.375, -0.2592592592592593],
  [0.625, 0.40740740740740744],
  [-0.625, -0.7037037037037037],
  [0.375, -0.03703703703703709],
  [-0.125, 0.6296296296296293],
  [0.875, -0.4814814814814815],
  [-0.9375, 0.18518518518518512]
];
class pw {
  constructor(t) {
    f(this, "_lastTextureRequirementsKey", -1);
    f(this, "_inited", !1);
    f(this, "_useFastEmissiveMethod", !0);
    f(this, "_jitterOffsets", pD);
    f(this, "_jitterIndex", 0);
    this._rendering = t;
  }
  beginFrame() {
    if (!this._inited) {
      this._init(), this._inited = !0;
      return;
    }
    this._rendering.main.requirements.isTextureRequirementsChanged() && this._onTextureRequirementsChanged();
  }
  updateRenderTargetSamples(t) {
  }
  _onTextureRequirementsChanged() {
    this.dispose(), this._init();
  }
  _init() {
  }
  render() {
  }
  endFrame() {
  }
  dispose() {
  }
  get useFastEmissiveMethod() {
    return this._useFastEmissiveMethod;
  }
  set useFastEmissiveMethod(t) {
    this._useFastEmissiveMethod = t;
  }
}
const hi = "EPSG:4326", Mt = "EPSG:3857", zs = "EPSG:4978", Fg = "BD:MERCATOR", yY = "UTM", SY = "EPSG:8857", mw = "SCREEN_PIXEL", lc = 1, Nd = 2, Fd = 3, bY = 0, yw = 10, mD = 11, yD = 20, SD = 30;
class bD extends pw {
  constructor() {
    super(...arguments);
    f(this, "isDirectSceneRendering", !0);
  }
  _init() {
    this._rendering.main, this._onTextureRequirementsChanged();
  }
  beginFrame() {
    if (!this._inited) {
      this._init(), this._inited = !0;
      return;
    }
    this._rendering.main.requirements.isTextureRequirementsChanged() && this._onTextureRequirementsChanged();
  }
  _onTextureRequirementsChanged() {
    const e = this._rendering, i = e.resolution, n = e.pixelRatio;
    e.main.requirements.needsEmissiveTexture ? (this._emissiveRenderTarget = new It(i.x * n, i.y * n), this._emissiveRenderTarget.name = "EmissiveRenderTarget") : this._disposeEmissiveRenderTarget();
  }
  render() {
    const e = this._rendering, i = e.renderState, n = e.stats, o = e.main, r = e.renderer, a = e._renderer.xr.isPresenting ? e.xr.camera : e.camera, g = e.scene, c = e.resolution;
    e.pixelRatio;
    const l = o.requirements;
    if (!i.viewChanged && l.enableRenderingJitter) {
      let [h, d] = this._jitterOffsets[this._debugEngineJitterIndex !== void 0 ? this._debugEngineJitterIndex : this._jitterIndex];
      a.setViewOffset(
        c.x,
        c.y,
        h / 2,
        d / 2,
        c.x,
        c.y
      ), this._jitterIndex = (this._jitterIndex + 1) % this._jitterOffsets.length;
    }
    if (r.extraProgramCacheKey = l.currentShaderKey, this.renderTarget) {
      if (!this._sceneRenderTarget || l.isRenderTargetTypeChanged()) {
        this._sceneRenderTarget && (this._sceneRenderTarget.dispose(), this._sceneRenderTarget = null);
        const h = e.resolution, d = e.pixelRatio, C = this._tDepth = new Dh();
        C.generateMipmaps = !1, this._sceneRenderTarget = new It(h.x * d, h.y * d, {
          type: l.getRenderTargetType()
        }), this._sceneRenderTarget.name = "SceneRenderTarget", l.enableStencilBuffer && (C.format = ob, C.type = FA, this._sceneRenderTarget.stencilBuffer = !0), this._sceneRenderTarget.depthTexture = C, this._sceneRenderTarget.samples = e.features.antialias.samples;
      }
      r.setRenderTarget(this._sceneRenderTarget);
    } else
      r.getRenderTarget() && r.getRenderTarget().isXRRenderTarget || r.setRenderTarget(null), this._sceneRenderTarget && (this._sceneRenderTarget.dispose(), this._sceneRenderTarget = null);
    if (n.beginTimeStatsItem("renderScene"), r.render(g, a), n.endTimeStatsItem("renderScene"), this.renderTarget ? (this._fsQuad || (this._fsQuad = new Ut(new ze({
      name: "DirectSceneRenderingCopy",
      vertexShader: Ht.vertexShader,
      fragmentShader: Ht.fragmentShader,
      blending: jl,
      depthTest: !1,
      uniforms: {
        tDiffuse: {
          value: this._sceneRenderTarget.texture
        },
        opacity: {
          value: 1
        }
      }
    }))), this._fsQuad.material.uniforms.tDiffuse.value = this._sceneRenderTarget.texture, r.setRenderTarget(this.renderTarget), this._fsQuad.render(r)) : this._fsQuad && (this._fsQuad.dispose(), this._fsQuad = null), e.opaquePostprocessings.hide(), l.needsEmissiveTexture) {
      i.stage = mD, r.extraProgramCacheKey = l.currentShaderKey + ",emissive";
      const h = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
      let C = null;
      g.traverseVisible((S) => {
        if (C = S.material, C) {
          if (this._useFastEmissiveMethod && !this._isEmissiveMaterial(C)) {
            S.visible = !1, h.add(S);
            return;
          }
          C.defines || (C.defines = {}), C.defines.MVT_MODE_EMISSIVE = !0, d.add(S);
        }
      }), this._useFastEmissiveMethod ? this._emissiveRenderTarget.depthTexture = this._sceneRenderTarget.depthTexture : this._emissiveRenderTarget.depthTexture && (this._emissiveRenderTarget.depthTexture = null), n.beginTimeStatsItem("renderEmissiveTexture"), r.setRenderTarget(this._emissiveRenderTarget);
      const p = r.autoClear;
      this._useFastEmissiveMethod && (r.autoClear = !1, r.clear(!0, !1, !0));
      const m = g.background;
      g.background = null;
      const b = r.shadowMap.enabled;
      r.shadowMap.enabled = !1, r.render(g, a), g.background = m, r.autoClear = p, r.shadowMap.enabled = b, n.endTimeStatsItem("renderEmissiveTexture");
      for (const S of d)
        S.material.defines.MVT_MODE_EMISSIVE = !1;
      if (this._useFastEmissiveMethod)
        for (const S of h)
          S.visible = !0;
      r.extraProgramCacheKey = "", r.setRenderTarget(this.renderTarget);
    }
    a.setViewOffset(
      c.x,
      c.y,
      0,
      0,
      c.x,
      c.y
    );
  }
  updateRenderTargetSamples(e) {
    const i = this._sceneRenderTarget;
    i && (i.samples = e);
  }
  _isBlackColor(e) {
    return e.r === 0 && e.g === 0 && e.b === 0;
  }
  _isEmissiveMaterial(e) {
    if (e.disableEmissive)
      return !1;
    if (e.isShaderMaterial || e.isRawShaderMaterial)
      return !0;
    if (e.isMeshBasicMaterial)
      return e.emissive && !this._isBlackColor(e.emissive);
    if (e.isMeshStandardMaterial || e.isMeshPhongMaterial || e.isMeshLambertMaterial || e.isMeshToonMaterial)
      return e.emissive && !this._isBlackColor(e.emissive) || !!e.emissiveMap;
  }
  _disposeEmissiveRenderTarget() {
    this._emissiveRenderTarget && (this._sceneRenderTarget && this._emissiveRenderTarget.depthTexture === this._sceneRenderTarget.depthTexture && (this._emissiveRenderTarget.depthTexture = null), this._emissiveRenderTarget.dispose(), this._emissiveRenderTarget = null);
  }
  dispose() {
    const i = this._rendering.stats;
    i.removeTimeStatsItem("renderScene"), i.removeTimeStatsItem("renderEmissiveTexture"), this._disposeEmissiveRenderTarget(), this._fsQuad && (this._fsQuad.dispose(), this._fsQuad = null);
  }
  setSize(e, i) {
    const n = this._rendering;
    n.resolution;
    const o = n.pixelRatio;
    this._emissiveRenderTarget && this._emissiveRenderTarget.setSize(e * o, i * o), this._sceneRenderTarget && this._sceneRenderTarget.setSize(e * o, i * o);
  }
  get emissiveTexture() {
    return this._emissiveRenderTarget && this._emissiveRenderTarget.texture;
  }
  get depthTexture() {
    return this._sceneRenderTarget && this._sceneRenderTarget.depthTexture;
  }
  get diffuseTexture() {
    return this._sceneRenderTarget && this._sceneRenderTarget.texture;
  }
}
class BD extends pw {
  constructor() {
    super(...arguments);
    f(this, "isMRTSceneRendering", !0);
  }
  _init() {
    const e = this._rendering, i = e.resolution, n = e.main.requirements;
    let o = 1, r = {}, a = "";
    n.needsEmissiveTexture && (r.emissive = o, a += `#define MVT_MRT_OUT_EMISSIVE ${o}
`, o++), (n.needsNormalTextureWhenMRT || n.needsNormalTexture) && (r.normal = o, a += `#define MVT_MRT_OUT_NORMAL ${o}
`, o++), n.needsMetallicRoughTexture && (r.metallicRough = o, a += `#define MVT_MRT_OUT_METALLICROUGH ${o}
`, o++), this._textureChannelNameMap = r, a += `#include <mvt_mrt_output_pars_fragment>
`, this._fragBeforeMainStart = a, this._fragBeforeMainEnd = `#include <mvt_mrt_output_fragment>
`;
    const g = this._mainMrt = new rb(
      i.x * e.pixelRatio,
      i.y * e.pixelRatio,
      o,
      {
        samples: e.features.antialias.samples
      }
    ), c = this._tDepth = new Dh();
    c.generateMipmaps = !1, n.enableStencilBuffer && (c.format = ob, c.type = FA, g.stencilBuffer = !0), g.depthTexture = c, g.depthBuffer = !0;
    for (let l = 0, h = g.texture.length; l < h; l++)
      g.texture[l].minFilter = cs, g.texture[l].magFilter = cs, g.texture[l].format = Hs;
    g.texture.isTexture = !0, this._fsQuad || (this._fsQuad = new Ut(new ze({
      name: Ht.name,
      vertexShader: Ht.vertexShader,
      fragmentShader: Ht.fragmentShader,
      uniforms: {
        tDiffuse: {
          value: g.texture[0]
        },
        opacity: {
          value: 1
        }
      }
    })));
  }
  render() {
    const e = this._rendering, i = e.stats, n = e.renderer, o = e.main.requirements;
    n.extraProgramCacheKey = "mrt-" + o.currentTextureRequirementsKey + o.currentShaderKey, n.setRenderTarget(this._mainMrt), i.beginTimeStatsItem("renderMRTScene"), n.render(e.scene, e.camera), i.endTimeStatsItem("renderMRTScene"), n.extraProgramCacheKey = "", n.setRenderTarget(this.renderTarget), this._fsQuad.render(n);
  }
  updateRenderTargetSamples(e) {
    const i = this._mainMrt;
    i.samples = e;
  }
  modifyFragmentShader(e) {
    return YB(e, this._fragBeforeMainStart, null, this._fragBeforeMainEnd);
  }
  dispose() {
    this._rendering.stats.removeTimeStatsItem("renderMRTScene"), this._tDepth && (this._tDepth.dispose(), this._tDepth = null), this._mainMrt && (this._mainMrt.dispose(), this._mainMrt = null), this._fsQuad && (this._fsQuad.dispose(), this._fsQuad = null);
  }
  setSize(e, i) {
    const n = this._rendering, o = this._mainMrt;
    o && o.setSize(e * n.pixelRatio, i * n.pixelRatio);
  }
  get emissiveTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.emissive];
  }
  get normalTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.normal];
  }
  get metallicRoughTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.metallicRough];
  }
  get depthTexture() {
    return this._tDepth;
  }
  get diffuseTexture() {
    return this._mainMrt && this._mainMrt.texture[0];
  }
  get highPDepthTexture() {
    return this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.depth];
  }
}
class wD {
  constructor(t) {
    f(this, "needsEmissiveTexture", !1);
    f(this, "needsNormalTexture", !1);
    f(this, "needsNormalTextureWhenMRT", !1);
    f(this, "needsDepthTexture", !1);
    f(this, "needsMetallicRoughTexture", !1);
    f(this, "enableStencilBuffer", !1);
    f(this, "enableRenderingJitter", !1);
    f(this, "needsFloatRenderTarget", !1);
    f(this, "_lastNeedsFloatRenderTarget", null);
    f(this, "_lastTextureRequirementsKey", -1);
    f(this, "_currentTextureRequirementsKey", -1);
    f(this, "featuresShaderKey", "");
    this._rendering = t, this._renderingMain = t.main;
  }
  beginFrame() {
    this._resetTextureRequirements(), this._updateRequirements(), this._currentTextureRequirementsKey = this._updateTextureRequirementsKey();
  }
  _updateRequirements() {
    const t = this._renderingMain, e = t.features, i = t.postprocessings;
    this._rendering.useHighPrecisionBuffer && (this.needsFloatRenderTarget = !0), e.updateReqirements(this), i.updateReqirements(this);
  }
  _resetTextureRequirements() {
    this.needsEmissiveTexture = !1, this.needsNormalTexture = !1, this.needsNormalTextureWhenMRT = !1, this.needsDepthTexture = !1, this.needsMetallicRoughTexture = !1, this.enableStencilBuffer = !0, this.enableRenderingJitter = !1, this.needsFloatRenderTarget = !1;
  }
  _updateTextureRequirementsKey() {
    let t = 0;
    return this.needsEmissiveTexture && (t |= 1), this.needsNormalTexture && (t |= 2), this.needsDepthTexture && (t |= 4), this.needsMetallicRoughTexture && (t |= 8), this.enableStencilBuffer && (t |= 16), t;
  }
  isTextureRequirementsChanged() {
    return this._lastTextureRequirementsKey !== this._currentTextureRequirementsKey;
  }
  isRenderTargetTypeChanged() {
    return this._lastNeedsFloatRenderTarget !== this.needsFloatRenderTarget;
  }
  getRenderTargetType() {
    return this.needsFloatRenderTarget ? xi : Pi;
  }
  endFrame() {
    this._lastTextureRequirementsKey = this._currentTextureRequirementsKey, this._lastNeedsFloatRenderTarget = this.needsFloatRenderTarget;
  }
  get currentTextureRequirementsKey() {
    return this._currentTextureRequirementsKey;
  }
  get currentShaderKey() {
    return this.featuresShaderKey;
  }
}
class _D extends Xi {
  constructor(t, e) {
    super(), this.textureID = e !== void 0 ? e : "tDiffuse", t instanceof ze ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = we.clone(t.uniforms), this.material = new ze({
      name: t.name !== void 0 ? t.name : "unspecified",
      defines: Object.assign({}, t.defines),
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    })), this.fsQuad = new Ut(this.material);
  }
  render(t, e, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const xD = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
};
class vD extends Xi {
  constructor() {
    super();
    const t = xD;
    this.uniforms = we.clone(t.uniforms), this.material = new eT({
      name: t.name,
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: t.fragmentShader
    }), this.fsQuad = new Ut(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(t, e, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = t.toneMappingExposure, (this._outputColorSpace !== t.outputColorSpace || this._toneMapping !== t.toneMapping) && (this._outputColorSpace = t.outputColorSpace, this._toneMapping = t.toneMapping, this.material.defines = {}, Jl.getTransfer(this._outputColorSpace) === ab && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === gb ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === cb ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === lb ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === hb && (this.material.defines.ACES_FILMIC_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class TD extends Xi {
  constructor(t) {
    super(), this.name = "UIPass", this.needsSwap = !1, this.rendering = t, this.camera = t.camera, this._outputColorSpace = null, this._toneMapping = null, this._uiScene = null, this.material = new ze(Ht), this.material.name = "UIPassCopyShader", this.fsQuad = new Ut(this.material);
  }
  render(t, e, i) {
    const n = this._uiScene = this.rendering.uiScene;
    n.visible = !0, t.setRenderTarget(i), (this._outputColorSpace !== t.outputColorSpace || this._toneMapping !== t.toneMapping) && (this._outputColorSpace = t.outputColorSpace, this._toneMapping = t.toneMapping, n.traverse((o) => {
      const r = o.material;
      r && (Jl.getTransfer(this._outputColorSpace) === ab && (r.uniforms.srgbTransformer = { value: !0 }), this._toneMapping === gb ? r.uniforms.isLinearToneMapping = { value: !0 } : this._toneMapping === cb ? r.uniforms.isReinhardToneMapping = { value: !0 } : this._toneMapping === lb ? r.uniforms.isCineonToneMapping = { value: !0 } : this._toneMapping === hb && (r.uniforms.isACESFilmicToneMapping = { value: !0 }));
    })), t.autoClear = !1, t.render(n, this.camera), t.autoClear = !0, this.renderToScreen === !0 && (t.setRenderTarget(null), this.material.uniforms.tDiffuse.value = i.texture, this.fsQuad.render(t)), n.visible = !1;
  }
  dispose() {
    this.material.dispose(), this.material = null, this.fsQuad.dispose(), this.fsQuad = null;
  }
}
class Sw {
  constructor(t) {
    f(this, "_postprocessings", []);
    f(this, "_validCount", 0);
    f(this, "_composer", null);
    f(this, "_outputPass", null);
    f(this, "_samples", 0);
    this._rendering = t;
  }
  setSize(t, e) {
    this._composer && this._composer.setSize(t, e);
    for (const i of this._postprocessings)
      i.setSize && i.setSize(t, e);
  }
  beginFrame() {
    if (this._outputPass || (this._outputPass = new vD(), this._outputPass.renderOrder = 200, this.add(this._outputPass)), !this._uiPass) {
      const i = this._uiPass = new TD(this._rendering);
      i.material.transparent = !0, i.renderOrder = 3e3, this.add(i);
    }
    const e = this._rendering.uiScene.children.length > 0;
    this._uiPass.enabled = e, this._updatePostprocessings();
  }
  _updatePostprocessings() {
    let t = 0;
    for (let e = 0, i = this._postprocessings.length; e < i; e++)
      this._postprocessings[e].enabled && t++;
    this._validCount = t;
  }
  add(t) {
    this._postprocessings.indexOf(t) === -1 && (t.rendering = this._rendering, this._postprocessings.push(t)), this._postprocessings.sort((e, i) => {
      const n = e.renderOrder || 0, o = i.renderOrder || 0;
      return n - o;
    });
  }
  remove(t) {
    const e = this._postprocessings.indexOf(t);
    e !== -1 && this._postprocessings.splice(e, 1);
  }
  render() {
    if (this._validCount <= 0)
      return;
    const t = this._rendering, e = t.sharedFullScreenRenderTargets, i = t.stats;
    i.beginTimeStatsItem("postprocessingRender");
    let n = t.renderer.getRenderTarget(), o = e.getAvailableRenderTarget();
    const r = t.renderState.deltaTime / 1e3;
    let a = this._validCount - 1, g = 0;
    for (let c = 0, l = this._postprocessings.length; c < l; c++) {
      const h = this._postprocessings[c];
      if (!!h.enabled) {
        if (a === g ? h.renderToScreen = !0 : h.renderToScreen = !1, h.render(t.renderer, o, n, r), h.needsSwap && a !== g) {
          let d = n;
          n = o, o = d;
        }
        g++;
      }
    }
    e.releaseRenderTarget(n), i.endTimeStatsItem("postprocessingRender");
  }
  updateReqirements(t) {
    for (const e of this._postprocessings)
      !e.enabled || (e.needsEmissiveTexture && (t.needsEmissiveTexture = !0), e.needsNormalTexture && (t.needsNormalTexture = !0), e.needsNormalTextureWhenMRT && (t.needsNormalTextureWhenMRT = !0), e.needsDepthTexture && (t.needsDepthTexture = !0), e.needsMetallicRoughTexture && (t.needsMetallicRoughTexture = !0), e.enableStencilBuffer && (t.enableStencilBuffer = !0), e.enableRenderingJitter && (t.enableRenderingJitter = !0));
  }
  endFrame() {
  }
  dispose() {
    this._postprocessingRenderTarget1 && (this._postprocessingRenderTarget1.dispose(), this._postprocessingRenderTarget1 = null);
  }
  get renderTarget1() {
    return this._postprocessingRenderTarget1;
  }
  get validCount() {
    return this._validCount;
  }
  get postprocessings() {
    return this._postprocessings;
  }
}
class LD extends Sw {
  constructor(e) {
    super(e);
    f(this, "_handleMeshBeforeRender", (e, i, n) => {
      if (this._rendering.renderState.stage !== yw || this._validCount <= 0)
        return;
      const r = this._rendering.sharedFullScreenRenderTargets;
      let a = e.getRenderTarget();
      const g = a;
      this._updateMultisampleRenderTarget(e, a);
      let c = r.getAvailableRenderTarget();
      const l = c;
      let h = null;
      const d = this._postprocessings;
      let C = this._validCount - 1, p = 0;
      for (let m = 0, b = d.length; m < b; m++) {
        const S = d[m];
        if (S.enabled) {
          if (S.render(e, c, a), C !== p && S.needsSwap)
            if (a === g)
              a = c, c = r.getAvailableRenderTarget(), h = c;
            else {
              let A = a;
              a = c, c = A;
            }
          p++;
        }
      }
      this._mesh.material.uniforms.tDiffuse.value = c.texture, r.releaseRenderTarget(l), h && r.releaseRenderTarget(h), e.setRenderTarget(g);
    });
    this._postprocessings = [], this._testRenderTarget = new It(1, 1, {}), this._testScene = new le(new Nt(1, 1, 1), new _t({})), this._testScene.frustumCulled = !1;
  }
  beginFrame() {
    if (this._updatePostprocessings(), this._rendering, this._validCount > 0) {
      if (!this._mesh) {
        const e = this._geometry = new Qe();
        e.setAttribute("position", new ae([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), e.setAttribute("uv", new ae([0, 2, 0, 0, 2, 0], 2));
        const i = this._material = new ze({
          depthTest: !1,
          name: "OpaquePostprocessingsCopy",
          uniforms: {
            tDiffuse: { value: null }
          },
          vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
          fragmentShader: `
                        uniform sampler2D tDiffuse;
                        varying vec2 vUv;

                        void main() {
                            vec4 color = texture2D(tDiffuse, vUv);
                            gl_FragColor = color;
                            // gl_FragColor = vec4(1.0, .0, .0, 1.0);
                        }
                    `
        }), n = this._mesh = new le(e, i);
        n.isFSQuad = !0, n.frustumCulled = !1, n.renderOrder = 1e9, n.onBeforeRender = this._handleMeshBeforeRender, this._rendering.add(n);
      }
      this._mesh.visible = !0;
    } else
      this._mesh && (this._mesh.visible = !1);
  }
  add(e) {
    super.add(e);
    const i = e.material;
    i.defines ? i.defines.USE_OPAQUE_POST_STAGE = !0 : i.defines = {
      USE_OPAQUE_POST_STAGE: !0
    }, i.needsUpdate = !0;
  }
  _useMultisampledRTT(e, i) {
    const n = e.properties, o = e.extensions, a = e.capabilities.isWebGL2, g = n.get(i);
    return a && i.samples > 0 && o.has("WEBGL_multisampled_render_to_texture") === !0 && g.__useRenderToTexture !== !1;
  }
  _updateMultisampleRenderTarget(e, i) {
    if (e.capabilities.isWebGL2 && i.samples > 0 && this._useMultisampledRTT(e, i) === !1) {
      const r = e.getContext(), a = e.state, g = e.properties, c = i.isWebGLMultipleRenderTargets ? i.texture : [i.texture], l = i.width, h = i.height;
      let d = r.COLOR_BUFFER_BIT;
      const C = [], p = i.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, m = g.get(i), b = i.isWebGLMultipleRenderTargets === !0;
      if (b)
        for (let S = 0; S < c.length; S++)
          a.bindFramebuffer(r.FRAMEBUFFER, m.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + S, r.RENDERBUFFER, null), a.bindFramebuffer(r.FRAMEBUFFER, m.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + S, r.TEXTURE_2D, null, 0);
      a.bindFramebuffer(r.READ_FRAMEBUFFER, m.__webglMultisampledFramebuffer), a.bindFramebuffer(r.DRAW_FRAMEBUFFER, m.__webglFramebuffer);
      for (let S = 0; S < c.length; S++) {
        C.push(r.COLOR_ATTACHMENT0 + S), i.depthBuffer && C.push(p);
        const A = m.__ignoreDepthValues !== void 0 ? m.__ignoreDepthValues : !1;
        if (A === !1 && i.depthBuffer && (d |= r.DEPTH_BUFFER_BIT), b && r.framebufferRenderbuffer(
          r.READ_FRAMEBUFFER,
          r.COLOR_ATTACHMENT0,
          r.RENDERBUFFER,
          m.__webglColorRenderbuffer[S]
        ), A === !0 && (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [p]), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [p])), b) {
          const u = g.get(c[S]).__webglTexture;
          r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, u, 0);
        }
        r.blitFramebuffer(0, 0, l, h, 0, 0, l, h, d, r.NEAREST);
      }
      if (a.bindFramebuffer(r.READ_FRAMEBUFFER, null), a.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), b)
        for (let S = 0; S < c.length; S++) {
          a.bindFramebuffer(r.FRAMEBUFFER, m.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(
            r.FRAMEBUFFER,
            r.COLOR_ATTACHMENT0 + S,
            r.RENDERBUFFER,
            m.__webglColorRenderbuffer[S]
          );
          const A = g.get(c[S]).__webglTexture;
          a.bindFramebuffer(r.FRAMEBUFFER, m.__webglFramebuffer), r.framebufferTexture2D(
            r.DRAW_FRAMEBUFFER,
            r.COLOR_ATTACHMENT0 + S,
            r.TEXTURE_2D,
            A,
            0
          );
        }
      a.bindFramebuffer(r.DRAW_FRAMEBUFFER, m.__webglMultisampledFramebuffer);
    }
  }
  _updatePostprocessings() {
    let e = 0;
    for (let i = 0, n = this._postprocessings.length; i < n; i++)
      this._postprocessings[i].enabled && e++;
    this._validCount = e;
  }
  render() {
  }
  endFrame() {
  }
  setSize(e, i) {
  }
  show() {
    this._mesh && (this._mesh.visible = !0);
  }
  hide() {
    this._mesh && (this._mesh.visible = !1);
  }
  dispose() {
    this._renderTarget && (this._renderTarget.dispose(), this._renderTarget = null), this._mesh && (this._rendering.remove(this._mesh), this._mesh.geometry.dispose(), this._mesh.material.dispose(), this._mesh = null);
  }
}
const GD = {
  name: "LuminosityHighPassShader",
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new Ce(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
};
class Ba extends Xi {
  constructor(t, e, i, n) {
    super(), this.strength = e !== void 0 ? e : 1, this.radius = i, this.threshold = n, this.resolution = t !== void 0 ? new Z(t.x, t.y) : new Z(256, 256), this.clearColor = new Ce(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let o = Math.round(this.resolution.x / 2), r = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new It(o, r, { type: xi }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let h = 0; h < this.nMips; h++) {
      const d = new It(o, r, { type: xi });
      d.texture.name = "UnrealBloomPass.h" + h, d.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(d);
      const C = new It(o, r, { type: xi });
      C.texture.name = "UnrealBloomPass.v" + h, C.texture.generateMipmaps = !1, this.renderTargetsVertical.push(C), o = Math.round(o / 2), r = Math.round(r / 2);
    }
    const a = GD;
    this.highPassUniforms = we.clone(a.uniforms), this.highPassUniforms.luminosityThreshold.value = n, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new ze({
      uniforms: this.highPassUniforms,
      vertexShader: a.vertexShader,
      fragmentShader: a.fragmentShader
    }), this.separableBlurMaterials = [];
    const g = [3, 5, 7, 9, 11];
    o = Math.round(this.resolution.x / 2), r = Math.round(this.resolution.y / 2);
    for (let h = 0; h < this.nMips; h++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(g[h])), this.separableBlurMaterials[h].uniforms.invSize.value = new Z(1 / o, 1 / r), o = Math.round(o / 2), r = Math.round(r / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = e, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
    const c = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [new B(1, 1, 1), new B(1, 1, 1), new B(1, 1, 1), new B(1, 1, 1), new B(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
    const l = Ht;
    this.copyUniforms = we.clone(l.uniforms), this.blendMaterial = new ze({
      uniforms: this.copyUniforms,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader,
      blending: NA,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Ce(), this.oldClearAlpha = 1, this.basic = new _t(), this.fsQuad = new Ut(null);
  }
  dispose() {
    for (let t = 0; t < this.renderTargetsHorizontal.length; t++)
      this.renderTargetsHorizontal[t].dispose();
    for (let t = 0; t < this.renderTargetsVertical.length; t++)
      this.renderTargetsVertical[t].dispose();
    this.renderTargetBright.dispose();
    for (let t = 0; t < this.separableBlurMaterials.length; t++)
      this.separableBlurMaterials[t].dispose();
    this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
  }
  setSize(t, e) {
    let i = Math.round(t / 2), n = Math.round(e / 2);
    this.renderTargetBright.setSize(i, n);
    for (let o = 0; o < this.nMips; o++)
      this.renderTargetsHorizontal[o].setSize(i, n), this.renderTargetsVertical[o].setSize(i, n), this.separableBlurMaterials[o].uniforms.invSize.value = new Z(1 / i, 1 / n), i = Math.round(i / 2), n = Math.round(n / 2);
  }
  render(t, e, i, n, o) {
    t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha();
    const r = t.autoClear;
    t.autoClear = !1, t.setClearColor(this.clearColor, 0), o && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t);
    let a = this.renderTargetBright;
    for (let g = 0; g < this.nMips; g++)
      this.fsQuad.material = this.separableBlurMaterials[g], this.separableBlurMaterials[g].uniforms.colorTexture.value = a.texture, this.separableBlurMaterials[g].uniforms.direction.value = Ba.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[g]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[g].uniforms.colorTexture.value = this.renderTargetsHorizontal[g].texture, this.separableBlurMaterials[g].uniforms.direction.value = Ba.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[g]), t.clear(), this.fsQuad.render(t), a = this.renderTargetsVertical[g];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, o && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(i), this.fsQuad.render(t)), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = r;
  }
  getSeperableBlurMaterial(t) {
    const e = [];
    for (let i = 0; i < t; i++)
      e.push(0.39894 * Math.exp(-0.5 * i * i / (t * t)) / t);
    return new ze({
      defines: {
        KERNEL_RADIUS: t
      },
      uniforms: {
        colorTexture: { value: null },
        invSize: { value: new Z(0.5, 0.5) },
        direction: { value: new Z(0.5, 0.5) },
        gaussianCoefficients: { value: e }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  getCompositeMaterial(t) {
    return new ze({
      defines: {
        NUM_MIPS: t
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
}
Ba.BlurDirectionX = new Z(1, 0);
Ba.BlurDirectionY = new Z(0, 1);
class Vn {
  constructor(t, e = {}) {
    f(this, "_enabled", !1);
    f(this, "name", "");
    f(this, "needsShaderKey", !1);
    this._options = e, this._enabled = !!e.enabled, this._rendering = t;
  }
  beginFrame() {
  }
  render() {
  }
  endFrame() {
  }
  getCurrentShaderKey() {
    return "";
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    this._enabled = !!t;
  }
}
class MD extends Vn {
  constructor() {
    super(...arguments);
    f(this, "name", "bloom");
    f(this, "_lastEnabled", !1);
    f(this, "_strength", 0.1);
    f(this, "_threshold", 1);
    f(this, "_radius", 0);
    f(this, "needsFloatRenderTarget", !0);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
    this.enabled;
  }
  _init() {
    const e = this._rendering, i = e.resolution, n = e.main, o = e.pixelRatio;
    this._bloomRenderTarget = new It(
      i.x * o,
      i.y * o,
      {
        type: xi
      }
    ), this._bloomRenderTarget.name = "bloomRenderTarget";
    const r = new Z();
    r.set(i.x * o, i.y * o);
    const a = this._bloomRenderPass = new Ba(r, this._strength, this._radius, this._threshold);
    a.renderOrder = 70, n.postprocessings.add(a), n.useMRT;
  }
  afterRender() {
    if (this.enabled) {
      const e = this._rendering;
      e.main, e.stats;
    }
  }
  getCurrentUsedTextures() {
    if (this.enabled)
      return [this._bloomRenderTarget.texture];
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._rendering.stats, this._bloomRenderPass && (this._rendering.main.postprocessings.remove(this._bloomRenderPass), this._bloomRenderPass.dispose(), this._bloomRenderPass = null);
  }
  get strength() {
    return this._strength;
  }
  set strength(e) {
    this._strength = e, this._bloomRenderPass && (this._bloomRenderPass.strength = e);
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    this._radius = e, this._bloomRenderPass && (this._bloomRenderPass.radius = e);
  }
  get threshold() {
    return this._threshold;
  }
  set threshold(e) {
    this._threshold = e, this._bloomRenderPass && (this._bloomRenderPass.threshold = e);
  }
}
const ED = `
struct TextureInfo {
    vec2 offset;
    vec2 scale;
};
uniform sampler2D maps[MVT_TEXTURE_COUNT];
uniform sampler2D tDiffuse;
varying vec2 vUv;

uniform TextureInfo textureInfos[MVT_TEXTURE_COUNT];

void addTextureColor(sampler2D map, TextureInfo textureInfo) {
    vec2 transformedUv = (vUv - textureInfo.offset) * textureInfo.scale;
    if (transformedUv.x >= 0.0 && transformedUv.x <= 1.0 && transformedUv.y >= 0.0 && transformedUv.y <= 1.0) {
        // gl_FragColor += texture2D(map, transformedUv);
        vec4 sampleColor = texture2D(map, transformedUv);
        gl_FragColor.rgb = mix(sampleColor.rgb, gl_FragColor.rgb, 1.0 - sampleColor.a);
        gl_FragColor.a += sampleColor.a;
        // gl_FragColor = sampleColor + gl_FragColor;
    }
}
void main() {

    gl_FragColor = texture2D(tDiffuse, vUv);
    // gl_FragColor = vec4(0.5, 0, 0, 0.5);
    #if MVT_TEXTURE_COUNT > 0
        addTextureColor(maps[0], textureInfos[0]);
    #endif

    #if MVT_TEXTURE_COUNT > 1
        addTextureColor(maps[1], textureInfos[1]);
    #endif

    #if MVT_TEXTURE_COUNT > 2
        addTextureColor(maps[2], textureInfos[2]);
    #endif

    #if MVT_TEXTURE_COUNT > 3
        addTextureColor(maps[3], textureInfos[3]);
    #endif

    #if MVT_TEXTURE_COUNT > 4
        addTextureColor(maps[4], textureInfos[4]);
    #endif

    #if MVT_TEXTURE_COUNT > 5
        addTextureColor(maps[5], textureInfos[5]);
    #endif

    #if MVT_TEXTURE_COUNT > 6
        addTextureColor(maps[6], textureInfos[6]);
    #endif

    #if MVT_TEXTURE_COUNT > 7
        addTextureColor(maps[7], textureInfos[7]);
    #endif

    #if MVT_TEXTURE_COUNT > 8
        addTextureColor(maps[8], textureInfos[8]);
    #endif
}
`;
class bw extends Xi {
  constructor() {
    super();
    const t = Ht;
    this.uniforms = {
      tDiffuse: { value: null },
      textureInfos: { value: null },
      maps: { value: null }
    }, this._lastTextureCount = 1, this.material = new ze({
      defines: {
        MVT_TEXTURE_COUNT: 1
      },
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: ED,
      depthTest: !1,
      depthWrite: !1
    }), this.needsSwap = !0, this.fsQuad = new Ut(null);
  }
  render(t, e, i) {
    const n = t.autoClear;
    t.autoClear = !1, this.fsQuad.material = this.material, this.material.uniforms.tDiffuse.value = i.texture, t.setRenderTarget(this.renderToScreen ? null : e), t.clear(), this.fsQuad.render(t), t.autoClear = n;
  }
  updateTextures(t, e) {
    if (t.length !== e.length) {
      console.warn("textures and infos length must be equal");
      return;
    }
    this.uniforms.maps.value = t, this.uniforms.textureInfos.value = e, this._lastTextureCount !== e.length && (this.material.defines.MVT_TEXTURE_COUNT = e.length, this.material.needsUpdate = !0, this._lastTextureCount = e.length);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class RD extends Vn {
  constructor() {
    super(...arguments);
    f(this, "name", "stats");
    f(this, "_lastEnabled", !1);
    f(this, "_canvasWidth", 600);
    f(this, "_canvasHeight", 320);
    f(this, "_canvasPadding", 10);
    f(this, "_lastUpdateTime", 0);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
    this.enabled && this._updateTexture();
  }
  _init() {
    const e = this._rendering, i = e.pixelRatio, n = this._canvas = document.createElement("canvas");
    this._context = n.getContext("2d"), n.width = this._canvasWidth * i, n.height = this._canvasHeight * i, this._texture = new ls(n), this._texture.generateMipmaps = !1;
    const o = this._renderPass = new bw();
    o.renderOrder = 10100, o.material.uniforms.textureInfos.value = [{
      offset: [0.2, 0.2],
      scale: [2.5, 2.5]
    }], o.material.uniforms.maps.value = [this._texture], e.main.postprocessings.add(this._renderPass);
  }
  _updateTexture() {
    const e = this._rendering, i = e.renderState;
    if (i.time - this._lastUpdateTime < 100)
      return;
    this._lastUpdateTime = i.time;
    const n = e.renderer, o = e.stats, r = this._context, a = e.pixelRatio;
    o.beginTimeStatsItem("updateStatsTexture"), r.save(), r.scale(a, a), r.clearRect(0, 0, this._canvasWidth, this._canvasHeight), r.fillStyle = "rgba(0, 0, 0, .6)", r.fillRect(0, 0, this._canvasWidth, this._canvasHeight), r.font = "14px sans-serif", r.textAlign = "right", r.fillStyle = "rgb(220,220,220)";
    const g = o.getSortedTimeStatsItems(), c = Math.min(g.length, 10);
    let l = this._canvasPadding + 100, h = this._canvasPadding + 20;
    r.fillText("average", l + 150, h), r.fillText("lastValue", l + 230, h), r.fillText("count", l + 310, h), r.fillText("total", l + 450, h), r.strokeStyle = "rgb(130,130,130)";
    for (let S = 0; S < c; S++) {
      l = this._canvasPadding + 100, h = this._canvasPadding + 50 + S * 20;
      const A = g[S];
      r.fillText(A.name, l + 50, h), r.fillText(A.average.toFixed(2), l + 150, h), r.fillText(A.lastValue.toFixed(2), l + 230, h), r.fillText(A.count.toFixed(0), l + 310, h), r.fillText(A.total.toFixed(2), l + 450, h), h += 5, r.beginPath(), r.moveTo(this._canvasPadding, h), r.lineTo(this._canvasWidth - this._canvasPadding, h), r.stroke();
    }
    const d = n.info;
    r.font = "13px sans-serif", r.textAlign = "left", l = this._canvasPadding, h = 270, r.fillText("frame: " + d.render.frame, l, h), l += 160, r.fillText("calls: " + d.render.calls, l, h), l += 160, r.fillText("triangles: " + d.render.triangles, l, h), l += 160, r.fillText("points: " + d.render.points, l, h), l = this._canvasPadding, h += 20, r.fillText("lines: " + d.render.lines, l, h), l += 160, r.fillText("geometries: " + d.memory.geometries, l, h), l += 160, r.fillText("textures: " + d.memory.textures, l, h), l += 160, r.fillText("programs: " + d.programs.length, l, h), l = this._canvasPadding, h += 20, r.fillText("postprocessing: " + e.main.postprocessings.validCount, l, h);
    const C = e.main.features.features;
    let p = "";
    for (const S of C)
      S.enabled && (p += S.name + " ");
    l += 160, r.fillText("features: " + p, l, h), l += 160, r.fillText("tasks: " + e.taskScheduler.taskCount, l, h), r.restore(), o.endTimeStatsItem("updateStatsTexture"), this._texture.needsUpdate = !0;
    const m = e.resolution, b = this._renderPass;
    b.material.uniforms.textureInfos.value[0].offset = [
      0.5 - this._canvasWidth / 2 / m.x,
      0.5 - this._canvasHeight / 2 / m.y
    ], b.material.uniforms.textureInfos.value[0].scale = [
      1 / (this._canvasWidth / m.x),
      1 / (this._canvasHeight / m.y)
    ];
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    const e = this._rendering;
    e.stats.removeTimeStatsItem("updateStatsTexture"), e.main.postprocessings.remove(this._renderPass), this._renderPass && this._renderPass.dispose(), this._texture && this._texture.dispose();
  }
}
const DD = new ze({
  uniforms: {
    numFrames: { value: 0 },
    tLastFrame: { value: null },
    height: { value: 1 },
    width: { value: 1 },
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  transparent: !0,
  blending: NA,
  depthTest: !1,
  depthWrite: !1,
  vertexShader: `
    varying vec2 Uv;

    void main() {
        Uv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }`,
  fragmentShader: `
    // uniform float opacity;
    uniform float numFrames;
    uniform float height;
    uniform float width;
    uniform sampler2D tDiffuse;
    // uniform sampler2D tMotion;
    uniform sampler2D tLastFrame;
    varying vec2 Uv;

    void main() {
        vec4 texel = texture2D(tDiffuse, Uv);
        // vec4 pixelMovement = texture2D(tMotion, Uv);
        // vec2 oldPixelUv = Uv - ((pixelMovement.xy * 2.0) - 1.0);
        vec4 oldTexel = texture2D(tLastFrame, Uv);

        // Use simple neighbor clamping
        vec4 maxNeighbor = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 minNeighbor = vec4(1.0);
        vec4 average = vec4(0.0);

        for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
                vec2 neighborUv = Uv + vec2(float(x) / width, float(y) / height);
                vec4 neighborTexel = texture2D(tDiffuse, neighborUv);

                maxNeighbor = max(maxNeighbor, neighborTexel);
                minNeighbor = min(minNeighbor, neighborTexel);
                average += neighborTexel / 9.0;
            }
        }


        oldTexel = clamp(oldTexel, minNeighbor, maxNeighbor);

        // UE Method to get rid of flickering. Weight frame mixing amount
        // based on local contrast.
        float contrast = distance(average, texel);
        // # fix float type color range
        contrast = clamp(contrast, 0.0, 0.1);
        float weight = 0.1 * contrast;
        vec4 compositeColor = mix(oldTexel, texel, weight);

        gl_FragColor = compositeColor;
    }`
});
class KD extends Xi {
  constructor() {
    super();
    f(this, "enableRenderingJitter", !0);
    f(this, "getCurrentUsedTextures", () => {
      const e = [];
      return this._scratchBuffer && e.push(this._scratchBuffer.texture), this._oldFrameTarget && e.push(this._oldFrameTarget.texture), e;
    });
    const e = Ht;
    this._oldClearColor = new Ce(), this.uniforms = {
      tDiffuse: { value: null },
      opacity: { value: 1 }
    }, this._reprojectionMaterial = DD.clone(), this.material = new ze({
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader,
      depthTest: !1,
      depthWrite: !1
    }), this.needsSwap = !0, this.fsQuad = new Ut(null), this._isFirstFrame = !0;
  }
  render(e, i, n) {
    const o = this.rendering.resolution, r = this.rendering.pixelRatio, a = this.rendering.renderState, g = e.autoClear;
    e.autoClear = !1;
    let c = null;
    this._oldFrameTarget || (this._oldFrameTarget = new It(
      o.x * r,
      o.y * r,
      {}
    )), !a.viewChanged && !this._isFirstFrame && !this._debugEngineForceRender ? (this._scratchBuffer || (this._scratchBuffer = new It(
      o.x * r,
      o.y * r,
      {}
    )), c = this._reprojectionMaterial.uniforms, c.tLastFrame.value = this._oldFrameTarget.texture, c.height.value = n.height, c.width.value = n.width, c.tDiffuse.value = n.texture, this.fsQuad.material = this._reprojectionMaterial, e.setRenderTarget(this._scratchBuffer), e.clear(), this.fsQuad.render(e), c = this.material.uniforms, c.tDiffuse.value = this._scratchBuffer.texture, c.opacity.value = 1, this.fsQuad.material = this.material, e.setRenderTarget(this._oldFrameTarget), e.clear(), this.fsQuad.render(e), a.viewStableFrameCount < 32 && this.rendering.requestRender()) : (c = this.material.uniforms, c.tDiffuse.value = n.texture, c.opacity.value = 1, this.fsQuad.material = this.material, e.setRenderTarget(this._oldFrameTarget), e.clear(), this.fsQuad.render(e)), c = this.material.uniforms, c.tDiffuse.value = a.viewChanged ? n.texture : this._oldFrameTarget.texture, c.opacity.value = 1, this.fsQuad.material = this.material, e.setRenderTarget(this.renderToScreen ? null : i), e.clear(), this.fsQuad.render(e), e.autoClear = g, this._isFirstFrame = !1;
  }
  dispose() {
    this._reprojectionMaterial.dispose(), this.material.dispose(), this.fsQuad.dispose(), this._scratchBuffer && this._scratchBuffer.dispose(), this._oldFrameTarget && this._oldFrameTarget.dispose();
  }
}
const HD = {
  name: "FXAAShader",
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Z(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `
	precision highp float;

	uniform sampler2D tDiffuse;

	uniform vec2 resolution;

	varying vec2 vUv;

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:       gameworks@nvidia.com
	// Site:        http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//  * Redistributions of source code must retain the above copyright
	//    notice, this list of conditions and the following disclaimer.
	//  * Redistributions in binary form must reproduce the above copyright
	//    notice, this list of conditions and the following disclaimer in the
	//    documentation and/or other materials provided with the distribution.
	//  * Neither the name of NVIDIA CORPORATION nor the names of its
	//    contributors may be used to endorse or promote products derived
	//    from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

	#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
	#endif

	/*--------------------------------------------------------------------------*/
	#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
	#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
	/*--------------------------------------------------------------------------*/

	#define NUM_SAMPLES 5

	// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
	float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
	}

	/*============================================================================

									FXAA3 QUALITY - PC

	============================================================================*/

	/*--------------------------------------------------------------------------*/
	vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
	) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
					if(earlyExit) FxaaDiscard;
			#else
					if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
					// locate the edge
					vec2 dirToEdge;
					dirToEdge.x = contrastE > contrastW ? 1. : -1.;
					dirToEdge.y = contrastS > contrastN ? 1. : -1.;
					// . 2 .      . 1 .
					// 1 0 2  ~=  0 0 1
					// . 1 .      . 0 .

					// tap 2 pixels and see which ones are "outside" the edge, to
					// determine if the edge is vertical or horizontal

					vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongH = contrast( rgbaM, rgbaAlongH );
					// . 1 .
					// 0 0 1
					// . 0 H

					vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongV = contrast( rgbaM, rgbaAlongV );
					// V 1 .
					// 0 0 1
					// . 0 .

					relativeVContrast = matchAlongV - matchAlongH;
					relativeVContrast *= fxaaQualityinvEdgeThreshold;

					if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
							// 1 1 .
							// 0 0 1
							// . 0 1

							// do a simple blur
							return mix(
									rgbaM,
									(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
									.4
							);
					}

					horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
					iterationsUsed = i;

					float increment = float(i + 1);

					if(!doneN) {
							nDist += increment;
							posN = posM + offNP * nDist;
							vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
							doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
							iterationsUsedN = i;
					}

					if(!doneP) {
							pDist += increment;
							posP = posM - offNP * pDist;
							vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
							doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
							iterationsUsedP = i;
					}

					if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
					doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
					doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
					rgbaM,
					rgbaN,
					dist * .5
			);
	}

	void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
					vUv,
					tDiffuse,
					resolution,
					edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
					invEdgeDetectionQuality
			);

	}
	`
}, hc = {
  name: "SMAAEdgesShader",
  defines: {
    SMAA_THRESHOLD: "0.1"
  },
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Z(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`
}, dc = {
  name: "SMAAWeightsShader",
  defines: {
    SMAA_MAX_SEARCH_STEPS: "8",
    SMAA_AREATEX_MAX_DISTANCE: "16",
    SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
    SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
  },
  uniforms: {
    tDiffuse: { value: null },
    tArea: { value: null },
    tSearch: { value: null },
    resolution: { value: new Z(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`
}, kd = {
  name: "SMAABlendShader",
  uniforms: {
    tDiffuse: { value: null },
    tColor: { value: null },
    resolution: { value: new Z(1 / 1024, 1 / 512) }
  },
  vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`
};
class PD extends Xi {
  constructor(t, e) {
    super(), this.edgesRT = new It(t, e, {
      depthBuffer: !1,
      type: xi
    }), this.edgesRT.texture.name = "SMAAPass.edges", this.weightsRT = new It(t, e, {
      depthBuffer: !1,
      type: xi
    }), this.weightsRT.texture.name = "SMAAPass.weights";
    const i = this, n = new Image();
    n.src = this.getAreaTexture(), n.onload = function() {
      i.areaTexture.needsUpdate = !0;
    }, this.areaTexture = new pa(), this.areaTexture.name = "SMAAPass.area", this.areaTexture.image = n, this.areaTexture.minFilter = Gt, this.areaTexture.generateMipmaps = !1, this.areaTexture.flipY = !1;
    const o = new Image();
    o.src = this.getSearchTexture(), o.onload = function() {
      i.searchTexture.needsUpdate = !0;
    }, this.searchTexture = new pa(), this.searchTexture.name = "SMAAPass.search", this.searchTexture.image = o, this.searchTexture.magFilter = cs, this.searchTexture.minFilter = cs, this.searchTexture.generateMipmaps = !1, this.searchTexture.flipY = !1, this.uniformsEdges = we.clone(hc.uniforms), this.uniformsEdges.resolution.value.set(1 / t, 1 / e), this.materialEdges = new ze({
      defines: Object.assign({}, hc.defines),
      uniforms: this.uniformsEdges,
      vertexShader: hc.vertexShader,
      fragmentShader: hc.fragmentShader
    }), this.uniformsWeights = we.clone(dc.uniforms), this.uniformsWeights.resolution.value.set(1 / t, 1 / e), this.uniformsWeights.tDiffuse.value = this.edgesRT.texture, this.uniformsWeights.tArea.value = this.areaTexture, this.uniformsWeights.tSearch.value = this.searchTexture, this.materialWeights = new ze({
      defines: Object.assign({}, dc.defines),
      uniforms: this.uniformsWeights,
      vertexShader: dc.vertexShader,
      fragmentShader: dc.fragmentShader
    }), this.uniformsBlend = we.clone(kd.uniforms), this.uniformsBlend.resolution.value.set(1 / t, 1 / e), this.uniformsBlend.tDiffuse.value = this.weightsRT.texture, this.materialBlend = new ze({
      uniforms: this.uniformsBlend,
      vertexShader: kd.vertexShader,
      fragmentShader: kd.fragmentShader
    }), this.fsQuad = new Ut(null);
  }
  render(t, e, i) {
    this.uniformsEdges.tDiffuse.value = i.texture, this.fsQuad.material = this.materialEdges, t.setRenderTarget(this.edgesRT), this.clear && t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.materialWeights, t.setRenderTarget(this.weightsRT), this.clear && t.clear(), this.fsQuad.render(t), this.uniformsBlend.tColor.value = i.texture, this.fsQuad.material = this.materialBlend, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(), this.fsQuad.render(t));
  }
  setSize(t, e) {
    this.edgesRT.setSize(t, e), this.weightsRT.setSize(t, e), this.materialEdges.uniforms.resolution.value.set(1 / t, 1 / e), this.materialWeights.uniforms.resolution.value.set(1 / t, 1 / e), this.materialBlend.uniforms.resolution.value.set(1 / t, 1 / e);
  }
  getAreaTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
  }
  getSearchTexture() {
    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
  }
  dispose() {
    this.edgesRT.dispose(), this.weightsRT.dispose(), this.areaTexture.dispose(), this.searchTexture.dispose(), this.materialEdges.dispose(), this.materialWeights.dispose(), this.materialBlend.dispose(), this.fsQuad.dispose();
  }
}
class ND extends Vn {
  constructor(e, i) {
    super(e, i);
    f(this, "name", "AA");
    f(this, "_method", "msaa");
    f(this, "_lastMethod", "msaa");
    f(this, "_lastEnabled", !1);
    f(this, "_lastUseMRT", !1);
    f(this, "_samples", 0);
    this.enabled = i.enabled, this._method = i.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _disableOldMethod() {
    const e = this._lastMethod, i = this._rendering;
    e === "msaa" ? (i.updateContextParameters({
      antialias: !1
    }), i.main.sceneRendering.updateRenderTargetSamples(0), this._samples = 0) : e === "fxaa" ? (this._fxaaPass && i.main.postprocessings.remove(this._fxaaPass), this._fxaaPass = null) : e === "taa" ? (this._taaPass && i.main.postprocessings.remove(this._taaPass), this._taaPass = null) : e === "smaa" && (this._smaaPass && i.main.postprocessings.remove(this._smaaPass), this._smaaPass = null);
  }
  _enableNewMethod() {
    const e = this._method, i = this._rendering;
    if (e === "msaa")
      i.updateContextParameters({
        antialias: !0
      }), i.main.sceneRendering.updateRenderTargetSamples(4), this._samples = 4;
    else if (e === "fxaa") {
      const n = this._fxaaPass = new _D(HD), o = i.resolution, r = i.pixelRatio;
      n.uniforms.resolution.value.set(1 / o.x / r, 1 / o.y / r), n.renderOrder = 80, i.main.postprocessings.add(n);
    } else if (e === "taa") {
      const n = this._taaPass = new KD();
      n.rendering = i, n.renderOrder = 80, i.main.postprocessings.add(n);
    } else if (e === "smaa") {
      const n = i.resolution, o = i.pixelRatio, r = this._smaaPass = new PD(n.x * o, n.y * o);
      r.renderOrder = 80, i.main.postprocessings.add(r);
    } else
      console.warn("Unknown antialias method:", e);
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  dispose() {
    this.enabled && this._method !== "msaa" && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
  get samples() {
    return this._samples;
  }
}
class FD extends Vn {
  constructor(e, i = {}) {
    super(e, i);
    f(this, "name", "bufferView");
    f(this, "_lastEnabled", !1);
    f(this, "_offset", 0);
    f(this, "_currentFrameTextures", []);
    this._offset = i.offset || 0;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
  }
  _init() {
    const e = this._rendering, i = this._renderPass = new bw();
    i.renderOrder = 10900, i.material.uniforms.textureInfos.value = [{
      offset: [0.2, 0.2],
      scale: [2.5, 2.5]
    }], i.material.uniforms.maps.value = [], e.main.postprocessings.add(this._renderPass);
  }
  afterRender() {
    if (!this.enabled)
      return;
    const e = [], i = this._rendering, n = i.main.sceneRendering;
    n.diffuseTexture && e.push(n.diffuseTexture), n.emissiveTexture && e.push(n.emissiveTexture), n.normalTexture && e.push(n.normalTexture), n.depthTexture && e.push(n.depthTexture), n.metallicRoughTexture && e.push(n.metallicRoughTexture);
    const o = i.main.features.features || [];
    for (let c = 0; c < o.length; c++) {
      const l = o[c];
      if (!!l.enabled && l.getCurrentUsedTextures) {
        const h = l.getCurrentUsedTextures();
        h && e.push(...h);
      }
    }
    const r = i.main.postprocessings.postprocessings || [];
    for (let c = 0; c < r.length; c++) {
      const l = r[c];
      if (l.getCurrentUsedTextures) {
        const h = l.getCurrentUsedTextures();
        h && e.push(...h);
      }
    }
    this._currentFrameTextures.length > 0 && e.push(...this._currentFrameTextures);
    const a = [], g = e.slice(this._offset, this._offset + 4);
    if (g.length !== 0) {
      for (let c = 0; c < g.length; c++)
        a.push({
          offset: [c * 0.25, Math.floor(c / 4) * 0.25],
          scale: [4, 4]
        });
      this._renderPass.updateTextures(g, a);
    }
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._currentFrameTextures.length = 0;
  }
  addCurrentFrameTexture(e) {
    !this.enabled || this._currentFrameTextures.push(e);
  }
  dispose() {
    this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass && this._renderPass.dispose();
  }
  get offset() {
    return this._offset;
  }
  set offset(e) {
    this._offset = e;
  }
}
class kD {
  constructor(t = Math) {
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ], this.grad4 = [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ], this.p = [];
    for (let e = 0; e < 256; e++)
      this.p[e] = Math.floor(t.random() * 256);
    this.perm = [];
    for (let e = 0; e < 512; e++)
      this.perm[e] = this.p[e & 255];
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ];
  }
  dot(t, e, i) {
    return t[0] * e + t[1] * i;
  }
  dot3(t, e, i, n) {
    return t[0] * e + t[1] * i + t[2] * n;
  }
  dot4(t, e, i, n, o) {
    return t[0] * e + t[1] * i + t[2] * n + t[3] * o;
  }
  noise(t, e) {
    let i, n, o;
    const r = 0.5 * (Math.sqrt(3) - 1), a = (t + e) * r, g = Math.floor(t + a), c = Math.floor(e + a), l = (3 - Math.sqrt(3)) / 6, h = (g + c) * l, d = g - h, C = c - h, p = t - d, m = e - C;
    let b, S;
    p > m ? (b = 1, S = 0) : (b = 0, S = 1);
    const A = p - b + l, u = m - S + l, y = p - 1 + 2 * l, I = m - 1 + 2 * l, M = g & 255, G = c & 255, x = this.perm[M + this.perm[G]] % 12, L = this.perm[M + b + this.perm[G + S]] % 12, E = this.perm[M + 1 + this.perm[G + 1]] % 12;
    let T = 0.5 - p * p - m * m;
    T < 0 ? i = 0 : (T *= T, i = T * T * this.dot(this.grad3[x], p, m));
    let R = 0.5 - A * A - u * u;
    R < 0 ? n = 0 : (R *= R, n = R * R * this.dot(this.grad3[L], A, u));
    let w = 0.5 - y * y - I * I;
    return w < 0 ? o = 0 : (w *= w, o = w * w * this.dot(this.grad3[E], y, I)), 70 * (i + n + o);
  }
  noise3d(t, e, i) {
    let n, o, r, a;
    const g = 0.3333333333333333, c = (t + e + i) * g, l = Math.floor(t + c), h = Math.floor(e + c), d = Math.floor(i + c), C = 1 / 6, p = (l + h + d) * C, m = l - p, b = h - p, S = d - p, A = t - m, u = e - b, y = i - S;
    let I, M, G, x, L, E;
    A >= u ? u >= y ? (I = 1, M = 0, G = 0, x = 1, L = 1, E = 0) : A >= y ? (I = 1, M = 0, G = 0, x = 1, L = 0, E = 1) : (I = 0, M = 0, G = 1, x = 1, L = 0, E = 1) : u < y ? (I = 0, M = 0, G = 1, x = 0, L = 1, E = 1) : A < y ? (I = 0, M = 1, G = 0, x = 0, L = 1, E = 1) : (I = 0, M = 1, G = 0, x = 1, L = 1, E = 0);
    const T = A - I + C, R = u - M + C, w = y - G + C, v = A - x + 2 * C, D = u - L + 2 * C, K = y - E + 2 * C, P = A - 1 + 3 * C, k = u - 1 + 3 * C, V = y - 1 + 3 * C, N = l & 255, z = h & 255, O = d & 255, Q = this.perm[N + this.perm[z + this.perm[O]]] % 12, U = this.perm[N + I + this.perm[z + M + this.perm[O + G]]] % 12, $ = this.perm[N + x + this.perm[z + L + this.perm[O + E]]] % 12, ee = this.perm[N + 1 + this.perm[z + 1 + this.perm[O + 1]]] % 12;
    let se = 0.6 - A * A - u * u - y * y;
    se < 0 ? n = 0 : (se *= se, n = se * se * this.dot3(this.grad3[Q], A, u, y));
    let ie = 0.6 - T * T - R * R - w * w;
    ie < 0 ? o = 0 : (ie *= ie, o = ie * ie * this.dot3(this.grad3[U], T, R, w));
    let Y = 0.6 - v * v - D * D - K * K;
    Y < 0 ? r = 0 : (Y *= Y, r = Y * Y * this.dot3(this.grad3[$], v, D, K));
    let Ie = 0.6 - P * P - k * k - V * V;
    return Ie < 0 ? a = 0 : (Ie *= Ie, a = Ie * Ie * this.dot3(this.grad3[ee], P, k, V)), 32 * (n + o + r + a);
  }
  noise4d(t, e, i, n) {
    const o = this.grad4, r = this.simplex, a = this.perm, g = (Math.sqrt(5) - 1) / 4, c = (5 - Math.sqrt(5)) / 20;
    let l, h, d, C, p;
    const m = (t + e + i + n) * g, b = Math.floor(t + m), S = Math.floor(e + m), A = Math.floor(i + m), u = Math.floor(n + m), y = (b + S + A + u) * c, I = b - y, M = S - y, G = A - y, x = u - y, L = t - I, E = e - M, T = i - G, R = n - x, w = L > E ? 32 : 0, v = L > T ? 16 : 0, D = E > T ? 8 : 0, K = L > R ? 4 : 0, P = E > R ? 2 : 0, k = T > R ? 1 : 0, V = w + v + D + K + P + k, N = r[V][0] >= 3 ? 1 : 0, z = r[V][1] >= 3 ? 1 : 0, O = r[V][2] >= 3 ? 1 : 0, Q = r[V][3] >= 3 ? 1 : 0, U = r[V][0] >= 2 ? 1 : 0, $ = r[V][1] >= 2 ? 1 : 0, ee = r[V][2] >= 2 ? 1 : 0, se = r[V][3] >= 2 ? 1 : 0, ie = r[V][0] >= 1 ? 1 : 0, Y = r[V][1] >= 1 ? 1 : 0, Ie = r[V][2] >= 1 ? 1 : 0, xe = r[V][3] >= 1 ? 1 : 0, fe = L - N + c, be = E - z + c, pe = T - O + c, Te = R - Q + c, ge = L - U + 2 * c, lt = E - $ + 2 * c, Ke = T - ee + 2 * c, Pe = R - se + 2 * c, nt = L - ie + 3 * c, Ve = E - Y + 3 * c, rt = T - Ie + 3 * c, on = R - xe + 3 * c, $e = L - 1 + 4 * c, st = E - 1 + 4 * c, ot = T - 1 + 4 * c, et = R - 1 + 4 * c, Je = b & 255, _n = S & 255, xn = A & 255, vn = u & 255, nc = a[Je + a[_n + a[xn + a[vn]]]] % 32, mf = a[Je + N + a[_n + z + a[xn + O + a[vn + Q]]]] % 32, Ad = a[Je + U + a[_n + $ + a[xn + ee + a[vn + se]]]] % 32, Cd = a[Je + ie + a[_n + Y + a[xn + Ie + a[vn + xe]]]] % 32, fd = a[Je + 1 + a[_n + 1 + a[xn + 1 + a[vn + 1]]]] % 32;
    let Zn = 0.6 - L * L - E * E - T * T - R * R;
    Zn < 0 ? l = 0 : (Zn *= Zn, l = Zn * Zn * this.dot4(o[nc], L, E, T, R));
    let Un = 0.6 - fe * fe - be * be - pe * pe - Te * Te;
    Un < 0 ? h = 0 : (Un *= Un, h = Un * Un * this.dot4(o[mf], fe, be, pe, Te));
    let On = 0.6 - ge * ge - lt * lt - Ke * Ke - Pe * Pe;
    On < 0 ? d = 0 : (On *= On, d = On * On * this.dot4(o[Ad], ge, lt, Ke, Pe));
    let mi = 0.6 - nt * nt - Ve * Ve - rt * rt - on * on;
    mi < 0 ? C = 0 : (mi *= mi, C = mi * mi * this.dot4(o[Cd], nt, Ve, rt, on));
    let Qt = 0.6 - $e * $e - st * st - ot * ot - et * et;
    return Qt < 0 ? p = 0 : (Qt *= Qt, p = Qt * Qt * this.dot4(o[fd], $e, st, ot, et)), 27 * (l + h + d + C + p);
  }
}
new Z(), new J(), new J();
const uc = {
  name: "SSAOBlurShader",
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Z() }
  },
  vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`
}, Ic = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tDepth: { value: null },
    tNoise: { value: null },
    kernel: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new Z() },
    cameraProjectionMatrix: { value: new J() },
    cameraInverseProjectionMatrix: { value: new J() },
    kernelRadius: { value: 0.1 },
    minDistance: { value: 1e-4 },
    maxDistance: { value: 1e3 },
    intensity: { value: 1 }
  },
  vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away
        uniform float intensity;
		varying vec2 vUv;

		#include <packing>

        float linearize_depth(in float depth){
            float a = cameraFar / (cameraFar - cameraNear);
            float b = cameraFar * cameraNear / (cameraNear - cameraFar);
            return a + b / depth;
        }

        float reconstruct_depth(const in vec2 uv){
            float depth = texture2D(tDepth, uv).x;
            return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
        }

        float getDepth(vec2 uv) {
            #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
                return linearize_depth(reconstruct_depth(uv));
            #else
                return texture2D(tDepth, uv).x;
            #endif
        }
		// float getDepth( const in vec2 screenPosition ) {

		// 	return texture2D( tDepth, screenPosition ).x;

		// }

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				// float fragCoordZ = texture2D( tDepth, screenPosition ).x;
                float fragCoordZ = getDepth(screenPosition);
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

            vec3 sampleNormal = texture2D( tNormal, vUv ).xyz;
            if (length(sampleNormal) < 0.5) {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                return;
            }
            vec3 viewNormal = unpackRGBToNormal(sampleNormal);

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
            // float depth = texture2D( tDepth, vUv ).x;
            // float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );
            // float viewZ = -1.0 * (exp2(depth / (logDepthBufFC * 0.5)) - 1.0);

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );
                // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );

                // realDepth = getDepth(samplePointUv);
                // // realDepth = reconstruct_depth(samplePointUv);
                // sampleDepth = viewZToPerspectiveDepth(samplePoint.z, cameraNear, cameraFar);

                // sampleDepth = log2(sampleDepth + 1.0) / log2(cameraFar + 1.0);
                // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) {
                // if ( delta > 0.00001 && delta < 0.0001) {
                    // if fragment is before sample point, increase occlusion

                    // occlusion += 1.0;
					occlusion += 1.0 * length(sampleVector) * intensity;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3((1.0 - occlusion) ), 1.0 );

		}`
};
class VD extends Xi {
  constructor(t, e) {
    super(), this.width = t !== void 0 ? t : 512, this.height = e !== void 0 ? e : 512, this.clear = !0, this.kernelRadius = 0.5, this.kernelSize = 32, this.kernel = [], this.noiseTexture = null, this.intensity = 1, this.minDistance = 1e-5, this.maxDistance = 1e-4, this.generateSampleKernel(), this.generateRandomKernelRotations(), this.ssaoMaterial = new ze({
      defines: Object.assign({}, Ic.defines),
      uniforms: we.clone(Ic.uniforms),
      vertexShader: Ic.vertexShader,
      fragmentShader: Ic.fragmentShader,
      blending: jl
    }), this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture, this.ssaoMaterial.uniforms.kernel.value = this.kernel, this.blurMaterial = new ze({
      defines: Object.assign({}, uc.defines),
      uniforms: we.clone(uc.uniforms),
      vertexShader: uc.vertexShader,
      fragmentShader: uc.fragmentShader
    }), this.copyMaterial = new ze({
      uniforms: we.clone(Ht.uniforms),
      vertexShader: Ht.vertexShader,
      fragmentShader: Ht.fragmentShader,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      blendSrc: tT,
      blendDst: ql,
      blendEquation: yf,
      blendSrcAlpha: iT,
      blendDstAlpha: ql,
      blendEquationAlpha: yf
    }), this.fsQuad = new Ut(null), this.originalClearColor = new Ce(), this.needsNormalTexture = !0, this.needsDepthTexture = !0;
  }
  dispose() {
    this.ssaoRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.normalMaterial.dispose(), this.blurMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose();
  }
  render(t, e, i) {
    t.capabilities.isWebGL2 === !1 && (this.noiseTexture.format = db), this.ssaoRenderTarget || (this.ssaoRenderTarget = new It(i.width, i.height, {})), this.blurRenderTarget || (this.blurRenderTarget = new It(i.width, i.height, {}));
    const n = this.rendering, o = n.main.sceneRendering.normalTexture, r = n.main.sceneRendering.depthTexture;
    this.ssaoMaterial.uniforms.tDiffuse.value = i.texture, this.ssaoMaterial.uniforms.tNormal.value = o, this.ssaoMaterial.uniforms.tDepth.value = r, this.ssaoMaterial.uniforms.cameraNear.value = n.camera.near, this.ssaoMaterial.uniforms.cameraFar.value = n.camera.far, this.ssaoMaterial.uniforms.resolution.value.set(i.width, i.height), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(n.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(n.camera.projectionMatrixInverse), this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius, this.ssaoMaterial.uniforms.minDistance.value = this.minDistance, this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance, this.ssaoMaterial.uniforms.intensity.value = this.intensity, this.renderPass(t, this.ssaoMaterial, this.ssaoRenderTarget), this.blurMaterial.uniforms.resolution.value.set(i.width, i.height), this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.renderPass(t, this.blurMaterial, this.blurRenderTarget), this.copyMaterial.uniforms.tDiffuse.value = i.texture, this.copyMaterial.blending = jl, this.renderPass(t, this.copyMaterial, this.renderToScreen ? null : e), this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = kA, this.renderPass(t, this.copyMaterial, this.renderToScreen ? null : e);
  }
  renderPass(t, e, i, n, o) {
    t.getClearColor(this.originalClearColor);
    const r = t.getClearAlpha(), a = t.autoClear;
    t.setRenderTarget(i), t.autoClear = !1, n != null && (t.setClearColor(n), t.setClearAlpha(o || 0), t.clear()), this.fsQuad.material = e, this.fsQuad.render(t), t.autoClear = a, t.setClearColor(this.originalClearColor), t.setClearAlpha(r);
  }
  setSize(t, e) {
    this.width = t, this.height = e, this.ssaoRenderTarget.setSize(t, e), this.blurRenderTarget.setSize(t, e);
  }
  generateSampleKernel() {
    const t = this.kernelSize, e = this.kernel;
    for (let i = 0; i < t; i++) {
      const n = new B();
      n.x = Math.random() * 2 - 1, n.y = Math.random() * 2 - 1, n.z = Math.random(), n.normalize();
      let o = i / t;
      o = ce.lerp(0.1, 1, o * o), n.multiplyScalar(o), e.push(n);
    }
  }
  generateRandomKernelRotations() {
    const i = new kD(), n = 4 * 4, o = new Float32Array(n);
    for (let r = 0; r < n; r++) {
      const a = Math.random() * 2 - 1, g = Math.random() * 2 - 1, c = 0;
      o[r] = i.noise3d(a, g, c);
    }
    this.noiseTexture = new Ga(o, 4, 4, Ps, ur), this.noiseTexture.wrapS = ii, this.noiseTexture.wrapT = ii, this.noiseTexture.needsUpdate = !0;
  }
}
class zD extends Vn {
  constructor(e, i) {
    super(e, i);
    f(this, "name", "AO");
    f(this, "_method", "ssao");
    f(this, "_ssaoKernelRadius", 0.5);
    f(this, "_ssaoMinDistance", 1e-5);
    f(this, "_ssaoMaxDistance", 1e-4);
    f(this, "_ssaoIntensity", 1);
    f(this, "_lastMethod", "ssao");
    f(this, "_lastEnabled", !1);
    this.enabled = i.enabled, this._method = i.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _disableOldMethod() {
    const e = this._lastMethod, i = this._rendering;
    e === "ssao" && (this._ssaoPass && i.main.postprocessings.remove(this._ssaoPass), this._ssaoPass = null);
  }
  _enableNewMethod() {
    const e = this._method, i = this._rendering;
    if (e === "ssao") {
      const n = this._ssaoPass = new VD();
      n.kernelRadius = this._ssaoKernelRadius, n.minDistance = this._ssaoMinDistance, n.maxDistance = this._ssaoMaxDistance, n.intensity = this._ssaoIntensity, n.renderOrder = 900, n.rendering = i, i.main.postprocessings.add(n);
    }
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  dispose() {
    this.enabled && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
  get ssaoKernelRadius() {
    return this._ssaoKernelRadius;
  }
  set ssaoKernelRadius(e) {
    this._ssaoKernelRadius = e, this._ssaoPass && (this._ssaoPass.kernelRadius = e);
  }
  get ssaoMinDistance() {
    return this._ssaoMinDistance;
  }
  set ssaoMinDistance(e) {
    this._ssaoMinDistance = e, this._ssaoPass && (this._ssaoPass.minDistance = e);
  }
  get ssaoMaxDistance() {
    return this._ssaoMaxDistance;
  }
  set ssaoMaxDistance(e) {
    this._ssaoMaxDistance = e, this._ssaoPass && (this._ssaoPass.maxDistance = e);
  }
  get ssaoIntensity() {
    return this._ssaoIntensity;
  }
  set ssaoIntensity(e) {
    this._ssaoIntensity = e, this._ssaoPass && (this._ssaoPass.intensity = e);
  }
}
const XD = `#define GLSLIFY 1
varying vec2 vUv;

void main() {

    vUv = uv;

    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

}`, WD = `precision highp sampler2D;
#define GLSLIFY 1
varying vec2 vUv;
uniform sampler2D tDepth;
uniform sampler2D tNormal;
uniform sampler2D tMetalness;
uniform sampler2D tDiffuse;

#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
uniform sampler2D tEnhancement;
uniform vec2 tEnhancementScale;
uniform mat4 mvt_viewInverseMatrix;
uniform mat3 mvt_normalInverseMatrix;
#endif

uniform float cameraRange;
uniform vec2 resolution;
uniform float opacity;
uniform float cameraNear;
uniform float cameraFar;
uniform float maxDistance;
uniform float thickness;
uniform mat4 cameraProjectionMatrix;
uniform mat4 cameraInverseProjectionMatrix;
uniform float threshold; // \u63A7\u5236\u53CD\u5C04\u6700\u4F4E\u9608\u503C\uFF0C\u4F4E\u4E8E\u6B64\u81F4\u7684\u4E0D\u8BA1\u7B97\uFF0C\u53EF\u63D0\u9AD8\u6027\u80FD

#include <packing>
float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
    //x0: point, x1: linePointA, x2: linePointB
    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);
}
float pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {
    // https://mathworld.wolfram.com/Point-PlaneDistance.html
    //// https://en.wikipedia.org/wiki/Plane_(geometry)
    //// http://paulbourke.net/geometry/pointlineplane/
    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;
    float x0 = point.x, y0 = point.y, z0 = point.z;
    float x = planePoint.x, y = planePoint.y, z = planePoint.z;
    float d = -(a * x + b * y + c * z);
    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);
    return distance;
}
// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer
float linearize_depth(in float depth) {
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(const in vec2 uv) {
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float get_logarithmic_depth(const in vec2 uv) {
    float depth = texture2D(tDepth, uv).x;
    float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );
    float invViewZ = exp2(depth / (logDepthBufFC * 0.5)) - 1.0;
    return viewZToPerspectiveDepth(-invViewZ, cameraNear, cameraFar);
}
float getDepth(const in vec2 uv) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    // return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;
    return get_logarithmic_depth(uv);
    #else
    return texture2D(tDepth, uv).x;
    #endif

}
float getViewZ(const in float depth) {
    #ifdef PERSPECTIVE_CAMERA
    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);
    #else
    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);
    #endif
}
vec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {
    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc
    clipPosition *= clipW; //clip
    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view
}
#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
vec3 getWorldPositionFromDepth(float depth) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);
    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;
    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;
    return worldSpacePosition.xyz / worldSpacePosition.w;
}
#endif
vec3 getViewNormal(const in vec2 uv) {
    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);
}
vec2 viewPositionToXY(vec3 viewPosition) {
    vec2 xy;
    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);
    xy = clip.xy;//clip
    float clipW = clip.w;
    xy /= clipW;//NDC
    xy = (xy + 1.) / 2.;//uv
    xy *= resolution;//screen
    return xy;
}
void main() {

    gl_FragColor = texture2D(tDiffuse, vUv);
   
    vec3 sampleNormal = texture2D(tNormal, vUv).xyz;
    if (length(sampleNormal) < 0.9) {
        return;
    }

    vec3 viewNormal = unpackRGBToNormal(sampleNormal);
    float depth = getDepth(vUv);
    #ifdef SELECTIVE
    // \u5B8C\u5168\u6CA1\u53CD\u5C04\u7684\u8868\u9762\u76F4\u63A5\u5254\u9664
    float intensity = texture2D(tMetalness, vUv).x;

    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)
        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));
        if (dirAlpha > 0.5) {
            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);
            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, 
                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);
            float enhancement = texture2D(tEnhancement, enhancementUv).x;
            intensity += (1.0 - enhancement);
        }
        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);
        // return;
    #endif

         
    if(intensity < threshold)
        return;
    intensity -= threshold;
    intensity *= 1.0 / (1.0 - threshold);
    #endif

    
    float viewZ = getViewZ(depth);
    // z\u503C\u5DF2\u7ECF\u8D85\u8FC7\u76F8\u673A\u8FDC\u7AEF\u8DDD\u79BB
    if(-viewZ >= cameraFar)
        return;

    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
    // \u76F8\u673A\u89C6\u56FE\u4E0B\u7684\u5F53\u524D\u7247\u5143\u5750\u6807
    vec3 viewPosition = getViewPosition(vUv, depth, clipW);

    // \u8D77\u70B9\u7684\u5C4F\u5E55\u5750\u6807
    vec2 d0 = gl_FragCoord.xy;
    vec2 d1;

    #ifdef PERSPECTIVE_CAMERA
    // \u5165\u5C04\u5149\u65B9\u5411\uFF0C\u76F8\u673A\u5728\u539F\u70B9\uFF0C\u65B9\u5411\u5373\u4E3A\u5750\u6807\u7684\u5355\u4F4D\u5411\u91CF
    vec3 viewIncidentDir = normalize(viewPosition);
    // \u53CD\u5C04\u5149\u65B9\u5411
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #else
    vec3 viewIncidentDir = vec3(0, 0, -1);
    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);
    #endif

    // \u53CD\u5C04\u5149\u7EBF\u6700\u957F\u8DDD\u79BB\u7531\u8F93\u5165\u7684\u6700\u5927\u53CD\u5C04\u8DDD\u79BB\u548C\u5165\u5C04\u89D2\u51B3\u5B9A
    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);
    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
    // maxDistance/maxReflectRayLen=cos(theta)
    // maxDistance/maxReflectRayLen==dot(a,b)
    // maxReflectRayLen==maxDistance/dot(a,b)

    // \u53CD\u5C04\u6700\u8FDC\u8DDD\u79BB\u4E0B\u7684\u5750\u6807\u70B9
    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;
    #ifdef PERSPECTIVE_CAMERA
    if(d1viewPosition.z > -cameraNear) {
            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
        // \u5E94\u8BE5\u662F\u5904\u7406\u53CD\u5C04\u70B9\u6EA2\u51FA\u76F8\u673A\u89C6\u91CE\u5916\u7684\u60C5\u51B5
        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;
        d1viewPosition = viewPosition + viewReflectDir * t;
    }
    #endif
    // \u53CD\u5C04\u6700\u8FDC\u70B9\u5728\u5C4F\u5E55\u4E0A\u7684\u4F4D\u7F6E
    d1 = viewPositionToXY(d1viewPosition);

    // \u5C4F\u5E55\u50CF\u7D20\u8DDD\u79BB
    float totalLen = length(d1 - d0);
    float xLen = d1.x - d0.x;
    float yLen = d1.y - d0.y;
    // \u6700\u5927\u6B65\u6570\u53D6xy\u65B9\u5411\u8F83\u5927\u7684\u4E00\u4E2A\u65B9\u5411\uFF0C\u6BCF\u6B21\u6B65\u8FDB\u4E00\u4E2A\u50CF\u7D20
    float totalStep = max(abs(xLen), abs(yLen));
    // x\u65B9\u5411\u6BCF\u6B21\u6B65\u8FDB\u7684\u5927\u5C0F
    float xSpan = xLen / totalStep;
    // y\u65B9\u5411\u6BCF\u6B21\u6B65\u8FDB\u7684\u5927\u5C0F
    float ySpan = yLen / totalStep;
    // \u6B65\u8FDB\u6B21\u6570\u6700\u5927\u662F\u5C4F\u5E55\u5BF9\u89D2\u7EBF\u8DDD\u79BB\uFF08\u5E94\u8BE5\u662F\u6A2A\u5411\u6216\u8005\u7EB5\u5411\u7684\u6700\u5927\u503C\uFF09\uFF0C\u5B9E\u9645\u6B21\u6570\u8981\u8FDC\u5C0F\u4E8E\u8FD9\u4E2A
    for(float i = 0.; i < float(MAX_STEP); i += 4.0) {
        if(i >= totalStep)
            break;
        // march\u5230\u7684\u5F53\u524D\u5C4F\u5E55\u50CF\u7D20
        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);
        // \u8DD1\u5230\u5C4F\u5E55\u5916march\u5931\u8D25
        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)
            break;
        // \u5F53\u524D\u767E\u5206\u6BD4
        float s = length(xy - d0) / totalLen;
        // \u5F53\u524Duv
        vec2 uv = xy / resolution;
        // \u8BA1\u7B97\u5F53\u524D\u70B9\u7684\u5404\u9879\u53C2\u6570\uFF0C\u548C\u4E00\u5F00\u59CB\u4E00\u6837
        float d = getDepth(uv);
        float vZ = getViewZ(d);
        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);
        // return;
        if(-vZ >= cameraFar)
            continue;
        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];
        // \u5F97\u5230\u5F53\u524D\u70B9\u7684viewposition
        vec3 vP = getViewPosition(uv, d, cW);

        // \u5F97\u5230\u5F53\u524D\u53CD\u5C04\u7EBF\u7684z
        #ifdef PERSPECTIVE_CAMERA
            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
        float recipVPZ = 1. / viewPosition.z;
        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));
        #else
        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);
        #endif

        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
        // \u53CD\u5C04\u7EBF\u7684z\u5C0F\u4E8E\u5F53\u524D\u70B9\u7684z,\u5426\u5219\u5C31\u662F\u88AB\u906E\u6321\u4F4F\u4E86
        if(viewReflectRayZ <= vZ) {

            bool hit;
            #ifdef INFINITE_THICK
            hit = true;
            #else
            // \u70B9\u5230\u5C04\u7EBF\u7684\u8DDD\u79BB
            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);

            // minThickness\u6CA1\u770B\u61C2\uFF0C\u548C\u6A2A\u5411\u90BB\u63A5\u70B9\u7684viewx\u5DEE\u503C\uFF0C\u5927\u7EA6\u4EE3\u8868\u4E86\u6B64\u5904\u4E00\u4E2A\u50CF\u7D20\u548C\u5B9E\u9645\u8DDD\u79BB\u7684\u6BD4\u4F8B\uFF0C\u4E583.0\uFF1F
            float minThickness;
            vec2 xyNeighbor = xy;
            xyNeighbor.x += 1.;
            vec2 uvNeighbor = xyNeighbor / resolution;
            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);
            minThickness = vPNeighbor.x - vP.x;
            minThickness *= 3.;
            float tk = max(minThickness, thickness);
            // \u5F53\u8DDD\u79BB\u5C0F\u4E8E\u9608\u503C\u65F6\u624D\u7B97\u662F\u771F\u6B63\u76F8\u4EA4
            hit = away <= tk;
            #endif

            if(hit) {
                vec3 vN = getViewNormal(uv);
                // \u76F8\u4EA4\u5230\u7269\u4F53\u7684\u53CD\u9762\u4E86\uFF0Cmarch\u65E0\u6548
                if(dot(viewReflectDir, vN) >= 0.)
                    continue;
                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);
                // march\u8DDD\u79BB\u8D85\u8FC7\u6700\u5927
                if(distance > maxDistance)
                    break;
                float op = opacity;
                // \u968F\u7740\u8DDD\u79BB\u51CF\u5F31\u53CD\u5C04\uFF0C\u9632\u6B62\u53CD\u5C04\u7A81\u7136\u6D88\u5931
                #ifdef DISTANCE_ATTENUATION
                float ratio = 1. - (distance / maxDistance);
                float attenuation = ratio * ratio;
                op = opacity * attenuation;
                #endif
                // \u83F2\u6D85\u5C14\u53CD\u5C04\u5B9A\u5F8B\uFF0C\u4E0E\u89C6\u91CE\u89D2\u5EA6\u504F\u79BB\u8D8A\u5927\uFF0C\u989C\u8272\u6743\u91CD\u8D8A\u5927
                #ifdef FRESNEL
                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;
                op *= fresnelCoe;
                #endif
                // \u8BFB\u53D6\u53CD\u5C04\u989C\u8272\u8D4B\u7ED9\u5F53\u524D\u7247\u5143
                gl_FragColor = texture2D(tDiffuse, vUv);
                vec4 reflectColor = texture2D(tDiffuse, uv);
                reflectColor.a = op;
                #ifdef SELECTIVE
                reflectColor.a *= intensity;
                #endif
                gl_FragColor.rgb = mix(gl_FragColor.rgb, reflectColor.rgb, reflectColor.a);
                // gl_FragColor = vec4(1.0, 0, 0, 1.0);
                return;
                
                // break;
            }
        }
    }
    // gl_FragColor = texture2D(tDiffuse, vUv);
}`;
function pi(s) {
  let t = BC(s).toArray(), e = t[3] === void 0 ? 1 : t[3];
  return [t[0], t[1], t[2], e];
}
function sr(s) {
  let t = BC(s).toArray(), e = t[3] === void 0 ? 1 : t[3];
  return [t[0] * 255, t[1] * 255, t[2] * 255, e];
}
function Oh(s) {
  const t = pi(s);
  return new Ce(t[0], t[1], t[2]);
}
function BC(s) {
  if (!s)
    return new Ce(1, 1, 1);
  if (s.isColor)
    return s;
  if (typeof s == "string") {
    const t = /^#([0-9A-Fa-f]{8})/, e = s.match(t);
    if (e) {
      const a = e[1], g = `#${a.slice(0, 6)}`, c = parseInt(a.slice(6, 8), 16) / 255, l = new Ce(g);
      return new Me(l.r, l.g, l.b, c);
    }
    const i = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/, n = s.match(i);
    if (n) {
      const a = parseInt(n[1], 10), g = parseInt(n[2], 10), c = parseInt(n[3], 10), l = parseFloat(n[4]), h = `rgb(${a}, ${g}, ${c})`, d = new Ce(h);
      return new Me(d.r, d.g, d.b, l);
    }
    const o = /hsla\s*\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*([\d.]+)\s*\)/, r = s.match(o);
    if (r) {
      const a = parseInt(r[1], 10) / 360, g = parseInt(r[2], 10) / 100, c = parseInt(r[3], 10) / 100, l = parseFloat(r[4]), h = new Ce().setHSL(a, g, c);
      return new Me(h.r, h.g, h.b, l);
    }
  }
  return new Ce(s);
}
function Bw(s) {
  const t = s >> 11, e = s >> 5 & 63, i = s & 31, n = Math.round(t / 31 * 255), o = Math.round(e / 63 * 255), r = Math.round(i / 31 * 255);
  return [n, o, r];
}
const BY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  colorToArr4: pi,
  colorToRgbaArr: sr,
  normalizeColor: Oh,
  convertSRGBColor: BC,
  rgb565torgb: Bw
}, Symbol.toStringTag, { value: "Module" })), Ho = {
  mvt_emissive: {
    value: null
  },
  mvt_emissiveIntensity: {
    value: 1
  }
}, zn = {
  selectedObjectColor: {
    value: [1, 1, 0, 0.5]
  },
  selectedObjectIndex: {
    value: -1
  },
  selectedObjectColorMode: {
    value: 0
  }
}, wC = {
  keepSize: {
    value: !1
  },
  zoomUnits: {
    value: 1
  }
}, oi = (s, t = []) => {
  for (let e of t)
    Object.defineProperty(s, e, {
      get: function() {
        return this.uniforms[e].value;
      },
      set: function(i) {
        this.uniforms[e].value = i;
      }
    });
}, Xn = (s, t = []) => {
  for (let e of t)
    Object.defineProperty(s, e, {
      get: function() {
        return this.uniforms[e].value;
      },
      set: function(i) {
        this.uniforms[e].value = Oh(i);
      }
    });
}, Js = (s, t = []) => {
  for (let [e, i, n] of t)
    Object.defineProperty(s, e, {
      get: function() {
        return this.uniforms[i].value;
      },
      set: function(o) {
        this.uniforms[i].value = n ? n(o) : o;
      }
    });
}, ri = (s, t = []) => {
  for (let [e, i] of t)
    Object.defineProperty(s, e, {
      get: function() {
        return !!this.defines[i];
      },
      set: function(n) {
        this[e] !== n && (n ? this.defines[i] = !0 : delete this.defines[i], this.needsUpdate = !0);
      }
    });
}, Po = (s) => {
  Object.defineProperties(s, {
    selectedObjectColor: {
      get: function() {
        return this.uniforms.selectedObjectColor.value;
      },
      set: function(t) {
        this.uniforms.selectedObjectColor.value = t;
      }
    },
    selectedObjectColorMode: {
      get: function() {
        return this.uniforms.selectedObjectColorMode.value;
      },
      set: function(t) {
        this.uniforms.selectedObjectColorMode.value = t;
      }
    },
    selectedObjectIndex: {
      get: function() {
        return this.uniforms.selectedObjectIndex.value;
      },
      set: function(t) {
        this.uniforms.selectedObjectIndex.value = t;
      }
    },
    selective: {
      get: function() {
        return !!this.defines.MVT_ENABLE_SELECTIVE;
      },
      set: function(t) {
        this.selective !== t && (t ? this.defines.MVT_ENABLE_SELECTIVE = !0 : delete this.defines.MVT_ENABLE_SELECTIVE, this.needsUpdate = !0);
      }
    }
  });
}, Ka = (s) => {
  Object.defineProperties(s, {
    keepSize: {
      get: function() {
        return this.uniforms.keepSize.value;
      },
      set: function(t) {
        this.uniforms.keepSize.value = t;
      }
    },
    zoomUnits: {
      get: function() {
        return this.uniforms.zoomUnits.value;
      },
      set: function(t) {
        this.uniforms.zoomUnits.value = t;
      }
    },
    zoomUnitsUniform: {
      get: function() {
        return this.uniforms.zoomUnits;
      },
      set: function(t) {
        this.uniforms.zoomUnits = t;
      }
    }
  });
}, No = (s) => {
  Object.defineProperties(s, {
    emissiveEnabled: {
      get: function() {
        return this.defines.MVT_EMISSIVE_UNIFORM || !1;
      },
      set: function(t) {
        t ? this.defines.MVT_EMISSIVE_UNIFORM = !0 : delete this.defines.MVT_EMISSIVE_UNIFORM;
      }
    },
    emissive: {
      get: function() {
        return this.uniforms.mvt_emissive.value;
      },
      set: function(t) {
        t ? this.defines.MVT_EMISSIVE_COLOR = !0 : delete this.defines.MVT_EMISSIVE_COLOR, this.uniforms.mvt_emissive.value = t;
      }
    },
    emissiveIntensity: {
      get: function() {
        return this.uniforms.mvt_emissiveIntensity.value;
      },
      set: function(t) {
        this.uniforms.mvt_emissiveIntensity.value = t;
      }
    }
  });
}, ZD = {
  tDiffuse: { value: null },
  tNormal: { value: null },
  tMetalness: { value: null },
  tEnhancement: { value: null },
  tEnhancementScale: { value: new Z(20, 20) },
  tDepth: { value: null },
  cameraNear: { value: null },
  cameraFar: { value: null },
  resolution: { value: new Z() },
  cameraProjectionMatrix: { value: new J() },
  cameraInverseProjectionMatrix: { value: new J() },
  mvt_viewInverseMatrix: { value: new J() },
  mvt_normalInverseMatrix: { value: new qe() },
  opacity: { value: 0.5 },
  maxDistance: { value: 180 },
  cameraRange: { value: 0 },
  thickness: { value: 0.018 },
  logDepthBufFC: { value: 1 },
  threshold: { value: 0.6 }
};
class UD extends ze {
  constructor(t) {
    super(), this.vertexShader = XD, this.fragmentShader = WD, this.uniforms = we.clone(ZD), this.defines = {
      MAX_STEP: 0,
      PERSPECTIVE_CAMERA: !0,
      DISTANCE_ATTENUATION: !0,
      FRESNEL: !0,
      INFINITE_THICK: !1,
      SELECTIVE: !1
    }, oi(this, [
      "tDiffuse",
      "tNormal",
      "tDepth",
      "tMetalness",
      "cameraNear",
      "cameraFar",
      "threshold",
      "thickness",
      "opacity",
      "tEnhancementScale"
    ]), ri(this, []), Object.defineProperties(this, {
      tEnhancement: {
        get: function() {
          return this.uniforms.tEnhancement.value;
        },
        set: function(e) {
          e ? (this.uniforms.tEnhancement.value = e, this.defines.MVT_SSR_USE_ENHANCEMENT_MAP = !0) : (this.uniforms.tEnhancement.value = null, delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP);
        }
      }
    }), this.setValues(t);
  }
  dispose() {
    let t = [
      "tEnhancement",
      "tDiffuse",
      "tNormal",
      "tDepth",
      "tMetalness"
    ];
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      this.uniforms[i] && this.uniforms[i].value && this.uniforms[i].value.dispose();
    }
    super.dispose();
  }
}
class OD extends Xi {
  constructor() {
    super();
    const t = this.material = new UD();
    t.defines.DISTANCE_ATTENUATION = !0, t.defines.SELECTIVE = !0, this.fsQuad = new Ut(null), this.needsSwap = !0, this.needsMetallicRoughTexture = !0, this.needsNormalTexture = !0, this.needsDepthTexture = !0;
  }
  render(t, e, i) {
    const n = this.rendering, o = n.main.sceneRendering, r = n.camera, a = this.material;
    a.uniforms.tDiffuse.value = i.texture, a.uniforms.tDepth.value = o.depthTexture, a.uniforms.tNormal.value = o.normalTexture, a.uniforms.tMetalness.value = o.metallicRoughTexture;
    const g = new Z(i.width, i.height);
    a.uniforms.resolution.value = g, a.defines.MAX_STEP = Math.min(512, Math.sqrt(g.x * g.x + g.y * g.y)), a.uniforms.cameraProjectionMatrix.value.copy(r.projectionMatrix), a.uniforms.cameraInverseProjectionMatrix.value.copy(r.projectionMatrixInverse), a.uniforms.mvt_viewInverseMatrix.value.copy(r.matrixWorld), a.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(r.matrixWorldInverse), a.uniforms.cameraNear.value = r.near, a.uniforms.cameraFar.value = r.far, this.fsQuad.material = a, t.setRenderTarget(this.renderToScreen ? null : e), t.clear(), this.fsQuad.render(t);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class QD extends Vn {
  constructor(e, i) {
    super(e, i);
    f(this, "name", "reflection");
    f(this, "_method", "ssr");
    f(this, "_lastMethod", "ssr");
    f(this, "_lastEnabled", !1);
    this.enabled = i.enabled, this._method = i.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _disableOldMethod() {
    const e = this._lastMethod, i = this._rendering;
    e === "ssr" && (this._ssrPass && i.main.postprocessings.remove(this._ssrPass), this._ssrPass = null);
  }
  _enableNewMethod() {
    const e = this._method, i = this._rendering;
    if (e === "ssr") {
      const n = this._ssrPass = new OD();
      n.renderOrder = 800, n.rendering = i, i.main.postprocessings.add(n);
    }
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  dispose() {
    this.enabled && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
}
const Vd = new J(), Cs = new B(), ka = new Ue(), zd = new J(), xp = new J(), YD = new B(0, 1, 0);
class jD {
  constructor() {
    f(this, "maxFar", 500);
    f(this, "lightMargin", 20);
    this.vertices = {
      near: [
        new B(),
        new B(),
        new B(),
        new B()
      ],
      far: [
        new B(),
        new B(),
        new B(),
        new B()
      ]
    };
  }
  updateFromCameraProjectionMatrix(t, e = 0) {
    const i = t.projectionMatrixInverse;
    this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(o) {
      o.applyMatrix4(i);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1);
    let n = Math.min((t.position.z - e) * 5, this.maxFar);
    n = Math.max(n, 50), this.vertices.far.forEach((o) => {
      o.applyMatrix4(i);
      const r = Math.abs(o.z);
      o.multiplyScalar(Math.min(n / r, 1));
    });
  }
  updateShadowBounds(t, e) {
    const i = t.shadow.camera, n = this.vertices.near, o = this.vertices.far, r = o[0];
    let a;
    r.distanceTo(o[2]) > r.distanceTo(n[2]) ? a = o[2] : a = n[2];
    let g = r.distanceTo(a);
    this.fade, i.left = -g / 2, i.right = g / 2, i.top = g / 2, i.bottom = -g / 2, i.updateProjectionMatrix();
  }
  updateLightPosition(t, e, i, n = 1024, o = 0) {
    zd.lookAt(new B(), e, YD), xp.copy(zd).invert();
    const r = t.shadow.camera, a = (r.right - r.left) / n, g = (r.top - r.bottom) / n;
    Vd.multiplyMatrices(xp, i.matrixWorld);
    for (let h = 0; h < 4; h++)
      this.vertices.near[h].copy(this.vertices.near[h]).applyMatrix4(Vd), this.vertices.far[h].copy(this.vertices.far[h]).applyMatrix4(Vd);
    const c = this.vertices.near, l = this.vertices.far;
    ka.makeEmpty();
    for (let h = 0; h < 4; h++)
      ka.expandByPoint(c[h]), ka.expandByPoint(l[h]);
    ka.getCenter(Cs), Cs.z = ka.max.z + this.lightMargin, Cs.x = Math.floor(Cs.x / a) * a, Cs.y = Math.floor(Cs.y / g) * g, Cs.applyMatrix4(zd), t.position.copy(Cs), t.target.position.copy(Cs), t.target.position.x += e.x, t.target.position.y += e.y, t.target.position.z += e.z;
  }
}
class JD {
  constructor(t) {
    this._rendering = t, this._shadowFrustum = new jD();
  }
  update(t, e) {
    const i = this._rendering._engine, [n, o] = i.map.getProjectionCenter();
    let r = i.map.getCameraDistance();
    const a = i.rendering.camera.position.z;
    let g = 1e3;
    const c = g * e[0], l = g * e[1], h = g * e[2];
    t.position.set(n + c, o + l, h), t.target.position.set(n, o, 0), t.shadow.camera.left = -r, t.shadow.camera.bottom = -r, t.shadow.camera.right = r, t.shadow.camera.top = r, t.shadow.camera.near = 1, a > 1e3 ? t.shadow.camera.far = 2 : t.shadow.camera.far = g * 2;
    const d = i.camera;
    this._shadowFrustum.updateFromCameraProjectionMatrix(d, i.rendering.shadow.baseHeight), this._shadowFrustum.updateShadowBounds(t, d), this._shadowFrustum.updateLightPosition(
      t,
      new B(-e.x, -e.y, -e.z),
      d,
      t.shadow.mapSize.x
    ), t.updateMatrix(), t.updateMatrixWorld(), t.target.updateMatrix(), t.target.updateMatrixWorld(), t.shadow.camera.updateProjectionMatrix();
    const C = ce.mapLinear(a, 1, 1e4, -8e-5, -0.5);
    t.shadow.bias = C < -5e-3 ? -1e-3 : C * 0.2, this._currenLight = t;
  }
  getCurrentUsedTextures() {
    if (this._currenLight)
      return [this._currenLight.shadow.map.texture];
  }
  dispose() {
  }
}
const vp = {
  lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
 	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
 
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

  		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further
			cascade = CSM_cascades[ i ];
			cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
			closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
			margin = 0.25 * pow( closestEdge, 2.0 );
			csmx = cascade.x - margin / 2.0;
			csmy = cascade.y + margin / 2.0;
			if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

				float dist = min( linearDepth - csmx, csmy - linearDepth );
				float ratio = clamp( dist / margin, 0.0, 1.0 );

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

				ReflectedLight prevLight = reflectedLight;
				RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

				bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
				float blendRatio = shouldBlend ? ratio : 1.0;

				reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
				reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
				reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
				reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

			}
	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

			directionalLightShadow = directionalLightShadows[ i ];
			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

			if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,
  lights_pars_begin: `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + Ee.lights_pars_begin
}, Xd = new J();
class Qh {
  constructor(t) {
    t = t || {}, this.vertices = {
      near: [
        new B(),
        new B(),
        new B(),
        new B()
      ],
      far: [
        new B(),
        new B(),
        new B(),
        new B()
      ]
    }, t.projectionMatrix !== void 0 && this.setFromProjectionMatrix(t.projectionMatrix, t.maxFar || 1e4);
  }
  setFromProjectionMatrix(t, e) {
    const i = t.elements[11] === 0;
    return Xd.copy(t).invert(), this.vertices.near[0].set(1, 1, -1), this.vertices.near[1].set(1, -1, -1), this.vertices.near[2].set(-1, -1, -1), this.vertices.near[3].set(-1, 1, -1), this.vertices.near.forEach(function(n) {
      n.applyMatrix4(Xd);
    }), this.vertices.far[0].set(1, 1, 1), this.vertices.far[1].set(1, -1, 1), this.vertices.far[2].set(-1, -1, 1), this.vertices.far[3].set(-1, 1, 1), this.vertices.far.forEach(function(n) {
      n.applyMatrix4(Xd);
      const o = Math.abs(n.z);
      i ? n.z *= Math.min(e / o, 1) : n.multiplyScalar(Math.min(e / o, 1));
    }), this.vertices;
  }
  split(t, e) {
    for (; t.length > e.length; )
      e.push(new Qh());
    e.length = t.length;
    for (let i = 0; i < t.length; i++) {
      const n = e[i];
      if (i === 0)
        for (let o = 0; o < 4; o++)
          n.vertices.near[o].copy(this.vertices.near[o]);
      else
        for (let o = 0; o < 4; o++)
          n.vertices.near[o].lerpVectors(this.vertices.near[o], this.vertices.far[o], t[i - 1]);
      if (i === t.length - 1)
        for (let o = 0; o < 4; o++)
          n.vertices.far[o].copy(this.vertices.far[o]);
      else
        for (let o = 0; o < 4; o++)
          n.vertices.far[o].lerpVectors(this.vertices.near[o], this.vertices.far[o], t[i]);
    }
  }
  toSpace(t, e) {
    for (let i = 0; i < 4; i++)
      e.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(t), e.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(t);
  }
}
class qD extends mt {
  constructor(t) {
    super(), this.csm = t, this.displayFrustum = !0, this.displayPlanes = !0, this.displayShadowBounds = !0;
    const e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), n = new Qe();
    n.setIndex(new Fe(e, 1)), n.setAttribute("position", new Fe(i, 3, !1));
    const o = new Ma(n, new _r());
    this.add(o), this.frustumLines = o, this.cascadeLines = [], this.cascadePlanes = [], this.shadowLines = [];
  }
  updateVisibility() {
    const t = this.displayFrustum, e = this.displayPlanes, i = this.displayShadowBounds, n = this.frustumLines, o = this.cascadeLines, r = this.cascadePlanes, a = this.shadowLines;
    for (let g = 0, c = o.length; g < c; g++) {
      const l = o[g], h = r[g], d = a[g];
      l.visible = t, h.visible = t && e, d.visible = i;
    }
    n.visible = t;
  }
  update() {
    const t = this.csm, e = t.camera, i = t.cascades, n = t.mainFrustum, o = t.frustums, r = t.lights, g = this.frustumLines.geometry.getAttribute("position"), c = this.cascadeLines, l = this.cascadePlanes, h = this.shadowLines;
    for (this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.updateMatrixWorld(!0); c.length > i; )
      this.remove(c.pop()), this.remove(l.pop()), this.remove(h.pop());
    for (; c.length < i; ) {
      const p = new $l(new Ue(), 16777215), m = new _t({ transparent: !0, opacity: 0.1, depthWrite: !1, side: xr }), b = new le(new Og(), m), S = new mt(), A = new $l(new Ue(), 16776960);
      S.add(A), this.add(p), this.add(b), this.add(S), c.push(p), l.push(b), h.push(S);
    }
    for (let p = 0; p < i; p++) {
      const m = o[p], S = r[p].shadow.camera, A = m.vertices.far, u = c[p], y = l[p], I = h[p], M = I.children[0];
      u.box.min.copy(A[2]), u.box.max.copy(A[0]), u.box.max.z += 1e-4, y.position.addVectors(A[0], A[2]), y.position.multiplyScalar(0.5), y.scale.subVectors(A[0], A[2]), y.scale.z = 1e-4, this.remove(I), I.position.copy(S.position), I.quaternion.copy(S.quaternion), I.scale.copy(S.scale), I.updateMatrixWorld(!0), this.attach(I), M.box.min.set(S.bottom, S.left, -S.far), M.box.max.set(S.top, S.right, -S.near);
    }
    const d = n.vertices.near, C = n.vertices.far;
    g.setXYZ(0, C[0].x, C[0].y, C[0].z), g.setXYZ(1, C[3].x, C[3].y, C[3].z), g.setXYZ(2, C[2].x, C[2].y, C[2].z), g.setXYZ(3, C[1].x, C[1].y, C[1].z), g.setXYZ(4, d[0].x, d[0].y, d[0].z), g.setXYZ(5, d[3].x, d[3].y, d[3].z), g.setXYZ(6, d[2].x, d[2].y, d[2].z), g.setXYZ(7, d[1].x, d[1].y, d[1].z), g.needsUpdate = !0;
  }
  dispose() {
    const t = this.frustumLines, e = this.cascadeLines, i = this.cascadePlanes, n = this.shadowLines;
    t.geometry.dispose(), t.material.dispose();
    const o = this.csm.cascades;
    for (let r = 0; r < o; r++) {
      const a = e[r], g = i[r], l = n[r].children[0];
      a.dispose(), g.geometry.dispose(), g.material.dispose(), l.dispose();
    }
  }
}
const Tp = new J(), Wd = new Qh(), fs = new B(), Va = new Ue(), Zd = [], Ud = [], Od = new J(), Lp = new J(), $D = new B(0, 0, 1);
function eK(s, t, e, i) {
  for (let n = 1; n < s; n++)
    i.push((t + (e - t) * n / s) / e);
  i.push(1);
}
function tK(s, t, e, i) {
  for (let n = 1; n < s; n++)
    i.push(t * (e / t) ** (n / s) / e);
  i.push(1);
}
function iK(s, t, e, i, n) {
  Zd.length = 0, Ud.length = 0, tK(s, t, e, Ud), eK(s, t, e, Zd);
  for (let o = 1; o < s; o++)
    n.push(ce.lerp(Zd[o - 1], Ud[o - 1], i));
  n.push(1);
}
const nK = [
  -5e-4,
  -8e-4,
  -15e-4,
  -4e-3
];
class sK {
  constructor(t) {
    f(this, "_lights", null);
    f(this, "_light", null);
    f(this, "_parent", null);
    f(this, "_cascades", 4);
    f(this, "_maxFar", 1e3);
    f(this, "_shadowMapSize", 1024);
    f(this, "_lightNear", 1);
    f(this, "_lightFar", 1e3);
    f(this, "_lightMargin", 100);
    f(this, "_shadowBias", -5e-4);
    f(this, "_mainFrustum", null);
    f(this, "_frustums", []);
    f(this, "_breaks", []);
    f(this, "_helper", null);
    f(this, "_fade", !0);
    this._rendering = t, this._engine = t._engine, this._uniforms = {
      CSM_cascades: {
        value: []
      },
      cameraNear: {
        value: 1
      },
      shadowFar: {
        value: 1e3
      }
    };
  }
  init() {
    this._old_lights_fragment_begin = Ee.lights_fragment_begin, this._old_lights_pars_begin = Ee.lights_pars_begin, Ee.lights_fragment_begin = vp.lights_fragment_begin, Ee.lights_pars_begin = vp.lights_pars_begin;
  }
  update(t, e, i) {
    this._rendering._engine, this._light && this._light !== t && this._destroyLight(), this._light || (this._createLight(t, i), this._light = t);
    const n = new B(-e.x, -e.y, -e.z);
    this.updateFrame(t, n);
  }
  updateFrame(t, e) {
    const i = this._engine.camera, n = this._frustums;
    Od.lookAt(new B(), e, $D), Lp.copy(Od).invert();
    for (let o = 0; o < n.length; o++) {
      const r = this._lights[o];
      r.color.copy(t.color), r.intensity = t.intensity;
      const a = r.shadow.camera, g = (a.right - a.left) / this._shadowMapSize, c = (a.top - a.bottom) / this._shadowMapSize;
      Tp.multiplyMatrices(Lp, i.matrixWorld), n[o].toSpace(Tp, Wd);
      const l = Wd.vertices.near, h = Wd.vertices.far;
      Va.makeEmpty();
      for (let d = 0; d < 4; d++)
        Va.expandByPoint(l[d]), Va.expandByPoint(h[d]);
      Va.getCenter(fs), fs.z = Va.max.z + this._lightMargin, fs.x = Math.floor(fs.x / g) * g, fs.y = Math.floor(fs.y / c) * c, fs.applyMatrix4(Od), r.position.copy(fs), r.target.position.copy(fs), r.target.position.x += e.x, r.target.position.y += e.y, r.target.position.z += e.z;
    }
  }
  _createLight(t, e) {
    this._parent = e, this._lights = [], this._light = t, this._mainLightCastShadow = t.castShadow, t.castShadow = !1, t.visible = !1;
    for (let i = 0; i < this._cascades; i++) {
      const n = new Ph(t.color, t.intensity);
      n.castShadow = !0, n.shadow.mapSize.width = this._shadowMapSize, n.shadow.mapSize.height = this._shadowMapSize, n.shadow.camera.near = this._lightNear, n.shadow.camera.far = this._lightFar, n.shadow.bias = this._shadowBias, n.shadow.bias = nK[i], n.shadow.normalBias = 1e-4, e.add(n), e.add(n.target), this._lights.push(n);
    }
    this._mainFrustum = new Qh(), this._frustums = [], this.updateFrustums();
  }
  getBreaks() {
    const e = this._rendering._engine.camera, i = Math.min(e.far, this._maxFar);
    this._breaks.length = 0, iK(this._cascades, e.near, i, 0.5, this._breaks), this._breaks = [0.05, 0.2, 0.45, 1], this.getExtendedBreaks(this._uniforms.CSM_cascades.value);
  }
  initCascades() {
    const e = this._rendering._engine.camera;
    this._mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this._maxFar), this._mainFrustum.split(this._breaks, this._frustums);
  }
  updateShadowBounds() {
    const t = this._frustums;
    for (let e = 0; e < t.length; e++) {
      const n = this._lights[e].shadow.camera, o = t[e], r = o.vertices.near, a = o.vertices.far, g = a[0];
      let c;
      g.distanceTo(a[2]) > g.distanceTo(r[2]) ? c = a[2] : c = r[2];
      let l = g.distanceTo(c);
      const h = this._engine.camera, d = Math.max(h.far, this._maxFar), C = o.vertices.far[0].z / (d - h.near), p = 0.25 * Math.pow(C, 2) * (d - h.near);
      l += p * 2, n.left = -l / 2, n.right = l / 2, n.top = l / 2, n.bottom = -l / 2, n.updateProjectionMatrix();
    }
  }
  updateUniforms() {
    const t = this._engine.camera, e = Math.min(t.far, this._maxFar), i = this._uniforms;
    i.cameraNear.value = t.near, i.shadowFar.value = e;
  }
  getExtendedBreaks(t) {
    for (; t.length < this._breaks.length; )
      t.push(new Z());
    t.length = this._breaks.length;
    for (let e = 0; e < this._cascades; e++) {
      const i = this._breaks[e], n = this._breaks[e - 1] || 0;
      t[e].x = n, t[e].y = i;
    }
  }
  updateFrustums() {
    this.getBreaks(), this.initCascades(), this.updateShadowBounds(), this.updateUniforms();
  }
  updateCSMShadow(t, e) {
    t.defines || (t.defines = {}), this._fade && (t.defines.CSM_FADE = ""), t.defines.USE_CSM = 1, t.defines.CSM_CASCADES = this._cascades, e.uniforms.CSM_cascades = this._uniforms.CSM_cascades, e.uniforms.cameraNear = this._uniforms.cameraNear, e.uniforms.shadowFar = this._uniforms.shadowFar;
  }
  _destroyLight() {
    const t = this._light;
    t.castShadow = this._mainLightCastShadow, t.visible = !0, this._light = null;
    for (const e of this._lights)
      this._parent.remove(e), this._parent.remove(e.target);
  }
  dispose() {
    Ee.lights_fragment_begin = this._old_lights_fragment_begin, Ee.lights_pars_begin = this._old_lights_pars_begin, this._destroyLight();
  }
  getCurrentUsedTextures() {
    const t = [];
    for (const e of this._lights)
      t.push(e.shadow.map.texture);
    return t;
  }
  get shadowBias() {
    return this._shadowBias;
  }
  set shadowBias(t) {
    this._shadowBias = t;
    for (const e of this._lights)
      e.shadow.bias = t;
  }
  get showHelper() {
    return !!this._helper;
  }
  set showHelper(t) {
    t ? (this._helper || (this._helper = new qD(this._lights)), this._parent.add(this._helper)) : (this._parent.remove(this._helper), this._helper = null);
  }
}
class oK extends Vn {
  constructor(e, i) {
    super(e, i);
    f(this, "name", "shadow");
    f(this, "_method", "default");
    f(this, "_lastMethod", "default");
    f(this, "_lastEnabled", !1);
    f(this, "_baseHeight", 0);
    f(this, "needsShaderKey", !0);
    f(this, "updateShadow", (e, i, n) => {
      this._method === "default" ? this._defaultShadow.update(e, i) : this._method === "csm" && this._csmShadow.update(e, i, n);
    });
    f(this, "getCurrentUsedTextures", () => {
      if (!!this.enabled) {
        if (this._method === "csm")
          return this._csmShadow.getCurrentUsedTextures();
        if (this._method === "default")
          return this._defaultShadow.getCurrentUsedTextures();
      }
    });
    f(this, "updateCSMShadow", (e, i) => {
      this._method === "csm" && this._csmShadow.updateCSMShadow(e, i);
    });
    this.enabled = i.enabled, this._method = i.method;
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._enableNewMethod() : this._disableOldMethod();
      return;
    }
    this.enabled && this._lastMethod !== this._method && (this._disableOldMethod(), this._enableNewMethod());
  }
  _enableNewMethod() {
    const e = this._method, i = this._rendering;
    i.renderer.shadowMap.enabled = !0, e === "default" ? (this._defaultShadow = new JD(i), this._currentShaderKey = "1") : e === "csm" && (this._csmShadow = new sK(i), this._csmShadow.init(), this._currentShaderKey = "2"), this._lastMethod = e;
  }
  _disableOldMethod() {
    const e = this._lastMethod, i = this._rendering;
    i.renderer.shadowMap.enabled = !1, e === "default" ? (this._defaultShadow.dispose(), this._defaultShadow = null) : e === "csm" && (this._csmShadow.dispose(), this._csmShadow = null), this._currentShaderKey = "0";
  }
  getCurrentShaderKey() {
    return this._currentShaderKey;
  }
  endFrame() {
    this._lastEnabled = this.enabled, this._lastMethod = this._method;
  }
  set baseHeight(e) {
    this._baseHeight = e;
  }
  get baseHeight() {
    return this._baseHeight;
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
}
const rK = `
#include <packing>
uniform sampler2D tDiffuse;
varying vec2 vUv;

void main() {

    gl_FragColor = packDepthToRGBA(texture2D(tDiffuse, vUv).r);
}
`, Ac = 255 / 256, aK = new Me(
  Ac / (256 * 256 * 256),
  Ac / (256 * 256),
  Ac / 256,
  Ac
), Gp = new Me();
class gK extends Vn {
  constructor() {
    super(...arguments);
    f(this, "name", "depthPicking");
    f(this, "_lastEnabled", !1);
    f(this, "needsDepthTexture", !0);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
  }
  _init() {
    const e = this._rendering, i = e.resolution, n = e.pixelRatio;
    this._depthColorRenderTarget = new It(
      i.x * n,
      i.y * n,
      {
        depthBuffer: !1
      }
    ), this._fsQuad = new Ut(new ze({
      name: Ht.name,
      vertexShader: Ht.vertexShader,
      fragmentShader: rK,
      uniforms: {
        tDiffuse: {
          value: null
        },
        opacity: {
          value: 1
        }
      }
    }));
  }
  _unpackRGBAToDepth(e) {
    return Gp.set(e[0] / 255, e[1] / 255, e[2] / 255, e[3] / 255), Gp.dot(aK);
  }
  async pickDepth(e, i) {
    const n = this._rendering, o = n.renderer, r = n.pixelRatio, a = new Uint8Array(4);
    o.readRenderTargetPixels(
      this._depthColorRenderTarget,
      e * r,
      i * r,
      1,
      1,
      a
    );
    let g = this._unpackRGBAToDepth(a);
    if (g > 0.99 || g < 1e-6)
      return null;
    const c = n.camera, l = c.far, h = c.near, d = 2 / (Math.log(l + 1) / Math.log(2));
    let C = Math.pow(2, g / (d * 0.5)) - 1;
    return C = -C, g = (h + C) * l / ((l - h) * C), g;
  }
  afterRender() {
    if (!this.enabled)
      return;
    const e = this._rendering, i = e.main.sceneRendering;
    if (!i.depthTexture)
      return;
    this._fsQuad.material.uniforms.tDiffuse.value = i.depthTexture;
    const n = e.renderer, o = n.autoClear;
    n.autoClear = !1, n.setRenderTarget(this._depthColorRenderTarget), n.clear(), this._fsQuad.render(n), n.autoClear = o;
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._fsQuad.material.dispose(), this._fsQuad.dispose(), this._depthColorRenderTarget.dispose(), this._depthColorRenderTarget = null, this._fsQuad = null;
  }
  get viewTextures() {
    return this._depthColorRenderTarget ? [this._depthColorRenderTarget.texture] : null;
  }
}
const cK = `

uniform sampler2D tDiffuse;
varying vec2 vUv;

uniform float saturation;
uniform float brightness;
uniform float contrast;

void main() {
    vec4 outColor = texture2D(tDiffuse, vUv);
    vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));
    outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + saturation);

    outColor.xyz = 0.5 + (1.0 + contrast) * (outColor.xyz - 0.5);
    outColor.xyz = outColor.xyz + brightness;
    gl_FragColor = outColor;
}
`;
class lK extends Xi {
  constructor() {
    super();
    const t = Ht;
    this.uniforms = {
      tDiffuse: { value: null },
      saturation: { value: 1 },
      brightness: { value: 0 },
      contrast: { value: 1 }
    }, this.material = new ze({
      uniforms: this.uniforms,
      vertexShader: t.vertexShader,
      fragmentShader: cK,
      depthTest: !1,
      depthWrite: !1
    }), this.needsSwap = !0, this.fsQuad = new Ut(null);
  }
  render(t, e, i) {
    const n = t.autoClear;
    t.autoClear = !1, this.fsQuad.material = this.material, this.material.uniforms.tDiffuse.value = i.texture, t.setRenderTarget(this.renderToScreen ? null : e), t.clear(), this.fsQuad.render(t), t.autoClear = n;
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
  get saturation() {
    return this.uniforms.saturation.value;
  }
  set saturation(t) {
    this.uniforms.saturation.value = t;
  }
  get brightness() {
    return this.uniforms.brightness.value;
  }
  set brightness(t) {
    this.uniforms.brightness.value = t;
  }
  get contrast() {
    return this.uniforms.contrast.value;
  }
  set contrast(t) {
    this.uniforms.contrast.value = t;
  }
}
class hK extends Vn {
  constructor(e, i) {
    super(e, i);
    f(this, "name", "ColorAdjustment");
    f(this, "_saturation", 0);
    f(this, "_brightness", 0);
    f(this, "_contrast", 0);
    this.enabled = i.enabled, i.saturation !== void 0 && (this._saturation = i.saturation), i.brightness !== void 0 && (this._brightness = i.brightness), i.contrast !== void 0 && (this._contrast = i.contrast);
  }
  beginFrame() {
    if (this.enabled && !this._renderPass) {
      const e = this._renderPass = new lK();
      e.saturation = this._saturation, e.brightness = this._brightness, e.contrast = this._contrast, this._rendering.main.postprocessings.add(this._renderPass);
    } else
      !this.enabled && this._renderPass && (this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass.dispose(), this._renderPass = null);
  }
  afterRender() {
  }
  endFrame() {
  }
  dispose() {
    this._renderPass && (this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass.dispose(), this._renderPass = null);
  }
  get saturation() {
    return this._saturation;
  }
  set saturation(e) {
    this._saturation = e, this._renderPass && (this._renderPass.saturation = e);
  }
  get brightness() {
    return this._brightness;
  }
  set brightness(e) {
    this._brightness = e, this._renderPass && (this._renderPass.brightness = e);
  }
  get contrast() {
    return this._contrast;
  }
  set contrast(e) {
    this._contrast = e, this._renderPass && (this._renderPass.contrast = e);
  }
}
const dK = `
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform sampler2D tVideo;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewInverseMatrix;
uniform mat4 videoProjectionMatrix;
uniform mat4 videoViewMatrix;
uniform float cameraNear;
uniform float cameraFar;
uniform float opacity;

uniform float k1, k2, k3;
uniform float p1, p2;

varying vec2 vUv;

#include <packing>
#include <mvt_depth_packing>

bool visible(vec4 result) {
    result.x /= result.w;
    result.y /= result.w;
    result.z /= result.w;

    return result.x >= -1.0 && result.x <= 1.0 &&
           result.y >= -1.0 && result.y <= 1.0 &&
           result.z >= -1.0 && result.z <= 1.0;
}

// \u7578\u53D8\u6821\u6B63\u51FD\u6570
vec2 undistort(vec2 uv) {
    // \u5C06\u7EB9\u7406\u5750\u6807\u8F6C\u6362\u5230[-1, 1]\u8303\u56F4
    vec2 uvNorm = uv * 2.0 - 1.0;

    float r2 = uvNorm.x * uvNorm.x + uvNorm.y * uvNorm.y;
    float radialDistortion = 1.0 + k1 * r2 + k2 * r2 * r2 + k3 * r2 * r2 * r2;
    float tangentialDistortionX = 2.0 * p1 * uvNorm.x * uvNorm.y + p2 * (r2 + 2.0 * uvNorm.x * uvNorm.x);
    float tangentialDistortionY = p1 * (r2 + 2.0 * uvNorm.y * uvNorm.y) + 2.0 * p2 * uvNorm.x * uvNorm.y;

    uvNorm.x = uvNorm.x * radialDistortion + tangentialDistortionX;
    uvNorm.y = uvNorm.y * radialDistortion + tangentialDistortionY;

    // \u5C06\u7EB9\u7406\u5750\u6807\u8F6C\u6362\u56DE[0, 1]\u8303\u56F4
    return (uvNorm + 1.0) / 2.0;
}

void main() {
    vec4 diffuseColor = texture2D(tDiffuse, vUv);
    vec4 outputColor = diffuseColor;

    // \u8BA1\u7B97\u5F53\u524D\u7247\u5143\u7684\u4E16\u754C\u5750\u6807
    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);
    vec3 worldPosition = mvtGetWorldPositionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix);

    vec4 videoPos= videoProjectionMatrix * videoViewMatrix * vec4(worldPosition, 1.0);

    // \u5728\u89C6\u91CE\u5185\u7684\u7247\u5143\u624D\u8FDB\u884C\u878D\u5408
    if (visible(videoPos) && depth <= 0.999999) {
        vec4 gytyPosition = videoProjectionMatrix * videoViewMatrix * vec4(worldPosition.xyz, 1.0);
        gytyPosition= gytyPosition / gytyPosition.w;
        float s = (gytyPosition.s + 1.0) / 2.0;
        float t = (gytyPosition.t + 1.0) / 2.0;
        vec2 uv_depth = vec2(s, t);

        // \u5BF9\u7EB9\u7406\u5750\u6807\u8FDB\u884C\u7578\u53D8\u6821\u6B63
        uv_depth = undistort(uv_depth);
        if (uv_depth.x >= 0.0 && uv_depth.x <= 1.0 && uv_depth.y >= 0.0 && uv_depth.y <= 1.0) {
            vec4 videoColor = texture2D(tVideo, uv_depth);
            outputColor = mix(diffuseColor, videoColor, opacity);
        }
    }

    gl_FragColor = outputColor;
}
`;
class uK extends Xi {
  constructor(t, e) {
    super(), this.name = "CameraFusionPass", this.needsSwap = !0, this._camera = e;
    const i = Ht;
    this.uniforms = we.merge([
      we.clone(i.uniforms),
      {
        tDepth: { value: null },
        tVideo: { value: t },
        projectionInverseMatrix: { value: new J() },
        viewInverseMatrix: { value: new J() },
        videoProjectionMatrix: { value: new J() },
        videoViewMatrix: { value: new J() },
        cameraNear: { value: null },
        cameraFar: { value: null },
        cameraPosition: { value: new B() },
        opacity: { value: 0.5 },
        k1: { value: 0 },
        k2: { value: 0 },
        k3: { value: 0 },
        p1: { value: 0 },
        p2: { value: 0 }
      }
    ]), this.material = new ze({
      name: "VideoFusionMaterial",
      uniforms: this.uniforms,
      vertexShader: i.vertexShader,
      fragmentShader: dK
    }), this.fsQuad = new Ut(this.material);
  }
  render(t, e, i) {
    const n = this.rendering.camera, o = this._camera, r = this.uniforms;
    r.tDiffuse.value = i.texture, r.tDepth.value = this.rendering.main.sceneRendering.depthTexture, r.projectionInverseMatrix.value.copy(n.projectionMatrixInverse), r.viewInverseMatrix.value.copy(n.matrixWorld), r.cameraNear.value = n.near, r.cameraFar.value = n.far, o && (r.videoProjectionMatrix.value.copy(o.projectionMatrix), r.videoViewMatrix.value.copy(o.matrixWorldInverse)), this.renderToScreen === !0 ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), t.clear(), this.fsQuad.render(t));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
  set camera(t) {
    this._camera = t;
  }
  get camera() {
    return this._camera;
  }
  set texture(t) {
    this.uniforms.tVideo.value = t;
  }
  get texture() {
    return this.uniforms.tVideo.value;
  }
  set opacity(t) {
    this.uniforms.opacity.value = t;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
}
class IK extends Vn {
  constructor() {
    super(...arguments);
    f(this, "name", "CameraFusion");
    f(this, "_lastEnabled", !1);
    f(this, "_camera", null);
    f(this, "_texture", null);
    f(this, "_opacity", 0.5);
  }
  beginFrame() {
    if (this._lastEnabled !== this.enabled) {
      this.enabled ? this._init() : this.dispose();
      return;
    }
  }
  _init() {
    const e = this._rendering, i = this._renderPass = new uK(this._texture, this._camera);
    i.opacity = this._opacity, i.renderOrder = 600, e.main.postprocessings.add(this._renderPass);
  }
  afterRender() {
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._rendering.main.postprocessings.remove(this._renderPass), this._renderPass && (this._renderPass.dispose(), this._renderPass = null);
  }
  set camera(e) {
    e !== this._camera && (this._camera && this._rendering._engine.remove(this._camera), this._rendering._engine.add(e), this._renderPass && (this._renderPass.camera = e), this._camera = e);
  }
  get camera() {
    return this._camera;
  }
  set texture(e) {
    this._texture = e, this._renderPass && (this._renderPass.texture = e);
  }
  get texture() {
    return this._texture;
  }
  set opacity(e) {
    this._opacity = e, this._renderPass && (this._renderPass.opacity = e);
  }
  get opacity() {
    return this._opacity;
  }
}
class AK extends Vn {
  constructor() {
    super(...arguments);
    f(this, "name", "HDR");
    f(this, "_bufferType", Pi);
    f(this, "_exposure", 1);
    f(this, "_lastEnabled", !1);
    f(this, "needsFloatRenderTarget", !0);
  }
  beginFrame() {
    this._lastEnabled, this._enabled;
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  set enabled(e) {
    this._enabled = !!e;
  }
  get enabled() {
    return this._enabled;
  }
  set exposure(e) {
    this._exposure = e;
  }
  get exposure() {
    return this._exposure;
  }
}
class CK {
  constructor(t, e) {
    f(this, "_features", []);
    this._rendering = t, this._bloom = new MD(this._rendering, e.bloom), this._features.push(this._bloom), this._antialias = new ND(this._rendering, e.antialias), this._features.push(this._antialias), this._ao = new zD(this._rendering, e.ao), this._features.push(this._ao), this._reflection = new QD(this._rendering, e.reflection), this._features.push(this._reflection), this._bufferView = new FD(this._rendering, e.bufferView), this._features.push(this._bufferView), this._stats = new RD(this._rendering, e.stats), this._features.push(this._stats), this._shadow = new oK(this._rendering, e.shadow), this._features.push(this._shadow), this._depthPicking = new gK(this._rendering, e.depthPicking), this._features.push(this._depthPicking), this._colorAdjustment = new hK(this._rendering, e.colorAdjustment), this._features.push(this._colorAdjustment), this._cameraFusion = new IK(this._rendering), this._features.push(this._cameraFusion), this._hdr = new AK(this._rendering, e.hdr), this._features.push(this._hdr);
  }
  beginFrame() {
    for (const t of this._features)
      t.beginFrame();
  }
  afterRender() {
    for (const t of this._features)
      t.afterRender && t.afterRender();
  }
  endFrame() {
    for (const t of this._features)
      t.endFrame();
  }
  updateReqirements(t) {
    const e = [];
    for (const i of this._features)
      !i.enabled || (i.needsEmissiveTexture && (t.needsEmissiveTexture = !0), i.needsNormalTexture && (t.needsNormalTexture = !0), i.needsDepthTexture && (t.needsDepthTexture = !0), i.needsMetallicRoughTexture && (t.needsMetallicRoughTexture = !0), i.needsFloatRenderTarget && (t.needsFloatRenderTarget = !0), i.needsShaderKey && e.push(i.getCurrentShaderKey()));
    t.featuresShaderKey = e.join("");
  }
  get ao() {
    return this._ao;
  }
  get bloom() {
    return this._bloom;
  }
  get stats() {
    return this._stats;
  }
  get bufferView() {
    return this._bufferView;
  }
  get antialias() {
    return this._antialias;
  }
  get reflection() {
    return this._reflection;
  }
  get features() {
    return this._features;
  }
  get shadow() {
    return this._shadow;
  }
  get depthPicking() {
    return this._depthPicking;
  }
  get colorAdjustment() {
    return this._colorAdjustment;
  }
  get cameraFusion() {
    return this._cameraFusion;
  }
  get hdr() {
    return this._hdr;
  }
}
class fK {
  constructor(t) {
    f(this, "_renderTargets", []);
    f(this, "_locks", []);
    f(this, "_maxRenderTargets", 10);
    this._rendering = t;
  }
  beginFrame() {
    this._resetLocks(), this._rendering.main.requirements.isRenderTargetTypeChanged() && this._disposeRenderTargets();
  }
  _disposeRenderTargets() {
    const t = this._renderTargets;
    for (let e = 0; e < this._maxRenderTargets; e++)
      t[e] && (t[e].dispose(), t[e] = null);
  }
  _resetLocks() {
    const t = this._locks;
    for (let e = 0; e < this._maxRenderTargets; e++)
      t[e] = !1;
  }
  getAvailableRenderTarget() {
    const t = this._renderTargets, e = this._locks, i = this._rendering, n = i.resolution, o = i.pixelRatio, r = i.main.requirements.getRenderTargetType();
    for (let a = 0; a < this._maxRenderTargets; a++)
      if (t[a] || (t[a] = new It(n.x * o, n.y * o, {
        type: r,
        depthBuffer: !1,
        magFilter: cs,
        minFilter: cs,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }), t[a].name = `SharedFullScreenRenderTarget_${a}`), !e[a])
        return e[a] = !0, t[a];
    throw new Error("No available render target");
  }
  releaseRenderTarget(t) {
    const e = this._renderTargets, i = this._locks;
    for (let n = 0; n < this._maxRenderTargets; n++)
      if (e[n] === t) {
        i[n] = !1;
        return;
      }
    console.warn("Invalid render target to release");
  }
  releaseRenderTargetByIndex(t) {
    const e = this._locks;
    if (t < 0 || t >= this._maxRenderTargets) {
      console.warn("Invalid render target to release");
      return;
    }
    e[t] = !1;
  }
  lockRenderTarget(t) {
    const e = this._renderTargets, i = this._locks;
    for (let n = 0; n < this._maxRenderTargets; n++)
      if (e[n] === t) {
        i[n] = !0;
        return;
      }
    console.warn("Invalid render target to lock");
  }
  setSize(t, e) {
    const i = this._renderTargets, n = this._rendering.pixelRatio;
    for (let o = 0; o < this._maxRenderTargets; o++)
      i[o] && i[o].setSize(t * n, e * n);
  }
  endFrame() {
  }
}
class pK {
  constructor(t, e) {
    f(this, "_rendering");
    f(this, "_requirements");
    f(this, "_useMRT", !1);
    f(this, "_lastUseMRT", null);
    f(this, "_sceneRendering");
    f(this, "_features");
    f(this, "_postprocessings");
    f(this, "_opaquePostprocessings");
    t._main = this, this._rendering = t, this._requirements = new wD(t), this._features = new CK(t, e.features), this._postprocessings = new Sw(t), this._opaquePostprocessings = new LD(t), this._sharedFullScreenRenderTargets = new fK(t), t.postprocessings = this._postprocessings, t.opaquePostprocessings = this._opaquePostprocessings, t.sharedFullScreenRenderTargets = this._sharedFullScreenRenderTargets, t.features = this._features;
  }
  beginFrame() {
    const t = this._rendering;
    if (t.isUseMRTChanged || !this._sceneRendering) {
      let e = !0;
      this._sceneRendering && (e = this._sceneRendering.useFastEmissiveMethod, this._sceneRendering.dispose()), t.useMRT ? this._sceneRendering = new BD(this._rendering) : this._sceneRendering = new bD(this._rendering), this._sceneRendering.useFastEmissiveMethod = e;
    }
    this._features.beginFrame(), this._requirements.beginFrame(), this._sharedFullScreenRenderTargets.beginFrame(), this._sceneRendering.beginFrame(), this._opaquePostprocessings.beginFrame(), this._postprocessings.beginFrame();
  }
  render() {
    const e = this._rendering.renderState, i = this._sceneRendering, n = this._features, o = this._postprocessings, r = this._opaquePostprocessings, a = this._sharedFullScreenRenderTargets;
    let g = null;
    (this._rendering.useMRT || o.validCount > 0 || r.validCount > 0) && (g = a.getAvailableRenderTarget()), i.renderTarget = g, e.stage = yw, r.show(), i.render(), r.hide(), e.stage = yD, n.afterRender(), (this._rendering.useMRT || o.validCount > 0) && (e.stage = SD, o.render());
  }
  endFrame() {
    this._requirements.endFrame(), this._features.endFrame(), this._sceneRendering.endFrame(), this._opaquePostprocessings.endFrame(), this._postprocessings.endFrame(), this._sharedFullScreenRenderTargets.endFrame();
  }
  setSize(t, e) {
    this._rendering, this._sceneRendering && this._sceneRendering.setSize(t, e), this._sharedFullScreenRenderTargets && this._sharedFullScreenRenderTargets.setSize(t, e), this._opaquePostprocessings && this._opaquePostprocessings.setSize(t, e), this._postprocessings && this._postprocessings.setSize(t, e);
  }
  get sceneRendering() {
    return this._sceneRendering;
  }
  get useFastEmissiveMethod() {
    return this._sceneRendering.useFastEmissiveMethod;
  }
  set useFastEmissiveMethod(t) {
    this._sceneRendering.useFastEmissiveMethod = t;
  }
  get antialias() {
    return !0;
  }
  get rendering() {
    return this._rendering;
  }
  get requirements() {
    return this._requirements;
  }
  get features() {
    return this._features;
  }
  get postprocessings() {
    return this._postprocessings;
  }
  get opaquePostprocessings() {
    return this._opaquePostprocessings;
  }
}
new B();
class Jg {
  constructor() {
    f(this, "isProjection", !0);
    f(this, "isGeo", !1);
    f(this, "isAxisAligned", !1);
  }
  projectCoordinate(t, e) {
    throw new Error("projectCoordinate() must be implemented in derived classes");
  }
  unprojectCoordinate(t, e) {
    throw new Error("unprojectCoordinate() must be implemented in derived classes");
  }
  geoBoxToProjectedBox(t, e) {
    e || (e = new Ue());
    const i = this.projectCoordinate(t.min), n = this.projectCoordinate(t.max);
    return e.min.copy(i), e.max.copy(n), e;
  }
  getGeodeticSurfaceNormal(t, e) {
    return e || (e = new B()), e.set(0, 0, 1), e;
  }
  getProjectedSurfaceNormal(t, e) {
    return e || (e = new B()), e.set(0, 0, 1), e;
  }
  projectedBoxToGeoBox(t, e) {
    e || (e = new Ue());
    const i = this.unprojectCoordinate(t.min), n = this.unprojectCoordinate(t.max);
    return e.min.copy(i), e.max.copy(n), e;
  }
  equals(t) {
    return t ? this.name === t.name : !1;
  }
  getWorldBoundingBox() {
    const t = new Ue(new B(-180, -90, -100), new B(180, 90, 100));
    return this.geoBoxToProjectedBox(t);
  }
  localFrameToFixedFrame(t, e) {
    return e || (e = new J()), e.identity(), e.setPosition(t), e;
  }
}
const uh = (s, t, e, i) => {
  if (Math.abs(s) < i)
    return t;
  const n = s > 0 ? 1 : -1, r = (Math.abs(s) - i) / i;
  return n * (e * (1 + r));
}, Ih = (s, t, e, i) => {
  if (Math.abs(s) < e)
    return t;
  const n = s > 0 ? 1 : -1, r = (Math.abs(s) - e) / e;
  return n * (i * (1 + r));
}, Mp = Math.PI / 180, Ah = 6378137, In = 20037508, Ep = 180 / Math.PI, ww = 85.0511287798;
function mK(s, t = null, e = !1) {
  var i = Math.abs(s[0]) <= 180 ? s[0] : s[0] - SK(s[0]) * 360;
  const n = t || [0, 0];
  return n[0] = Ah * i * Mp, n[1] = Ah * Math.log(Math.tan(Math.PI * 0.25 + 0.5 * s[1] * Mp)), e ? (n[0] = Ih(s[0], n[0], 180, In), n[1] = Ih(s[1], n[1], ww, In)) : (n[0] > In && (n[0] = In), n[0] < -In && (n[0] = -In), n[1] > In && (n[1] = In), n[1] < -In && (n[1] = -In)), n;
}
function yK(s, t, e = !1) {
  const i = t || [0, 0];
  return i[0] = s[0] * Ep / Ah, i[1] = (Math.PI * 0.5 - 2 * Math.atan(Math.exp(-s[1] / Ah))) * Ep, e && (i[0] = uh(s[0], i[0], 180, In), i[1] = uh(s[1], i[1], ww, In)), i;
}
function SK(s) {
  return s < 0 ? -1 : s > 0 ? 1 : 0;
}
const Rp = [0, 0];
class bK extends Jg {
  constructor() {
    super(...arguments);
    f(this, "name", Mt);
    f(this, "isAxisAligned", !0);
  }
  projectCoordinate(e, i) {
    const n = mK([e.x, e.y], Rp, !0);
    return i || (i = new B()), i.x = n[0], i.y = n[1], i.z = e.z, i;
  }
  unprojectCoordinate(e, i) {
    const n = yK([e.x, e.y], Rp, !0);
    return i || (i = new B()), i.x = n[0], i.y = n[1], i.z = e.z, i;
  }
}
class Us {
  static clone(t, e) {
    return e || (e = new Me()), e.copy(t), e;
  }
  static fromElements(t, e, i, n, o) {
    return o || (o = new Me()), o.set(t, e, i, n), o;
  }
  static lerp(t, e, i, n) {
    return n || (n = new Me()), n.lerpVectors(t, e, i), n;
  }
  static equals(t, e) {
    return t.equals(e);
  }
  static normalize(t, e) {
    return t === e ? (t.normalize(), t) : (e.copy(t), e.normalize(), e);
  }
  static add(t, e, i) {
    return i || (i = new Me()), i.addVectors(t, e);
  }
  static multiplyByScalar(t, e, i) {
    return i || (i = new Me()), i.copy(t).multiplyScalar(e), i;
  }
  static subtract(t, e, i) {
    return i || (i = new Me()), i.subVectors(t, e), i;
  }
  static distance(t, e) {
    return t.distanceTo(e);
  }
}
f(Us, "ZERO", new Me(0, 0, 0, 0)), f(Us, "UNIT_W", Object.freeze(new Me(0, 0, 0, 1)));
const BK = new B(), wK = new B(), _K = new J(), xK = new Me(0, 0, 0, 0), vK = new B();
class ti {
  static fromPointNormal(t, e, i) {
    return i || (i = new Zt()), i.setFromNormalAndCoplanarPoint(e, t), i;
  }
  static fromCartesian4(t, e) {
    const i = _.fromCartesian4(t, BK), n = t.w;
    if (!X.equalsEpsilon(
      _.magnitude(i),
      1,
      X.EPSILON6
    ))
      throw new Error("normal must be normalized.");
    return F(e) ? (_.clone(i, e.normal), e.constant = n, e) : new ti(i, n);
  }
  static getPointDistance(t, e) {
    return _.dot(t.normal, e) + t.constant;
  }
  static projectPointOntoPlane(t, e, i) {
    F(i) || (i = new B());
    const n = ti.getPointDistance(t, e), o = _.multiplyByScalar(
      t.normal,
      n,
      wK
    );
    return _.subtract(e, o, i);
  }
  static transform(t, e, i) {
    const n = t.normal, o = t.constant, r = J.inverseTranspose(
      e,
      _K
    );
    let a = Us.fromElements(
      n.x,
      n.y,
      n.z,
      o,
      xK
    );
    a = J.multiplyByVector(
      r,
      a,
      a
    );
    const g = _.fromCartesian4(
      a,
      vK
    );
    return a = Us.divideByScalar(
      a,
      _.magnitude(g),
      a
    ), Zt.fromCartesian4(a, i);
  }
  static clone(t, e) {
    return F(e) ? (_.clone(t.normal, e.normal), e.constant = t.constant, e) : new ti(t.normal, t.constant);
  }
  static equals(t, e) {
    return t.constant === e.constant && _.equals(t.normal, e.normal);
  }
}
Zt.ORIGIN_XY_PLANE = Object.freeze(new ti(_.UNIT_Z, 0));
Zt.ORIGIN_YZ_PLANE = Object.freeze(new ti(_.UNIT_X, 0));
Zt.ORIGIN_ZX_PLANE = Object.freeze(new ti(_.UNIT_Y, 0));
const Qd = new Me(0, 0, 0, 0), Dp = new yt(), Cc = new B();
class Sr {
  constructor(t, e) {
    if (e = he(e, De.WGS84), t = e.scaleToGeodeticSurface(t), !F(t))
      throw new re(
        "origin must not be at the center of the ellipsoid."
      );
    const i = Ze.eastNorthUpToFixedFrame(t, e);
    this._ellipsoid = e, this._origin = t, this._xAxis = _.fromCartesian4(
      _e.getColumn(i, 0, Qd)
    ), this._yAxis = _.fromCartesian4(
      _e.getColumn(i, 1, Qd)
    );
    const n = _.fromCartesian4(
      _e.getColumn(i, 2, Qd)
    );
    this._plane = ti.fromPointNormal(t, n);
  }
  static fromPoints(t, e) {
    let i = t[0].x, n = t[0].y, o = t[0].z, r = t[0].x, a = t[0].y, g = t[0].z;
    for (let C = 0; C < t.length; C++) {
      const p = t[C], m = p.x, b = p.y, S = p.z;
      i = Math.min(m, i), r = Math.max(m, r), n = Math.min(b, n), a = Math.max(b, a), o = Math.min(S, o), g = Math.max(S, g);
    }
    const c = new B(i, n, o), l = new B(r, a, g), h = new Ue(c, l);
    let d = new B();
    return d = h.getCenter(d), new Sr(d, e);
  }
  projectPointToNearestOnPlane(t, e) {
    F(e) || (e = new oe());
    const i = Dp;
    i.origin = t, _.clone(this._plane.normal, i.direction);
    let n = We.rayPlane(
      i,
      this._plane,
      Cc
    );
    if (F(n) || (_.negate(i.direction, i.direction), n = We.rayPlane(
      i,
      this._plane,
      Cc
    )), F(n)) {
      const o = _.subtract(
        n,
        this._origin,
        n
      ), r = _.dot(this._xAxis, o), a = _.dot(this._yAxis, o);
      return F(e) ? (e.x = r, e.y = a, e) : new Z(r, a);
    }
  }
  projectPointsOntoPlane(t, e) {
    F(e) || (e = []);
    let i = 0;
    const n = t.length;
    for (let o = 0; o < n; o++) {
      const r = this.projectPointOntoPlane(t[o], e[i]);
      r && (e[i] = r, i++);
    }
    return e.length = i, e;
  }
  projectPointOntoPlane(t, e) {
    const i = Dp;
    i.origin = t, _.normalize(t, i.direction);
    let n = We.rayPlane(
      i,
      this._plane,
      Cc
    );
    if (F(n) || (_.negate(i.direction, i.direction), n = We.rayPlane(
      i,
      this._plane,
      Cc
    )), F(n)) {
      const o = _.subtract(
        n,
        this._origin,
        n
      ), r = _.dot(this._xAxis, o), a = _.dot(this._yAxis, o);
      return F(e) ? (e.x = r, e.y = a, e) : new Z(r, a);
    }
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
  get origin() {
    return this._origin;
  }
  get plane() {
    return this._plane;
  }
  get xAxis() {
    return this._xAxis;
  }
  get yAxis() {
    return this._yAxis;
  }
  get zAxis() {
    return this._plane.normal;
  }
}
const TK = {
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
}, Ci = Object.freeze(TK);
class ki {
  constructor(t, e) {
    this.isOrientedBoundingBox = !0, this.center = _.clone(he(t, _.ZERO), new B()), this.halfAxes = Ae.clone(he(e, Ae.ZERO));
  }
  intersectPlane(t) {
    return ki.intersectPlane(this, t);
  }
  distanceSquaredTo(t) {
    return ki.distanceSquaredTo(this, t);
  }
  computeCorners(t) {
    return ki.computeCorners(this, t);
  }
  getCenter(t) {
    return F(t) ? (t.copy(this.center), t) : this.center.clone();
  }
  intersectsObb(t) {
    const e = this.center, i = t.center, n = this.halfAxes, o = t.halfAxes, r = new B().subVectors(i, e), a = new B(n.elements[0], n.elements[1], n.elements[2]), g = new B(n.elements[3], n.elements[4], n.elements[5]), c = new B(n.elements[6], n.elements[7], n.elements[8]), l = new B(o.elements[0], o.elements[1], o.elements[2]), h = new B(o.elements[3], o.elements[4], o.elements[5]), d = new B(o.elements[6], o.elements[7], o.elements[8]), C = a.length(), p = g.length(), m = c.length();
    a.normalize(), g.normalize(), c.normalize();
    const b = l.length(), S = h.length(), A = d.length();
    l.normalize(), h.normalize(), d.normalize();
    let u, y, I;
    return u = C, y = b * Math.abs(a.dot(l)) + S * Math.abs(a.dot(h)) + A * Math.abs(a.dot(d)), I = Math.abs(r.dot(a)), !(I > u + y || (u = p, y = b * Math.abs(g.dot(l)) + S * Math.abs(g.dot(h)) + A * Math.abs(g.dot(d)), I = Math.abs(r.dot(g)), I > u + y) || (u = m, y = b * Math.abs(c.dot(l)) + S * Math.abs(c.dot(h)) + A * Math.abs(c.dot(d)), I = Math.abs(r.dot(c)), I > u + y) || (u = C * Math.abs(l.dot(a)) + p * Math.abs(l.dot(g)) + m * Math.abs(l.dot(c)), y = b, I = Math.abs(r.dot(l)), I > u + y) || (u = C * Math.abs(h.dot(a)) + p * Math.abs(h.dot(g)) + m * Math.abs(h.dot(c)), y = S, I = Math.abs(r.dot(h)), I > u + y) || (u = C * Math.abs(d.dot(a)) + p * Math.abs(d.dot(g)) + m * Math.abs(d.dot(c)), y = A, I = Math.abs(r.dot(d)), I > u + y));
  }
}
const _w = new B(), LK = new B();
function Kp(s, t, e, i, n, o, r, a, g, c, l) {
  if (!F(n) || !F(o) || !F(r) || !F(a) || !F(g) || !F(c))
    throw new re(
      "all extents (minimum/maximum X/Y/Z) are required."
    );
  F(l) || (l = new ki());
  const h = l.halfAxes;
  Ae.setColumn(h, 0, t, h), Ae.setColumn(h, 1, e, h), Ae.setColumn(h, 2, i, h);
  let d = _w;
  d.x = (n + o) / 2, d.y = (r + a) / 2, d.z = (g + c) / 2;
  const C = LK;
  C.x = (o - n) / 2, C.y = (a - r) / 2, C.z = (c - g) / 2;
  const p = l.center;
  return d = Ae.multiplyByVector(h, d, d), _.add(s, d, p), Ae.multiplyByScale(h, C, h), l;
}
const Hp = new B(), GK = new B(), MK = new B(), EK = new B(), RK = new B(), DK = new B(), KK = new B(), HK = new B(), Pp = new B(), PK = new B(), Np = new B(), NK = new B(), FK = new Z(), kK = new Z(), VK = new Z(), zK = new Z(), XK = new Z(), WK = new B(), ZK = new B(), UK = new B(), OK = new B(), QK = new Z(), YK = new B(), jK = new B(), JK = new B(), qK = new Zt(new B(1, 0, 0), 0);
ki.fromRectangle = function(s, t, e, i, n) {
  if (!F(s))
    throw new re("rectangle is required");
  if (s.width < 0 || s.width > X.TWO_PI)
    throw new re("Rectangle width must be between 0 and 2 * pi");
  if (s.height < 0 || s.height > X.PI)
    throw new re("Rectangle height must be between 0 and pi");
  if (F(i) && !X.equalsEpsilon(
    i.radii.x,
    i.radii.y,
    X.EPSILON15
  ))
    throw new re(
      "Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)"
    );
  t = he(t, 0), e = he(e, 0), i = he(i, De.WGS84);
  let o, r, a, g, c, l, h;
  if (s.width <= X.PI) {
    const G = Oe.center(
      s,
      Hp
    ), x = i.cartographicToCartesian(
      G,
      GK
    ), L = new Sr(x, i);
    h = L.plane;
    const E = G.x, T = s.south < 0 && s.north > 0 ? 0 : G.y, R = qi.fromRadians(
      E,
      s.north,
      e,
      MK
    ), w = qi.fromRadians(
      s.west,
      s.north,
      e,
      EK
    ), v = qi.fromRadians(
      s.west,
      T,
      e,
      RK
    ), D = qi.fromRadians(
      s.west,
      s.south,
      e,
      DK
    ), K = qi.fromRadians(
      E,
      s.south,
      e,
      KK
    ), P = i.cartographicToCartesian(
      R,
      HK
    );
    let k = i.cartographicToCartesian(
      w,
      Pp
    );
    const V = i.cartographicToCartesian(
      v,
      PK
    );
    let N = i.cartographicToCartesian(
      D,
      Np
    );
    const z = i.cartographicToCartesian(
      K,
      NK
    ), O = L.projectPointToNearestOnPlane(
      P,
      FK
    ), Q = L.projectPointToNearestOnPlane(
      k,
      kK
    ), U = L.projectPointToNearestOnPlane(
      V,
      VK
    ), $ = L.projectPointToNearestOnPlane(
      N,
      zK
    ), ee = L.projectPointToNearestOnPlane(
      z,
      XK
    );
    return o = Math.min(
      Q.x,
      U.x,
      $.x
    ), r = -o, g = Math.max(Q.y, O.y), a = Math.min($.y, ee.y), w.z = D.z = t, k = i.cartographicToCartesian(
      w,
      Pp
    ), N = i.cartographicToCartesian(
      D,
      Np
    ), c = Math.min(
      ti.getPointDistance(h, k),
      ti.getPointDistance(h, N)
    ), l = e, Kp(
      L.origin,
      L.xAxis,
      L.yAxis,
      L.zAxis,
      o,
      r,
      a,
      g,
      c,
      l,
      n
    );
  }
  const d = s.south > 0, C = s.north < 0, p = d ? s.south : C ? s.north : 0, m = Oe.center(
    s,
    Hp
  ).x, b = _.fromRadians(
    m,
    p,
    e,
    i,
    WK
  );
  b.z = 0;
  const A = Math.abs(b.x) < X.EPSILON10 && Math.abs(b.y) < X.EPSILON10 ? _.UNIT_X : _.normalize(b, ZK), u = _.UNIT_Z, y = _.cross(
    A,
    u,
    UK
  );
  h = ti.fromPointNormal(b, A, qK);
  const I = _.fromRadians(
    m + X.PI_OVER_TWO,
    p,
    e,
    i,
    OK
  );
  r = _.dot(
    ti.projectPointOntoPlane(
      h,
      I,
      QK
    ),
    y
  ), o = -r, g = _.fromRadians(
    0,
    s.north,
    C ? t : e,
    i,
    YK
  ).z, a = _.fromRadians(
    0,
    s.south,
    d ? t : e,
    i,
    jK
  ).z;
  const M = _.fromRadians(
    s.east,
    p,
    e,
    i,
    JK
  );
  return c = ti.getPointDistance(h, M), l = 0, Kp(
    b,
    y,
    u,
    A,
    o,
    r,
    a,
    g,
    c,
    l,
    n
  );
};
const $K = new B(), eH = new B(), tH = new B(), iH = new B(), Fp = new B(), nH = new B();
ki.distanceSquaredTo = function(s, t) {
  if (!F(s))
    throw new re("box is required.");
  if (!F(t))
    throw new re("cartesian is required.");
  const e = _.subtract(t, s.center, _w), i = s.halfAxes;
  let n = Ae.getColumn(i, 0, $K), o = Ae.getColumn(i, 1, eH), r = Ae.getColumn(i, 2, tH);
  const a = _.magnitude(n), g = _.magnitude(o), c = _.magnitude(r);
  let l = !0, h = !0, d = !0;
  a > 0 ? _.divideByScalar(n, a, n) : l = !1, g > 0 ? _.divideByScalar(o, g, o) : h = !1, c > 0 ? _.divideByScalar(r, c, r) : d = !1;
  const C = !l + !h + !d;
  let p, m, b;
  if (C === 1) {
    let y = n;
    p = o, m = r, h ? d || (y = r, m = n) : (y = o, p = n), b = _.cross(p, m, Fp), y === n ? n = b : y === o ? o = b : y === r && (r = b);
  } else if (C === 2) {
    p = n, h ? p = o : d && (p = r);
    let y = _.UNIT_Y;
    _.equalsEpsilon(y, p, X.EPSILON3) && (y = _.UNIT_X), m = _.cross(p, y, iH), _.normalize(m, m), b = _.cross(p, m, Fp), _.normalize(b, b), p === n ? (o = m, r = b) : p === o ? (r = m, n = b) : p === r && (n = m, o = b);
  } else
    C === 3 && (n = _.UNIT_X, o = _.UNIT_Y, r = _.UNIT_Z);
  const S = nH;
  S.x = _.dot(e, n), S.y = _.dot(e, o), S.z = _.dot(e, r);
  let A = 0, u;
  return S.x < -a ? (u = S.x + a, A += u * u) : S.x > a && (u = S.x - a, A += u * u), S.y < -g ? (u = S.y + g, A += u * u) : S.y > g && (u = S.y - g, A += u * u), S.z < -c ? (u = S.z + c, A += u * u) : S.z > c && (u = S.z - c, A += u * u), A;
};
ki.intersectPlane = function(s, t) {
  if (!F(s))
    throw new re("box is required.");
  if (!F(t))
    throw new re("plane is required.");
  const e = s.center, i = t.normal, n = s.halfAxes, o = i.x, r = i.y, a = i.z, g = n.elements, c = Math.abs(
    o * g[Ae.COLUMN0ROW0] + r * g[Ae.COLUMN0ROW1] + a * g[Ae.COLUMN0ROW2]
  ) + Math.abs(
    o * g[Ae.COLUMN1ROW0] + r * g[Ae.COLUMN1ROW1] + a * g[Ae.COLUMN1ROW2]
  ) + Math.abs(
    o * g[Ae.COLUMN2ROW0] + r * g[Ae.COLUMN2ROW1] + a * g[Ae.COLUMN2ROW2]
  ), l = _.dot(i.clone(), e) + t.constant;
  return l <= -c ? Ci.OUTSIDE : l >= c ? Ci.INSIDE : Ci.INTERSECTING;
};
const sH = new B(), oH = new B(), rH = new B();
ki.computeCorners = function(s, t) {
  F(t) || (t = [
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B()
  ]);
  const e = s.center, i = s.halfAxes, n = Ae.getColumn(i, 0, sH), o = Ae.getColumn(i, 1, oH), r = Ae.getColumn(i, 2, rH);
  return _.clone(e, t[0]), _.subtract(t[0], n, t[0]), _.subtract(t[0], o, t[0]), _.subtract(t[0], r, t[0]), _.clone(e, t[1]), _.subtract(t[1], n, t[1]), _.subtract(t[1], o, t[1]), _.add(t[1], r, t[1]), _.clone(e, t[2]), _.subtract(t[2], n, t[2]), _.add(t[2], o, t[2]), _.subtract(t[2], r, t[2]), _.clone(e, t[3]), _.subtract(t[3], n, t[3]), _.add(t[3], o, t[3]), _.add(t[3], r, t[3]), _.clone(e, t[4]), _.add(t[4], n, t[4]), _.subtract(t[4], o, t[4]), _.subtract(t[4], r, t[4]), _.clone(e, t[5]), _.add(t[5], n, t[5]), _.subtract(t[5], o, t[5]), _.add(t[5], r, t[5]), _.clone(e, t[6]), _.add(t[6], n, t[6]), _.add(t[6], o, t[6]), _.subtract(t[6], r, t[6]), _.clone(e, t[7]), _.add(t[7], n, t[7]), _.add(t[7], o, t[7]), _.add(t[7], r, t[7]), t;
};
ki.fromGeoBoundingBox = function(s, t) {
  if (!F(s))
    throw new re("geoBoundingBox is required.");
  const e = s.min, i = s.max, n = Oe.fromBox(s, null, !0);
  return ki.fromRectangle(
    n,
    e.z,
    i.z,
    null,
    t
  );
};
class aH extends Jg {
  constructor() {
    super(...arguments);
    f(this, "name", zs);
  }
  projectCoordinate(e, i) {
    return De.WGS84.cartographicDegreeToCartesian(e, i);
  }
  unprojectCoordinate(e, i) {
    return De.WGS84.cartesianToCartographicDegree(e, i);
  }
  getGeodeticSurfaceNormal(e, i) {
    return i || (i = new B()), De.WGS84.geodeticSurfaceNormalCartographic(e, i);
  }
  getProjectedSurfaceNormal(e, i) {
    return i || (i = new B()), De.WGS84.geodeticSurfaceNormal(e, i);
  }
  geoBoxToProjectedBox(e, i) {
    return i || (i = new ki()), i = ki.fromGeoBoundingBox(e, i), i;
  }
  getLODSacleOfGeoBoundingBox(e) {
    if (e.min.y > 85 || e.max.y < -85)
      return 0;
    const i = (e.min.y + e.max.y) / 2;
    return Math.cos(ce.degToRad(i));
  }
  localFrameToFixedFrame(e, i) {
    return i || (i = new J()), Ze.eastNorthUpToFixedFrame(e, null, i), i;
  }
}
function Hn() {
}
function _C(s, t) {
  for (let e in t)
    s[e] = t[e];
}
function ji(s, t) {
  this.lng = s, this.lat = t;
}
_C(ji.prototype, {
  equals: function(s) {
    return this.lat === s.lat && this.lng === s.lng;
  },
  clone: function() {
    return new ji(this.lat, this.lng);
  },
  getLngSpan: function(s) {
    let t = this.lng, e = Math.abs(s - t);
    return e > 180 && (e = 360 - e), e;
  },
  sub: function(s) {
    return new ji(this.lat - s.lat, this.lng - s.lng);
  },
  toString: function() {
    return "Point";
  }
});
function kp(s, t) {
  this.x = s, this.y = t;
}
_C(Hn, {
  EARTHRADIUS: 637099681e-2,
  MCBAND: [1289059486e-2, 836237787e-2, 5591021, 348198983e-2, 167804312e-2, 0],
  LLBAND: [75, 60, 45, 30, 15, 0],
  MC2LL: [
    [1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1],
    [-7435856389565537e-24, 8983055097726239e-21, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1026014486e-2],
    [-3030883460898826e-23, 898305509983578e-20, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475, 685681737e-2],
    [-1981981304930552e-23, 8983055099779535e-21, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 448277706e-2],
    [309191371068437e-23, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -23663490511e-14, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 25551644e-1],
    [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]
  ],
  LL2MC: [
    [-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5],
    [8277824516172526e-19, 111320.7020463578, 6477955746671607e-7, -4082003173641316e-6, 1077490566351142e-5, -1517187553151559e-5, 1205306533862167e-5, -5124939663577472e-6, 9133119359512032e-7, 67.5],
    [0.00337398766765, 111320.7020202162, 4481351045890365e-9, -2339375119931662e-8, 7968221547186455e-8, -1159649932797253e-7, 9723671115602145e-8, -4366194633752821e-8, 8477230501135234e-9, 52.5],
    [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837749470245e-9, 992013.7397791013, -122195221711287e-8, 1340652697009075e-9, -620943.6990984312, 144416.9293806241, 37.5],
    [-3441963504368392e-19, 111320.7020576856, 278.2353980772752, 2485758690035394e-9, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5],
    [-3218135878613132e-19, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]
  ],
  getDistanceByMC: function(s, t) {
    if (!s || !t)
      return 0;
    let e, i, n, o;
    return s = this.convertMC2LL(s), !s || (e = this.toRadians(s.lng), i = this.toRadians(s.lat), t = this.convertMC2LL(t), !t) ? 0 : (n = this.toRadians(t.lng), o = this.toRadians(t.lat), this.getDistance(e, n, i, o));
  },
  getDistanceByLL: function(s, t) {
    if (!s || !t)
      return 0;
    s.lng = this.getLoop(s.lng, -180, 180), s.lat = this.getRange(s.lat, -74, 74), t.lng = this.getLoop(t.lng, -180, 180), t.lat = this.getRange(t.lat, -74, 74);
    let e, i, n, o;
    return e = this.toRadians(s.lng), n = this.toRadians(s.lat), i = this.toRadians(t.lng), o = this.toRadians(t.lat), this.getDistance(e, i, n, o);
  },
  convertMC2LL: function(n) {
    if (n == null)
      return new ji(0, 0);
    if (n.lng < 180 && n.lng > -180 && n.lat < 90 && n.lat > -90)
      return n;
    let t, e;
    t = new ji(Math.abs(n.lng), Math.abs(n.lat));
    for (let o = 0; o < this.MCBAND.length; o++)
      if (t.lat >= this.MCBAND[o]) {
        e = this.MC2LL[o];
        break;
      }
    let i = this.convertor(n, e);
    var n = new ji(i.lng.toFixed(6), i.lat.toFixed(6));
    return n;
  },
  convertLL2MC: function(c) {
    if (c == null)
      return new ji(0, 0);
    if (c.lng > 180 || c.lng < -180 || c.lat > 90 || c.lat < -90)
      return c;
    let t, e;
    if (c.lng = this.getLoop(c.lng, -180, 180), c.lat = this.getRange(c.lat, -74, 74), t = new ji(c.lng, c.lat), window.BMAPGL_84) {
      var i = {}, n = 6378137;
      i.lng = t.lng * Math.PI / 180 * n;
      var o = t.lat * Math.PI / 180;
      i.lat = n / 2 * Math.log((1 + Math.sin(o)) / (1 - Math.sin(o)));
      var r = new ji(Number(i.lng), Number(i.lat));
      return r;
    }
    for (var a = 0; a < this.LLBAND.length; a++)
      if (t.lat >= this.LLBAND[a]) {
        e = this.LL2MC[a];
        break;
      }
    if (!e) {
      for (var a = 0; a < this.LLBAND.length; a++)
        if (t.lat <= -this.LLBAND[a]) {
          e = this.LL2MC[a];
          break;
        }
    }
    let g = this.convertor(c, e);
    var c = new ji(Number(g.lng), Number(g.lat));
    return c;
  },
  convertor: function(s, t) {
    if (!s || !t)
      return;
    let e = t[0] + t[1] * Math.abs(s.lng), i = Math.abs(s.lat) / t[9], n = t[2] + t[3] * i + t[4] * i * i + t[5] * i * i * i + t[6] * i * i * i * i + t[7] * i * i * i * i * i + t[8] * i * i * i * i * i * i;
    return e *= s.lng < 0 ? -1 : 1, n *= s.lat < 0 ? -1 : 1, new ji(e, n);
  },
  getDistance: function(s, t, e, i) {
    return this.EARTHRADIUS * Math.acos(Math.sin(e) * Math.sin(i) + Math.cos(e) * Math.cos(i) * Math.cos(t - s));
  },
  toRadians: function(s) {
    return Math.PI * s / 180;
  },
  toDegrees: function(s) {
    return 180 * s / Math.PI;
  },
  getRange: function(s, t, e) {
    return t != null && (s = Math.max(s, t)), e != null && (s = Math.min(s, e)), s;
  },
  getLoop: function(s, t, e) {
    for (; s > e; )
      s -= e - t;
    for (; s < t; )
      s += e - t;
    return s;
  }
});
_C(Hn.prototype, {
  lngLatToMercator: function(s) {
    return Hn.convertLL2MC(s);
  },
  lngLatToPoint: function(s) {
    let t = Hn.convertLL2MC(s);
    return new kp(t.lng, t.lat);
  },
  mercatorToLngLat: function(s) {
    return Hn.convertMC2LL(s);
  },
  pointToLngLat: function(s) {
    let t = new ji(s.x, s.y);
    return Hn.convertMC2LL(t);
  },
  pointToPixel: function(s, t, e, i, n) {
    if (!s)
      return;
    s = this.lngLatToMercator(s, n);
    let o = this.getZoomUnits(t), r = Math.round((s.lng - e.lng) / o + i.width / 2), a = Math.round((e.lat - s.lat) / o + i.height / 2);
    return new kp(r, a);
  },
  pixelToPoint: function(s, t, e, i, n) {
    if (!s)
      return;
    let o = this.getZoomUnits(t), r = e.lng + o * (s.x - i.width / 2), a = e.lat - o * (s.y - i.height / 2), g = new ji(r, a);
    return this.mercatorToLngLat(g, n);
  },
  getZoomUnits: function(s) {
    return Math.pow(2, 18 - s);
  }
});
const fc = 2003772416e-2, Vp = 85.05112877980659;
class gH extends Jg {
  constructor() {
    super(...arguments);
    f(this, "name", Fg);
    f(this, "isAxisAligned", !0);
    f(this, "unprojectCoordinate", (e, i) => {
      i || (i = new B());
      const n = Hn.convertMC2LL({ lng: e.x, lat: e.y });
      return i.set(Number(n.lng), Number(n.lat), e.z), i.x = uh(e.x, i.x, 180, fc), i.y = uh(e.y, i.y, Vp, fc), i;
    });
  }
  projectCoordinate(e, i) {
    i || (i = new B());
    const n = Hn.convertLL2MC({ lng: e.x, lat: e.y });
    return i.set(Number(n.lng), Number(n.lat), e.z), i.x = Ih(e.x, i.x, 180, fc), i.y = Ih(e.y, i.y, Vp, fc), i;
  }
}
const pc = 6378137 * Math.PI / 180;
class cH extends Jg {
  constructor() {
    super(...arguments);
    f(this, "name", hi);
    f(this, "isGeo", !0);
    f(this, "isAxisAligned", !0);
  }
  projectCoordinate(e, i) {
    return i || (i = new B()), i.x = e.x * pc, i.y = e.y * pc, i.z = e.z, i;
  }
  unprojectCoordinate(e, i) {
    return i || (i = new B()), i.x = e.x / pc, i.y = e.y / pc, i.z = e.z, i;
  }
}
class lH extends Jg {
  constructor() {
    super(...arguments);
    f(this, "name", mw);
    f(this, "isAxisAligned", !0);
  }
  projectCoordinate(e, i) {
    return i || (i = new B()), i.x = e.x, i.y = -e.y, i.z = e.z, i;
  }
  unprojectCoordinate(e, i) {
    return i || (i = new B()), i.x = e.x, i.y = -e.y, i.z = e.z, i;
  }
}
const Uo = {}, hH = (s) => (s = s.toUpperCase().trim(), s === "EPSG:900913" ? Mt : s === "GLOBE" || s === "ECEF" ? zs : s), bn = (s) => {
  if (s = hH(s), !Uo[s])
    switch (s) {
      case Mt:
        Uo[s] = new bK();
        break;
      case zs:
        Uo[s] = new aH();
        break;
      case Fg:
        Uo[s] = new gH();
        break;
      case hi:
        Uo[s] = new cH();
        break;
      case mw:
        Uo[s] = new lH();
        break;
      default:
        throw new Error(`Unsupported projection: ${s}`);
    }
  return Uo[s];
}, Ch = new B(), vo = new B(), xw = (s, t) => {
  if (!!s)
    if (t === 0)
      s[2] === void 0 && (s[2] = 0);
    else
      for (const e of s)
        xw(e, t - 1);
};
function dH(s, t) {
  if (!s)
    return [];
  let e = null;
  return t && oA(s, t), s.features ? e = s.features : Array.isArray(s) ? e = s : e = [s], e;
}
function oA(s, t) {
  if (!!s) {
    if (s.type === "FeatureCollection" || s.features) {
      const e = s.features;
      for (const i of e)
        oA(i, t);
    } else if (Array.isArray(s)) {
      const e = s;
      for (const i of e)
        oA(i, t);
    } else if (s.type === "Feature" || s.geometry) {
      if (!s.geometry)
        return;
      if (Array.isArray(s.geometry.coordinates)) {
        if (s.geometry[t.name])
          return;
        vw(s);
        const e = Yh(s.geometry.coordinates, t);
        s.geometry[t.name] = e;
      }
    }
  }
}
function Yh(s, t) {
  if (Array.isArray(s[0])) {
    const e = [];
    for (let i of s)
      e.push(Yh(i, t));
    return e;
  } else if (typeof s[0] == "number" || typeof s[0] == "string")
    return Ch.set(s[0], s[1], s[2] || 0), t.projectCoordinate(Ch, vo), [vo.x, vo.y, vo.z];
}
function xC(s, t) {
  if (Array.isArray(s[0])) {
    const e = [];
    for (let i of s)
      e.push(xC(i, t));
    return e;
  } else if (typeof s[0] == "number" || typeof s[0] == "string")
    return Ch.set(s[0], s[1], s[2] || 0), t.unprojectCoordinate(Ch, vo), [vo.x, vo.y, vo.z];
}
function vw(s) {
  s.type || (s.type = "Feature");
  const t = s.geometry.type, e = {
    Point: 0,
    MultiPoint: 1,
    LineString: 1,
    MultiLineString: 2,
    Polygon: 2,
    MultiPolygon: 3
  };
  return Object.keys(e).includes(t) && xw(s.geometry.coordinates, e[t]), s;
}
function uH(s, t) {
  if (!s.geometry)
    return [];
  if (s.geometry.type === "Point")
    return [s];
  if (s.geometry.type === "MultiPoint" || s.geometry.type === "LineString") {
    const e = [], { type: i, geometry: n, ...o } = s;
    for (let r = 0; r < s.geometry.coordinates.length; r++) {
      const a = s.geometry.coordinates[r];
      if (t) {
        const g = s.geometry[t][r];
        e.push({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a,
            [t]: g
          },
          ...o
        });
      } else
        e.push({
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          ...o
        });
    }
    return e;
  }
  return [];
}
function IH(s, t) {
  if (!s.geometry)
    return [];
  if (s.geometry.type === "LineString")
    return [s];
  if (s.geometry.type === "MultiLineString" || s.geometry.type === "Polygon") {
    const e = [], { type: i, geometry: n, ...o } = s;
    for (let r = 0; r < s.geometry.coordinates.length; r++) {
      const a = s.geometry.coordinates[r];
      if (t) {
        const g = s.geometry[t][r];
        e.push({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: a,
            [t]: g
          },
          ...o
        });
      } else
        e.push({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: a
          },
          ...o
        });
    }
    return e;
  }
  return [];
}
function AH(s, t) {
  if (!s.geometry)
    return [];
  if (s.geometry.type === "Polygon")
    return [s];
  if (s.geometry.type === "MultiPolygon") {
    const e = [], { type: i, geometry: n, ...o } = s;
    for (let r = 0; r < s.geometry.coordinates.length; r++) {
      const a = s.geometry.coordinates[r];
      if (t) {
        const g = s.geometry[t][r];
        e.push({
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: a,
            [t]: g
          },
          ...o
        });
      } else
        e.push({
          type: "Feature",
          geometry: {
            type: "Polygon",
            coordinates: a
          },
          ...o
        });
    }
    return e;
  }
  return [];
}
function CH(s) {
  let t = this.getGeoFeatures(s), e = [];
  for (let i = 0; i < t.length; i++) {
    const n = t[i], o = this.multiLineStringToLineStrings(n);
    for (let r = 0; r < o.length; r++) {
      const a = o[r], g = this.multiPointToPoints(a);
      e.push(...g);
    }
  }
  return e;
}
function fH(s) {
  let t = this.getGeoFeatures(s), e = [];
  for (let i = 0; i < t.length; i++) {
    const n = t[i], o = this.multiPolygonToPolygons(n);
    for (let r = 0; r < o.length; r++) {
      const a = o[r], g = this.multiLineStringToLineStrings(a);
      e.push(...g);
    }
  }
  return e;
}
function vC(s, t, e) {
  if (s === null)
    return;
  let i, n, o, r, a, g, c, l = 0, h = 0, d, C = s.type, p = C === "FeatureCollection", m = C === "Feature", b = p ? s.features.length : 1;
  for (let S = 0; S < b; S++) {
    c = p ? s.features[S].geometry : m ? s.geometry : s, d = c ? c.type === "GeometryCollection" : !1, a = d ? c.geometries.length : 1;
    for (let A = 0; A < a; A++) {
      let u = 0, y = 0;
      if (r = d ? c.geometries[A] : c, r === null)
        continue;
      g = r.coordinates;
      let I = r.type;
      switch (l = e && (I === "Polygon" || I === "MultiPolygon") ? 1 : 0, I) {
        case null:
          break;
        case "Point":
          if (t(
            g,
            h,
            S,
            u,
            y
          ) === !1)
            return !1;
          h++, u++;
          break;
        case "LineString":
        case "MultiPoint":
          for (i = 0; i < g.length; i++) {
            if (t(
              g[i],
              h,
              S,
              u,
              y
            ) === !1)
              return !1;
            h++, I === "MultiPoint" && u++;
          }
          I === "LineString" && u++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (i = 0; i < g.length; i++) {
            for (n = 0; n < g[i].length - l; n++) {
              if (t(
                g[i][n],
                h,
                S,
                u,
                y
              ) === !1)
                return !1;
              h++;
            }
            I === "MultiLineString" && u++, I === "Polygon" && y++;
          }
          I === "Polygon" && u++;
          break;
        case "MultiPolygon":
          for (i = 0; i < g.length; i++) {
            for (y = 0, n = 0; n < g[i].length; n++) {
              for (o = 0; o < g[i][n].length - l; o++) {
                if (t(
                  g[i][n][o],
                  h,
                  S,
                  u,
                  y
                ) === !1)
                  return !1;
                h++;
              }
              y++;
            }
            u++;
          }
          break;
        case "GeometryCollection":
          for (i = 0; i < r.geometries.length; i++)
            if (vC(r.geometries[i], t, e) === !1)
              return !1;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function Tw(s, t) {
  let e, i, n, o, r, a, g, c, l, h, d = 0, C = s.type === "FeatureCollection", p = s.type === "Feature", m = C ? s.features.length : 1;
  for (e = 0; e < m; e++) {
    for (a = C ? s.features[e].geometry : p ? s.geometry : s, c = C ? s.features[e].properties : p ? s.properties : {}, l = C ? s.features[e].bbox : p ? s.bbox : void 0, h = C ? s.features[e].id : p ? s.id : void 0, g = a ? a.type === "GeometryCollection" : !1, r = g ? a.geometries.length : 1, n = 0; n < r; n++) {
      if (o = g ? a.geometries[n] : a, o === null) {
        if (t(
          null,
          d,
          c,
          l,
          h
        ) === !1)
          return !1;
        continue;
      }
      switch (o.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (t(
            o,
            d,
            c,
            l,
            h
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (i = 0; i < o.geometries.length; i++)
            if (t(
              o.geometries[i],
              d,
              c,
              l,
              h
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    d++;
  }
}
function pH(s, t) {
  if (s.type === "Feature")
    t(s, 0);
  else if (s.type === "FeatureCollection")
    for (let e = 0; e < s.features.length && t(s.features[e], e) !== !1; e++)
      ;
}
function Lw(s, t, e) {
  let i = e;
  return Tw(
    s,
    function(n, o, r, a, g) {
      o === 0 && e === void 0 ? i = n : i = t(
        i,
        n,
        o,
        r,
        a,
        g
      );
    }
  ), i;
}
function Gw(s, t = {}) {
  if (s.bbox != null && t.recompute !== !0)
    return s.bbox;
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return vC(s, (i) => {
    e[0] > i[0] && (e[0] = i[0]), e[1] > i[1] && (e[1] = i[1]), e[2] < i[0] && (e[2] = i[0]), e[3] < i[1] && (e[3] = i[1]);
  }), e;
}
function Mw(s) {
  if (Array.isArray(s))
    return s;
  if (s.type === "Feature") {
    if (s.geometry !== null)
      return s.geometry.coordinates;
  } else if (s.coordinates)
    return s.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function Ew(s) {
  return s.type === "Feature" ? s.geometry : s;
}
function Rw(s, t) {
  return t[0] <= s[0] && t[1] <= s[1] && t[2] >= s[0] && t[3] >= s[1];
}
function mH(s, t) {
  let e = 0, i = 0, n = 0, o = 0, r = 0, a = 0, g = 0, c = 0, l = null, h = null;
  const d = s[0], C = s[1], p = t.length;
  for (e; e < p; e++) {
    i = 0;
    const m = t[e].length - 1, b = t[e];
    if (l = b[0], l[0] !== b[m][0] && l[1] !== b[m][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (r = l[0] - d, a = l[1] - C, i; i < m; i++) {
      if (h = b[i + 1], c = h[1] - C, a < 0 && c < 0 || a > 0 && c > 0) {
        l = h, a = c, r = l[0] - d;
        continue;
      }
      if (g = h[0] - s[0], c > 0 && a <= 0) {
        if (o = r * c - g * a, o > 0)
          n = n + 1;
        else if (o === 0)
          return 0;
      } else if (a > 0 && c <= 0) {
        if (o = r * c - g * a, o < 0)
          n = n + 1;
        else if (o === 0)
          return 0;
      } else if (c === 0 && a < 0) {
        if (o = r * c - g * a, o === 0)
          return 0;
      } else if (a === 0 && c < 0) {
        if (o = r * c - g * a, o === 0)
          return 0;
      } else if (a === 0 && c === 0) {
        if (g <= 0 && r >= 0)
          return 0;
        if (r <= 0 && g >= 0)
          return 0;
      }
      l = h, a = c, r = g;
    }
  }
  return n % 2 !== 0;
}
function yH(s, t, e = {}) {
  if (!s)
    throw new Error("point is required");
  if (!t)
    throw new Error("polygon is required");
  const i = Mw(s), n = Ew(t), o = n.type, r = t.bbox;
  let a = n.coordinates;
  if (r && Rw(i, r) === !1)
    return !1;
  o === "Polygon" && (a = [a]);
  let g = !1;
  for (let c = 0; c < a.length; ++c) {
    const l = mH(i, a[c]);
    if (l === 0)
      return !e.ignoreBoundary;
    l && (g = !0);
  }
  return g;
}
function jh(s, t, e = {}) {
  const i = { type: "Feature" };
  return (e.id === 0 || e.id) && (i.id = e.id), e.bbox && (i.bbox = e.bbox), i.properties = t || {}, i.geometry = s, i;
}
function SH(s, t = {}) {
  const e = { type: "FeatureCollection" };
  return t.id && (e.id = t.id), t.bbox && (e.bbox = t.bbox), e.features = s, e;
}
function Dw(s, t, e = {}) {
  if (!s)
    throw new Error("coordinates is required");
  if (!Array.isArray(s))
    throw new Error("coordinates must be an Array");
  if (s.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!iA(s[0]) || !iA(s[1]))
    throw new Error("coordinates must contain numbers");
  return jh({
    type: "Point",
    coordinates: s
  }, t, e);
}
function bH(s, t, e = {}) {
  if (!s)
    throw new Error("coordinates is required");
  if (!Array.isArray(s))
    throw new Error("coordinates must be an Array");
  return jh({
    type: "LineString",
    coordinates: s
  }, t, e);
}
function BH(s, t, e = {}) {
  for (const n of s) {
    if (n.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (n[n.length - 1].length !== n[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let o = 0; o < n[n.length - 1].length; o++)
      if (n[n.length - 1][o] !== n[0][o])
        throw new Error("First and last Position are not equivalent.");
  }
  return jh({
    type: "Polygon",
    coordinates: s
  }, t, e);
}
function wH(s) {
  return Lw(
    s,
    (t, e) => t + _H(e),
    0
  );
}
function _H(s) {
  let t = 0, e;
  switch (s.type) {
    case "Polygon":
      return zp(s.coordinates);
    case "MultiPolygon":
      for (e = 0; e < s.coordinates.length; e++)
        t += zp(s.coordinates[e]);
      return t;
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
      return 0;
  }
  return 0;
}
function zp(s) {
  let t = 0;
  if (s && s.length > 0) {
    t += Math.abs(Xp(s[0]));
    for (let e = 1; e < s.length; e++)
      t -= Math.abs(Xp(s[e]));
  }
  return t;
}
function Xp(s) {
  let t, e, i, n, o, r, a, g = 0;
  const c = s.length;
  if (c > 2) {
    for (a = 0; a < c; a++)
      a === c - 2 ? (n = c - 2, o = c - 1, r = 0) : a === c - 1 ? (n = c - 1, o = 0, r = 1) : (n = a, o = a + 1, r = a + 2), t = s[n], e = s[o], i = s[r], g += (Hn.toRadians(i[0]) - Hn.toRadians(t[0])) * Math.sin(Hn.toRadians(e[1]));
    g = g * 63710088e-1 * 63710088e-1 / 2;
  }
  return g;
}
function xH(s, t = {}) {
  const e = Gw(s), i = (e[0] + e[2]) / 2, n = (e[1] + e[3]) / 2;
  return Dw([i, n], t.properties, t);
}
function Kw(s) {
  return s[0] >= -180 && s[0] <= 180 && s[1] >= -90 && s[1] <= 90;
}
const wY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getGeoFeatures: dH,
  projectArrayCoordinates: Yh,
  unprojectArrayCoordinates: xC,
  fixFeature: vw,
  multiPointToPoints: uH,
  multiLineStringToLineStrings: IH,
  multiPolygonToPolygons: AH,
  convertLineString2Points: CH,
  convertPolygon2LineString: fH,
  coordEach: vC,
  geomEach: Tw,
  featureEach: pH,
  geomReduce: Lw,
  getbbox: Gw,
  getCoord: Mw,
  getGeom: Ew,
  inBBox: Rw,
  booleanPointInPolygon: yH,
  feature: jh,
  featureCollection: SH,
  coordToPoint: Dw,
  coordToLineString: bH,
  coordToPolygon: BH,
  computeGeoJSONArea: wH,
  getcenter: xH,
  isLngLatArrValid: Kw
}, Symbol.toStringTag, { value: "Module" })), Wp = function(s) {
  return typeof s == "string" ? s : typeof s == "object" ? s.properties.name : null;
};
class Ds {
  constructor(t, e = {}, i = !1) {
    f(this, "_originalCoordinates");
    f(this, "_attributes");
    f(this, "_id");
    f(this, "_sourceProjectionName");
    f(this, "_coordinates");
    f(this, "_projectedCoordinates", {});
    f(this, "_type");
    f(this, "_isMulti", !1);
    f(this, "_size", 1);
    f(this, "_isValid", !0);
    t || (console.warn("DataItem: feature is required"), this._isValid = !1);
    let n = null, o = {};
    if (Array.isArray(t))
      this._type = lc, this._originalCoordinates = t;
    else if (t.isVector3)
      this._type = lc, this._originalCoordinates = [t.x, t.y, t.z];
    else if (typeof t == "object") {
      const r = t.geometry;
      if (!r)
        console.warn("DataItem: geometry is required"), this._isValid = !1;
      else {
        const a = (r.type || "").toUpperCase();
        a === "POINT" ? this._type = lc : a === "LINESTRING" ? this._type = Nd : a === "POLYGON" ? this._type = Fd : a === "MULTIPOINT" ? (this._type = lc, this._isMulti = !0, this._size = r.coordinates.length) : a === "MULTILINESTRING" ? (this._type = Nd, this._isMulti = !0, this._size = r.coordinates.length) : a === "MULTIPOLYGON" ? (this._type = Fd, this._isMulti = !0, this._size = r.coordinates.length) : (this._isValid = !1, console.warn("DataItem: geometry is invalid")), this._originalCoordinates = r.coordinates;
      }
      t.crs && (n = Wp(t.crs)), t.properties && Object.assign(o, t.properties);
    } else
      console.warn("DataItem: feature is invalid");
    Object.assign(o, e), this._attributes = o, o.id !== void 0 && (this._id = o.id), !n && o.crs && (n = Wp(o.crs)), this._sourceProjectionName = n, !n || n === hi && !i ? this._coordinates = this._originalCoordinates : this._projectedCoordinates[n] = this._originalCoordinates;
  }
  getProjectedCoordinates(t, e = 0) {
    return this._projectedCoordinates[t.name] ? this._isMulti ? this._projectedCoordinates[t.name][e] : this._projectedCoordinates[t.name] : (this._projectedCoordinates[t.name] = Yh(this.coordinates, t), this._isMulti ? this._projectedCoordinates[t.name][e] : this._projectedCoordinates[t.name]);
  }
  toGeoJSON() {
    let t = "Point";
    return this._type === Nd ? t = "LineString" : this._type === Fd && (t = "Polygon"), this._isMulti && (t = "Multi" + t), {
      type: "Feature",
      geometry: {
        type: t,
        coordinates: this.coordinates
      },
      properties: this._attributes
    };
  }
  setCoordinates(t, e) {
    this._coordinates = null, this._projectedCoordinates = {}, this._isMulti && (this._size = t.length), e ? (this._sourceProjectionName = e.name, this._originalCoordinates = t, this._projectedCoordinates[e.name] = t) : this._coordinates = t;
  }
  setAttribute(t, e) {
    this._attributes[t] = e;
  }
  setAttributes(t) {
    Object.assign(this._attributes, t);
  }
  get attributes() {
    return this._attributes;
  }
  get id() {
    return this._id;
  }
  set id(t) {
    if (this._id !== void 0) {
      console.warn("DataItem: id is already set");
      return;
    }
    this._id = t;
  }
  get coordinates() {
    if (!this._coordinates) {
      const t = bn(this._sourceProjectionName);
      this._coordinates = xC(this._originalCoordinates, t);
    }
    return this._coordinates;
  }
  get sourceProjectionName() {
    return this._sourceProjectionName;
  }
  get type() {
    return this._type;
  }
  get isMulti() {
    return this._isMulti;
  }
  get size() {
    return this._size;
  }
  get isValid() {
    return this._isValid;
  }
}
function vH(s, t) {
  const e = 1 - s;
  return e * e * e * t;
}
function TH(s, t) {
  const e = 1 - s;
  return 3 * e * e * s * t;
}
function LH(s, t) {
  return 3 * (1 - s) * s * s * t;
}
function GH(s, t) {
  return s * s * s * t;
}
function Yd(s, t, e, i, n) {
  return vH(s, t) + TH(s, e) + LH(s, i) + GH(s, n);
}
const MH = function(s, t) {
  let e = s[0], i = s[1], n = t[0], o = t[1], r = (3 * e + n) / 4, a = (3 * i + o) / 4;
  return [r, a];
}, EH = function(s, t) {
  let e = s[0], i = s[1], n = t[0], o = t[1];
  return Math.sqrt(
    Math.pow(e - n, 2) + Math.pow(i - o, 2)
  );
}, Zp = function(s, t, e = 1) {
  return [...MH(s, t), EH(s, t) / e];
}, RH = function(s, t, e, i, n) {
  let o = [];
  return o.push(
    Yd(s, t[0], e[0], i[0], n[0]),
    Yd(s, t[1], e[1], i[1], n[1]),
    Yd(s, t[2], e[2], i[2], n[2])
  ), o;
};
function DH(s, t = 20) {
  const e = s[0], i = s[s.length - 1], n = Zp(e, i, 2), o = Zp(i, e, 2);
  let r = [];
  for (let a = 0; a <= t; a++)
    r.push(RH(a / t, e, n, o, i));
  return r;
}
const Up = 1, Op = 2, jd = 4;
class Gi {
  constructor(t = {}) {
    f(this, "_generatedIdIndex", 1);
    f(this, "_objects", []);
    f(this, "_data", {});
    f(this, "_userData", []);
    f(this, "_userDataNeedsUpdate", !1);
    f(this, "_dataItems", []);
    f(this, "_attributeMap", /* @__PURE__ */ new Map());
    f(this, "_needsUpdate", !0);
    f(this, "_idIndexMap", {});
    f(this, "_indexIdMap", {});
    f(this, "_queuedData", []);
    f(this, "_isCurve", !1);
    this._options = t, this._id = t.id || new Date().valueOf(), t.attributes && this.defineAttributes(t.attributes);
  }
  async load(t) {
    if (!t || typeof t != "string") {
      console.warn("url is required");
      return;
    }
    try {
      const e = await fetch(t), i = await this._convertStreamingDataToObjectData(e);
      this._queuedData.push({
        operation: jd,
        data: i
      }), this.needsUpdate = !0;
    } catch (e) {
      console.error("load data error", e);
    }
    return this;
  }
  async _convertStreamingDataToObjectData(t) {
    console.error("please implement _convertStreamingDataToObjectData method");
  }
  _parseObjectDataToDataItems(t) {
    console.error("please implement _parseObjectDataToDataItems method");
  }
  defineAttribute(t, e) {
    return e ? this._attributeMap.set(t, e) : this._attributeMap.set(t, t), this.needsUpdate = !0, this;
  }
  setAttribute(t, e) {
    return console.warn("setAttribute is deprecated, please use defineAttribute instead."), this.defineAttribute(t, e);
  }
  defineAttributes(t) {
    let e = Object.keys(t);
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      this._attributeMap.set(n, t[n]);
    }
    return this.needsUpdate = !0, this;
  }
  setAttributes(t) {
    return console.warn("setAttributes is deprecated, please use defineAttributes instead."), this.defineAttributes(t);
  }
  undefineAttribute(t) {
    return this._attributeMap.delete(t), this.needsUpdate = !0, this;
  }
  removeAttribute(t) {
    return console.warn("removeAttribute is deprecated, please use undefineAttribute instead."), this.undefineAttribute(t);
  }
  undefineAllAttributes() {
    return this._attributeMap.clear(), this.needsUpdate = !0, this;
  }
  removeAttributes() {
    return console.warn("removeAttributes is deprecated, please use undefineAllAttributes instead."), this.undefineAllAttributes();
  }
  add(t) {
    return this._queuedData.push({
      operation: Up,
      data: Array.isArray(t) ? t : [t]
    }), this.needsUpdate = !0, this;
  }
  remove(t) {
    return this._queuedData.push({
      operation: Op,
      data: Array.isArray(t) ? t : [t]
    }), this.needsUpdate = !0, this;
  }
  setAttributeValue(t, e, i) {
    return this.setAttributeValues(t, {
      [e]: i
    });
  }
  setAttributeValues(t, e) {
    Array.isArray(t) || (t = [t]);
    for (let i = 0; i < t.length; i++) {
      const n = t[i], o = this._idIndexMap[n];
      o !== void 0 && this._dataItems[o].setAttributes(e);
    }
    return this.needsUpdate = !0, this;
  }
  setCoordinates(t, e, i) {
    Array.isArray(t) || (t = [t]);
    for (let n = 0; n < t.length; n++) {
      const o = t[n], r = this._idIndexMap[o];
      r !== void 0 && this._dataItems[r].setCoordinates(e, i);
    }
    return this.needsUpdate = !0, this;
  }
  get(t) {
    let e = {};
    if (!(!this.data.position || !this.data.position.length || t === void 0 || t >= this.data.position.length)) {
      for (const i in this.data)
        if (Object.hasOwnProperty.call(this.data, i)) {
          const n = this.data[i];
          e[i] = n[t];
        }
      return e;
    }
  }
  getDataItemIndex(t) {
    return this.data.index[t];
  }
  getDataItem(t) {
    const e = this.getDataItemIndex(t);
    if (e !== void 0)
      return this._dataItems[e];
  }
  exportToGeoJSON() {
    let t = [];
    for (let e = 0; e < this._dataItems.length; e++) {
      const i = this._dataItems[e];
      t.push(i.toGeoJSON());
    }
    return {
      type: "FeatureCollection",
      features: t
    };
  }
  _executeAddData(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      i.id || (i.id = "_gid_" + this._generatedIdIndex++);
      const n = i.id;
      if (this._idIndexMap[n] !== void 0)
        continue;
      const o = this._dataItems.length;
      this._indexIdMap[o] = n, this._idIndexMap[n] = o, this._dataItems.push(i);
    }
  }
  _executeRemoveData(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e];
      let n;
      if (i instanceof Ds || Array.prototype.toString.call(i) === "[object Object]" ? n = i.id : n = i, n !== void 0) {
        const o = this._idIndexMap[n];
        if (o === void 0) {
          console.warn("remove fail1", o, n);
          return;
        }
        const r = this._dataItems.length - 1;
        if (o > r) {
          console.warn("remove fail2", o, n);
          return;
        }
        if (o < r) {
          const a = this._indexIdMap[r];
          this._dataItems[o] = this._dataItems[r], this._indexIdMap[o] = a, this._idIndexMap[a] = o;
        }
        delete this._idIndexMap[n], delete this._indexIdMap[r], this._dataItems.length = this._dataItems.length - 1;
      }
    }
  }
  _processData(t) {
    this._templateDataLength = t.index.length;
    let e = null, i = 0;
    for (let n = 0; n < this._dataItems.length; n++)
      if (e = this._dataItems[n], !!e.isValid) {
        e.isMulti ? i = e.size : i = 1;
        for (let o = 0; o < i; o++) {
          const r = e.getProjectedCoordinates(this.projection, o);
          t.position.push(r), t.index.push(n);
          for (const a of this._attributeMap.keys()) {
            let g;
            const c = this._attributeMap.get(a);
            e.attributes && e.attributes[c] !== void 0 && e.attributes[c] !== null ? g = e.attributes[c] : c instanceof Function && (g = c(e.attributes, e, o, n)), t[a].push(g);
          }
        }
      }
  }
  update() {
    if (this.isDirectBuffer) {
      this.needsUpdate = !1;
      return;
    }
    const t = this._queuedData.length;
    if (t > 0)
      for (let n = 0; n < t; n++) {
        const o = this._queuedData.shift();
        if (o.operation === jd) {
          const r = this._parseObjectDataToDataItems(o.data);
          this._executeAddData(r);
        } else
          o.operation === Up ? this._executeAddData(o.data) : o.operation === Op && this._executeRemoveData(o.data);
      }
    let e = {
      position: [],
      index: []
    }, i = [];
    for (const n of this._attributeMap.keys())
      e[n] = [];
    if (this._processData(e, i), this._isCurve && e.position.length > 0 && Array.isArray(e.position[0]) && Array.isArray(e.position[0][0]) && !Array.isArray(e.position[0][0][0]))
      for (let n = 0; n < e.position.length; n++) {
        const o = e.position[n];
        e.position[n] = DH(o);
      }
    this._data = e, this._userDataNeedsUpdate = !0, this.needsUpdate = !1;
  }
  setData(t) {
    this.clear(), this._queuedData.push({
      operation: jd,
      data: t
    }), this.needsUpdate = !0;
  }
  clear() {
    this._data = {}, this._userData = [], this._queuedData = [], this._dataItems = [], this.needsUpdate = !0, this._idIndexMap = {}, this._indexIdMap = {}, this.onClear();
  }
  onClear() {
  }
  _formatGeometry(t) {
    return t ? Array.isArray(t) ? {
      type: "Point",
      coordinates: t
    } : t.isVector3 ? {
      type: "Point",
      coordinates: [t.x, t.y, t.z]
    } : t : null;
  }
  dispose() {
    this.clear();
  }
  get dataItems() {
    return this._dataItems;
  }
  get size() {
    return this.needsUpdate && this.update(), this.data && this.data.position && this.data.position.length || 0;
  }
  get data() {
    return this._data;
  }
  get userData() {
    if (!this._userDataNeedsUpdate)
      return this._userData;
    if (!this._data || !this._data.position || !this._data.position.length)
      return [];
    const t = [];
    let e = null;
    for (let i = 0, n = this._data.position.length; i < n; i++) {
      const o = {
        position: this._data.position[i],
        index: this._data.index[i]
      };
      for (const r of this._attributeMap.keys())
        e = this._data[r] && this._data[r][i], o[r] = e;
      t.push(o);
    }
    return this._userData = t, this._userDataNeedsUpdate = !1, this._userData;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(t) {
    this._needsUpdate = t;
  }
  get objects() {
    return this._objects;
  }
  set objects(t) {
    this._objects = t;
  }
  get isCurve() {
    return this._isCurve;
  }
  set isCurve(t) {
    this._isCurve = t, this.needsUpdate = !0;
  }
}
class KH extends Wt {
  constructor(e) {
    super();
    f(this, "_enableRtc", !0);
    f(this, "_cachedRtc", [0, 0, 0]);
    f(this, "makeMeshPositionOffset", (e) => {
      this._cachedRtc = [e[0], e[1], e[2] || 0], this.updateTransform();
    });
    f(this, "makeGeometryOffsetPosition", (e, i) => {
      if (!this._enableRtc)
        return;
      const n = e.boundingSphere && e.boundingSphere.center;
      if (!n) {
        this._cachedRtc = [0, 0, 0], this.updateTransform();
        return;
      }
      const { x: o, y: r, z: a } = n;
      e.isCustomInstancedBufferGeometry ? this.makePostionArrayOffset(e.attributes.instancedPosition.array, o, r, a, i) : (this.makePostionArrayOffset(e.attributes.position.array, o, r, a, i), e.attributes.position.array.length), e.computeBoundingSphere(), this._cachedRtc = [o, r, a], this.updateTransform();
    });
    f(this, "makePostionArrayOffset", (e, i, n, o, r) => {
      if (!e || e.length < 3)
        return;
      let a = r || e;
      for (let g = 0, c = e.length - 2; g < c; g += 3)
        e[g] = a[g] - i, e[g + 1] = a[g + 1] - n, e[g + 2] = a[g + 2] - o;
    });
    f(this, "updateTransform", () => {
      const [e, i, n] = this._cachedRtc;
      this.position.set(e, i, n), this.updateMatrixWorld(!0);
    });
    Object.defineProperties(this, {
      enableRtc: {
        get: function() {
          return this._enableRtc;
        },
        set: function(i) {
          this._enableRtc = i;
        }
      }
    });
  }
  defineGeometryProxyProperties(e = []) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Object.defineProperty(this, n, {
        get: function() {
          return this.geometry[n];
        },
        set: function(o) {
          this.geometry[n] = o;
        }
      });
    }
  }
  defineGeometryUpdateProxyProperties(e = []) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Object.defineProperty(this, n, {
        get: function() {
          return this.geometry[n];
        },
        set: function(o) {
          this.geometry[n] = o, this.needsUpdate = !0;
        }
      });
    }
  }
  defineMaterialProxyProperties(e = []) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Object.defineProperty(this, n, {
        get: function() {
          return this.material[n];
        },
        set: function(o) {
          this.material[n] = o;
        }
      });
    }
  }
  defineMaterialUpdateProxyProperties(e = []) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Object.defineProperty(this, n, {
        get: function() {
          return this.material[n];
        },
        set: function(o) {
          this.material[n] = o, this.material.needsUpdate = !0;
        }
      });
    }
  }
  defineMaterialColorProxyProperties(e = []) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Object.defineProperty(this, n, {
        get: function() {
          return this.material[n];
        },
        set: function(o) {
          this.material[n] = Oh(o);
        }
      });
    }
  }
  raycast(e, i) {
    !this.visible || super.raycast(e, i);
  }
}
class Os extends KH {
  constructor() {
    super(...arguments);
    f(this, "isGeoObject", !0);
    f(this, "dataAutoUpdate", !0);
    f(this, "_parameters");
    f(this, "_dataSource");
    f(this, "_dataSourceUpdated");
    f(this, "_needsUpdate");
    f(this, "_zooms", [0, 100]);
    f(this, "_zoomVisibleCache");
    f(this, "engine");
    f(this, "travelFeatureLineCoordinate", (e, i, n) => {
      const o = e.geometry;
      if (!o || !o[i] || !o.type)
        return;
      const r = o[i];
      if (o.type === "LineString")
        n && n(r);
      else if (o.type === "MultiLineString" || o.type === "Polygon")
        for (let a of r)
          n && n(a);
      else if (o.type === "MultiPolygon")
        for (let a of r)
          for (let g of a)
            n && n(g);
    });
    f(this, "travelLineCoordinates", (e, i = "coordinates", n, o = 0) => {
      if (!(!Array.isArray(e) || !n))
        for (let r = 0, a = e.length; r < a; r++) {
          const g = e[r], c = o + r, l = g.geometry;
          if (!l || !l[i] || !l.type)
            continue;
          const h = l[i];
          if (l.type === "LineString")
            n && n(h, g, c);
          else if (l.type === "MultiLineString" || l.type === "Polygon")
            for (let d of h)
              n && n(d, g, c);
          else if (l.type === "MultiPolygon")
            for (let d of h)
              for (let C of d)
                n && n(C, g, c);
        }
    });
    f(this, "travelPolygonCoordinates", (e, i = "coordinates", n, o = 0) => {
      if (!(!Array.isArray(e) || !n))
        for (let r = 0, a = e.length; r < a; r++) {
          const g = e[r], c = o + r, l = g.geometry;
          if (!l || !l[i] || !l.type)
            continue;
          const h = l[i];
          if (l.type === "Polygon")
            n && n(h, g, c);
          else if (l.type === "MultiPolygon")
            for (let d of h)
              n && n(d, g, c);
          else if (l.type === "LineString")
            n && n([h], g, c);
          else if (l.type === "MultiLineString")
            for (let d of h)
              n && n([d], g, c);
        }
    });
    f(this, "travelPointCoordinates", (e, i = "coordinates", n, o = 0) => {
      if (!(!Array.isArray(e) || !n))
        for (let r = 0, a = e.length; r < a; r++) {
          const g = e[r], c = o + r, l = g.geometry;
          if (!l || !l[i] || !l.type)
            continue;
          const h = l[i];
          l.type === "Point" && n && n(h, g, c);
        }
    });
    f(this, "getPointsBounding", (e, i = "coordinates") => {
      let n = 1 / 0, o = 1 / 0, r = 1 / 0, a = -1 / 0, g = -1 / 0, c = -1 / 0;
      return this.travelPointCoordinates(e, i, (l) => {
        const [h, d, C = 0] = l;
        h < n && (n = h), h > a && (a = h), d < o && (o = d), d > g && (g = d), C < r && (r = C), C > c && (c = C);
      }), isFinite(n) || (n = 0), isFinite(a) || (a = 0), isFinite(o) || (o = 0), isFinite(g) || (g = 0), isFinite(r) || (r = 0), isFinite(c) || (c = 0), [n, o, r, a, g, c];
    });
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(e) {
    this._parameters ? this._parameters = { ...this._parameters, ...e } : this._parameters = { ...this.getDefaultParams(), ...e };
  }
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(e) {
    this.setDataSource(e);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get zooms() {
    return this._zooms;
  }
  set zooms(e) {
    this._zooms = e;
  }
  get inZoomsRange() {
    const e = this.engine;
    return e ? e.map.getZoom() >= this.zooms[0] && e.map.getZoom() <= this.zooms[1] : !1;
  }
  afterAddToEngine(e) {
    this.engine = e, this.initObject(), this.isInstancedMesh && this.material && (this.material.defines ? this.material.defines.IS_INSTANCE = !0 : this.material.defines = {
      IS_INSTANCE: !0
    });
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  initObject() {
  }
  getDefaultParams() {
    return {};
  }
  getEntityByIndex(e) {
    const i = this.dataSource;
    if (!i)
      return;
    const n = {
      index: e,
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e];
    return n;
  }
  setDataSource(e) {
    if (!e) {
      if (this._dataSource) {
        const i = this._dataSource.objects.indexOf(this);
        i > -1 && this._dataSource.objects.splice(i, 1), this._dataSource = null, this.needsUpdate = !0, this.engine.requestRender();
      }
      return;
    }
    e.objects.indexOf(this) > -1 || (this._dataSource = e, e.projection = this.engine.map.projection, e.objects.push(this), this.needsUpdate = !0, this.engine.requestRender());
  }
  onBeforeScenePrepareRender(e, i, n, o) {
    !this.dataSource || (this.dataSource.needsUpdate && (this.dataSource.update(), this.needsUpdate = !0), this.dataAutoUpdate && this.needsUpdate && this._enableCollision && (e.rendering.collision.needsUpdate = !0), this.onBeforeScenePrepareRenderHook && this.onBeforeScenePrepareRenderHook(e, i, n, o), this.visible && !this.inZoomsRange ? (this._zoomVisibleCache = this.visible, this.visible = !1) : !this.visible && this._zoomVisibleCache && this.inZoomsRange && (this.visible = this._zoomVisibleCache, this._zoomVisibleCache = void 0));
  }
  onBeforeSceneRender(e, i, n, o) {
    !this.dataSource || (this.dataAutoUpdate && this.needsUpdate && !this._enableCollision ? this._updateData() : this.dataAutoUpdate && this.isGroundPrimitive && this.isDynamic ? this._updateData() : this.dataAutoUpdate && this._collisionUpdated ? (this._updateData(), this._collisionUpdated = !1) : this.geometry && this.geometry.needsUpdate && this.geometry.updateGeometry && (this.geometry.updateGeometry(), this.afterGeometryUpdate && this.afterGeometryUpdate()), this.onBeforeSceneRenderHook && this.onBeforeSceneRenderHook(e, i, n, o));
  }
  _updateData() {
  }
  collisionTest(e) {
    return {};
  }
  onDispose() {
  }
  dispose() {
    if (this.geometry && this.geometry.dispose(), this.material)
      if (Array.isArray(this.material))
        for (let e = 0; e < this.material.length; e++)
          this.material[e].dispose();
      else
        this.material.dispose();
    this.onDispose();
  }
  bindTerrain(e) {
    this._terrain = e;
  }
}
class Fo extends Os {
  constructor() {
    super(...arguments);
    f(this, "isMesh", !0);
  }
}
const Qp = new B(), eo = new Ue(), za = new Ue(), ps = new B();
class HH extends Qe {
  constructor(t) {
    super(t), this.parameters = t, this._drawRange = 0, this._init = !1;
  }
  setData(t) {
    if (this._init) {
      this.updateData(t);
      return;
    }
    const {
      positions: e,
      indices: i,
      typesAndPIndices: n,
      uvs: o,
      whs: r,
      rotateZs: a,
      offsets: g,
      instanceRotationMatrices: c,
      styles: l,
      drawRange: h,
      fadeOpacityAndSince: d
    } = t;
    if (o.length > 0 && this.setAttribute("uv", new ae(o, 2)), a.length > 0 && this.setAttribute("rotateZ", new ae(a, 1)), g.length > 0 && this.setAttribute("offset", new ae(g, 2)), c.length > 0 && this.setAttribute("instanceRotationMatrix", new ae(c, 9)), d.length > 0) {
      const b = new Ai(d, 2);
      this.setAttribute("fadeOpacity", new ve(b, 1, 0)), this.setAttribute("fadeSince", new ve(b, 1, 1));
    }
    const C = new Ai(r, 4);
    this.setAttribute("wh", new ve(C, 2, 0)), this.setAttribute("size", new ve(C, 2, 2));
    const p = new Ai(l, 8);
    this.setAttribute("fillStyles", new ve(p, 4, 0)), this.setAttribute("strokeStyles", new ve(p, 4, 4)), this.setAttribute("position", new ae(e, 3));
    const m = new Ai(n, 2);
    this.setAttribute("pIndex", new ve(m, 1, 1)), this.setAttribute("type", new ve(m, 1, 0)), this.setIndex(i), this._drawRange = h, this._init = !0;
  }
  updateData(t) {
    const {
      positions: e,
      uvs: i,
      whs: n,
      rotateZs: o,
      offsets: r,
      instanceRotationMatrices: a,
      styles: g,
      typesAndPIndices: c,
      indices: l,
      drawRange: h,
      fadeOpacityAndSince: d
    } = t, C = h / 3, p = this.getAttribute("position");
    for (let T = 0; T < C; T++)
      p.setXYZ(T, e[T * 3], e[T * 3 + 1], e[T * 3 + 2]);
    p.needsUpdate = !0;
    const m = this.getAttribute("uv");
    if (m)
      for (let T = 0; T < C; T++)
        m.setXY(T, i[T * 2], i[T * 2 + 1]);
    m.needsUpdate = !0;
    const b = this.getAttribute("rotateZ");
    if (b)
      for (let T = 0; T < C; T++)
        b.setX(T, o[T]);
    b.needsUpdate = !0;
    const S = this.getAttribute("offset");
    if (S)
      for (let T = 0; T < C; T++)
        S.setXYZW(
          T,
          r[T * 2],
          r[T * 2 + 1]
        );
    S.needsUpdate = !0;
    const A = this.getAttribute("fadeOpacity"), u = this.getAttribute("fadeSince");
    if (A && u)
      for (let T = 0; T < C; T++)
        A.setX(T, d[T * 2]), u.setX(T, d[T * 2 + 1]);
    A.needsUpdate = !0, u.needsUpdate = !0;
    const y = this.getAttribute("instanceRotationMatrix");
    if (y)
      for (let T = 0; T < C; T++) {
        const R = T * 9;
        y.set([
          a[R],
          a[R + 1],
          a[R + 2],
          a[R + 3],
          a[R + 4],
          a[R + 5],
          a[R + 6],
          a[R + 7],
          a[R + 8]
        ], R);
      }
    y.needsUpdate = !0;
    const I = this.getAttribute("wh"), M = this.getAttribute("size");
    if (I && M)
      for (let T = 0; T < C; T++)
        I.setXY(T, n[T * 4], n[T * 4 + 1]), M.setXY(T, n[T * 4 + 2], n[T * 4 + 3]);
    I.needsUpdate = !0, M.needsUpdate = !0;
    const G = this.getAttribute("fillStyles"), x = this.getAttribute("strokeStyles");
    if (G && x)
      for (let T = 0; T < C; T++)
        G.setXYZW(T, g[T * 8], g[T * 8 + 1], g[T * 8 + 2], g[T * 8 + 3]), x.setXYZW(
          T,
          g[T * 8 + 4],
          g[T * 8 + 5],
          g[T * 8 + 6],
          g[T * 8 + 7]
        );
    G.needsUpdate = !0, x.needsUpdate = !0;
    const L = this.getAttribute("type"), E = this.getAttribute("pIndex");
    if (L && E)
      for (let T = 0; T < C; T++)
        L.setX(T, c[T * 2]), E.setX(T, c[T * 2 + 1]);
    L.needsUpdate = !0, E.needsUpdate = !0, this._drawRange = h, this.setIndex(l);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Bn());
    const t = this.attributes.position, e = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ), this.boundingSphere.set(new B(), 1 / 0);
      return;
    }
    if (t) {
      const i = this.boundingSphere.center, n = t.array.slice(0, this._drawRange);
      if (eo.setFromArray(n), e)
        for (let r = 0, a = e.length; r < a; r++) {
          const g = e[r];
          za.setFromBufferAttribute(g), this.morphTargetsRelative ? (ps.addVectors(eo.min, za.min), eo.expandByPoint(ps), ps.addVectors(eo.max, za.max), eo.expandByPoint(ps)) : (eo.expandByPoint(za.min), eo.expandByPoint(za.max));
        }
      eo.getCenter(i);
      let o = 0;
      for (let r = 0, a = n.length; r < a; r += 3)
        ps.fromArray(n, r), o = Math.max(o, i.distanceToSquared(ps));
      if (e)
        for (let r = 0, a = e.length; r < a; r++) {
          const g = e[r], c = this.morphTargetsRelative;
          for (let l = 0, h = g.count; l < h; l++)
            ps.fromBufferAttribute(g, l), c && (Qp.fromBufferAttribute(t, l), ps.add(Qp)), o = Math.max(o, i.distanceToSquared(ps));
        }
      this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
        this
      );
    }
  }
}
const PH = `#define GLSLIFY 1
#include <common>
uniform vec2 pixelOffset;
uniform vec3 positionOffset;
uniform bool u_flat;

#ifdef RENDER_IN_POSTPROCESS
    uniform float cameraFar;
#endif

#ifdef IS_GLOBE
    attribute mat3 instanceRotationMatrix;
#endif

attribute float pIndex;
attribute vec2 wh;
attribute vec2 size;
attribute float rotateZ;
attribute float type;
attribute vec4 strokeStyles;
attribute vec4 fillStyles;
attribute vec2 offset;

varying vec2 v_uv;
varying float v_type;
varying float v_iconOpacity;

varying vec4 vStrokeStyles;
varying vec3 vFillStyles;
varying vec2 vSize;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif

uniform float elapsedTime;
#ifdef MVT_ENABLE_FADE
    attribute float fadeOpacity;
    attribute float fadeSince;
    uniform float fadeDuration;
    varying float vFadeOpacity;
#endif

// \u4EC5\u4EC5text\u6709\u7684
// offset, anchor, strokeStyles

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>
void main() {
    v_uv = uv;
    v_type = type;

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = mat4(
            vec4(instanceRotationMatrix[0], 0.0),
            vec4(instanceRotationMatrix[1], 0.0),
            vec4(instanceRotationMatrix[2], 0.0),
            vec4(position, 1.0)
        );

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));

    #ifdef RENDER_IN_POSTPROCESS
        vec4 clipSpacePosition = projectionMatrix * viewMatrix * worldPosition;
        vClipSpacePosition.xy = ((clipSpacePosition.xy / clipSpacePosition.w) + 1.0) / 2.0;

        float fcoef = 1.0 / log2(cameraFar + 1.0);
        float logDepth = log2(max(1e-6, 1.0 + clipSpacePosition.w)) * fcoef;
        vLogDepth = logDepth;
    #endif

    if (type == 0.0) {
        float iconRotateZ = rotateZ;
        v_iconOpacity = fillStyles.w;
        // vec4 worldPosition = modelMatrix * vec4(position, 1.0);
        if (u_flat) {
            float hw = wh.x * 0.5;
            float hh = wh.y * 0.5;

            if (keepSize) {
                float pixelSize = getPixelSize(worldPosition.xyz);
                hw *= pixelSize;
                hh *= pixelSize;
            }

            vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -iconRotateZ);

            gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);
        }
        else {
            worldPosition.x += positionOffset.x;
            worldPosition.y += positionOffset.y;
            worldPosition.z += positionOffset.z;
            gl_Position = projectionMatrix * viewMatrix * worldPosition;
            float w = gl_Position.w;
            gl_Position /= w;

            float hw = wh.x / resolution.x;
            float hh = wh.y / resolution.y;

            float pixelSize = getPixelSize(worldPosition.xyz);
            float iconOffsetX = offset.x * 2.0 / resolution.x;
            float iconOffsetY = offset.y * 2.0 / resolution.y;
            if (!keepSize) {
                hw = hw / pixelSize;
                hh = hh / pixelSize;

                iconOffsetX /= pixelSize;
                iconOffsetY /= pixelSize;
            }
            gl_Position.x += pixelOffset.x / resolution.x;
            gl_Position.y += pixelOffset.y / resolution.y;

            if (pIndex == 1.0) {
                gl_Position.x -= hw;
                gl_Position.y += hh;
            } else if (pIndex == 2.0) {
                gl_Position.x += hw;
                gl_Position.y += hh;
            } else if (pIndex == 3.0) {
                gl_Position.x += hw;
                gl_Position.y -= hh;
            } else {
                gl_Position.x -= hw;
                gl_Position.y -= hh;
            }

            gl_Position.x += iconOffsetX;
            gl_Position.y += iconOffsetY;

            gl_Position *= w;
        }
    }
    else {
        float textRotateZ = rotateZ;

        // vec4 worldPosition = (modelMatrix * vec4(position, 1.0));
        float scale = size.x / wh.y;

        if (u_flat) {
            // viewMatrix[0]\u8868\u793A\u76F8\u673A\u7684\u53F3\u65B9\u5411\uFF0C\u4E0D\u7BA1\u76F8\u673A\u5982\u4F55\u503E\u659Ctilt\uFF0C\u6CD5\u5411\u91CF\u90FD\u6307\u5411\u6B63\u5317\u65B9\u5411\uFF0C\u6B63\u597D\u53EF\u4EE5\u7528\u6765\u8BA1\u7B97\u548C\u6587\u5B57\u7684\u5939\u89D2
            mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;
            vec4 right = localViewMatrix[0];
            float theta = dot(vec2(sin(textRotateZ), cos(textRotateZ)), vec2(-right.y, right.x));
            if (theta < 0.0) {
                textRotateZ += PI;
            }
            // TODO \u652F\u6301offset
            float hw = wh.x * 0.5 * scale;
            float hh = wh.y * 0.5 * scale;

            float pixelSize = getPixelSize(worldPosition.xyz);
            float xOffset = offset.x;
            float yOffset = offset.y;
            if (keepSize) {
                hw = hw * pixelSize;
                hh = hh * pixelSize;

                xOffset *= pixelSize;
                yOffset *= pixelSize;
            }

            vec3 transformedPoint =  transformCoord(currentPosition, vec2(xOffset, yOffset), 2.0, -textRotateZ);

            vec3 current = transformCoord(transformedPoint, vec2(hw, hh), pIndex, -textRotateZ);

            gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);

            // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        }
        else {
            // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
            worldPosition.x += positionOffset.x;
            worldPosition.y += positionOffset.y;
            worldPosition.z += positionOffset.z;
            vec4 pos = projectionMatrix * viewMatrix * worldPosition;
            float w = pos.w;
            vec3 screen = pos.xyz / w;

            float hw = wh.x / resolution.x * scale;
            float hh = wh.y / resolution.y * scale;

            float textOffsetX = offset.x * 2.0 / resolution.x;
            float textOffsetY = offset.y * 2.0 / resolution.y;
            if (!keepSize) {
                float pixelSize = getPixelSize(worldPosition.xyz);
                hw = hw / pixelSize;
                hh = hh / pixelSize;

                textOffsetX /= pixelSize;
                textOffsetY /= pixelSize;
            }

            screen.x += pixelOffset.x / resolution.x;
            screen.y += pixelOffset.y / resolution.y;

            vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -textRotateZ);

            current = vec3(current.x + textOffsetX, current.y + textOffsetY, current.z);

            gl_Position = vec4(current, 1.0);

            gl_Position *= w;

        }

        vStrokeStyles = strokeStyles;
        vFillStyles = fillStyles.xyz;
        vSize = size;
    }

    #ifdef MVT_ENABLE_FADE
        float fadeDiff = (elapsedTime - fadeSince) / fadeDuration;
        if (fadeOpacity > 2.0) {
            fadeDiff = clamp(fadeDiff, 0.0, 1.0);
            vFadeOpacity = fadeOpacity - fadeDiff - 2.0;
            // vFadeOpacity = vFadeOpacity * vFadeOpacity;
        } else {
            vFadeOpacity = fadeOpacity + fadeDiff;
            // vFadeOpacity = sqrt(vFadeOpacity);
        }
        vFadeOpacity = clamp(vFadeOpacity, 0.0, 1.0);
    #endif

    #include <logdepthbuf_vertex>
}`, NH = `#define GLSLIFY 1
#ifdef USE_ICON
uniform sampler2D spriteMap;
uniform sampler2D map;
#endif

#ifdef USE_TEXT
uniform sampler2D textMap;
#endif
uniform sampler2D depthTexture;
uniform float pixelRatio;
uniform bool useMap;

varying vec2 v_uv;
varying float v_type;
varying float v_iconOpacity;
varying vec3 vFillStyles;
varying vec4 vStrokeStyles;
varying vec2 vSize;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif

#ifdef MVT_ENABLE_FADE
    varying float vFadeOpacity;
#endif

#include <logdepthbuf_pars_fragment>
#include <tonemapping_pars_fragment>
#include <output_pars_fragment>
void main() {
    // #ifdef RENDER_IN_POSTPROCESS
    //     float depthValue = texture2D(depthTexture, vClipSpacePosition).r;
    //     float bias = 0.002; // \u907F\u514D\u8BBE\u7F6E\u4E00\u4E2A\u9608\u503C\uFF0C\u7CBE\u5EA6\u8BEF\u5DEE\u9020\u6210\u6587\u5B57\u7ED8\u5236\u4E0D\u7A33\u5B9A
    //     if (vLogDepth > depthValue + bias) {
    //         discard;
    //     }
    // #endif
    if (v_type == 0.0) {
        #ifdef USE_ICON
            if (useMap) {
                gl_FragColor = texture2D(map, vec2(v_uv.x, 1.0 - v_uv.y));
            }
            else {
                gl_FragColor = texture2D(spriteMap, vec2(v_uv.x, 1.0 - v_uv.y));
            }

            gl_FragColor.a *= v_iconOpacity;
        #endif
    }
    else {
        #ifdef USE_TEXT
            float fontScale = vSize.y / 24.0;
            float gamma = (0.105 / pixelRatio) / fontScale;
            float buff = (256.0 - 64.0) / 256.0;

            float distance = texture2D(textMap, vec2(v_uv.x, v_uv.y)).r;
            float alpha = smoothstep(buff - gamma, buff + gamma, distance);
            vec3 fontColor = vFillStyles;

            if (vStrokeStyles.w > 0.0) {
                float inFill = alpha;
                float outlineBuffer = (6.0 - vStrokeStyles.w / fontScale) / 8.0;
                float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);

                fontColor = mix(vStrokeStyles.xyz, fontColor, smoothstep(0.0, 1.0, inFill * 1.5));
                alpha = inBorder;
            }

            gl_FragColor = vec4(fontColor, alpha);
        #endif

    }

    #ifdef MVT_ENABLE_FADE
        gl_FragColor.a *= vFadeOpacity;
    #endif

    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>

    #include <output_fragment>
}`;
class di extends ze {
  constructor(e) {
    super();
    f(this, "isCommonShaderMaterial", !0);
    f(this, "setCommonUniforms", (e) => {
      for (const i of Object.keys(e))
        this.uniforms[i] = e[i];
    });
    this.setValues(e);
  }
}
const FH = we.merge([
  Xt.fog,
  zn,
  {
    spriteMap: { value: null },
    textMap: { value: null },
    map: { value: null },
    useMap: { value: !1 },
    pixelOffset: { value: [0, 0] },
    positionOffset: { value: [0, 0, 0] },
    opacity: { value: 1 },
    keepSize: {
      value: !0
    },
    depthTexture: {
      value: null
    },
    u_flat: {
      value: !1
    },
    cameraFar: {
      value: 0
    },
    srgbTransformer: {
      value: !1
    },
    fadeDuration: {
      value: 300
    }
  }
]), kH = new Ot();
class VH extends di {
  constructor(t) {
    super(), this.name = "SymbolMaterial", this.vertexShader = PH, this.fragmentShader = NH, this.transparent = !0, this.depthTest = !1, this._mapSrc = "", Object.assign(this.uniforms, we.clone(FH)), Ka(this), Js(this, [
      ["flat", "u_flat"]
    ]), ri(this, [
      ["isRenderInPostprocess", "RENDER_IN_POSTPROCESS"],
      ["isGlobe", "IS_GLOBE"],
      ["useText", "USE_TEXT"],
      ["useIcon", "USE_ICON"],
      ["enableFade", "MVT_ENABLE_FADE"]
    ]), oi(this, [
      "depthTexture",
      "cameraFar",
      "resolution",
      "pixelOffset",
      "positionOffset",
      "opacity",
      "fadeDuration"
    ]), Object.defineProperties(this, {
      spriteTexture: {
        get: function() {
          return this.uniforms.spriteMap.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.spriteMap.value = null;
            return;
          }
          this.uniforms.spriteMap.value = e;
        }
      },
      textTexture: {
        get: function() {
          return this.uniforms.textMap.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.textMap.value = null;
            return;
          }
          this.uniforms.textMap.value = e;
        }
      },
      mapSrc: {
        get: function() {
          return this._mapSrc;
        },
        set: function(e) {
          if (this.mapSrc !== e) {
            if (this.uniforms.map.value && this.uniforms.map.value.dispose(), !e) {
              this.uniforms.map.value = null, this.uniforms.useMap.value = !1;
              return;
            }
            kH.load(e, (n) => {
              n.wrapS = n.wrapT = hs, n.colorSpace = gt, this.uniforms.map.value = n, this.uniforms.useMap.value = !0, this._mapSrc = e;
            });
          }
        }
      }
    }), this.setValues(t);
  }
  dispose() {
    this.uniforms.spriteMap.value && this.uniforms.spriteMap.value.dispose(), this.uniforms.textMap.value && this.uniforms.textMap.value.dispose(), super.dispose();
  }
}
const vg = 1e20;
class zH {
  constructor({
    fontSize: t = 24,
    buffer: e = 3,
    radius: i = 8,
    cutoff: n = 0.25,
    fontFamily: o = "sans-serif",
    fontWeight: r = "normal",
    fontStyle: a = "normal"
  } = {}) {
    this.buffer = e, this.cutoff = n, this.radius = i;
    const g = this.size = t + e * 4, c = this._createCanvas(g), l = this.ctx = c.getContext("2d", { willReadFrequently: !0 });
    l.font = `${a} ${r} ${t}px ${o}`, l.textBaseline = "alphabetic", l.textAlign = "left", l.fillStyle = "black", this.gridOuter = new Float64Array(g * g), this.gridInner = new Float64Array(g * g), this.f = new Float64Array(g), this.z = new Float64Array(g + 1), this.v = new Uint16Array(g);
  }
  _createCanvas(t) {
    const e = document.createElement("canvas");
    return e.width = e.height = t, e;
  }
  draw(t) {
    const {
      width: e,
      actualBoundingBoxAscent: i,
      actualBoundingBoxDescent: n,
      actualBoundingBoxLeft: o,
      actualBoundingBoxRight: r
    } = this.ctx.measureText(t), a = Math.ceil(i), g = 0, c = Math.min(this.size - this.buffer, Math.ceil(r - o)), l = Math.min(this.size - this.buffer, a + Math.ceil(n)), h = c + 2 * this.buffer, d = l + 2 * this.buffer, C = Math.max(h * d, 0), p = new Uint8ClampedArray(C), m = { data: p, width: h, height: d, glyphWidth: c, glyphHeight: l, glyphTop: a, glyphLeft: g, glyphAdvance: e };
    if (c === 0 || l === 0)
      return m;
    const { ctx: b, buffer: S, gridInner: A, gridOuter: u } = this;
    b.clearRect(S, S, c, l), b.fillText(t, S, S + a);
    const y = b.getImageData(S, S, c, l);
    u.fill(vg, 0, C), A.fill(0, 0, C);
    for (let I = 0; I < l; I++)
      for (let M = 0; M < c; M++) {
        const G = y.data[4 * (I * c + M) + 3] / 255;
        if (G === 0)
          continue;
        const x = (I + S) * h + M + S;
        if (G === 1)
          u[x] = 0, A[x] = vg;
        else {
          const L = 0.5 - G;
          u[x] = L > 0 ? L * L : 0, A[x] = L < 0 ? L * L : 0;
        }
      }
    Yp(u, 0, 0, h, d, h, this.f, this.v, this.z), Yp(A, S, S, c, l, h, this.f, this.v, this.z);
    for (let I = 0; I < C; I++) {
      const M = Math.sqrt(u[I]) - Math.sqrt(A[I]);
      p[I] = Math.round(255 - 255 * (M / this.radius + this.cutoff));
    }
    return m;
  }
}
function Yp(s, t, e, i, n, o, r, a, g) {
  for (let c = t; c < t + i; c++)
    jp(s, e * o + c, o, n, r, a, g);
  for (let c = e; c < e + n; c++)
    jp(s, c * o + t, 1, i, r, a, g);
}
function jp(s, t, e, i, n, o, r) {
  o[0] = 0, r[0] = -vg, r[1] = vg, n[0] = s[t];
  for (let a = 1, g = 0, c = 0; a < i; a++) {
    n[a] = s[t + a * e];
    const l = a * a;
    do {
      const h = o[g];
      c = (n[a] - n[h] + l - h * h) / (a - h) / 2;
    } while (c <= r[g] && --g > -1);
    g++, o[g] = a, r[g] = c, r[g + 1] = vg;
  }
  for (let a = 0, g = 0; a < i; a++) {
    for (; r[g + 1] < a; )
      g++;
    const c = o[g], l = a - c;
    s[t + a * e] = n[c] + l * l;
  }
}
const XH = 32, WH = [];
function ZH(s) {
  return Math.pow(2, Math.ceil(Math.log2(s)));
}
function UH() {
  const s = [];
  for (let t = 32; t < 128; t++)
    s.push(String.fromCharCode(t));
  return s;
}
function OH({
  characterSet: s,
  context: t,
  fontHeight: e,
  buffer: i,
  maxCanvasWidth: n,
  mapping: o = {},
  xOffset: r = 0,
  yOffset: a = 0,
  defaultFontWeight: g
}) {
  let c = 0, l = r, h = 0;
  for (const d of s) {
    const { char: C, fontWeight: p } = d, m = C + W(p, g);
    if (!o[m]) {
      const b = t.measureText(C), S = b.width;
      let A = b.actualBoundingBoxAscent + b.actualBoundingBoxDescent;
      A === 0 && (A = S), A += i, l + S + i * 2 > n && (l = 0, c++, h = 0), h = Math.max(h, e + i * 2), o[m] = {
        x: l + i,
        y: a + c * h + i,
        width: S,
        height: h,
        layoutWidth: S,
        layoutHeight: e,
        textHeight: Math.max(A, S)
      }, l += S + i * 2;
    }
  }
  return {
    mapping: o,
    xOffset: l,
    yOffset: a + c * h,
    canvasHeight: ZH(a + (c + 1) * h)
  };
}
function Hw(s, t, e, i) {
  var o;
  let n = 0;
  for (let r = t; r < e; r++) {
    const a = s[r];
    n += ((o = i[a]) == null ? void 0 : o.layoutWidth) || 0;
  }
  return n;
}
function Pw(s, t, e, i, n, o) {
  let r = t, a = 0;
  for (let g = t; g < e; g++) {
    const c = Hw(s, g, g + 1, n);
    a + c > i && (r < g && o.push(g), r = g, a = 0), a += c;
  }
  return a;
}
function QH(s, t, e, i, n, o) {
  let r = t, a = t, g = t, c = 0;
  for (let l = t; l < e; l++)
    if ((s[l] === " " || s[l + 1] === " " || l + 1 === e) && (g = l + 1), g > a) {
      let h = Hw(s, a, g, n);
      c + h > i && (r < a && (o.push(a), r = a, c = 0), h > i && (h = Pw(
        s,
        a,
        g,
        i,
        n,
        o
      ), r = o[o.length - 1])), a = g, c += h;
    }
  return c;
}
function YH(s, t, e, i, n = 0, o) {
  o === void 0 && (o = s.length);
  const r = [];
  return t === "break-all" ? Pw(s, n, o, e, i, r) : QH(s, n, o, e, i, r), r;
}
function jH(s, t, e, i, n, o, r) {
  let a = 0, g = 0;
  for (let c = t; c < e; c++) {
    const l = s[c], h = i[l];
    h ? (g || (g = h.layoutHeight), n[c] = a + h.layoutWidth / 2, a += h.layoutWidth + r) : (n[c] = a, a += XH);
  }
  o[0] = a - r, o[1] = g;
}
function Nw(s, t, e, i, n, o, r = 0) {
  var I, M;
  let a;
  Array.isArray(t) ? a = t : a = Array.from(t);
  const g = a.length, c = new Array(g), l = new Array(g), h = new Array(g), d = (i === "break-word" || i === "break-all") && isFinite(n) && n > 0, C = [0, 0], p = [0, 0], m = [];
  let b = 0, S = 0, A = 0, u = 0, y = 1;
  for (let G = 0; G <= g; G++) {
    const x = s[G];
    if ((x === "\\" || G === g) && (u = G), u > A) {
      const L = d ? YH(a, i, n, o, A, u) : WH;
      for (let E = 0; E <= L.length; E++) {
        const T = E === 0 ? A : L[E - 1], R = E < L.length ? L[E] : u;
        jH(a, T, R, o, c, p, r);
        for (let w = T; w < R; w++) {
          const v = a[w], D = ((I = o[v]) == null ? void 0 : I.layoutOffsetY) || 0, K = ((M = o[v]) == null ? void 0 : M.textHeight) || 0;
          l[w] = S - D, h[w] = p[0], m.push(K), b += K;
        }
        S = S + p[1] * e, C[0] = Math.max(C[0], p[0]);
      }
      A = u;
    }
    x === "\\" && (c[A] = 0, l[A] = 0, h[A] = 0, A++, y++);
  }
  return C[1] = S, { x: c, y: l, rowWidth: h, size: C, rowNum: y, heightSize: b, textHeights: m };
}
const Jp = {};
function JH(s, t, e, i) {
  const n = i + "," + e + "," + t;
  let o = Jp[n];
  if (!o) {
    const r = t.split(" ");
    if (r.length > 1) {
      const g = s.measureText("M").width * i;
      let c = "";
      const l = [];
      for (let h = 0, d = r.length; h < d; ++h) {
        const C = r[h], p = c + (c ? " " : "") + C;
        s.measureText(p).width <= g ? c = p : (c && l.push(c), c = C);
      }
      c && l.push(c);
      for (let h = 0, d = l.length; h < d && d > 1; ++h) {
        const C = l[h];
        if (s.measureText(C).width < g * 0.35) {
          const m = s.measureText(l[h - 1]).width, b = s.measureText(l[h + 1]).width, S = h > 0 ? m : 1 / 0, A = h < d - 1 ? b : 1 / 0;
          l.splice(h, 1), d -= 1, S < A ? (l[h - 1] += " " + C, h -= 1) : l[h] = C + " " + l[h];
        }
      }
      for (let h = 0, d = l.length - 1; h < d; ++h) {
        const C = l[h], p = l[h + 1];
        if (s.measureText(C) > g * 0.7 && s.measureText(p) < g * 0.6) {
          const m = C.split(" "), b = m.pop();
          s.measureText(b) < g * 0.2 && (l[h] = m.join(" "), l[h + 1] = b + " " + p), d -= 1;
        }
      }
      o = l.join("\\");
    } else
      o = t;
    Jp[n] = o;
  }
  return o;
}
class wa {
  constructor(t) {
    f(this, "triggerRemoveEvent", (t, e) => {
      try {
        this.onRemove(e, t);
      } catch (i) {
        console.warn("error occurs when disposing tile", i);
      }
    });
    this.cache = {}, this.head = this.tail = null, this.length = 0, this.max = t.max || 1e3, this.maxAge = t.maxAge || 0, this.onRemove = t.onRemove || (() => {
    });
  }
  clear() {
    for (const t of Object.keys(this.cache)) {
      const e = this.cache[t];
      this.triggerRemoveEvent(t, e.value);
    }
    this.cache = {}, this.head = this.tail = null, this.length = 0;
  }
  remove(t) {
    if (!this.cache.hasOwnProperty(t))
      return;
    const e = this.cache[t];
    return delete this.cache[t], this._unlink(t, e.prev, e.next), e.value;
  }
  _unlink(t, e, i) {
    this.length--, this.length === 0 ? this.head = this.tail = null : this.head === t ? (this.head = e, this.cache[this.head].next = null) : this.tail === t ? (this.tail = i, this.cache[this.tail].prev = null) : (this.cache[e].next = i, this.cache[i].prev = e);
  }
  peek(t) {
    if (!this.cache.hasOwnProperty(t))
      return;
    const e = this.cache[t];
    if (!!this._checkAge(t, e))
      return e.value;
  }
  set(t, e) {
    let i = null;
    if (this.cache.hasOwnProperty(t)) {
      if (i = this.cache[t], i.value = e, this.maxAge && (i.modified = Date.now()), t === this.head)
        return e;
      this._unlink(t, i.prev, i.next);
    } else
      i = {
        value: e,
        modified: 0,
        next: null,
        prev: null
      }, this.maxAge && (i.modified = Date.now()), this.cache[t] = i, this.length === this.max && this.evict();
    return this.length++, i.next = null, i.prev = this.head, this.head && (this.cache[this.head].next = t), this.head = t, this.tail || (this.tail = t), e;
  }
  _checkAge(t, e) {
    return this.maxAge && Date.now() - e.modified > this.maxAge ? (this.remove(t), this.triggerRemoveEvent(e.value, t), !1) : !0;
  }
  has(t) {
    return this.cache.hasOwnProperty(t) && this._checkAge(t, this.cache[t]);
  }
  get(t) {
    if (!this.cache.hasOwnProperty(t))
      return;
    const e = this.cache[t];
    if (!!this._checkAge(t, e))
      return this.head !== t && (t === this.tail ? (this.tail = e.next, this.cache[this.tail].prev = null) : this.cache[e.prev].next = e.next, this.cache[e.next].prev = e.prev, this.cache[this.head].next = t, e.prev = this.head, e.next = null, this.head = t), e.value;
  }
  evict() {
    if (!this.tail)
      return;
    const t = this.tail, e = this.remove(this.tail);
    this.triggerRemoveEvent(t, e);
  }
}
const mc = 4096, Jd = 4096, qd = 2, yc = {
  fontSize: 24 * qd,
  buffer: 3 * qd,
  radius: 8 * qd
};
function qp(s) {
  let t;
  return typeof s == "string" ? t = new Set(Array.from(s)) : t = new Set(s), t;
}
function qH(s, t, e, i) {
  s.font = `${e}px ${t}`, s.fillStyle = "#000", s.textAlign = "start", s.textBaseline = "top";
}
const $H = 2e3, $d = new wa({
  max: $H
});
class Fw {
  constructor() {
    f(this, "props", {});
    f(this, "_entry", {});
    f(this, "_textureData", new Uint8Array(mc * Jd));
    f(this, "_xOffset", 0);
    f(this, "_yOffset", 0);
    f(this, "_mapping", {});
    f(this, "_canvasHeight", 0);
    f(this, "_oldMapping", {});
    f(this, "_atlas");
    f(this, "_ctx");
  }
  get atlas() {
    return this._atlas;
  }
  get mapping() {
    return this._atlas && this._atlas.mapping;
  }
  setProps(t = {}) {
    Object.assign(this.props, t);
    const e = qp(this.props.characterSet);
    this._generateFontAtlas(e);
    const i = this._createTextureData(e);
    this._atlas = i;
  }
  async setPropsAsync(t, e = {}, i = 30) {
    Object.assign(this.props, e);
    const n = qp(this.props.characterSet), o = Array.from(n);
    this._prepareFontAtlas();
    let r = 0;
    const a = o.length;
    return new Promise((g) => {
      const c = () => {
        const l = Math.min(r + i, a), h = o.slice(r, l);
        this._generateFontAtlas(h), this._processCharBatch(h) ? r = 0 : r = l, r < a ? t.addTask(() => Promise.resolve(c())) : (this._finalizeTextureData(), g());
      };
      t.addTask(() => Promise.resolve(c()));
    });
  }
  _prepareFontAtlas() {
    const t = document.createElement("canvas");
    t.width = mc, this._ctx = t.getContext("2d", { willReadFrequently: !0 }), qH(this._ctx, this.props.fontFamily, yc.fontSize);
  }
  _generateFontAtlas(t) {
    var a;
    const { fontSize: e, buffer: i, radius: n } = yc, { fontFamily: o, sdf: r } = this.props;
    if (!!r)
      for (const g of t) {
        let c, l;
        typeof g == "string" ? (c = this.props.fontWeight, l = g) : (c = W(g.fontWeight || ((a = g.textStyle) == null ? void 0 : a.fontWeight), this.props.fontWeight), l = g.char);
        const h = l + c;
        if ($d.get(h))
          continue;
        let d = this._entry[c];
        d || (d = new zH({ fontSize: e, buffer: i, radius: n, fontFamily: o, fontWeight: `${c}` }), d.ctx.textBaseline = "top", this._entry[c] = d);
        const C = d.draw(l);
        $d.set(h, C);
      }
  }
  _processCharBatch(t) {
    const { fontWeight: e } = this.props, { buffer: i } = yc, { mapping: n, canvasHeight: o, xOffset: r, yOffset: a } = OH({
      characterSet: t,
      context: this._ctx,
      fontHeight: yc.fontSize,
      buffer: i,
      maxCanvasWidth: mc,
      mapping: this._mapping,
      xOffset: this._xOffset,
      yOffset: this._yOffset,
      defaultFontWeight: e
    });
    if (o > Jd)
      return this._mapping = {}, this._xOffset = 0, this._yOffset = 0, this._textureData.fill(0), this._oldMapping = {}, console.warn("too many characterSet"), !0;
    const g = this._ctx.canvas.width, c = this._textureData;
    for (const l of t) {
      const h = typeof l == "string" ? l : l.char, d = typeof l == "string" ? e : W(l.fontWeight, e), C = h + d;
      if (this._oldMapping[C])
        continue;
      const { data: p, width: m, height: b, glyphTop: S } = $d.get(C), A = n[C];
      A.layoutOffsetY = S;
      const u = Math.floor(A.y * g + A.x);
      for (let y = 0; y < b; y++) {
        const I = u + y * g, M = y * m;
        for (let G = 0; G < m; G++)
          c[I + G] = p[M + G];
      }
    }
    Object.assign(this._oldMapping, n), this._xOffset = r, this._yOffset = a;
  }
  _finalizeTextureData() {
    this._atlas = {
      textureData: this._textureData,
      xOffset: this._xOffset,
      yOffset: this._yOffset,
      mapping: this._oldMapping,
      width: mc,
      height: Jd
    };
  }
  _createTextureData(t) {
    return this._prepareFontAtlas(), this._processCharBatch(Array.from(t)), this._finalizeTextureData(), this._atlas;
  }
}
class kw {
  constructor() {
    f(this, "_fadeDuration", 300);
    f(this, "_idField", "id");
    f(this, "_lastData", []);
    f(this, "_filterData", []);
    f(this, "_lastDataMap", {});
    f(this, "_fadeSinceField", "fadeSince");
    f(this, "_fadeOpacityField", "fadeOpacity");
    f(this, "_stableTime", 0);
    f(this, "_debugTrackLogId", null);
  }
  processId(t) {
    return t;
  }
  _dataToMap(t) {
    if (!Array.isArray(t))
      return {};
    const e = {};
    for (const i of t) {
      const n = this.processId(i[this._idField]);
      n !== void 0 && (e[n] = i);
    }
    return e;
  }
  isStable(t) {
    return t >= this._stableTime;
  }
  update(t, e, i = !1) {
    Array.isArray(t) || (console.warn("data should be an array"), t = []);
    let n = e;
    const o = this._dataToMap(t), r = i && this._dataToMap(this.filterData), a = this._lastDataMap, g = this._lastData, c = this._fadeDuration, l = [];
    for (const h of t) {
      const d = this.processId(h[this._idField]), C = d && a[d];
      if (this._debugTrackLogId, C) {
        const p = C[this._fadeOpacityField] || 0, m = C[this._fadeSinceField];
        if (this._debugTrackLogId, p > 2) {
          this._debugTrackLogId;
          const b = e - m;
          h[this._fadeOpacityField] = 1e-3, h[this._fadeSinceField] = e - (c - b), l.push(h), n = Math.max(n, e + c);
        } else
          this._debugTrackLogId, h[this._fadeOpacityField] = C[this._fadeOpacityField], h[this._fadeSinceField] = C[this._fadeSinceField], l.push(h), n = Math.max(n, m + c);
      } else
        this._debugTrackLogId, h[this._fadeSinceField] = e, h[this._fadeOpacityField] = 1e-3, d === void 0 && (h[this._fadeOpacityField] = 1), l.push(h), n = Math.max(n, e + c);
    }
    for (const h of g) {
      const d = this.processId(h[this._idField]);
      if (d !== void 0 && (this._debugTrackLogId, !(i && !r[d]) && !o[d])) {
        const C = h[this._fadeOpacityField] || 0, p = h[this._fadeSinceField], m = e - p;
        if (C <= 1)
          this._debugTrackLogId, h[this._fadeOpacityField] = 3, m < c ? h[this._fadeSinceField] = e - (c - m) : h[this._fadeSinceField] = e, l.push(h), o[d] = h, n = Math.max(n, e + c);
        else {
          this._debugTrackLogId;
          let b = C - m / c - 2;
          b = ce.clamp(b, 0, 1), b > 0 && (l.push(h), o[d] = h, n = Math.max(n, p + c));
        }
      }
    }
    this._stableTime = n, this._lastData = l, this._lastDataMap = o;
  }
  get filterData() {
    return this._filterData;
  }
  set filterData(t) {
    this._filterData = t;
  }
  get data() {
    return this._lastData;
  }
  get fadeDuration() {
    return this._fadeDuration;
  }
  set fadeDuration(t) {
    this._fadeDuration = t;
  }
}
function Vw(s) {
  let t = 0, e = 0;
  for (const a of s)
    t += a.w * a.h, e = Math.max(e, a.w);
  s.sort((a, g) => g.h - a.h);
  const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), e), h: 1 / 0 }];
  let o = 0, r = 0;
  for (const a of s)
    for (let g = n.length - 1; g >= 0; g--) {
      const c = n[g];
      if (!(a.w > c.w || a.h > c.h)) {
        if (a.x = c.x, a.y = c.y, r = Math.max(r, a.y + a.h), o = Math.max(o, a.x + a.w), a.w === c.w && a.h === c.h) {
          const l = n.pop();
          g < n.length && (n[g] = l);
        } else
          a.h === c.h ? (c.x += a.w, c.w -= a.w) : a.w === c.w ? (c.y += a.h, c.h -= a.h) : (n.push({
            x: c.x + a.w,
            y: c.y,
            w: c.w - a.w,
            h: a.h
          }), c.y += a.h, c.h -= a.h);
        break;
      }
    }
  return {
    w: o,
    h: r,
    fill: t / (o * r) || 0
  };
}
const zw = (s, t, e, i, n, o = 1, r = 1) => (s.font = `${r}px Microsoft Yahei`, s.textBaseline = "top", s.measureText(e).width + t[1] + t[3] >= i || r * o + 1 * (o - 1) + t[0] + t[2] >= n ? r - 1 : zw(s, t, e, i, n, o, r + 1)), TC = (s, t, e, i = {}) => {
  let n = !1;
  const o = Vw(s);
  let { fillStyle: r, fontSize: a, gap: g, padding: c, dpr: l, drawText: h = !0, textAlign: d } = i;
  const C = o.w, p = o.h;
  (e.width !== C || e.height !== p) && (n = !0), e.width = C || 1, e.height = p || 1, t.save(), d && (t.textAlign = d);
  for (let m = 0; m < s.length; m++) {
    const b = s[m], S = b.icon, A = b.text;
    if (t.drawImage(S, b.x + g[0] / 2, b.y + g[1] / 2, b.width, b.height), H(A) && h) {
      const u = `${String(A)}`.split("\\");
      u.forEach((y, I) => {
        a === "auto" && (a = zw(t, c, y, b.width, b.height, u.length)), t.font = `${a}px Microsoft Yahei`, t.fillStyle = r, t.textBaseline = "top", t.fillText(
          y,
          b.x + g[0] / 2 + (d === "center" ? b.width / 2 : c[3]),
          b.y + g[1] / 2 + c[0] + (Number(a) + 1) * I
        );
      });
    }
  }
  return t.restore(), n;
}, Xw = (s, t) => {
  if (typeof s == "object")
    t(s);
  else {
    let e = new Image();
    e.crossOrigin = "anonymous", e.onload = function() {
      let i = e.width, n = e.height, o = document.createElement("canvas");
      o.width = i, o.height = n, o.getContext("2d").drawImage(e, 0, 0, i, n), t(o);
    }, e.onerror = function() {
      let i = document.createElement("canvas");
      i.width = 20, i.height = 40;
      let n = i.getContext("2d");
      n.fillStyle = "red", n.beginPath(), n.lineTo(0, 0), n.lineTo(20, 0), n.lineTo(10, 40), n.closePath(), n.fill(), t(i);
    }, e.src = s;
  }
};
let $p;
const em = [
  "left",
  "right",
  "top",
  "bottom",
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
], Xa = new J(), eu = new B(), tm = new qe(), eP = {
  center: 0,
  left: 1,
  right: -1
}, tu = 2, tP = {
  fontSize: 24 * tu,
  buffer: 3 * tu,
  radius: 8 * tu
}, Zi = {
  ICON: "icon",
  TEXT: "text",
  ICONTEXT: "icontext"
}, iP = [0, 1, 0, 0, 1, 0, 1, 1], iu = [0, 0], nP = new J();
class Ii extends Fo {
  constructor(e = {}) {
    super(e);
    f(this, "parameters");
    f(this, "spriteTexture");
    f(this, "textTexture");
    f(this, "_maxChar", 3e4);
    f(this, "_version", 0);
    f(this, "oldMapTextureRes", /* @__PURE__ */ new Map());
    f(this, "iconUrlHash", new wa({
      max: 100,
      onRemove: (e, i) => {
        this.boxHash.delete(i);
      }
    }));
    f(this, "boxHash", /* @__PURE__ */ new Map());
    f(this, "gap", [4, 4]);
    f(this, "geometry");
    f(this, "material");
    f(this, "canvas");
    f(this, "ctx");
    f(this, "cachedTextData", []);
    f(this, "_collisionBoxCache", new wa({
      max: 1e3
    }));
    f(this, "isRenderInPostprocess", !1);
    f(this, "_bufferDataOffset", {
      positionsOffset: 0,
      typesAndPIndicesOffset: 0,
      rotateZsOffset: 0,
      offsetsOffset: 0,
      stylesOffset: 0,
      uvsOffset: 0,
      whsOffset: 0,
      fadeOpacityAndSinceOffset: 0,
      instanceRotationMatricesOffset: 0
    });
    f(this, "_bufferData", {
      positions: new Float32Array(this._maxChar * 3),
      typesAndPIndices: new Float32Array(this._maxChar * 2),
      rotateZs: new Float32Array(this._maxChar),
      uvs: new Float32Array(this._maxChar * 2),
      offsets: new Float32Array(this._maxChar * 2),
      instanceRotationMatrices: new Float32Array(this._maxChar * 9),
      whs: new Float32Array(this._maxChar * 4),
      styles: new Float32Array(this._maxChar * 8),
      fadeOpacityAndSince: new Float32Array(this._maxChar * 2),
      indices: []
    });
    this.parameters = e, this.spriteTexture = e.spriteTexture, this.vertexIcons = e.vertexIcons, this.flat = W(e.flat, !1), this.symbolType = W(e.type, Zi.ICON), this._enableFade = W(e.enableFade, !1), this._enableFadeFilter = W(e.enableFadeFilter, !0), this._textSize = W(e.textSize, 16), this._textFamily = W(e.textFamily, "sans-serif"), e.textFillStyle ? this._textFillStyle = Array.isArray(e.textFillStyle) ? e.textFillStyle : sr(e.textFillStyle) : this._textFillStyle = [255, 255, 255], e.textStrokeStyle ? this._textStrokeStyle = Array.isArray(e.textStrokeStyle) ? e.textStrokeStyle : sr(e.textStrokeStyle) : this._textStrokeStyle = [0, 0, 0], this._textStrokeWidth = W(e.textStrokeWidth, 0), this._textAnchor = W(e.textAnchor, "center"), this._textOffset = W(e.textOffset, [0, 0]), this._textWeight = W(e.textWeight, "400"), this._rotateZ = W(e.rotateZ, 0), this._textPadding = W(e.textPadding, [0, 0]), this.textAlign = W(this.parameters.textAlign, "center"), this.isRenderInPostprocess = this.parameters.isRenderInPostprocess || !1, this.symbolType === Zi.TEXT ? (this._iconWidth = 0, this._iconHeight = 0) : (this._iconWidth = W(this.parameters.iconWidth, 40), this._iconHeight = W(this.parameters.iconHeight, 40)), this._offset = W(this.parameters.offset, [0, 0]), this._fadeData = new kw(), this._fadeData.processId = (r) => r && r.split("_")[0];
    const i = new Fw();
    this.fontAtalasManager = i;
    const n = this.canvas = document.createElement("canvas");
    n.width = n.height = 1;
    const o = this.ctx = n.getContext("2d");
    o.textAlign = "start", o.textBaseline = "top", this.vertexIcons && (this.iconCanvas = document.createElement("canvas"), this.iconCanvas.width = this.iconCanvas.height = 1, this.iconCtx = this.iconCanvas.getContext("2d"), this.spriteTexture = new ls(this.iconCanvas), this.spriteTexture.colorSpace = gt), this.defineMaterialProxyProperties([
      "mapSrc",
      "transparent",
      "depthTest",
      "depthWrite",
      "opacity",
      "flat",
      "keepSize",
      "vertexColors",
      "positionOffset",
      "pixelOffset"
    ]), this.boxes = [];
  }
  initObject() {
    const e = this.symbolType === Zi.TEXT || this.symbolType === Zi.ICONTEXT, i = this.symbolType === Zi.ICON || this.symbolType === Zi.ICONTEXT, { fontFamily: n, fillStyle: o, strokeStyle: r, ...a } = this.parameters;
    this.geometry = new HH(this.parameters), this.material = new VH({
      useText: e,
      useIcon: i,
      ...a
    });
    const g = this.engine.map.isGlobe;
    this.material.isGlobe = g, this.material.enableFade = this._enableFade, this.material.setCommonUniforms(this.engine.rendering.uniforms), this.material.spriteTexture = this.spriteTexture;
  }
  collisionTest(e) {
    const i = e.boundingBox, n = this.symbolType === Zi.TEXT && this.flat;
    return i && !n ? i : this.computeBoundingBox(e);
  }
  computeBoundingBox(e) {
    const i = this.symbolType, n = e.iconSize || [], o = W(n[0], this._iconWidth), r = W(n[1], this._iconHeight), a = e.tolerance || 0;
    if (i === Zi.ICON)
      return {
        width: o,
        height: r,
        tolerance: a
      };
    const g = W(e.textAnchor, this._textAnchor), c = g ? em.indexOf(g) + 1 : 0;
    if (i === Zi.TEXT) {
      const l = this._getTextBox(e, this.flat), h = l.width, d = l.height;
      e.textBox = l;
      const { offsetX: C, offsetY: p } = this._getTextOrIconOffset(c, h, d);
      return {
        ...l,
        width: h,
        height: d,
        offsetX: C,
        offsetY: p,
        textBox: l,
        tolerance: a
      };
    }
    if (i === Zi.ICONTEXT) {
      const l = this._getTextBox(e);
      e.textBox = l;
      const { offsetX: h, offsetY: d, width: C, height: p } = this._getTextIconOffset(l, c, o, r);
      return {
        width: C,
        height: p,
        offsetX: h,
        offsetY: d,
        textBox: l,
        tolerance: a
      };
    }
  }
  _getTextIconOffset(e, i, n, o) {
    const r = this._textPadding, a = e.width, g = e.height;
    let c = 0, l = 0, h = 0, d = 0;
    switch (i) {
      case 0:
        c = Math.max(a, n), l = Math.max(g, o);
        break;
      case 1:
        c = a + n + r[0], l = Math.max(g, n), h = (a + r[0]) / 2;
        break;
      case 2:
        c = a + n + r[0], l = Math.max(g, n), h = -(a + r[0]) / 2;
        break;
      case 3:
        c = Math.max(a, n), l = g + o + r[1], d = (g + r[1]) / 2;
        break;
      case 4:
        c = Math.max(a, n), l = g + o + r[1], d = -(g + r[1]) / 2;
        break;
      case 5:
        c = a + n + r[0], l = g + o + r[1], h = (a + r[0]) / 2, d = (g + r[1]) / 2;
        break;
      case 6:
        c = a + n + r[0], l = g + o + r[1], h = -(a + r[0]) / 2, d = (g + r[1]) / 2;
        break;
      case 7:
        c = a + n + r[0], l = g + o + r[1], h = (a + r[0]) / 2, d = -(g + r[1]) / 2;
        break;
      case 8:
        c = a + n + r[0], l = g + o + r[1], h = -(a + r[0]) / 2, d = -(g + r[1]) / 2;
        break;
    }
    return {
      width: c,
      height: l,
      offsetX: h,
      offsetY: d
    };
  }
  _getTextOrIconOffset(e, i, n) {
    let o = 0, r = 0;
    switch (e) {
      case 0:
        break;
      case 1:
        o = i / 2;
        break;
      case 2:
        o = -i / 2;
        break;
      case 3:
        r = n / 2;
        break;
      case 4:
        r = -n / 2;
        break;
      case 5:
        o = i / 2, r = n / 2;
        break;
      case 6:
        o = -i / 2, r = n / 2;
        break;
      case 7:
        o = i / 2, r = -n / 2;
        break;
      case 8:
        o = -i / 2, r = -n / 2;
        break;
    }
    return {
      offsetX: o,
      offsetY: r
    };
  }
  _updateData() {
    this._version++, this._clearBufferDataOffset();
    let e = this.dataSource.userData;
    this._enableCollision && this._collisionData && (e = this._collisionData), this._enableFade && (this._fadeData.filterData = this.dataSource.userData, this._fadeData.update(
      e,
      this.engine.rendering.uniforms.elapsedTime.value,
      this._enableFadeFilter
    ), e = this._fadeData.data), $p = null, this.packBuffer(e), this.needsUpdate = !1;
  }
  packBuffer(e) {
    if (!e)
      return;
    const i = this._version, n = this.symbolType, o = this.engine.map.isGlobe;
    e = e.filter((g) => {
      if (g.checkVisible && o) {
        const c = g.position;
        return eu.fromArray(c), this.engine.map.map.occluder.isPointVisible(eu);
      }
      return !0;
    });
    let r = 0;
    const a = this.engine.rendering.taskScheduler;
    n === Zi.ICON ? this.updateIconHash(e).then(() => {
      this._version === i && a.addTask(() => new Promise((g) => {
        this._version === i && (this.updateIconSprite(), r = this.packIconBuffer(e, r), this._commitBuffer(), g());
      }));
    }) : n === Zi.TEXT ? this.updateTextSprite(e).then(() => {
      this._version === i && a.addTask(() => new Promise((g) => {
        this._version === i && (this.packTextBuffer(e, r), this._commitBuffer(), g());
      }));
    }) : n === Zi.ICONTEXT && this.updateTextSprite(e).then(() => {
      this._version === i && this.updateIconHash(e).then(() => {
        this._version === i && a.addTask(() => new Promise((g) => {
          this._version === i && (this.updateIconSprite(), r = this.packIconAndTextBuffer(e, r), this._commitBuffer(), g());
        }));
      });
    });
  }
  _commitBuffer() {
    this._bufferData.drawRange = this._bufferDataOffset.positionsOffset, this.geometry.setData(this._bufferData), this._enableFade && (this.material.fadeDuration = this._fadeData.fadeDuration), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, this._bufferData.positions), this.engine.requestRender();
  }
  updateIconDataItem(e, i) {
    const n = this.vertexIcons, o = this.iconCanvas, r = this._textPadding;
    if (n) {
      const a = e.position, g = e.iconSize, c = e.offset || iu, l = e.textDrawOnIcon, h = e.icon, d = e.rotateZ, C = this.boxHash.get(h);
      if (!C)
        return;
      if (this.packPosition(a), this.packRotationMatrix(a), this.packRotateZ(d), l) {
        let y;
        e.boundingBox && e.boundingBox.textBox ? y = e.boundingBox.textBox : y = e.textBox || this._getTextBox(e);
        const I = Math.ceil(y.width), M = Math.ceil(y.height), G = 5 - r[0], x = I + G * 2, L = Math.max(M, g[1]) + r[1] * 2;
        this.packWH(Math.round(x), Math.round(L / 2), 0, 0);
      } else
        this.packWH(g[0], g[1], 0, 0);
      this.packOffset(c[0], c[1]), this.packTypeAndPIndex(0), this.packIconStyle(), this.packFade(e);
      const p = C.x / o.width, m = (C.x + C.w) / o.width, b = (C.y + C.h) / o.height, S = C.y / o.height, A = this._bufferDataOffset.uvsOffset;
      this._bufferData.uvs[A] = p, this._bufferData.uvs[A + 1] = b, this._bufferData.uvs[A + 2] = p, this._bufferData.uvs[A + 3] = S, this._bufferData.uvs[A + 4] = m, this._bufferData.uvs[A + 5] = S, this._bufferData.uvs[A + 6] = m, this._bufferData.uvs[A + 7] = b, this._bufferDataOffset.uvsOffset += 8;
      const u = i * 4;
      this._bufferData.indices.push(
        u,
        u + 2,
        u + 1,
        u,
        u + 3,
        u + 2
      );
    } else {
      const a = e.position, g = e.offset || iu;
      let c = e.iconUvs;
      const l = e.rotateZ, h = e.iconOpacity, d = e.iconSize || [], C = W(d[0], this._iconWidth), p = W(d[1], this._iconHeight);
      this.packPosition(a), this.packRotationMatrix(a), this.packRotateZ(l), this.packWH(C, p, 0, 0), this.packOffset(g[0], g[1]), c || (c = iP), this.packIconUV(c), this.packIconStyle(h), this.packTypeAndPIndex(0), this.packFade(e);
      const m = i * 4;
      this._bufferData.indices.push(
        m,
        m + 2,
        m + 1,
        m,
        m + 3,
        m + 2
      );
    }
    return i++, i;
  }
  packIconAndTextBuffer(e, i = 0) {
    const [n, o] = this.material.resolution || [];
    if (isNaN(n) || n <= 0 || isNaN(o) || o <= 0) {
      console.warn("resolution is invalid");
      return;
    }
    for (let r = 0; r < e.length; r++)
      i = this.updateIconDataItem(e[r], i), i = this.updateTextDataItem(e[r], i);
    return i;
  }
  packIconBuffer(e, i = 0) {
    const [n, o] = this.material.resolution || [];
    if (isNaN(n) || n <= 0 || isNaN(o) || o <= 0) {
      console.warn("resolution is invalid");
      return;
    }
    for (let r = 0; r < e.length; r++)
      i = this.updateIconDataItem(e[r], i);
    return i;
  }
  async updateIconHash(e) {
    if (this.vertexIcons) {
      const i = this.getTextureAndHash(e, "icon", 0, 0, !0);
      Array.isArray(i) && await Promise.all(i);
    }
  }
  async updateTextSprite(e) {
    const i = e;
    let n = /* @__PURE__ */ new Map(), o = !1, r = {};
    this.fontAtalasManager && this.fontAtalasManager.mapping && (r = this.fontAtalasManager.mapping);
    for (let a = 0; a < i.length; a++) {
      const g = i[a], c = String(g.text), l = W(g.textWeight, this._textWeight), h = Array.from(c);
      for (let d = 0, C = h.length; d < C; d++) {
        const p = h[d], m = p + l;
        n.set(m, {
          char: p,
          fontWeight: l
        }), r[m] || (o = !0);
      }
    }
    o && await this.updateTextTexture(n.values());
  }
  getTextureAndHash(e, i, n, o, r) {
    const a = this.iconUrlHash;
    if (!r && this.oldMapTextureRes)
      return this.oldMapTextureRes;
    const g = e.map((l) => l.icon).filter((l) => !H(a.get(l)));
    return g.length === 0 ? this.oldMapTextureRes : (g.forEach((l) => a.set(l, a.size)), g.map((l) => new Promise((h) => {
      Xw(l, (d) => {
        a.set(l, d), h(l);
      });
    })));
  }
  updateIconSprite() {
    if (!this.iconCanvas)
      return this.oldMapTextureRes;
    const e = this.iconCtx, i = this.iconUrlHash, n = i.cache;
    for (let r in n)
      if (n.hasOwnProperty(r)) {
        const a = n[r].value;
        if (!H(a) || typeof a == "string" || typeof a == "number")
          continue;
        const g = this.boxes.findIndex((C) => C.key === r);
        if (g >= 0) {
          const [C] = this.boxes.splice(g, 1);
          this.boxes.unshift(C);
          continue;
        }
        const c = a.width, l = a.height, h = c + this.gap[0], d = l + this.gap[1];
        this.boxes.unshift({ w: h, h: d, width: c, height: l, key: r, icon: a });
      }
    let o = !1;
    return this.boxes.forEach((r) => {
      const a = r.key;
      this.boxHash.has(a) || (o = !0, this.boxHash.set(r.key, r));
    }), o && (TC(
      this.boxes,
      e,
      this.iconCanvas,
      {
        gap: this.gap,
        padding: [2, 2],
        dpr: this.engine.rendering.pixelRatio
      }
    ) && this.spriteTexture.dispose(), this.spriteTexture.needsUpdate = !0, this.material.spriteTexture = this.spriteTexture, this.material.isIconMap = !0), this.oldMapTextureRes = {
      texture: this.spriteTexture,
      iconUrlHash: i
    }, this.oldMapTextureRes;
  }
  async updateTextTexture(e) {
    this._fontSettings = {
      fontFamily: this._textFamily,
      fontWeight: "400",
      characterSet: e,
      sdf: !0,
      ...tP
    }, await this.fontAtalasManager.setPropsAsync(this.engine.rendering.taskScheduler, this._fontSettings);
    const {
      textureData: i,
      width: n,
      height: o
    } = this.fontAtalasManager.atlas;
    if (!this.textTexture) {
      const r = new Uint8Array(n * o);
      this.textTexture = new Ga(r, n, o), this.textTexture.minFilter = this.textTexture.magFilter = Gt, this.textTexture.format = Ps, this.material.textTexture = this.textTexture;
    }
    this.textTexture.image.data.set(i), this.textTexture.needsUpdate = !0;
  }
  packTextBuffer(e, i = 0) {
    const [n, o] = this.material.resolution || [];
    if (isNaN(n) || n <= 0 || isNaN(o) || o <= 0) {
      console.warn("resolution is invalid");
      return;
    }
    for (let r = 0; r < e.length; r++)
      i = this.updateTextDataItem(e[r], i);
    return i;
  }
  updateTextDataItem(e, i) {
    const o = "break-word", { mapping: r } = this.fontAtalasManager.atlas || {}, a = e.position;
    let g;
    e.boundingBox && e.boundingBox.textBox ? g = e.boundingBox.textBox : g = e.textBox || this._getTextBox(e);
    const c = g.wrappedText, l = g.widthList, h = Math.max(...l);
    e.textSize = W(e.textSize, this._textSize), e.textWeight = W(e.textWeight, this._textWeight), e.textFillStyle ? e.textFillStyle = Array.isArray(e.textFillStyle) ? e.textFillStyle : sr(e.textFillStyle) : e.textFillStyle = this._textFillStyle, e.textStrokeStyle ? e.textStrokeStyle = Array.isArray(e.textStrokeStyle) ? e.textStrokeStyle : sr(e.textStrokeStyle) : e.textStrokeStyle = this._textStrokeStyle, e.textStrokeWidth = W(e.textStrokeWidth, this._textStrokeWidth), e.textOffset = W(e.textOffset, this._textOffset), e.textDrawOnIcon = W(e.textDrawOnIcon, !1), e.icon = e.icon, e.iconSize = e.iconSize, e.rotateZ = W(e.rotateZ, this._rotateZ);
    const d = e.textWeight, C = e.textSize, p = e.rotateZ, m = Array.from(c).map((y) => y + d), b = Nw(c, m, 1, o, h * C, r), S = b.x.length, A = Array.from(c);
    let u = 0;
    for (let y = 0; y < S; y++) {
      const I = A[y];
      if (I === "\\")
        continue;
      const M = r[I + d];
      if (!M)
        return;
      this.packPosition(a), this.packTextOffset(e, b, y), this.packTextUV(M), this.packTextWh(e, M), this.packTextStyle(e), this.packTypeAndPIndex(1), this.packRotateZ(p), this.packRotationMatrix(a), this.packFade(e);
      const G = (i + u) * 4;
      this._bufferData.indices.push(
        G,
        G + 2,
        G + 1,
        G,
        G + 3,
        G + 2
      ), u++;
    }
    return i += u, i;
  }
  packRotateZ(e) {
    e = e || 0;
    const i = this._bufferDataOffset.rotateZsOffset;
    this._bufferData.rotateZs[i] = e, this._bufferData.rotateZs[i + 1] = e, this._bufferData.rotateZs[i + 2] = e, this._bufferData.rotateZs[i + 3] = e, this._bufferDataOffset.rotateZsOffset += 4;
  }
  packRotationMatrix(e) {
    if (this.engine.map.isGlobe) {
      this._calculateTransform(e, Xa), tm.setFromMatrix4(Xa);
      const n = tm.elements;
      for (let o = 0; o < 4; o++) {
        const r = this._bufferDataOffset.instanceRotationMatricesOffset;
        this._bufferData.instanceRotationMatrices[r] = n[0], this._bufferData.instanceRotationMatrices[r + 1] = n[1], this._bufferData.instanceRotationMatrices[r + 2] = n[2], this._bufferData.instanceRotationMatrices[r + 3] = n[3], this._bufferData.instanceRotationMatrices[r + 4] = n[4], this._bufferData.instanceRotationMatrices[r + 5] = n[5], this._bufferData.instanceRotationMatrices[r + 6] = n[6], this._bufferData.instanceRotationMatrices[r + 7] = n[7], this._bufferData.instanceRotationMatrices[r + 8] = n[8], this._bufferDataOffset.instanceRotationMatricesOffset += 9;
      }
    }
  }
  packPosition(e) {
    for (let i = 0; i < 4; i++)
      this._bufferData.positions.set(e, this._bufferDataOffset.positionsOffset), this._bufferDataOffset.positionsOffset += 3;
  }
  packFade(e) {
    if (this._enableFade) {
      const { fadeOpacity: i, fadeSince: n } = e;
      for (let o = 0; o < 4; o++) {
        const r = this._bufferDataOffset.fadeOpacityAndSinceOffset;
        this._bufferData.fadeOpacityAndSince[r] = i, this._bufferData.fadeOpacityAndSince[r + 1] = n, this._bufferDataOffset.fadeOpacityAndSinceOffset += 2;
      }
    }
  }
  packOffset(e, i) {
    for (let n = 0; n < 4; n++) {
      const o = this._bufferDataOffset.offsetsOffset;
      this._bufferData.offsets[o] = e, this._bufferData.offsets[o + 1] = i, this._bufferDataOffset.offsetsOffset += 2;
    }
  }
  packWH(e, i, n, o) {
    for (let r = 0; r < 4; r++) {
      const a = this._bufferDataOffset.whsOffset;
      this._bufferData.whs[a] = e, this._bufferData.whs[a + 1] = i, this._bufferData.whs[a + 2] = n, this._bufferData.whs[a + 3] = o, this._bufferDataOffset.whsOffset += 4;
    }
  }
  packTypeAndPIndex(e) {
    const i = this._bufferDataOffset.typesAndPIndicesOffset;
    this._bufferData.typesAndPIndices[i] = e, this._bufferData.typesAndPIndices[i + 1] = 0, this._bufferData.typesAndPIndices[i + 2] = e, this._bufferData.typesAndPIndices[i + 3] = 1, this._bufferData.typesAndPIndices[i + 4] = e, this._bufferData.typesAndPIndices[i + 5] = 2, this._bufferData.typesAndPIndices[i + 6] = e, this._bufferData.typesAndPIndices[i + 7] = 3, this._bufferDataOffset.typesAndPIndicesOffset += 8;
  }
  packIconStyle(e = 1) {
    const i = this._bufferDataOffset.stylesOffset;
    this._bufferData.styles[i + 3] = e, this._bufferData.styles[i + 11] = e, this._bufferData.styles[i + 19] = e, this._bufferData.styles[i + 27] = e, this._bufferDataOffset.stylesOffset += 8 * 4;
  }
  packIconUV(e) {
    this._bufferData.uvs.set(e, this._bufferDataOffset.uvsOffset), this._bufferDataOffset.uvsOffset += 8;
  }
  packTextStyle(e) {
    let {
      textStrokeStyle: i,
      textStrokeWidth: n,
      textFillStyle: o
    } = e;
    for (let r = 0; r < 4; r++) {
      const a = this._bufferDataOffset.stylesOffset;
      this._bufferData.styles[a] = o[0] / 255, this._bufferData.styles[a + 1] = o[1] / 255, this._bufferData.styles[a + 2] = o[2] / 255, this._bufferData.styles[a + 3] = 1, this._bufferData.styles[a + 4] = i[0] / 255, this._bufferData.styles[a + 5] = i[1] / 255, this._bufferData.styles[a + 6] = i[2] / 255, this._bufferData.styles[a + 7] = n, this._bufferDataOffset.stylesOffset += 8;
    }
  }
  packTextWh(e, i) {
    const {
      textSize: n
    } = e;
    let { width: o, height: r } = i;
    o += this._fontSettings.buffer * 2;
    const a = n * (r / this._fontSettings.fontSize);
    this.packWH(o, r, a, n);
  }
  packTextUV(e) {
    const {
      width: i,
      height: n
    } = this.fontAtalasManager.atlas || {};
    let { x: o, y: r, width: a, height: g } = e;
    a += this._fontSettings.buffer * 2;
    const c = o / i, l = r / n, h = c + a / i, d = l + g / n, C = this._bufferDataOffset.uvsOffset;
    this._bufferData.uvs[C] = c, this._bufferData.uvs[C + 1] = d, this._bufferData.uvs[C + 2] = c, this._bufferData.uvs[C + 3] = l, this._bufferData.uvs[C + 4] = h, this._bufferData.uvs[C + 5] = l, this._bufferData.uvs[C + 6] = h, this._bufferData.uvs[C + 7] = d, this._bufferDataOffset.uvsOffset += 8;
  }
  packTextOffset(e, i, n) {
    const {
      x: o,
      y: r,
      rowWidth: a,
      rowNum: g,
      size: [c, l]
    } = i, {
      textSize: h,
      textOffset: d,
      textAnchor: C = this._textAnchor,
      iconSize: p = []
    } = e, m = W(p[0], this._iconWidth), b = W(p[1], this._iconHeight), S = this._textPadding, u = (1 - eP[this.textAlign]) * (c - a[n]) / 2;
    let y = (0 - 1) * c / 2 + u + o[n] + d[0], I = l / g * (g - 1) / 2 - r[n] + d[1], M = 0, G = 0;
    switch (H(C) ? em.indexOf(C) + 1 : 0) {
      case 1:
        y += c / 2, M += m / 2 + S[0];
        break;
      case 2:
        y -= c / 2, M -= m / 2 + S[0];
        break;
      case 3:
        I -= l / 2, G -= b / 2 + S[1];
        break;
      case 4:
        I += l / 2, G += b / 2 + S[1];
        break;
      case 5:
        y += c / 2, M += m / 2 + S[0], I -= l / 2, G -= b / 2 + S[1];
        break;
      case 6:
        y -= c / 2, M -= m / 2 + S[0], I -= l / 2, G -= b / 2 + S[1];
        break;
      case 7:
        y += c / 2, M += m / 2 + S[0], I += c / 2, M += m / 2 + S[0];
        break;
      case 8:
        y -= c / 2, M -= m / 2 + S[0], I += c / 2, M += m / 2 + S[0];
        break;
    }
    const L = h / this._fontSettings.fontSize, E = e.offset || iu, T = y * L + M + E[0], R = I * L + G + E[1];
    this.packOffset(T, R);
  }
  _calculateRotation(e, i, n) {
    const o = new J();
    o.multiplyMatrices(e, i);
    const r = o.elements[0], a = o.elements[1], g = Math.sin(n), c = Math.cos(n);
    return g * -a + c * r;
  }
  _calculateTransform(e, i) {
    return this.engine.map.isGlobe ? (i || (i = new J()), Ze.eastNorthUpToFixedFrame(eu.fromArray(e), null, i), i) : nP;
  }
  _getTextBox(e, i) {
    const n = this.ctx, o = this.engine.rendering.pixelRatio, r = this._textSize, a = this._textFamily, g = this._textPadding;
    e.textSize = W(e.textSize, this._textSize), e.textWeight = W(e.textWeight, this._textWeight), e.textFillStyle ? e.textFillStyle = Array.isArray(e.textFillStyle) ? e.textFillStyle : sr(e.textFillStyle) : e.textFillStyle = this._textFillStyle, e.textStrokeStyle ? e.textStrokeStyle = Array.isArray(e.textStrokeStyle) ? e.textStrokeStyle : sr(e.textStrokeStyle) : e.textStrokeStyle = this._textStrokeStyle, e.textStrokeWidth = W(e.textStrokeWidth, this._textStrokeWidth);
    let { text: c, textWeight: l, textSize: h, textStrokeWidth: d, maxWidth: C } = e;
    n.save(), n.scale(o, o), n.textBaseline = "top";
    let p = r;
    if (this.getStrictStyleId(e) !== $p ? (l >= 10 && l % 10 === 0 ? n.font = l + " " + h + "px " + a : n.font = h + "px " + a, p = h, d > 0 && (n.lineWidth = d)) : n.font = r + "px " + a, H(C) && c && (c = JH(n, c, n.font, C)), i) {
      const G = e.rotateZ, x = this._processTextLayout(c, p), L = x.flat();
      this._calculateTransform(e.position, Xa);
      const E = Xa.extractRotation(Xa), T = this._applyRotateZ(L, G, E), R = this._calculateWidths(x), w = Math.max(...R) + 2 * g[0], v = p * R.length + 2 * g[1];
      return {
        width: w,
        height: v,
        wrappedText: c,
        widthList: R,
        chars: T,
        rotationMatrix: E
      };
    }
    c = String(c);
    let b = c.split("\\");
    const S = b.map((G) => n.measureText(G).width);
    let A = Math.max(...S), u = p * b.length;
    const y = A + 2 * g[0], I = u + 2 * g[1];
    return n.restore(), {
      width: y,
      height: I,
      wrappedText: c,
      widthList: S
    };
  }
  _calculateWidths(e) {
    return e.map((i) => i.reduce((n, o) => n + o.width, 0));
  }
  _processTextLayout(e, i) {
    const n = this.ctx, o = this._textPadding, r = String(e).split("\\"), g = -(i * r.length) / 2;
    return r.map((c, l) => {
      const h = [];
      let d = 0;
      for (let p = 0; p < c.length; p++) {
        const m = c[p], S = n.measureText(m).width;
        h.push({
          char: m,
          width: S,
          height: i,
          offsetX: 0,
          offsetY: -(g + i / 2 + l * i)
        }), d += S;
      }
      let C = -d / 2;
      for (let p = 0; p < h.length; p++) {
        const m = h[p];
        C += m.width / 2, m.offsetX = C, m.offsetY = m.offsetY, C += m.width / 2, m.width += 2 * o[0];
      }
      return h;
    });
  }
  _applyRotateZ(e, i, n) {
    const o = this.engine.camera.matrixWorld;
    return this._calculateRotation(o, n, i) < 0 && (i += Math.PI), e.map((a) => {
      const g = a.offsetX, c = a.offsetY;
      return {
        ...a,
        offsetX: g * Math.cos(i) - c * Math.sin(i),
        offsetY: g * Math.sin(i) + c * Math.cos(i)
      };
    });
  }
  onBeforeScenePrepareRenderHook(e, i, n) {
    const o = e.rendering.main.sceneRendering.depthTexture;
    this.material.uniforms.depthTexture.value = o, this.material.uniforms.cameraFar.value = e.rendering.camera.far;
  }
  onBeforeSceneRender(e, i, n, o) {
    super.onBeforeSceneRender(e, i, n, o), this._enableFade && !this._fadeData.isStable(o.elapsedTime) && e.requestRender();
  }
  _clearBufferDataOffset() {
    Object.keys(this._bufferDataOffset).forEach((e) => {
      this._bufferDataOffset[e] = 0;
    }), this._bufferData.indices.length = 0;
  }
  getStrictStyleId(e) {
    const {
      text: i,
      textSize: n,
      textWeight: o,
      textStrokeWidth: r,
      textFillStyle: a,
      textStrokeStyle: g
    } = e;
    return i + "_" + n + "_" + o + "_" + r + "_" + a.join("_") + "_" + g.join("_");
  }
  onDispose() {
    this.spriteTexture && this.spriteTexture.dispose(), this.textTexture && this.textTexture.dispose();
  }
  get enableFade() {
    return this._enableFade;
  }
  set enableFade(e) {
    this._enableFade = e, this.material.enableFade = e;
  }
}
function sP(s) {
  let t = s.reduce((e, i) => {
    let n = +i.split("-")[0];
    return Math.max(n, e);
  }, 0);
  return s = s.sort((e, i) => {
    const n = e.split("-"), o = i.split("-");
    let r = n[0], a = n[1], g = n[2], c = o[0], l = o[1], h = o[2];
    if (r !== t) {
      const d = t - r;
      a = a * Math.pow(2, d), g = g * Math.pow(2, d);
    }
    if (c !== t) {
      const d = t - c;
      l = l * Math.pow(2, d), h = h * Math.pow(2, d);
    }
    return a !== l ? l - a : h - g;
  }), s.reverse(), s;
}
const oP = () => new Date().getTime() + Math.random().toString(36).slice(2);
class rP {
  constructor(t) {
    f(this, "_blocks", {});
    f(this, "_collisionLabels", {
      icon_text: {},
      text_flat: {},
      text_fix: {},
      icon_flat: {},
      icon: {}
    });
    f(this, "_timers", {});
    f(this, "_enabled", !1);
    f(this, "_spriteTexture");
    this._rendering = t;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    t !== this._enabled && (this._enabled = t, t ? this.init() : this.dispose());
  }
  set spriteTexture(t) {
    this._spriteTexture || (this._spriteTexture = t);
  }
  init() {
    this.initCollisionLabel(), this.initLabel();
  }
  initCollisionLabel() {
    const t = this._iconDataSource = new Gi(), e = this._icon = this._rendering.add(new Ii({
      type: "icon",
      vertexIcons: !0,
      enableFade: !0,
      isRenderInPostprocess: !0
    }));
    t.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), e.dataSource = t;
    const i = this._iconUvDataSource = new Gi(), n = this._iconUv = this._rendering.add(new Ii({
      spriteTexture: this._spriteTexture,
      transparent: !0,
      enableFade: !0,
      isRenderInPostprocess: !0,
      type: "icon"
    }));
    i.defineAttributes({
      id: "id",
      iconUvs: "iconUvs",
      iconSize: "iconSize",
      iconOpacity: "iconOpacity",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), n.dataSource = i;
    const o = this._iconFlatUvDataSource = new Gi(), r = this._iconFlatUv = this._rendering.add(new Ii({
      spriteTexture: this._spriteTexture,
      transparent: !0,
      isRenderInPostprocess: !0,
      enableFade: !0,
      flat: !0,
      type: "icon"
    }));
    o.defineAttributes({
      id: "id",
      iconUvs: "iconUvs",
      iconSize: "iconSize",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ",
      boundingBox: "boundingBox",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), r.dataSource = o;
    const a = this._textFlatDataSource = new Gi(), g = this._textFlat = this._rendering.add(new Ii({
      type: "text",
      vertexRotateZs: !0,
      isRenderInPostprocess: !0,
      enableFade: !0,
      flat: !0
    }));
    a.defineAttributes({
      id: "id",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      rotateZ: "rotateZ",
      boundingBox: "boundingBox",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), g.dataSource = a;
    const c = this._textFixedDataSource = new Gi(), l = this._textFixed = this._rendering.add(new Ii({
      type: "text",
      isRenderInPostprocess: !0,
      enableFade: !0,
      flat: !1
    }));
    c.defineAttributes({
      id: "id",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), l.dataSource = c;
    const h = this._iconTextDataSource = new Gi(), d = this._iconText = this._rendering.add(new Ii({
      type: "icontext",
      vertexIcons: !0,
      enableFade: !0,
      isRenderInPostprocess: !0
    }));
    h.defineAttributes({
      id: "id",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      icon: "icon",
      iconSize: "iconSize",
      direction: "direction",
      rotateZ: "rotateZ",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), d.dataSource = h;
    const C = this._iconTextUvDataSource = new Gi(), p = this._iconTextUv = this._rendering.add(new Ii({
      type: "icontext",
      isRenderInPostprocess: !0,
      spriteTexture: this._spriteTexture,
      enableFade: !0,
      transparent: !0
    }));
    C.defineAttributes({
      id: "id",
      type: "type",
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textOffset: "textOffset",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      rotateZ: "rotateZ",
      iconUvs: "iconUvs",
      iconSize: "iconSize",
      iconOpacity: "iconOpacity",
      boundingBox: "boundingBox",
      offset: "offset",
      checkVisible: "checkVisible",
      tolerance: "tolerance"
    }), p.dataSource = C, this._rendering.collision.setGroupOption("poi", {
      enabledBucketCache: !0,
      requireClip: !1,
      bucketSort: sP
    }), this._rendering.collision.add(e, { margin: [2, 2] }, "poi"), this._rendering.collision.add(n, { margin: [2, 2] }, "poi"), this._rendering.collision.add(r, { margin: [2, 2] }, "poi"), this._rendering.collision.add(g, { margin: [2, 2] }, "poi"), this._rendering.collision.add(l, { margin: [2, 2] }, "poi"), this._rendering.collision.add(d, { margin: [2, 2] }, "poi"), this._rendering.collision.add(p, { margin: [2, 2] }, "poi");
  }
  initLabel() {
    const t = this._labelIconDataSource = new Gi(), e = this._labelIcon = this._rendering.add(new Ii({
      type: "icon",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    }));
    t.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset"
    }), e.dataSource = t;
    const i = this._labelIconFlatDataSource = new Gi(), n = this._labelIconFlat = this._rendering.add(new Ii({
      vertexIcons: !0,
      transparent: !0,
      isRenderInPostprocess: !0,
      flat: !0,
      type: "icon"
    }));
    i.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      iconUvs: "iconUvs",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ"
    }), n.dataSource = i;
    const o = this._labelTextFlatDataSource = new Gi(), r = this._labelTextFlat = this._rendering.add(new Ii({
      type: "text",
      vertexRotateZs: !0,
      isRenderInPostprocess: !0,
      flat: !0
    }));
    o.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      rotateZ: "rotateZ"
    }), r.dataSource = o;
    const a = this._labelTextFixedDataSource = new Gi(), g = this._labelTextFixed = this._rendering.add(new Ii({
      type: "text",
      isRenderInPostprocess: !0,
      flat: !1
    }));
    a.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      offset: "offset"
    }), g.dataSource = a;
    const c = this._labelIconTextDataSource = new Gi(), l = this._labelIconText = this._rendering.add(new Ii({
      type: "icontext",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    }));
    c.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      icon: "icon",
      iconSize: "iconSize",
      direction: "direction",
      rotateZ: "rotateZ",
      offset: "offset"
    }), l.dataSource = c;
  }
  processLabel(t) {
    let e = t.type;
    if (e)
      return t;
    const i = t.flat;
    let n = !1, o = !1;
    if (t.text && (n = !0), t.mapSrc) {
      const { width: r, height: a } = t;
      t.icon = t.mapSrc, t.iconSize = [r || 40, a || 40], o = !0;
    }
    return n && o ? e = "icon_text" : n ? e = i ? "text_flat" : "text_fix" : o && (e = i ? "icon_flat" : "icon"), t.type = e, t;
  }
  _getCollisionLabel(t) {
    let e = t.type;
    t instanceof Ds && (e = t.attributes && t.attributes.type);
    let i = t.group || "default";
    t.attributes && t.attributes.group && (i = t.attributes.group);
    const n = this._collisionLabels[e];
    if (n[i])
      return n[i];
    let o;
    const r = new Gi();
    return e === "icon_text" ? (o = this._rendering.add(new Ii({
      type: "icontext",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    })), r.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      textDrawOnIcon: "textDrawOnIcon",
      icon: "icon",
      iconSize: "iconSize",
      direction: "direction",
      rotateZ: "rotateZ",
      offset: "offset",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "icon" ? (o = this._rendering.add(new Ii({
      type: "icon",
      vertexIcons: !0,
      isRenderInPostprocess: !0
    })), r.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "icon_flat" ? (o = this._rendering.add(new Ii({
      vertexIcons: !0,
      transparent: !0,
      isRenderInPostprocess: !0,
      flat: !0,
      type: "icon"
    })), r.defineAttributes({
      id: "id",
      icon: "icon",
      iconSize: "iconSize",
      offset: "offset",
      iconUvs: "iconUvs",
      iconOpacity: "iconOpacity",
      rotateZ: "rotateZ",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "text_flat" ? (o = this._rendering.add(new Ii({
      type: "text",
      vertexRotateZs: !0,
      isRenderInPostprocess: !0,
      flat: !0
    })), r.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      rotateZ: "rotateZ",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })) : e === "text_fix" && (o = this._rendering.add(new Ii({
      type: "text",
      isRenderInPostprocess: !0,
      flat: !1
    })), r.defineAttributes({
      text: "text",
      textSize: "textSize",
      textFillStyle: "textFillStyle",
      textStrokeStyle: "textStrokeStyle",
      textStrokeWidth: "textStrokeWidth",
      textAnchor: "textAnchor",
      offset: "offset",
      tolerance: "tolerance",
      isCustom: "isCustom"
    })), o.dataSource = r, n[i] = o, this._rendering.collision.add(o, { margin: [0, 0] }, i), o;
  }
  addCollisionLabel(t) {
    const e = this.computeBoundingBox(t);
    t.boundingBox = e;
    const i = t.type, n = !!i;
    n || this.processLabel(t);
    let o = t;
    if (!(t instanceof Ds) && Array.prototype.toString.call(t) === "[object Object]") {
      const { position: r, forceProjected: a, ...g } = t;
      g.isCustom = !n, o = new Ds(r, g, a);
    }
    return i === "icon_text" ? this._iconTextDataSource.add(o) : i === "icon_text_uv" ? this._iconTextUvDataSource.add(o) : i === "icon" ? this._iconDataSource.add(o) : i === "icon_uv" ? this._iconUvDataSource.add(o) : i === "icon_flat_uv" ? this._iconFlatUvDataSource.add(o) : i === "text_flat" || i === "labelp" ? this._textFlatDataSource.add(o) : i === "text_fix" ? this._textFixedDataSource.add(o) : this._getCollisionLabel(t).dataSource.add(o), o;
  }
  addNormalLabel(t) {
    let e = t;
    if (!(t instanceof Ds) && Array.prototype.toString.call(t) === "[object Object]") {
      const { position: i, forceProjected: n, ...o } = t;
      e = new Ds(i, o, n);
    }
    return t.type === "icon" ? this._labelIconDataSource.add(e) : t.type === "icon_flat" ? this._labelIconFlatDataSource.add(e) : t.type === "text_flat" ? this._labelTextFlatDataSource.add(e) : t.type === "text_fix" ? this._labelTextFixedDataSource.add(e) : t.type === "icon_text" && this._labelIconTextDataSource.add(e), e;
  }
  addLabel(t) {
    if (this.enabled || (this.enabled = !0), !t.position) {
      console.warn("need position");
      return;
    }
    let i;
    return t.collision ? i = this.addCollisionLabel(t) : (this.processLabel(t), i = this.addNormalLabel(t)), i;
  }
  addLabels(t, e) {
    const i = this._rendering.taskScheduler.addTask(this._createLabelTask(t));
    e = e || oP(), this._blocks[e] = i;
  }
  _createLabelTask(t) {
    return () => new Promise((i, n) => {
      try {
        for (const o of t) {
          const r = o.collision || !0;
          o.collision = r, r ? this.addCollisionLabel(o) : this.addNormalLabel(o);
        }
        this._rendering.requestRender(), i();
      } catch (o) {
        n(o);
      }
    });
  }
  computeBoundingBox(t) {
    this.enabled || (this.enabled = !0);
    let e;
    return t.type === "icon_text" ? e = this._iconText.computeBoundingBox(t) : t.type === "icon_text_uv" ? e = this._iconTextUv.computeBoundingBox(t) : t.type === "icon" ? e = this._icon.computeBoundingBox(t) : t.type === "icon_uv" ? e = this._iconUv.computeBoundingBox(t) : t.type === "icon_flat_uv" ? e = this._iconFlatUv.computeBoundingBox(t) : t.type === "text_flat" || t.type === "labelp" ? e = this._textFlat.computeBoundingBox(t) : t.type === "text_fix" && (e = this._textFixed.computeBoundingBox(t)), e;
  }
  _checkRemoveCollisionLabel(t, e) {
    if (t.dataSource.userData.length === 1) {
      this._rendering.remove(t);
      let i = e.type;
      e instanceof Ds && (i = e.attributes && e.attributes.type);
      let n = e.group || "default";
      e.attributes && e.attributes.group && (n = e.attributes.group), this._collisionLabels[i] && delete this._collisionLabels[i][n];
    }
  }
  removeCollisionLabel(t) {
    if (t.attributes && t.attributes.isCustom) {
      const i = this._getCollisionLabel(t);
      i.dataSource.remove(t), this._checkRemoveCollisionLabel(i, t);
      return;
    }
    t.type === "icon_text" ? this._iconTextDataSource.remove(t) : t.type === "icon_text_uv" ? this._iconTextUvDataSource.remove(t) : t.type === "icon" ? this._iconDataSource.remove(t) : t.type === "icon_uv" ? this._iconUvDataSource.remove(t) : t.type === "icon_flat_uv" ? this._iconFlatUvDataSource.remove(t) : t.type === "text_flat" || t.type === "labelp" ? this._textFlatDataSource.remove(t) : t.type === "text_fix" && this._textFixedDataSource.remove(t);
  }
  removeNormalLabel(t) {
    const e = t.attributes;
    let i = t.type;
    e && e.type && (i = e.type), i === "icon" ? this._labelIconDataSource.remove(t) : i === "icon_flat" ? this._labelIconFlatDataSource.remove(t) : i === "text_flat" ? this._labelTextFlatDataSource.remove(t) : i === "text_fix" ? this._labelTextFixedDataSource.remove(t) : i === "icon_text" && this._labelIconTextDataSource.remove(t);
  }
  removeLabel(t) {
    let e = t.collision;
    e || (e = t.attributes && t.attributes.collision), e ? this.removeCollisionLabel(t) : this.removeNormalLabel(t);
  }
  removeLabels(t, e) {
    const i = this._blocks[e];
    if (i && !i.isStart()) {
      i.cancel(), delete this._blocks[e];
      return;
    }
    for (const n of t) {
      const o = n.collision || !0;
      n.collision = o, this.removeLabel(n);
    }
    this._rendering.requestRender();
  }
  dispose() {
    this._rendering.collision.remove(this._fixText, "poi"), this._rendering.collision.remove(this._labelText, "poi"), this._rendering.collision.remove(this._flatText, "poi"), this._rendering.remove(this._fixText), this._rendering.remove(this._flatText), this._rendering.remove(this._labelText);
  }
}
function aP(s, t, e, i, n) {
  Ww(s, t, e || 0, i || s.length - 1, n || gP);
}
function Ww(s, t, e, i, n) {
  for (; i > e; ) {
    if (i - e > 600) {
      var o = i - e + 1, r = t - e + 1, a = Math.log(o), g = 0.5 * Math.exp(2 * a / 3), c = 0.5 * Math.sqrt(a * g * (o - g) / o) * (r - o / 2 < 0 ? -1 : 1), l = Math.max(e, Math.floor(t - r * g / o + c)), h = Math.min(i, Math.floor(t + (o - r) * g / o + c));
      Ww(s, t, l, h, n);
    }
    var d = s[t], C = e, p = i;
    for (Wa(s, e, t), n(s[i], d) > 0 && Wa(s, e, i); C < p; ) {
      for (Wa(s, C, p), C++, p--; n(s[C], d) < 0; )
        C++;
      for (; n(s[p], d) > 0; )
        p--;
    }
    n(s[e], d) === 0 ? Wa(s, e, p) : (p++, Wa(s, p, i)), p <= t && (e = p + 1), t <= p && (i = p - 1);
  }
}
function Wa(s, t, e) {
  var i = s[t];
  s[t] = s[e], s[e] = i;
}
function gP(s, t) {
  return s < t ? -1 : s > t ? 1 : 0;
}
class cP {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let e = this.data;
    const i = [];
    if (!bc(t, e))
      return i;
    const n = this.toBBox, o = [];
    for (; e; ) {
      for (let r = 0; r < e.children.length; r++) {
        const a = e.children[r], g = e.leaf ? n(a) : a;
        bc(t, g) && (e.leaf ? i.push(a) : su(t, g) ? this._all(a, i) : o.push(a));
      }
      e = o.pop();
    }
    return i;
  }
  collides(t) {
    let e = this.data;
    if (!bc(t, e))
      return !1;
    const i = [];
    for (; e; ) {
      for (let n = 0; n < e.children.length; n++) {
        const o = e.children[n], r = e.leaf ? this.toBBox(o) : o;
        if (bc(t, r)) {
          if (e.leaf || su(t, r))
            return !0;
          i.push(o);
        }
      }
      e = i.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length))
      return this;
    if (t.length < this._minEntries) {
      for (let i = 0; i < t.length; i++)
        this.insert(t[i]);
      return this;
    }
    let e = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = e;
    else if (this.data.height === e.height)
      this._splitRoot(this.data, e);
    else {
      if (this.data.height < e.height) {
        const i = this.data;
        this.data = e, e = i;
      }
      this._insert(e, this.data.height - e.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = sa([]), this;
  }
  remove(t, e) {
    if (!t)
      return this;
    let i = this.data;
    const n = this.toBBox(t), o = [], r = [];
    let a, g, c;
    for (; i || o.length; ) {
      if (i || (i = o.pop(), g = o[o.length - 1], a = r.pop(), c = !0), i.leaf) {
        const l = lP(t, i.children, e);
        if (l !== -1)
          return i.children.splice(l, 1), o.push(i), this._condense(o), this;
      }
      !c && !i.leaf && su(i, n) ? (o.push(i), r.push(a), a = 0, g = i, i = i.children[0]) : g ? (a++, i = g.children[a], c = !1) : i = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, e) {
    return t.minX - e.minX;
  }
  compareMinY(t, e) {
    return t.minY - e.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, e) {
    const i = [];
    for (; t; )
      t.leaf ? e.push(...t.children) : i.push(...t.children), t = i.pop();
    return e;
  }
  _build(t, e, i, n) {
    const o = i - e + 1;
    let r = this._maxEntries, a;
    if (o <= r)
      return a = sa(t.slice(e, i + 1)), Hr(a, this.toBBox), a;
    n || (n = Math.ceil(Math.log(o) / Math.log(r)), r = Math.ceil(o / Math.pow(r, n - 1))), a = sa([]), a.leaf = !1, a.height = n;
    const g = Math.ceil(o / r), c = g * Math.ceil(Math.sqrt(r));
    im(t, e, i, c, this.compareMinX);
    for (let l = e; l <= i; l += c) {
      const h = Math.min(l + c - 1, i);
      im(t, l, h, g, this.compareMinY);
      for (let d = l; d <= h; d += g) {
        const C = Math.min(d + g - 1, h);
        a.children.push(this._build(t, d, C, n - 1));
      }
    }
    return Hr(a, this.toBBox), a;
  }
  _chooseSubtree(t, e, i, n) {
    for (; n.push(e), !(e.leaf || n.length - 1 === i); ) {
      let o = 1 / 0, r = 1 / 0, a;
      for (let g = 0; g < e.children.length; g++) {
        const c = e.children[g], l = nu(c), h = uP(t, c) - l;
        h < r ? (r = h, o = l < o ? l : o, a = c) : h === r && l < o && (o = l, a = c);
      }
      e = a || e.children[0];
    }
    return e;
  }
  _insert(t, e, i) {
    const n = i ? t : this.toBBox(t), o = [], r = this._chooseSubtree(n, this.data, e, o);
    for (r.children.push(t), yg(r, n); e >= 0 && o[e].children.length > this._maxEntries; )
      this._split(o, e), e--;
    this._adjustParentBBoxes(n, o, e);
  }
  _split(t, e) {
    const i = t[e], n = i.children.length, o = this._minEntries;
    this._chooseSplitAxis(i, o, n);
    const r = this._chooseSplitIndex(i, o, n), a = sa(i.children.splice(r, i.children.length - r));
    a.height = i.height, a.leaf = i.leaf, Hr(i, this.toBBox), Hr(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(t, e) {
    this.data = sa([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Hr(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, e, i) {
    let n, o = 1 / 0, r = 1 / 0;
    for (let a = e; a <= i - e; a++) {
      const g = mg(t, 0, a, this.toBBox), c = mg(t, a, i, this.toBBox), l = IP(g, c), h = nu(g) + nu(c);
      l < o ? (o = l, n = a, r = h < r ? h : r) : l === o && h < r && (r = h, n = a);
    }
    return n || i - e;
  }
  _chooseSplitAxis(t, e, i) {
    const n = t.leaf ? this.compareMinX : hP, o = t.leaf ? this.compareMinY : dP, r = this._allDistMargin(t, e, i, n), a = this._allDistMargin(t, e, i, o);
    r < a && t.children.sort(n);
  }
  _allDistMargin(t, e, i, n) {
    t.children.sort(n);
    const o = this.toBBox, r = mg(t, 0, e, o), a = mg(t, i - e, i, o);
    let g = Sc(r) + Sc(a);
    for (let c = e; c < i - e; c++) {
      const l = t.children[c];
      yg(r, t.leaf ? o(l) : l), g += Sc(r);
    }
    for (let c = i - e - 1; c >= e; c--) {
      const l = t.children[c];
      yg(a, t.leaf ? o(l) : l), g += Sc(a);
    }
    return g;
  }
  _adjustParentBBoxes(t, e, i) {
    for (let n = i; n >= 0; n--)
      yg(e[n], t);
  }
  _condense(t) {
    for (let e = t.length - 1, i; e >= 0; e--)
      t[e].children.length === 0 ? e > 0 ? (i = t[e - 1].children, i.splice(i.indexOf(t[e]), 1)) : this.clear() : Hr(t[e], this.toBBox);
  }
}
function lP(s, t, e) {
  if (!e)
    return t.indexOf(s);
  for (let i = 0; i < t.length; i++)
    if (e(s, t[i]))
      return i;
  return -1;
}
function Hr(s, t) {
  mg(s, 0, s.children.length, t, s);
}
function mg(s, t, e, i, n) {
  n || (n = sa(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
  for (let o = t; o < e; o++) {
    const r = s.children[o];
    yg(n, s.leaf ? i(r) : r);
  }
  return n;
}
function yg(s, t) {
  return s.minX = Math.min(s.minX, t.minX), s.minY = Math.min(s.minY, t.minY), s.maxX = Math.max(s.maxX, t.maxX), s.maxY = Math.max(s.maxY, t.maxY), s;
}
function hP(s, t) {
  return s.minX - t.minX;
}
function dP(s, t) {
  return s.minY - t.minY;
}
function nu(s) {
  return (s.maxX - s.minX) * (s.maxY - s.minY);
}
function Sc(s) {
  return s.maxX - s.minX + (s.maxY - s.minY);
}
function uP(s, t) {
  return (Math.max(t.maxX, s.maxX) - Math.min(t.minX, s.minX)) * (Math.max(t.maxY, s.maxY) - Math.min(t.minY, s.minY));
}
function IP(s, t) {
  const e = Math.max(s.minX, t.minX), i = Math.max(s.minY, t.minY), n = Math.min(s.maxX, t.maxX), o = Math.min(s.maxY, t.maxY);
  return Math.max(0, n - e) * Math.max(0, o - i);
}
function su(s, t) {
  return s.minX <= t.minX && s.minY <= t.minY && t.maxX <= s.maxX && t.maxY <= s.maxY;
}
function bc(s, t) {
  return t.minX <= s.maxX && t.minY <= s.maxY && t.maxX >= s.minX && t.maxY >= s.minY;
}
function sa(s) {
  return {
    children: s,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function im(s, t, e, i, n) {
  const o = [t, e];
  for (; o.length; ) {
    if (e = o.pop(), t = o.pop(), e - t <= i)
      continue;
    const r = t + Math.ceil((e - t) / i / 2) * i;
    aP(s, r, t, e, n), o.push(t, r, r, e);
  }
}
const ou = new J(), AP = new B(), CP = new Me(), fP = new Me(), Oo = new Me(), pP = (s, t, e) => 0.2 * Math.tan(t / 2) * s / e * 10;
class mP {
  constructor(t) {
    f(this, "_groupObjectMap", {});
    f(this, "_groupDataMap", {});
    f(this, "_groupOptions", {});
    f(this, "_objectDataMap", /* @__PURE__ */ new Map());
    f(this, "_needsUpdate", !1);
    f(this, "_restrictCount", 1e4);
    f(this, "_cacheBucketKeys", {});
    f(this, "_lastUpdateTime", 0);
    f(this, "_delayUpdateTime", 200);
    f(this, "_delayUpdateTimeHandler", null);
    f(this, "_margin", [0, 0]);
    f(this, "_maxRenderDepth", 1);
    f(this, "_lastZoom", 0);
    f(this, "_viewMatrixWorld", new J());
    f(this, "_projectionMatrix", new J());
    f(this, "_viewChanged", !0);
    this._rendering = t;
  }
  add(t, e = {}, i = "_default") {
    if (!(t instanceof Os)) {
      console.error("Collison Test only work with GeoObject.");
      return;
    }
    if (!t.dataSource) {
      console.error("Object must have DataSource before it added to Collision!");
      return;
    }
    this._groupObjectMap[i] || (this._groupObjectMap[i] = [], this._groupDataMap[i] = []), this._groupObjectMap[i].push(t), e.margin !== void 0 && typeof e.margin == "number" && (e.margin = [e.margin, e.margin]), t._enableCollision = !0, t._collisionOptions = e, t.dataSource.defineAttribute("rank", "rank"), t.dataSource.defineAttribute("bucket", "bucket"), t.dataSource.defineAttribute("distance", "distance");
  }
  setGroupOption(t, e) {
    this._groupOptions[t] = e;
  }
  remove(t, e = "_default") {
    if (!(t instanceof Os)) {
      console.error("Collison Test only work with GeoObject.");
      return;
    }
    let i = this._groupObjectMap[e].indexOf(t);
    i > -1 ? (this._groupObjectMap[e].splice(i, 1), delete t._enableCollision, delete t._collisionOptions, delete t._collisionData, delete t._collisionUpdated, t.dataSource.undefineAttribute("rank", "rank")) : console.error("remove error: cannot find object in this group.");
  }
  sortBucket(t) {
    t && t.length > 0 && t.sort((e, i) => i.rank - e.rank || i.position[0] - e.position[0] || i.position[1] - e.position[1]);
  }
  sortBuckets(t, e) {
    const i = this._groupOptions[e] || {}, n = i.bucketSort, o = i.enabledBucketCache;
    let r = Object.keys(t);
    if (n && (r = n(r)), o) {
      this._cacheBucketKeys[e] || (this._cacheBucketKeys[e] = []);
      const g = this._cacheBucketKeys[e];
      if (g && g.length > 0) {
        const c = [], l = [];
        for (let h = 0; h < g.length; h++) {
          const d = g[h];
          r.includes(d) && c.push(d);
        }
        for (let h = 0; h < r.length; h++) {
          const d = r[h];
          if (!g.includes(d)) {
            const p = t[d][0] || {};
            l.push({
              key: d,
              distance: p.distance || Number.POSITIVE_INFINITY
            });
          }
        }
        l.sort((h, d) => h.distance - d.distance), r = c.concat(l.map((h) => h.key));
      }
      this._cacheBucketKeys[e] = r;
    }
    const a = [];
    for (let g = 0; g < r.length; g++) {
      const c = r[g], l = t[c];
      this.sortBucket(l), a.push(...l);
    }
    return this.sortBucket(a), a;
  }
  sortData() {
    let t = Object.keys(this._groupObjectMap);
    for (let e = 0; e < t.length; e++) {
      const i = t[e], n = this._groupObjectMap[i];
      for (let a = 0; a < n.length; a++) {
        const g = n[a];
        g._collisionData = [], g._collisionUpdated = !0;
        let c = g.dataSource.userData;
        for (let l = 0; l < c.length; l++)
          c[l]._objects = g.dataSource.objects;
      }
      let o = [];
      for (let a = 0; a < n.length; a++) {
        const g = n[a];
        o = o.concat(g.dataSource.userData);
      }
      const r = {};
      o.forEach((a) => {
        const g = a.bucket || "default";
        r[g] || (r[g] = []), r[g].push(a);
      }), this._groupDataMap[i] = this.sortBuckets(r, i);
    }
    this._needsUpdate = !1;
  }
  update(t) {
    if (!Object.keys(this._groupDataMap).length || this._delayUpdateTimeHandler)
      return;
    const i = Date.now(), n = i - this._lastUpdateTime;
    if (n < this._delayUpdateTime) {
      this._delayUpdateTimeHandler = setTimeout(() => {
        clearTimeout(this._delayUpdateTimeHandler), this._delayUpdateTimeHandler = null, this._rendering.requestRender();
      }, this._delayUpdateTime - n + 1);
      return;
    }
    this.needsUpdate ? (this.sortData(), this._collisionTest()) : (this._viewChanged = !t.viewMatrixWorld.equals(this._viewMatrixWorld) || !t.projectionMatrix.equals(this._projectionMatrix), this._viewChanged && (this._collisionTest(), this._viewMatrixWorld.copy(t.viewMatrixWorld), this._projectionMatrix.copy(t.projectionMatrix))), this._lastUpdateTime = i;
  }
  _calculatePixelSize(t, e) {
    const n = this._rendering.renderState.cameraOffset;
    e.sub(n);
    const o = t.position.distanceTo(e), r = t.fov * Math.PI / 180, a = this._rendering.resolution.y;
    return pP(o, r, a);
  }
  _collisionTest() {
    let t = Object.keys(this._groupDataMap);
    const e = this._rendering.camera;
    ou.multiplyMatrices(e.projectionMatrix, this._rendering.renderState.viewMatrixWorldInverse);
    const i = this._rendering.resolution ? this._rendering.resolution.toArray() : [0, 0], [n, o] = i;
    if (isNaN(n) || n <= 0 || isNaN(o) || o <= 0)
      return console.warn("resolution is invalid"), !1;
    const r = this._rendering.stats, a = this._rendering.renderState.cameraOffset, g = this._objectDataMap;
    g.clear(), r.beginTimeStatsItem("labelCollision");
    let c = null;
    for (let l = 0; l < t.length; l++) {
      const h = t[l], d = this._groupDataMap[h];
      if (!d)
        continue;
      const C = new cP(), p = this._groupOptions[h] || {};
      let m = !0;
      H(p.requireClip) && (m = p.requireClip);
      for (let b = 0; b < d.length; b++) {
        const S = d[b], A = S._objects;
        for (let v = 0; v < A.length; v++) {
          const D = A[v];
          g.get(D) || g.set(D, []);
        }
        const u = A.filter((v) => v._enableCollision)[0], [y, I, M] = S.position;
        Oo.set(y, I, M, 1), Oo.applyMatrix4(ou), Oo.divideScalar(Oo.w);
        const G = (Oo.x + 1) / 2 * n, x = (-Oo.y + 1) / 2 * o;
        if (Oo.z > this._maxRenderDepth)
          continue;
        let L = 0, E = 0;
        const T = u.collisionTest(S), R = T.tolerance || 0;
        if (T && T.chars) {
          const v = AP.fromArray(S.position), D = this._calculatePixelSize(e, v), K = T.chars, P = T.rotationMatrix;
          let k = !1;
          const V = [];
          for (let N = 0, z = K.length; N < z; N++) {
            const O = K[N];
            let Q = O.width, U = O.height;
            const $ = O.offsetX, ee = O.offsetY;
            if (!Q || !U)
              continue;
            const ie = CP.set($ * D, ee * D, 0, 0).applyMatrix4(P), Y = fP.set(
              y + ie.x,
              I + ie.y,
              M + ie.z,
              1
            );
            v.copy(Y).sub(a).sub(e.position);
            const Ie = v.applyMatrix4(P).normalize(), xe = Math.max(Math.abs(Ie.z), 0.1);
            Y.applyMatrix4(ou), Y.divideScalar(Y.w);
            const fe = (Y.x + 1) / 2 * n, be = (-Y.y + 1) / 2 * o;
            c = u._collisionOptions.margin || this.margin;
            const pe = Math.hypot(Q, U), Te = c[0] + R, ge = c[1] + R;
            Q = pe + Math.max(Te, 0) * 2, U = pe * xe + Math.max(ge, 0) * 2;
            const lt = fe - Q / 2, Ke = be - U / 2, Pe = lt + Q, nt = Ke + U, Ve = {
              minX: lt,
              minY: Ke,
              maxX: Pe,
              maxY: nt
            };
            V.push(Ve);
          }
          for (let N = 0; N < V.length; N++) {
            const z = V[N];
            if (C.collides(z)) {
              k = !0;
              break;
            }
          }
          if (k)
            continue;
          for (let N = 0; N < V.length; N++) {
            const z = V[N];
            C.insert(z);
          }
        } else {
          let v = T.width, D = T.height;
          const K = T.offsetX || 0, P = T.offsetY || 0;
          if (!v || !D)
            continue;
          L = v, E = D, c = u._collisionOptions.margin || this.margin;
          const k = c[0] + R, V = c[1] + R;
          v += Math.max(k, 0) * 2, D += Math.max(V, 0) * 2;
          const N = G - v / 2 + K, z = x - D / 2 + P, O = N + v, Q = z + D;
          if (m && (O < 0 || Q < 0 || N > n || z > o))
            continue;
          const U = {
            minX: N,
            minY: z,
            maxX: O,
            maxY: Q
          };
          if ((k >= 0 || V >= 0) && C.collides(U))
            continue;
          C.insert(U);
        }
        let w = {
          ...S,
          w: L,
          h: E
        };
        for (let v = 0; v < A.length; v++) {
          const D = A[v];
          g.get(D).push(w);
        }
      }
    }
    Array.from(g.entries()).forEach(([l, h]) => {
      (!l._collisionData || l._collisionData.length !== h.length) && (l._collisionData = h, l._collisionUpdated = !0);
    }), r.endTimeStatsItem("labelCollision");
  }
  set margin(t) {
    typeof t == "number" ? this._margin = [t, t] : t instanceof Array && (this._margin = t);
  }
  get margin() {
    return this._margin;
  }
  set maxRenderDepth(t) {
    this._maxRenderDepth = t;
  }
  set restrictCount(t) {
    this._restrictCount = t;
  }
  get restrictCount() {
    return this._restrictCount;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(t) {
    this._needsUpdate = t;
  }
}
class yP {
  constructor(t) {
    f(this, "_rendering", null);
    f(this, "_mixer", null);
    f(this, "_customMixers", []);
    this._rendering = t;
  }
  update(t) {
    this._mixer && this._mixer.update(t.deltaSeconds);
    for (const e of this._customMixers)
      e.update(t.deltaSeconds);
  }
  addMixer(t) {
    this._customMixers.indexOf(t) === -1 && this._customMixers.push(t);
  }
  removeMixer(t) {
    let e = this._customMixers.indexOf(t);
    e !== -1 && this._customMixers.splice(e, 1);
  }
  get mixer() {
    return this._mixer || (this._mixer = new nT(this._rendering.scene)), this._mixer;
  }
}
class _a {
  static createButton(t) {
    const e = document.createElement("button");
    function i() {
      let g = null;
      async function c(h) {
        h.addEventListener("end", l), await t.xr.setSession(h), e.textContent = "EXIT VR", g = h;
      }
      function l() {
        g.removeEventListener("end", l), e.textContent = "ENTER VR", g = null;
      }
      e.style.display = "", e.style.cursor = "pointer", e.style.left = "calc(50% - 50px)", e.style.width = "100px", e.textContent = "ENTER VR", e.onmouseenter = function() {
        e.style.opacity = "1.0";
      }, e.onmouseleave = function() {
        e.style.opacity = "0.5";
      }, e.onclick = function() {
        if (g === null) {
          const h = { optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"] };
          navigator.xr.requestSession("immersive-vr", h).then(c);
        } else
          g.end();
      };
    }
    function n() {
      e.style.display = "", e.style.cursor = "auto", e.style.left = "calc(50% - 75px)", e.style.width = "150px", e.onmouseenter = null, e.onmouseleave = null, e.onclick = null;
    }
    function o() {
      n(), e.textContent = "VR NOT SUPPORTED";
    }
    function r(g) {
      n(), console.warn("Exception when trying to call xr.isSessionSupported", g), e.textContent = "VR NOT ALLOWED";
    }
    function a(g) {
      g.style.position = "absolute", g.style.bottom = "20px", g.style.padding = "12px 6px", g.style.border = "1px solid #fff", g.style.borderRadius = "4px", g.style.background = "rgba(0,0,0,0.1)", g.style.color = "#fff", g.style.font = "normal 13px sans-serif", g.style.textAlign = "center", g.style.opacity = "0.5", g.style.outline = "none", g.style.zIndex = "999";
    }
    if ("xr" in navigator)
      return e.id = "VRButton", e.style.display = "none", a(e), navigator.xr.isSessionSupported("immersive-vr").then(function(g) {
        g ? i() : o(), g && _a.xrSessionIsGranted && e.click();
      }).catch(r), e;
    {
      const g = document.createElement("a");
      return window.isSecureContext === !1 ? (g.href = document.location.href.replace(/^http:/, "https:"), g.innerHTML = "WEBXR NEEDS HTTPS") : (g.href = "https://immersiveweb.dev/", g.innerHTML = "WEBXR NOT AVAILABLE"), g.style.left = "calc(50% - 90px)", g.style.width = "180px", g.style.textDecoration = "none", a(g), g;
    }
  }
  static registerSessionGrantedListener() {
    if (typeof navigator < "u" && "xr" in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent))
        return;
      navigator.xr.addEventListener("sessiongranted", () => {
        _a.xrSessionIsGranted = !0;
      });
    }
  }
}
_a.xrSessionIsGranted = !1;
_a.registerSessionGrantedListener();
class SP {
  constructor(t) {
    f(this, "onSessionStart", () => {
    });
    f(this, "onSessionEnd", () => {
    });
    this._rendering = t;
  }
  init() {
    const t = this._rendering, e = t._renderer;
    if (t._useXR) {
      t.useMrt = !1, t.enableAnimationLoop = !0, t.animationLoopFrameTime = 16, t.autoOffsetRelativeCenter = !1;
      const i = t._camera, n = this.camera = i.clone();
      n.far = 2e3, n.name = "xrCamera";
      const o = this.xrCamera = new mt();
      o.name = "xrCameraGroup", o.add(n), t._engine.add(o), o.rotation.set(Math.PI / 2, 0, 0), document.body.appendChild(_a.createButton(e)), e.setAnimationLoop(t.render), e.xr.enabled = !0, e.xr.addEventListener("sessionstart", this.onSessionStart), e.xr.addEventListener("sessionend", this.onSessionEnd);
    }
  }
  dispose() {
    const t = this._rendering._renderer;
    t.xr.removeEventListener("sessionstart", this.onSessionStart), t.xr.removeEventListener("sessionend", this.onSessionEnd);
  }
}
class bP {
  constructor(t) {
    f(this, "_lastValue", 0);
    f(this, "_count", 0);
    f(this, "_total", 0);
    f(this, "_beginTime", 0);
    f(this, "_name");
    this._name = t;
  }
  begin(t) {
    this._beginTime = t;
  }
  end(t) {
    this._lastValue = t - this._beginTime, this._total = this._total + this._lastValue, this._count++;
  }
  add(t) {
    this._total += t, this._lastValue = t, this._count++;
  }
  get total() {
    return this._total;
  }
  get count() {
    return this._count;
  }
  get average() {
    return this._count === 0 ? 0 : this._total / this._count;
  }
  get lastValue() {
    return this._lastValue;
  }
  get name() {
    return this._name;
  }
  get beginTime() {
    return this._beginTime;
  }
}
class BP {
  constructor() {
    f(this, "_timeStatsItem", {});
  }
  addTimeStatsItem(t) {
    const e = new bP(t);
    this._timeStatsItem[t] = e;
  }
  removeTimeStatsItem(t) {
    delete this._timeStatsItem[t];
  }
  beginTimeStatsItem(t, e) {
    this._timeStatsItem[t] || this.addTimeStatsItem(t), e == null && (e = performance.now()), this._timeStatsItem[t].begin(e);
  }
  endTimeStatsItem(t, e) {
    this._timeStatsItem[t] || this.addTimeStatsItem(t), e == null && (e = performance.now()), this._timeStatsItem[t].end(e);
  }
  addTimeStatsItemValue(t, e) {
    this._timeStatsItem[t] || this.addTimeStatsItem(t), this._timeStatsItem[t].add(e);
  }
  getSortedTimeStatsItems() {
    let t = Object.values(this._timeStatsItem);
    const e = performance.now();
    return t = t.filter((i) => e - i.beginTime < 5e3), t.sort((i, n) => n.average - i.average), t;
  }
  printString() {
    let t = `Stas:
`;
    const e = this.getSortedTimeStatsItems();
    for (const i of e)
      t += `${i.name}:
${i.average.toFixed(2)}	 ${i.lastValue.toFixed(2)}	 ${i.count}	 ${i.total.toFixed(2)}
`;
    return t;
  }
}
const Zw = 1, Uw = 2, wP = (s, t) => s.distance - t.distance, Ow = (s, t) => {
  const e = s._listeners;
  if (e === void 0)
    return !1;
  let i = null;
  for (let n = 0, o = t.length; n < o; n++)
    if (i = e[t[n]], i && i.length > 0)
      return !0;
  return !1;
}, Qw = (s, t, e, i, n, o, r, a) => {
  let g = !0, c = !0;
  if (e & Zw && (r = r || Ow(s, o), r || (c = !1)), !(e & Uw && !s.visible) && (i && !i(s, t, n) && (c = !1), c && s.layers.test(t.layers) && s.raycast(t, n) === !1 && (g = !1), g === !0 && a === !0)) {
    const l = s.children;
    for (let h = 0, d = l.length; h < d; h++)
      Qw(l[h], t, e, i, n, o, r, !0);
  }
};
class Ia extends js {
  constructor() {
    super(), this.mouse = new Z();
  }
  intersectFlagObjects(t, e, i, n = !0, o, r = []) {
    for (let a = 0, g = t.length; a < g; a++)
      Qw(t[a], this, e, o, r, i, !1, n);
    return r.sort(wP), r;
  }
}
f(Ia, "CHECK_EVENT", Zw), f(Ia, "CHECK_VISIBLE", Uw);
class _P {
  constructor() {
    f(this, "isFlowEvent", !0);
  }
  execute() {
  }
}
class xP extends _P {
  constructor(e, i = 0) {
    super();
    f(this, "_currentIndex", 0);
    f(this, "_callbacks", []);
    i > e.length - 1 && (i = e.length - 1), i < 0 && (i = 0), this._currentIndex = i, Array.isArray(e) ? this._callbacks = e : console.warn("callbacks must be an array");
  }
  execute(e) {
    const i = this._callbacks[this._currentIndex];
    i && i(e, this._currentIndex), this._currentIndex++, this._currentIndex > this._callbacks.length - 1 && (this._currentIndex = 0);
  }
}
class ru {
  constructor(t, e, i) {
    f(this, "_engine", null);
    f(this, "_originalEvent", null);
    f(this, "_isPropagationStopped", !1);
    f(this, "_entityProxy", null);
    f(this, "_position");
    f(this, "_point");
    f(this, "target", null);
    f(this, "currentTarget", null);
    f(this, "intersection", null);
    this._engine = t, this._originalEvent = e, this.pixel = e && e.pixel, this.event = e && e.event, this._entityProxy = i;
  }
  get originalEvent() {
    return this._originalEvent;
  }
  stopPropagation() {
    this._isPropagationStopped = !0;
  }
  get isPropagationStopped() {
    return this._isPropagationStopped;
  }
  get entity() {
    return this._entityProxy ? this._entityProxy.entity : null;
  }
  get object() {
    return console.warn("EventParams.object is deprecated, use EventParams.currentTarget instead"), this.currentTarget;
  }
  get directObject() {
    return console.warn("EventParams.directObject is deprecated, use EventParams.target instead"), this.target;
  }
  get position() {
    if (this._position !== void 0)
      return this._position;
    if (this.intersection && this.intersection.point) {
      const t = this.intersection.point;
      this._position = [t.x, t.y, t.z];
    } else
      this._position = null;
    return this._position;
  }
  set position(t) {
    if (this._position !== void 0) {
      console.warn("EventParams.position is readonly after initialized");
      return;
    }
    if (t === null) {
      this._position = null;
      return;
    }
    if (t.isVector3) {
      this._position = [t.x, t.y, t.z];
      return;
    }
    this._position = t;
  }
  get point() {
    if (this._point !== void 0)
      return this._point;
    const t = this.position;
    return t === null ? this._point = null : this._point = this._engine.map.unprojectArrayCoordinate(t), this._point;
  }
}
class vP {
  constructor(t, e) {
    f(this, "_hasComputed", !1);
    this._object = t, this._intersection = e;
  }
  _computeEntity() {
    const t = this._object, e = this._intersection;
    if (t.getEntityByIntersection)
      return t.getEntityByIntersection(e);
    let i = -1;
    return e.instanceId !== void 0 ? i = e.instanceId : e.face !== void 0 && e.face !== null ? t.getEntityIndexByFace && (i = t.getEntityIndexByFace(e.faceIndex, e.face.a)) : e.index !== void 0 && (i = e.index), i < 0 ? null : t.getEntityByIndex(i);
  }
  get entity() {
    return this._hasComputed || (this._entity = this._computeEntity(), this._hasComputed = !0), this._entity;
  }
  get intersection() {
    return this._intersection;
  }
}
class Yw {
  constructor() {
    this._eventToTriggerMap = {}, this._isBusy = !1, this._isEmpty = !0;
  }
  restart() {
    this._eventToTriggerMap = {};
  }
  putEvent(t, e) {
    this._eventToTriggerMap[t] || (this._eventToTriggerMap[t] = e, this._isEmpty = !1);
  }
  async triggerEvents(t) {
    if (this._isBusy)
      return;
    this._isBusy = !0;
    const e = this._eventToTriggerMap;
    this._eventToTriggerMap = {}, this._isEmpty = !0;
    try {
      await t(e);
    } catch (i) {
      console.error("error occurs when triggering event", i);
    } finally {
      this._isBusy = !1;
    }
  }
  get isEmpty() {
    return this._isEmpty;
  }
  get isBusy() {
    return this._isBusy;
  }
}
const Jt = class {
  constructor(t) {
    f(this, "_mouse", new Z());
    f(this, "_mousePosition", new Z());
    f(this, "_intersections");
    f(this, "_engine", null);
    f(this, "_currentMouseEnterLeaveObjects");
    f(this, "_handleTriggerEvents", async (t) => {
      await this._triggerEventOfObjects(t) && this._triggerMouseLeaveEvents(t), this._lastMouseEnterLeaveObjects = this._currentMouseEnterLeaveObjects, this._engine.requestRender();
    });
    f(this, "_triggerEventOfObjects", async (t) => {
      const e = this._engine, i = Object.keys(t), n = t[i[0]];
      this._updateMouse(n);
      const o = this._currentMouseEnterLeaveObjects, r = o && o.keys();
      let a = !1;
      r.forEach((b) => {
        a = a || Ow(b, i);
      }), this._intersections = await e.rendering.picking.pickIntersectionsOfEventObjects(this._mousePosition, i);
      const g = this._currentMouseEnterLeaveObjects = /* @__PURE__ */ new Map();
      if (this._intersections.length === 0)
        return await this._triggerRootObjectEvents(t, null), a;
      const c = this._intersections[0];
      let h = c.object;
      const d = h, C = {};
      let p = null, m = null;
      for (; h; ) {
        let b = !1;
        m = [];
        const S = h._listeners;
        for (const M of i)
          !S || !S[M] || S[M].length === 0 || m.push(M);
        const A = S && Object.keys(S) || [];
        (A.includes(Jt.EVENT_NAME_MOUSE_ENTER) || A.includes(Jt.EVENT_NAME_MOUSE_LEAVE)) && (b = !0), h.isEventEntitySupported ? p = new vP(h, c) : p = null;
        let u = !1, y = !1, I = null;
        if (b)
          if (g.set(h, p), !this._lastMouseEnterLeaveObjects.has(h))
            u = !0;
          else {
            const M = this._lastMouseEnterLeaveObjects.get(h);
            h.isEventEntitySupported && !this._isSameEntity(p, M) && (u = !0, y = !0, I = M);
          }
        for (const M of m) {
          if (C[M] || M === Jt.EVENT_NAME_MOUSE_ENTER && !u)
            continue;
          if (M === Jt.EVENT_NAME_MOUSE_LEAVE) {
            if (!y)
              continue;
            I && (p = I);
          }
          const G = t[M], L = h._listeners[M], E = new ru(this._engine, G, p);
          E.target = d, E.currentTarget = h, E.intersection = c, this._executeCallbacks(L, E), E.isPropagationStopped && (C[M] = !0);
        }
        h = h.parent;
      }
      return await this._triggerRootObjectEvents(t, c, C), a;
    });
    f(this, "_isSameEntity", (t, e) => {
      var o, r;
      const i = (o = t == null ? void 0 : t.entity) == null ? void 0 : o.index, n = (r = e == null ? void 0 : e.entity) == null ? void 0 : r.index;
      return i !== void 0 && i === n;
    });
    f(this, "_handlePointerDown", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_POINTER_DOWN, t), this._engine.requestRender();
    });
    f(this, "_handlePointerUp", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_POINTER_UP, t), this._engine.requestRender();
    });
    f(this, "_handleClick", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_CLICK, t), this._engine.requestRender();
    });
    f(this, "_handleDblClick", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_DOUBLE_CLICK, t), this._engine.requestRender();
    });
    f(this, "_handleRightClick", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_RIGHT_CLICK, t), this._engine.requestRender();
    });
    f(this, "_handleRightDblClick", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_RIGHT_DOUBLE_CLICK, t), this._engine.requestRender();
    });
    f(this, "_handleMouseMove", (t) => {
      this._eventThrottle.putEvent(Jt.EVENT_NAME_MOUSE_MOVE, t), this._eventThrottle.putEvent(Jt.EVENT_NAME_MOUSE_ENTER, t), this._eventThrottle.putEvent(Jt.EVENT_NAME_MOUSE_LEAVE, t), this._engine.requestRender();
    });
    f(this, "_updateMouse", (t) => {
      const e = this._engine, i = e.map.getResolution();
      let n = t.pixel[0], o = t.pixel[1];
      const r = e.map.map.control;
      r && (n = n / (r.startScaleX || 1), o = o / (r.startScaleY || 1));
      const a = n / i.x, g = o / i.y;
      this._mouse.set(a * 2 - 1, 1 - g * 2), this._mousePosition.set(n, o);
    });
    this._engine = t, this._eventThrottle = new Yw(), this._isEventHandleBusy = !1, this._currentMouseEnterLeaveObjects = /* @__PURE__ */ new Map(), this._lastMouseEnterLeaveObjects = /* @__PURE__ */ new Map();
  }
  beginFrame() {
  }
  endFrame() {
    const t = this._eventThrottle;
    t.isBusy || t.isEmpty || t.triggerEvents(this._handleTriggerEvents);
  }
  _triggerMouseLeaveEvents(t) {
    const e = this._currentMouseEnterLeaveObjects, i = this._lastMouseEnterLeaveObjects;
    for (const [n, o] of i)
      if (!e.has(n)) {
        const r = n._listeners;
        if (!r || !r[Jt.EVENT_NAME_MOUSE_LEAVE] || r[Jt.EVENT_NAME_MOUSE_LEAVE].length === 0)
          continue;
        const a = t[Jt.EVENT_NAME_MOUSE_MOVE], g = r[Jt.EVENT_NAME_MOUSE_LEAVE], c = new ru(this._engine, a, o);
        c.target = n, c.currentTarget = n, c.intersection = o && o.intersection, this._executeCallbacks(g, c);
      }
  }
  async _triggerRootObjectEvents(t, e, i) {
    const n = this._engine.map, o = n._listeners;
    if (!o || Object.keys(o).length === 0)
      return;
    const r = Object.keys(t);
    let a = null;
    e && (a = e.point);
    let g = !0;
    for (const c of r) {
      if (i && i[c])
        continue;
      const l = o[c];
      if (!l || l.length === 0)
        continue;
      !a && g && (g = !1, a = await this._engine.rendering.picking.pickWorldPosition(this._mousePosition));
      const h = t[c], d = new ru(this._engine, h, null);
      d.target = e && e.object, d.currentTarget = n, d.intersection = e, d.position = a, this._executeCallbacks(l, d);
    }
  }
  _executeCallbacks(t, e) {
    for (const i of t) {
      if (!i)
        continue;
      const n = e.event;
      if (n && (n.defaultPrevented || n.domEvent && n.domEvent.defaultPrevented))
        return;
      try {
        i.isFlowEvent ? i.execute(e) : i(e);
      } catch (o) {
        console.error("error occurs when triggering callback", o);
      }
    }
  }
  bind(t, e, i) {
    typeof t == "string" && (i = e, e = t, t = this._engine.map), console.warn("bind is deprecated, use object.addEventListener instead"), t.addEventListener(e, i);
  }
  unbind(t, e, i) {
    typeof t == "string" && (i = e, e = t, t = this._engine.map), console.warn("unbind is deprecated, use object.removeEventListener instead"), t.removeEventListener(e, i);
  }
  markEventProxy(t, e) {
    console.warn("markEventProxy is deprecated, no need to call this method");
  }
  createMultipleToggleEvent(t, e = 0) {
    return new xP(t, e);
  }
  dispose() {
  }
};
let $t = Jt;
f($t, "EVENT_NAME_CLICK", "click"), f($t, "EVENT_NAME_DOUBLE_CLICK", "dblclick"), f($t, "EVENT_NAME_RIGHT_CLICK", "rightclick"), f($t, "EVENT_NAME_RIGHT_DOUBLE_CLICK", "rightdblclick"), f($t, "EVENT_NAME_MOUSE_MOVE", "mousemove"), f($t, "EVENT_NAME_MOUSE_ENTER", "mouseenter"), f($t, "EVENT_NAME_MOUSE_LEAVE", "mouseleave"), f($t, "EVENT_NAME_POINTER_DOWN", "pointerdown"), f($t, "EVENT_NAME_POINTER_UP", "pointerup");
const Qo = new Ia(), nm = [
  $t.EVENT_NAME_CLICK,
  $t.EVENT_NAME_DOUBLE_CLICK,
  $t.EVENT_NAME_MOUSE_MOVE,
  $t.EVENT_NAME_POINTER_DOWN,
  $t.EVENT_NAME_POINTER_UP,
  $t.EVENT_NAME_MOUSE_ENTER,
  $t.EVENT_NAME_MOUSE_LEAVE
], Dn = class {
  constructor(t) {
    f(this, "_useDepthPicking", !1);
    f(this, "_positionCache", {});
    f(this, "_seaLevelPositionCache", {});
    f(this, "_intersectionCache", {});
    f(this, "pixelToNdc", (t) => {
      const i = this._rendering.resolution;
      return new Z(t.x / i.x * 2 - 1, 1 - t.y / i.y * 2);
    });
    f(this, "ndcToPixel", (t) => {
      const i = this._rendering.resolution;
      return new Z((t.x + 1) / 2 * i.x, (1 - t.y) / 2 * i.y);
    });
    this._rendering = t;
  }
  init() {
  }
  dispose() {
  }
  beginFrame() {
    this._positionCache = {}, this._seaLevelPositionCache = {}, this._intersectionCache = {
      [Dn.PICK_INTERSECTION_TYPE_ALL]: {},
      [Dn.PICK_INTERSECTION_TYPE_VISIBLE]: {},
      [Dn.PICK_INTERSECTION_TYPE_EVENT]: {}
    }, this._rendering.features.depthPicking.enabled = this._useDepthPicking;
  }
  endFrame() {
  }
  onResolutionChange() {
  }
  async pickWorldPosition(t) {
    let e = await this.pickSceneWorldPosition(t);
    return e || (e = this.pickSeaLevelWorldPosition(t)), e;
  }
  async pickWorldPositionFromNdc(t) {
    const e = this.ndcToPixel(t);
    return await this.pickWorldPosition(e);
  }
  async pickSceneWorldPosition(t) {
    const e = `${Math.round(t.x)}_${Math.round(t.y)}`;
    if (this._positionCache[e] !== void 0)
      return this._positionCache[e];
    let i = await this._pickSceneWorldPosition(t);
    return this._positionCache[e] = i, i;
  }
  async pickSceneWorldPositionFromNdc(t) {
    const e = this.ndcToPixel(t);
    return await this.pickSceneWorldPosition(e);
  }
  async _pickSceneWorldPosition(t) {
    if (this._useDepthPicking)
      return await this._pickSceneWorldPositionFromDepth(t);
    const e = await this.pickIntersectionsOfVisibleObjects(t);
    let i = null;
    for (let o = 0, r = e.length; o < r; o++)
      if (!(e[o].object.isPoints || e[o].object.isLine || e[o].object.collisionDisabled || e[o].object.visible === !1)) {
        i = e[o];
        break;
      }
    if (i === null || !i.point)
      return null;
    let n = new B();
    return n.copy(i.point), n;
  }
  async _pickSceneWorldPositionFromDepth(t) {
    const e = this._rendering, i = e.features.depthPicking, n = this.pixelToNdc(t), o = await i.pickDepth(t.x, (n.y + 1) * 0.5 * e.resolution.y);
    if (o === null || o > 0.999999)
      return null;
    const r = new B(n.x, n.y, 2 * o - 1), a = e.camera;
    return r.unproject(a), r;
  }
  pickIntersections(t) {
    return this._pickIntersectionByRayRasting(
      Dn.PICK_INTERSECTION_TYPE_ALL,
      t
    );
  }
  async pickIntersectionsOfVisibleObjects(t) {
    return this._pickIntersectionByRayRasting(
      Dn.PICK_INTERSECTION_TYPE_VISIBLE,
      t,
      null
    );
  }
  async pickIntersectionsOfEventObjects(t, e = nm) {
    return this._pickIntersectionByRayRasting(
      Dn.PICK_INTERSECTION_TYPE_EVENT,
      t,
      e
    );
  }
  async _pickIntersectionByRayRasting(t, e, i = nm) {
    const n = `${Math.round(e.x)}_${Math.round(e.y)}`, o = this._intersectionCache[t];
    if (o[n] !== void 0)
      return o[n];
    const r = this._rendering.camera, a = this.pixelToNdc(e);
    Qo.setFromCamera(a, r), Qo.mouse.copy(a);
    let g = null;
    if (t === Dn.PICK_INTERSECTION_TYPE_ALL)
      g = Qo.intersectObjects(this._rendering.objectsScene.children, !0);
    else if (t === Dn.PICK_INTERSECTION_TYPE_VISIBLE) {
      const c = Ia.CHECK_VISIBLE;
      g = Qo.intersectFlagObjects(
        this._rendering.objectsScene.children,
        c,
        null,
        !0
      );
    } else if (t === Dn.PICK_INTERSECTION_TYPE_EVENT) {
      const c = Ia.CHECK_EVENT | Ia.CHECK_VISIBLE;
      g = Qo.intersectFlagObjects(
        this._rendering.objectsScene.children,
        c,
        i,
        !0
      );
    }
    return o[n] = g, g;
  }
  pickTerrainWorldPosition(t) {
    const e = this._pickIntersectionsWithCheckCallback(t, (i, n) => i.isMesh && i.isTerrainTile);
    return e.length > 0 ? e[0].point : null;
  }
  _pickIntersectionsWithCheckCallback(t, e) {
    return Qo.set(t.origin, t.direction), Qo.intersectFlagObjects(
      this._rendering.objectsScene.children,
      0,
      null,
      !0,
      e
    );
  }
  pickSeaLevelWorldPositionFromNdc(t) {
    const e = this.ndcToPixel(t);
    return this.pickSeaLevelWorldPosition(e);
  }
  pickSeaLevelWorldPosition(t) {
    const e = `${Math.round(t.x)}_${Math.round(t.y)}`;
    if (this._seaLevelPositionCache[e] !== void 0)
      return this._seaLevelPositionCache[e];
    let i = this._rendering._engine.map.pickSeaLevelWorldPosition(t);
    return this._seaLevelPositionCache[e] = i, i;
  }
  get useDepthPicking() {
    return this._useDepthPicking;
  }
  set useDepthPicking(t) {
    this._useDepthPicking = t;
  }
};
let oa = Dn;
f(oa, "PICK_INTERSECTION_TYPE_ALL", 1), f(oa, "PICK_INTERSECTION_TYPE_VISIBLE", 2), f(oa, "PICK_INTERSECTION_TYPE_EVENT", 3);
function sm(s, t, e = 1e-10) {
  e = W(e, 0);
  const i = s.elements, n = t.elements;
  return i === n || H(i) && H(n) && Math.abs(i[0] - n[0]) <= e && Math.abs(i[1] - n[1]) <= e && Math.abs(i[2] - n[2]) <= e && Math.abs(i[3] - n[3]) <= e && Math.abs(i[4] - n[4]) <= e && Math.abs(i[5] - n[5]) <= e && Math.abs(i[6] - n[6]) <= e && Math.abs(i[7] - n[7]) <= e && Math.abs(i[8] - n[8]) <= e && Math.abs(i[9] - n[9]) <= e && Math.abs(i[10] - n[10]) <= e && Math.abs(i[11] - n[11]) <= e && Math.abs(i[12] - n[12]) <= e && Math.abs(i[13] - n[13]) <= e && Math.abs(i[14] - n[14]) <= e && Math.abs(i[15] - n[15]) <= e;
}
class TP {
  constructor(t) {
    f(this, "_stage", null);
    f(this, "_time", 0);
    f(this, "_startTime", 0);
    f(this, "_elapsedTime", 0);
    f(this, "_viewChanged", !1);
    f(this, "_viewMatrixWorld", new J());
    f(this, "_viewMatrixWorldInverse", new J());
    f(this, "_projectionMatrix", new J());
    f(this, "_cameraMatrix", new J());
    f(this, "_cameraMatrixInverse", new J());
    f(this, "_cameraOffsetX", 0);
    f(this, "_cameraOffsetY", 0);
    f(this, "_cameraOffset", new B());
    f(this, "_frameCount", 0);
    f(this, "_viewStableFrameCount", 0);
    f(this, "_isRendererRecreated", !1);
    f(this, "_cameraLocation", new B());
    this._rendering = t, this._startTime = new Date().getTime(), this._time = this._startTime;
  }
  beginFrame(t, e) {
    this._deltaTime = e - this._time, this._deltaSeconds = this._deltaTime / 1e3, this._time = e, this._elapsedTime = e - this._startTime;
    const i = t.renderer.info.render.frame;
    i < this._frameCount && (this._isRendererRecreated = !0), this._frameCount = i;
    const n = t.camera, o = n.matrixWorld, r = n.projectionMatrix;
    !sm(o, this._viewMatrixWorld, 1e-8) || !sm(r, this._projectionMatrix, 1e-8) ? (this._viewChanged = !0, this._viewStableFrameCount = 0, t.requestRender()) : (this._viewChanged = !1, this._viewStableFrameCount++), this._viewMatrixWorld.copy(n.matrixWorld), this._viewMatrixWorldInverse.copy(n.matrixWorldInverse), this._projectionMatrix.copy(n.projectionMatrix);
  }
  endFrame() {
    this._isRendererRecreated = !1;
  }
  updateCameraOffsetState(t, e, i, n) {
    this._cameraMatrix.copy(t.matrixWorld), this._cameraMatrixInverse.copy(t.matrixWorldInverse), this._cameraOffsetX = e, this._cameraOffsetY = i, this._cameraOffset.set(e, i, n);
  }
  getDepthByDistance(t) {
    const e = this._rendering.camera, i = e.far, n = e.near;
    return e.isPerspectiveCamera ? this._rendering.renderer.capabilities.logarithmicDepthBuffer ? Math.log(t + 1) / Math.log(i + 1) : i * (t - n) / (t * (i - n)) : (i - t) / (i - n);
  }
  get time() {
    return this._time;
  }
  get viewChanged() {
    return this._viewChanged;
  }
  get viewMatrixWorld() {
    return this._viewMatrixWorld;
  }
  get viewMatrixWorldInverse() {
    return this._viewMatrixWorldInverse;
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get cameraMatrix() {
    return this._cameraMatrix;
  }
  get cameraMatrixInverse() {
    return this._cameraMatrixInverse;
  }
  get cameraOffsetX() {
    return this._cameraOffsetX;
  }
  get cameraOffsetY() {
    return this._cameraOffsetY;
  }
  get deltaTime() {
    return this._deltaTime;
  }
  get elapsedTime() {
    return this._elapsedTime;
  }
  get deltaSeconds() {
    return this._deltaSeconds;
  }
  get frameCount() {
    return this._frameCount;
  }
  get viewStableFrameCount() {
    return this._viewStableFrameCount;
  }
  get cameraOffset() {
    return this._cameraOffset;
  }
  get isRendererRecreated() {
    return this._isRendererRecreated;
  }
  set stage(t) {
    this._stage = t;
  }
  get stage() {
    return this._stage;
  }
}
class LP {
  constructor(t, e = 0) {
    this.taskFunc = t, this.priority = e, this._isCancelled = !1, this._isStart = !1;
  }
  execute() {
    this._isStart = !0, !this.isCancelled() && this.taskFunc().catch((t) => console.error("Task failed:", t));
  }
  cancel() {
    this._isCancelled = !0;
  }
  isCancelled() {
    return this._isCancelled;
  }
  isStart() {
    return this._isStart;
  }
}
class GP {
  constructor(t) {
    f(this, "_frameDurationList", []);
    f(this, "_maxTaskCount", 1e3);
    f(this, "_taskQueue", []);
    this._rendering = t;
  }
  beginFrame() {
    if (this._frameStartTime = performance.now(), this._lastFrameStartTime) {
      const t = this._frameStartTime - this._lastFrameStartTime;
      this._frameDurationList.push(t), this._frameDurationList.length > 5 && this._frameDurationList.shift();
    }
    this._lastFrameStartTime = this._frameStartTime;
  }
  endFrame() {
    if (this._frameDurationList.length < 5)
      return;
    const t = performance.now(), e = t - this._frameStartTime, i = this._frameDurationList.reduce((r, a) => r + a, 0) / this._frameDurationList.length;
    let n = Math.min(16, i) - e;
    const o = this._taskQueue;
    for (; o.length > 0; ) {
      const { task: r } = this._taskQueue.shift();
      if (r.execute(), performance.now() - t >= n && o.length <= this._maxTaskCount)
        break;
    }
  }
  addTask(t, e = 0) {
    const i = new LP(t, e);
    return this._taskQueue.push({ task: i, priority: e }), this._taskQueue.sort((n, o) => o.priority - n.priority), i;
  }
  get maxTaskCount() {
    return this._maxTaskCount;
  }
  set maxTaskCount(t) {
    this._maxTaskCount = t;
  }
  get taskCount() {
    return this._taskQueue.length;
  }
}
const om = {};
function $i(s) {
  s in om || (om[s] = !0, console.warn(s));
}
const rm = {};
function MP(s) {
  s in rm || (rm[s] = !0, console.error(s));
}
const am = new J(), Pr = new Bn(), gm = new Nh(), EP = (s, t) => s.groupOrder !== t.groupOrder ? s.groupOrder - t.groupOrder : s.renderOrder !== t.renderOrder ? s.renderOrder - t.renderOrder : s.material.name !== t.material.name ? s.material.name > t.material.name ? 1 : -1 : s.material.type !== t.material.type ? s.material.type - t.material.type : s.material.id !== t.material.id ? s.material.id - t.material.id : s.z !== t.z ? s.z - t.z : s.id - t.id, RP = (s, t) => s.groupOrder !== t.groupOrder ? s.groupOrder - t.groupOrder : s.renderOrder !== t.renderOrder ? s.renderOrder - t.renderOrder : s.z !== t.z ? t.z - s.z : s.id - t.id, DP = `
    #include <common>
    #include <logdepthbuf_pars_vertex>
    void main() {
        #include <begin_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
    }
`, KP = `
    #include <common>
    #include <logdepthbuf_pars_fragment>
    uniform vec3 color;
    void main() {
        gl_FragColor = vec4( color, 1.0 );
        #include <logdepthbuf_fragment>
    }
`, cm = [
  4886754,
  5289385,
  7184241,
  12888157,
  14191694,
  12017001,
  10189749
], lm = 0, HP = 1, PP = 2, NP = 3;
let FP = 1;
class kP {
  constructor(t, e = {}) {
    f(this, "_engine");
    f(this, "_outputEncoding");
    f(this, "_enableAnimationLoop");
    f(this, "_animationLoopFrameTime");
    f(this, "_uniforms");
    f(this, "_main");
    f(this, "_bloom");
    f(this, "_ssr");
    f(this, "_composition");
    f(this, "_label");
    f(this, "_renderState");
    f(this, "_camera");
    f(this, "_canvas");
    f(this, "_context");
    f(this, "_renderer");
    f(this, "_scene");
    f(this, "_weather");
    f(this, "_useMRT", !1);
    f(this, "_isUseMRTChanged", !1);
    f(this, "_freezeUpdate", !1);
    f(this, "_isRunning", !1);
    f(this, "_needsRenderImmediately", !1);
    f(this, "_needsRenderNext", !1);
    f(this, "_beforeRenderListeners", []);
    f(this, "_prepareRenderListeners", []);
    f(this, "_startTime", 0);
    f(this, "_pixelRatio", window.devicePixelRatio);
    f(this, "_resolution");
    f(this, "_sky", null);
    f(this, "_debugShaderType", 0);
    f(this, "_beforeScenePrepareRenderObjects", /* @__PURE__ */ new Set());
    f(this, "_beforeSceneRenderObjects", /* @__PURE__ */ new Set());
    f(this, "_onRenderModeChangedObjects", /* @__PURE__ */ new Set());
    f(this, "_useClip");
    f(this, "_wireframe", !0);
    f(this, "_debugMaterial", null);
    f(this, "_debugMode", lm);
    f(this, "_autoOffsetRelativeCenter", !0);
    f(this, "_clampCameraNearFar", !1);
    f(this, "_options", {});
    f(this, "lastRenderTime", 0);
    f(this, "_contextParameters", {
      alpha: !0,
      stencil: !0,
      antialias: !1,
      powerPreference: "high-performance",
      preserveDrawingBuffer: !1,
      premultipliedAlpha: !1
    });
    f(this, "_needsReCreateRenderer", !1);
    f(this, "_frameDuration", 100);
    f(this, "_useHighPrecisionBuffer", !1);
    f(this, "handleShaderBeforeResolve", (t, e, i) => {
      if (this._useMRT) {
        const n = this._renderer.getRenderTarget();
        n && n.isWebGLMultipleRenderTargets && (e = this.convertMrtSupportedFragment(e));
      } else
        e = this.convertNMrtSupportedFragment(e, i.shaderID);
      return i.shaderID === "basic" && (e = `#define BASIC
uniform vec3 emissive;
` + e), t = AE(t), e = CE(e), {
        vertexShader: t,
        fragmentShader: e
      };
    });
    f(this, "handleShaderBeforeCompile", (t, e, i) => {
      if (t = IE(t), this._useMRT) {
        const n = this._renderer.getRenderTarget();
        n && n.isWebGLMultipleRenderTargets && i.isRawShaderMaterial && i.glslVersion !== sT && (t = [
          "#version 300 es",
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + t, e = [
          "#version 300 es",
          "#define varying in",
          "layout(location = 0) out highp vec4 pc_fragColor;",
          "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + e);
      }
      return {
        vertexShader: t,
        fragmentShader: e
      };
    });
    f(this, "handleMaterialBeforeCompile", (t, e) => {
      t.handleMaterialBeforeCompile && t.handleMaterialBeforeCompile(this._engine, this), this.shadow.enabled && this.shadow.method === "csm" && this.shadow.updateCSMShadow(t, e);
    });
    f(this, "convertMrtSupportedFragment", (t) => t = this._main.sceneRendering.modifyFragmentShader(t));
    f(this, "convertNMrtSupportedFragment", (t, e) => t = hE(t));
    f(this, "render", () => {
      if (!this._isRunning)
        return;
      this._beginFrame(), this._useXR || requestAnimationFrame(this.render);
      const t = new Date().valueOf();
      if ((this._needsRenderNext || this._enableAnimationLoop) && this._animationLoopFrameTime < 17 && (this._needsRenderImmediately = !0), !(this._needsRenderImmediately || (this._needsRenderNext || this._enableAnimationLoop) && t - this.lastRenderTime >= this._animationLoopFrameTime)) {
        this._endFrame();
        return;
      }
      let e = this._needsRenderImmediately ? 0 : t - this.lastRenderTime - this._animationLoopFrameTime;
      e > this._animationLoopFrameTime - 16 && (e = this._animationLoopFrameTime - 16), this.lastRenderTime = t - e, this._needsRenderImmediately = !1, this._needsRenderNext = !1;
      const i = this._stats;
      i.beginTimeStatsItem("renderAll");
      try {
        this.renderScene(t);
      } catch (n) {
        console.error("renderScene error", n);
      } finally {
        i.endTimeStatsItem("renderAll"), this._endFrame();
      }
    });
    f(this, "scaleZAtCurrentPosition", () => {
      const t = this._engine.map, e = t.getScaleAt(t.getCenter());
      this.scene.scale.z = e;
    });
    f(this, "showCurrentViewFrustum", () => {
      this._currentViewCamera ? this._currentViewCamera.copy(this._camera) : this._currentViewCamera = this._camera.clone();
      const t = this._currentViewCameraHelper = new zA(this._currentViewCamera);
      t.matrixAutoUpdate = !1, this.add(t);
    });
    f(this, "removeCurrentViewFrustum", () => {
      !this._currentViewCameraHelper || (this.remove(this._currentViewCameraHelper), this._currentViewCameraHelper = null, this._currentViewCamera = null);
    });
    this._engine = t;
    const i = this._options = this.getInitialConfig(e);
    Object.assign(this._contextParameters, i.contextParameters), i.preserveDrawingBuffer && (this._contextParameters.preserveDrawingBuffer = !0);
    const n = i.features.antialias;
    this._contextParameters.antialias = n.enabled && n.method === "msaa", this._enableAnimationLoop = i.enableAnimationLoop || !1, this._animationLoopFrameTime = i.animationLoopFrameTime || 16, this._useMRT = i.useMRT || !1, this._useXR = i.useXR || !1, this._pixelRatio = i.pixelRatio || window.devicePixelRatio, this._resolution = e.resolution, this._uniforms = {
      time: {
        value: 0
      },
      elapsedTime: {
        value: 0
      },
      pixelRatio: {
        value: this._pixelRatio
      },
      zoomUnits: {
        value: 1
      },
      resolution: {
        value: new Z(i.resolution.x, i.resolution.y)
      }
    }, Object.freeze(this._uniforms), this._stats = new BP(this), this._main = new pK(this, i), this._picking = new oa(this), this._label = new rP(this), this._collision = new mP(this), this._animation = new yP(this), this._xr = new SP(this), this._renderState = new TP(this), this._taskScheduler = new GP(this);
  }
  getInitialConfig(t) {
    const e = {
      useMRT: !1,
      enableAnimationLoop: !1,
      animationLoopFrameTime: 16,
      useXR: !1,
      pixelRatio: window.devicePixelRatio,
      features: {
        antialias: {
          enabled: !0,
          method: "smaa"
        },
        bloom: {
          enabled: !1,
          strength: 0.1,
          threshold: 1,
          radius: 0
        },
        ao: {
          enabled: !1,
          method: "ssao"
        },
        reflection: {
          enabled: !1,
          method: "ssr"
        },
        shadow: {
          enabled: !1,
          method: "default"
        },
        depthPicking: {
          enabled: !1
        },
        colorAdjustment: {
          enabled: !1
        },
        hdr: {
          enabled: !1
        }
      }
    };
    return rh(e, t);
  }
  init() {
    const t = this._resolution;
    this._options.isOrthographicCamera ? this._camera = new Zg(
      -t.x / 2,
      t.x / 2,
      t.y / 2,
      -t.y / 2,
      0.1,
      1e6
    ) : this._camera = new Ys(35, t.x / t.y, 1, 100), this._camera.matrixAutoUpdate = !1;
    const e = this._scene = new Kh(), i = this.uiScene = new mt(), n = this.objectsScene = new mt(), o = this.environmentScene = new mt();
    n.add(i), e.add(n), e.add(o), e.matrixWorldAutoUpdate = !1, this._createRenderer(), this._uniforms.resolution.value[0] = t.x, this._uniforms.resolution.value[1] = t.y, this._picking.init(), this._xr.init();
    let r = this._options.sky;
    r === void 0 && (r = new ID()), r && this.add(r);
  }
  _createRenderer() {
    const t = this._resolution, e = this._engine;
    let i = !!this._renderer, n = 1;
    i && (n = this._renderer.envMapIntensity, e.map.releaseCanvas(), this._renderer.forceContextLoss(), this._renderer.dispose());
    const o = this._canvas = document.createElement("canvas");
    Re(o, `${Vt}-canvas`), o.style.position = "absolute", o.style.top = "0", o.style.left = "0", o.style.zIndex = "2";
    const r = this._context = o.getContext("webgl2", this._contextParameters), a = this._renderer = new VA({
      canvas: o,
      context: r,
      logarithmicDepthBuffer: !0
    });
    a.setClearColor(16777215, 0), a.setPixelRatio(this._pixelRatio), a.setSize(t.x, t.y), a.setOpaqueSort(EP), a.setTransparentSort(RP), a.info.autoReset = !1, this._renderer.extraProgramCacheKey = "0", this._renderer.envMapIntensity = n, a.onShaderBeforeResolve = this.handleShaderBeforeResolve, a.onShaderBeforeCompile = this.handleShaderBeforeCompile, a.onMaterialBeforeCompile = this.handleMaterialBeforeCompile, i && (e.map._map.canvas = o, e.map.bindCanvas());
  }
  addBeforeRenderListener(t) {
    this._beforeRenderListeners.indexOf(t) === -1 && this._beforeRenderListeners.push(t);
  }
  removeBeforeRenderListener(t) {
    const e = this._beforeRenderListeners.indexOf(t);
    e > -1 && this._beforeRenderListeners.splice(e, 1);
  }
  addPrepareRenderListener(t) {
    this._prepareRenderListeners.indexOf(t) === -1 && this._prepareRenderListeners.push(t);
  }
  removePrepareRenderListener(t) {
    const e = this._prepareRenderListeners.indexOf(t);
    e > -1 && this._prepareRenderListeners.splice(e, 1);
  }
  add(t) {
    return t.traverse((e) => {
      e.afterAddToEngine && !e.__initInEngine && (e.__initInEngine = !0, e.afterAddToEngine(this._engine)), e instanceof gh ? this.sky = e : e instanceof _p && (this.weather = e), this.addBeforePrepareRenderObject(e), this.addBeforeRenderObject(e), this.addOnRenderModeChangeObject(e);
    }), t.__isEnvironment ? this.environmentScene.add(t) : t.isRenderInPostprocess ? this.uiScene.add(t) : this.objectsScene.add(t), this._needsRenderImmediately = !0, t.userData.__debugObjectId || (t.userData.__debugObjectId = FP++), t;
  }
  remove(t) {
    !t || (t.traverse((e) => {
      e.beforeRemoveFromEngine && (e.__initInEngine = void 0, e.beforeRemoveFromEngine(this._engine)), e instanceof gh ? this._sky = null : e instanceof _p && (this._weather = null), this.removeBeforeRenderObject(e), this.removeBeforePrepareRenderObject(e), this.removeOnRenderModeChangeObject(e);
    }), t.__isEnvironment ? this.environmentScene.remove(t) : t.isRenderInPostprocess ? this.uiScene.remove(t) : this.objectsScene.remove(t), this._needsRenderImmediately = !0);
  }
  addBeforePrepareRenderObject(t) {
    t.onBeforeScenePrepareRender && this._beforeScenePrepareRenderObjects.add(t);
  }
  removeBeforePrepareRenderObject(t) {
    this._beforeScenePrepareRenderObjects.delete(t);
  }
  addBeforeRenderObject(t) {
    t.onBeforeSceneRender && this._beforeSceneRenderObjects.add(t);
  }
  removeBeforeRenderObject(t) {
    this._beforeSceneRenderObjects.delete(t);
  }
  addOnRenderModeChangeObject(t) {
    t.onRenderModeChanged && this._onRenderModeChangedObjects.add(t);
  }
  removeOnRenderModeChangeObject(t) {
    t.onRenderModeChanged && this._onRenderModeChangedObjects.delete(t);
  }
  startRenderLoop() {
    this._isRunning = !0, this._needsRenderImmediately = !0, this._startTime = new Date().valueOf(), this.render();
  }
  stopRenderLoop() {
    this._isRunning = !1;
  }
  updateCamera() {
    this._engine.map.updateCamera();
  }
  requestRender() {
    this._needsRenderImmediately = !0;
  }
  renderScene(t) {
    const e = this._engine, i = e.event, n = this._stats;
    t || (t = new Date().valueOf()), this._uniforms.time.value = t, this._uniforms.elapsedTime.value = t - this._startTime, this._uniforms.zoomUnits.value = this._engine.map.getZoomUnits(), this.camera._isLocked || this.updateCamera();
    const o = this._camera, r = this._scene, a = this._renderer;
    this.environmentScene.visible = !1;
    const g = this._renderState;
    i.beginFrame(), g.beginFrame(this, t), this._picking.beginFrame(), this._main.beginFrame(), this._needsReCreateRenderer && (this._needsReCreateRenderer = !1, this._createRenderer()), g._viewChanged && o.dispatchEvent({
      type: "viewchanged"
    }), n.beginTimeStatsItem("updateAnimation"), this._animation.update(g), n.endTimeStatsItem("updateAnimation");
    for (let A of this._prepareRenderListeners)
      A(this._engine, g);
    this._beforeScenePrepareRenderObjects.forEach((A) => {
      A.onBeforeScenePrepareRender(e, r, o, g);
    });
    const l = o.position.clone();
    let h = 0, d = 0, C = 0;
    const p = 1e3, m = Math.floor(l.x / p) * p, b = Math.floor(l.y / p) * p, S = Math.floor(l.z / p) * p;
    h = l.x - m, d = l.y - b, C = l.z - S, this._autoOffsetRelativeCenter ? (a.xr.isPresenting && this._xr.xrCamera.position.set(m + h, b + d, S + C), o.position.set(h, d, C), o.updateMatrix(), o.updateMatrixWorld(), r.position.set(-m, -b, -S), g.updateCameraOffsetState(o, m, b, S)) : (a.xr.isPresenting && this._xr.xrCamera.position.copy(l), g.updateCameraOffsetState(o, 0, 0, 0)), r.updateMatrix(), r.updateMatrixWorld(), this._clampCameraNearFar && this._computeCameraNearFar(), a.info.reset(), n.beginTimeStatsItem("updateCollision"), this._collision.update(g), n.endTimeStatsItem("updateCollision"), this._beforeSceneRenderObjects.forEach((A) => {
      A.onBeforeSceneRender(e, r, o, g);
    });
    for (let A of this._beforeRenderListeners)
      A(this._engine, g);
    n.beginTimeStatsItem("updateNodeMaterials"), ia.update(), n.endTimeStatsItem("updateNodeMaterials"), n.beginTimeStatsItem("renderMain"), this._main.render(), n.endTimeStatsItem("renderMain"), this._autoOffsetRelativeCenter && (a.xr.isPresenting && this._xr.xrCamera.position.copy(l), o.position.copy(l), o.updateMatrix(), o.updateMatrixWorld(), r.position.set(0, 0, 0), r.updateMatrix(), r.updateMatrixWorld()), this._main.endFrame(), this._picking.endFrame(), g.endFrame(this), i.endFrame(), this._useMRTChanged = !1;
  }
  _computeCameraNearFar() {
    const t = this._camera, e = this._scene;
    am.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), gm.setFromProjectionMatrix(am);
    const i = new Z(1 / 0, 0), n = [null, null];
    this._computeObjectNearFar(e, t, gm, i, n), i.x < 0.1 && (i.x = 0.1), t.near = i.x, t.far = i.y, t.updateProjectionMatrix();
  }
  _computeObjectNearFar(t, e, i, n, o) {
    if (t.visible === !1)
      return;
    if (t.layers.test(e.layers) && (t.isMesh || t.isLine || t.isPoints || t.isSprite)) {
      if (t.isFSQuad)
        return;
      if (!t.frustumCulled || i.intersectsObject(t)) {
        const g = t.geometry;
        if (g.boundingSphere || g.computeBoundingSphere(), !g.boundingSphere)
          return;
        if (Pr.copy(g.boundingSphere), Pr.applyMatrix4(t.matrixWorld), Pr.radius > 0) {
          const c = Pr.center.distanceTo(e.position), l = c - Pr.radius, h = c + Pr.radius;
          n.x > l && (n.x = l, o[0] = t), n.y < h && (n.y = h, o[1] = t);
        }
      }
    }
    const a = t.children;
    if (a)
      for (let g = 0, c = a.length; g < c; g++)
        this._computeObjectNearFar(a[g], e, i, n, o);
  }
  _beginFrame() {
    this._taskScheduler.beginFrame();
  }
  _endFrame() {
    this._taskScheduler.endFrame();
  }
  updateContextParameters(t) {
    const e = this._contextParameters;
    for (const i of Object.keys(t))
      e[i] !== t[i] && (e[i] = t[i], this._needsReCreateRenderer = !0);
  }
  setResolution(t) {
    this._resolution.copy(t), this._uniforms.resolution.value.copy(t), this._renderer.setSize(t.x, t.y), this._main.setSize(t.x, t.y), this._picking.onResolutionChange(), this._needsRenderNext = !0;
  }
  dispose() {
    this.stopRenderLoop(), this._debugMaterial && this._debugMaterial.dispose();
    const t = Array.from(this.objectsScene.children), e = Array.from(this.environmentScene.children);
    for (let n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      this.remove(o), o.dispose && o.dispose();
    }
    for (let n = e.length - 1; n >= 0; n--) {
      const o = e[n];
      this.remove(o), o.dispose && o.dispose();
    }
    this._picking.dispose(), this._renderer.dispose();
    let i = this._context.getExtension("WEBGL_lose_context");
    i && i.loseContext();
  }
  get engine() {
    return this._engine;
  }
  get contextParameters() {
    return this._contextParameters;
  }
  get sky() {
    return this._sky;
  }
  set sky(t) {
    this._sky && console.warn("you are trying to set sky, but it has already been set.Please use `engine.remove(oldSky)` before setting a new sky."), this._sky = t;
  }
  get weather() {
    return this._weather;
  }
  set weather(t) {
    this._weather && console.warn("you are trying to set weather, but it has already been set.Please use `engine.remove(oldWeather)` before setting a new weather."), this._weather = t;
  }
  get debugShaderType() {
    return this._debugShaderType;
  }
  set debugShaderType(t) {
    if (this._debugShaderType = t, !this._useMRT)
      return;
    t = parseInt(t, 10);
    const e = this._composition;
    if (!t || t === 0)
      e.debugTextures = null;
    else if (t === 1)
      e.debugTextures = this._main.getTextures();
    else if (t === 2) {
      const i = [];
      this.objectsScene.traverse((n) => {
        n.isLight && n.shadow && n.shadow.map && i.push(n.shadow.map.texture);
      }), e.debugTextures = i;
    } else
      t === 3 ? e.debugTextures = this._bloom.getTextures() : t === 4 ? e.debugTextures = this._ssr.getTextures() : t === 5 && this._sky && this._sky.getTextures && (e.debugTextures = this._sky.getTextures());
  }
  get isUseMRTChanged() {
    return this._useMRTChanged;
  }
  get useMrt() {
    return this.useMRT;
  }
  set useMrt(t) {
    this.useMRT = t;
  }
  get useMRT() {
    return this._useMRT;
  }
  set useMRT(t) {
    this._useMRT !== t && (this._useMRT = t, this._useMRTChanged = !0);
  }
  get main() {
    return this._main;
  }
  get shadow() {
    return this._main.features.shadow;
  }
  get bloom() {
    return this._main.features.bloom;
  }
  get ssr() {
    return $i("deprecated, ssr has been removed"), {};
  }
  get composition() {
    return $i("deprecated, composition has been removed"), {};
  }
  get fog() {
    return $i("deprecated, fog has been removed"), {};
  }
  get postprocessing() {
    return $i("deprecated, postprocessing has been removed"), {};
  }
  get label() {
    return this._label;
  }
  get colorAdjustment() {
    return this._main.features.colorAdjustment;
  }
  get renderState() {
    return this._renderState;
  }
  get pick() {
    return $i("`rendering.pick` is deprecated, use `.picking` instead"), this._picking;
  }
  get picking() {
    return this._picking;
  }
  get stats() {
    return this._stats;
  }
  get collision() {
    return this._collision;
  }
  get animation() {
    return this._animation;
  }
  get xr() {
    return this._xr;
  }
  get taskScheduler() {
    return this._taskScheduler;
  }
  get enableAnimationLoop() {
    return this._enableAnimationLoop;
  }
  set enableAnimationLoop(t) {
    this._enableAnimationLoop = t;
  }
  get animationLoopFrameTime() {
    return this._animationLoopFrameTime;
  }
  set animationLoopFrameTime(t) {
    this._animationLoopFrameTime = t;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution = t;
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(t) {
    this._pixelRatio = t;
  }
  get outputEncoding() {
    return this._outputEncoding;
  }
  set outputEncoding(t) {
    this._outputEncoding = t;
  }
  get canvas() {
    return this._canvas;
  }
  get renderer() {
    return this._renderer;
  }
  get camera() {
    return this._camera;
  }
  get scene() {
    return this._scene;
  }
  get uniforms() {
    return this._uniforms;
  }
  set wireframe(t) {
    this._wireframe = t, this._debugMaterial && (this._debugMaterial.wireframe = t);
  }
  get wireframe() {
    return this._wireframe;
  }
  set debugMode(t) {
    t = parseInt(t, 10), t !== this._debugMode && (this._debugMode = t, t !== lm ? (this._debugMaterial || (this._debugMaterial = new ze({
      uniforms: {
        color: {
          value: new Ce(35071)
        }
      },
      vertexShader: DP,
      fragmentShader: KP,
      wireframe: this._wireframe
    }), this._debugMaterial.onBeforeRender = (e, i, n, o, r, a) => {
      let g = 0;
      const c = this._debugMode;
      if (c === HP)
        g = r.id;
      else if (c === PP)
        g = r.material.id;
      else if (c === NP) {
        let h = r;
        do
          if (h.userData.__debugObjectId) {
            g = h.userData.__debugObjectId;
            break;
          }
        while (h.parent && (h = h.parent));
      }
      let l = null;
      g ? l = cm[g % cm.length] : l = 13750737, this._debugMaterial.uniforms.color.value.set(l), this._debugMaterial.uniformsNeedUpdate = !0;
    }), this._scene.overrideMaterial = this._debugMaterial) : (this._scene.overrideMaterial = null, this._debugMaterial.dispose(), this._debugMaterial = null));
  }
  get debugMode() {
    return this._debugMode;
  }
  get autoOffsetRelativeCenter() {
    return this._autoOffsetRelativeCenter;
  }
  set autoOffsetRelativeCenter(t) {
    this._autoOffsetRelativeCenter = t;
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(t) {
    !!t !== this._freezeUpdate && (this._freezeUpdate = !!t, t ? this.stopRenderLoop() : this.startRenderLoop());
  }
  get useHighPrecisionBuffer() {
    return this._useHighPrecisionBuffer;
  }
  set useHighPrecisionBuffer(t) {
    this._useHighPrecisionBuffer = t;
  }
  get clampCameraNearFar() {
    return this._clampCameraNearFar;
  }
  set clampCameraNearFar(t) {
    this._clampCameraNearFar = t;
  }
}
const hm = new js(), VP = new Zt(new B(0, 0, 1), 0), Bc = new B(), to = new B();
class Jh {
  constructor(t, e) {
    this._engine = t, this._options = e;
  }
  init() {
  }
  parsePointToArr(t) {
    if (!t)
      return null;
    let e = [];
    if (Array.isArray(t))
      for (let i of t)
        e.push(parseFloat(i));
    else if (typeof t == "string") {
      const i = t.split(",");
      for (let n = 0; n < i.length; n++)
        e[n] = parseFloat(i[n]);
    } else
      typeof t == "object" && t.isVector3 && (e = [t.x, t.y, t.z]);
    return e;
  }
  projectArrayCoordinate(t, e) {
    return Bc.set(t[0], t[1], t[2] || 0), this.projection.projectCoordinate(Bc, to), e || (e = [0, 0, 0]), e[0] = to.x, e[1] = to.y, e[2] = to.z, e;
  }
  unprojectArrayCoordinate(t, e) {
    return Bc.set(t[0], t[1], t[2] || 0), this.projection.unprojectCoordinate(Bc, to), e || (e = [0, 0, 0]), e[0] = to.x, e[1] = to.y, e[2] = to.z, e;
  }
  getViewHeight() {
    return this.camera.position.z;
  }
  bindCanvas() {
    console.warn("bindCanvas must be implemented in subclass");
  }
  releaseCanvas() {
    console.warn("releaseCanvas must be implemented in subclass");
  }
  pickSeaLevelWorldPosition(t) {
    const e = this._engine.camera, i = this._engine.rendering.picking.pixelToNdc(t);
    hm.setFromCamera(i, e);
    const n = new B();
    return hm.ray.intersectPlane(VP, n), n;
  }
  dispose() {
  }
}
const rA = !!window.PointerEvent, zP = /ipod|ipad|iphone|android/.test(navigator.userAgent.toLowerCase()), au = (s) => s && s.pointerType === "touch", XP = (s) => s.type.includes("touch"), ye = (() => {
  let s;
  return rA ? s = {
    DOWN: "pointerdown",
    MOVE: "pointermove",
    UP: "pointerup",
    CANCEL: "pointercancel"
  } : zP ? s = {
    DOWN: "touchstart",
    MOVE: "touchmove",
    UP: "touchend",
    CANCEL: "touchcancel"
  } : s = {
    DOWN: "mousedown",
    MOVE: "mousemove",
    UP: "mouseup",
    CANCEL: "mousecancel"
  }, s;
})(), Qn = {
  NONE: 0,
  PAN: 1,
  ROTATE: 2,
  ZOOM: 3
}, Za = new Z(), dm = new js(), WP = new Zt(new B(0, 0, 1), 0);
new B();
const Yo = new B(), gu = new B(), Ua = new B(), aA = new Ys();
aA.fov = 35;
new Z();
class ZP {
  constructor(t) {
    f(this, "map");
    f(this, "currentAction");
    f(this, "startX");
    f(this, "startY");
    f(this, "startCenterX");
    f(this, "startCenterY");
    f(this, "startPitch");
    f(this, "startHeading");
    f(this, "startZoom");
    f(this, "startZoomUnits");
    f(this, "startAtTop");
    f(this, "mapWidth");
    f(this, "mapHeight");
    f(this, "startCamera", new Ys());
    f(this, "startCenter", new B());
    f(this, "startNdc", new Z());
    f(this, "startPoint", new B());
    f(this, "startScaleX", 1);
    f(this, "startScaleY", 1);
    f(this, "startBoundX");
    f(this, "startBoundY");
    f(this, "_enabled", !1);
    f(this, "minPitch", 0);
    f(this, "maxPitch", 89);
    f(this, "zoomSpeed", 5e-3);
    f(this, "headingSpeed", 0.4);
    f(this, "pitchSpeed", 0.3);
    f(this, "doubleClickTimer", null);
    f(this, "clickInterval", 200);
    f(this, "init", () => {
      const t = this.map.domContainer;
      t.addEventListener(ye.DOWN, this.handleMouseDown), t.addEventListener("wheel", this.handleWheel), t.addEventListener("contextmenu", this.handleContextMenu), t.addEventListener(ye.MOVE, this.handleMouseMove);
    });
    f(this, "handleResize", (t) => {
      const [e, i] = this.map.getContainerSize();
      this.mapWidth = e, this.mapHeight = i;
      const n = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = n.left, this.startBoundY = n.top, this.startScaleX = n.width / e, this.startScaleY = n.height / i;
    });
    f(this, "handleMouseMove", (t) => {
      this.currentAction === Qn.NONE && this.onEventMouseMove && this.onEventMouseMove(t);
    });
    f(this, "handleMouseDown", (t) => {
      let e = this.mapHeight, i = this.mapWidth;
      const n = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = n.left, this.startBoundY = n.top, this.startScaleX = n.width / i, this.startScaleY = n.height / e;
      const o = (t.clientX - this.startBoundX) / this.startScaleX, r = (t.clientY - this.startBoundY) / this.startScaleY;
      if (t.button === 0 ? (this.startZoomUnits = this.map.getZoomUnitsByZoom(this.map.zoom), this.setPanStartState(o, r), this.currentAction = Qn.PAN) : t.button === 2 ? this.currentAction = Qn.ROTATE : this.currentAction = Qn.NONE, this.currentAction === Qn.NONE)
        return;
      t && this.onEventPointerDown && (this.hasMoved || this.onEventPointerDown(t)), this.startX = o, this.startY = r;
      const a = this.map;
      this.startCenterX = a.center[0], this.startCenterY = a.center[1], this.startPitch = a.pitch, this.startHeading = a.heading, this.startZoom = a.zoom, this.startAtTop = r < e / 2, document.addEventListener(ye.MOVE, this.handleMouseDragging), document.addEventListener(ye.UP, this.handleMouseUp);
    });
    f(this, "handleMouseDragging", (t) => {
      if (this.currentAction === Qn.NONE)
        return;
      this.hasMoved = !0;
      const e = this.currentPixelX = (t.clientX - this.startBoundX) / this.startScaleX, i = this.currentPixelY = (t.clientY - this.startBoundY) / this.startScaleY;
      this.currentAction === Qn.PAN ? this.handlePan(e, i) : this.currentAction === Qn.ROTATE && this.handleRotate(e, i);
    });
    f(this, "handleMouseUp", (t) => {
      this.currentAction = Qn.NONE, document.removeEventListener(ye.MOVE, this.handleMouseDragging), document.removeEventListener(ye.UP, this.handleMouseUp), t && this.onEventPointerUp && this.onEventPointerUp(t), t && this.onEventClick && (this.hasMoved || this.onEventClick(t)), t && this.onEventDblClick && (!this.hasMoved && this.waitSecondClick ? (this.onEventDblClick(t), this.clearDoubleClickTimer()) : this.waitSecondClick = !0), clearTimeout(this.doubleClickTimer), this.doubleClickTimer = setTimeout(() => {
        this.clearDoubleClickTimer();
      }, this.clickInterval), this.hasMoved = !1;
    });
    f(this, "clearDoubleClickTimer", () => {
      this.doubleClickTimer && clearTimeout(this.doubleClickTimer), this.waitSecondClick = !1, this.doubleClickTimer = null;
    });
    f(this, "handleContextMenu", (t) => {
      t.preventDefault();
    });
    f(this, "handleWheel", (t) => {
      t.preventDefault(), t.stopPropagation();
      const e = (t.clientX - this.startBoundX) / this.startScaleX, i = (t.clientY - this.startBoundY) / this.startScaleY;
      this.handleZoom({
        deltaX: t.deltaX,
        deltaY: t.deltaY,
        pixelX: e,
        pixelY: i
      });
    });
    f(this, "handlePan", (t, e) => {
      const i = this.map;
      if (this.getNdc(t, e, Za), this.ndcToPoint(Za, this.startCamera, Ua), Ua.distanceTo(this.startCamera.position) > i.zoomUnits * 6e3) {
        this.handleMouseUp();
        return;
      }
      Yo.subVectors(this.startCenter, Ua.sub(this.startPoint)), i.center = [Yo.x, Yo.y], i.updateView();
    });
    f(this, "setPanStartState", (t, e) => {
      const i = this.map;
      this.startCamera.copy(i.camera), this.startCamera.updateMatrixWorld(), this.startCenter.set(i.center[0], i.center[1], 0), this.getNdc(t, e, this.startNdc), this.ndcToPoint(this.startNdc, i.camera, this.startPoint);
    });
    f(this, "handleRotate", (t, e) => {
      const i = this.map;
      let n = t - this.startX;
      const o = e - this.startY;
      this.startAtTop || (n *= -1);
      let r = this.startHeading + n * this.headingSpeed;
      r = this.makeHeadingSafe(r), i.heading = r;
      let a = this.startPitch + o * this.pitchSpeed;
      a = this.makePitchSafe(a), i.pitch = a, i.updateView();
    });
    f(this, "handleZoom", (t) => {
      const e = this.map;
      let i = e.zoom, n = i + t.deltaY * this.zoomSpeed * -1;
      if (i === n)
        return;
      if (n = this.makeZoomSafe(n), n < e.earthViewZoomMax) {
        this.map.zoom = n, this.map.updateView();
        return;
      }
      let o = this.mapWidth, r = this.mapHeight;
      const a = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = a.left, this.startBoundY = a.top, this.startScaleX = a.width / o, this.startScaleY = a.height / r;
      let g = e.center, c = e.pitch, l = e.heading;
      this.getNdc(t.pixelX, t.pixelY, Za), Yo.set(g[0], g[1], 0), this.ndcToPoint(Za, e.camera, gu), !(gu.distanceTo(e.camera.position) > e.zoomUnits * 6e3) && (e.computeMapCameraMatrix(aA, g, n, c, l), this.ndcToPoint(Za, aA, Ua), Yo.sub(Ua.sub(gu)), this.map.center[0] = Yo.x, this.map.center[1] = Yo.y, this.map.zoom = n, this.map.updateView());
    });
    f(this, "makeZoomSafe", (t) => t > this.map.maxZoom ? this.map.maxZoom : t < this.map.minZoom ? this.map.minZoom : t);
    f(this, "makeHeadingSafe", (t) => (t %= 360, t < 0 && (t += 360), t));
    f(this, "makePitchSafe", (t) => t < this.minPitch ? this.minPitch : t > this.maxPitch ? this.maxPitch : t);
    f(this, "dispose", () => {
      const t = this.map.domContainer;
      t.removeEventListener(ye.DOWN, this.handleMouseDown), t.removeEventListener("wheel", this.handleWheel), t.removeEventListener("contextmenu", this.handleContextMenu), document.removeEventListener(ye.MOVE, this.handleMouseDragging), document.removeEventListener(ye.UP, this.handleMouseUp), t.removeEventListener(ye.MOVE, this.handleMouseMove), this.clearDoubleClickTimer();
    });
    this.map = t, this.enabled = !0, this.currentAction = Qn.NONE;
  }
  set enabled(t) {
    t !== this._enabled && (t ? this.init() : this.dispose(), this._enabled = t);
  }
  ndcToPoint(t, e, i) {
    dm.setFromCamera(t, e), dm.ray.intersectPlane(WP, i);
  }
  getNdc(t, e, i) {
    i.x = t / this.mapWidth * 2 - 1, i.y = 1 - e / this.mapHeight * 2;
  }
}
var Cr = {}, xa = {}, jw = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), s.default = void 0;
  var t = 1, e = function() {
    return "".concat(t++);
  };
  s.default = e;
})(jw);
var qh = {}, $h = {}, LC = {};
(function(s) {
  Object.defineProperty(s, "__esModule", {
    value: !0
  }), s.default = void 0;
  var t = function(i) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60, o = null;
    return function() {
      for (var r = this, a = arguments.length, g = new Array(a), c = 0; c < a; c++)
        g[c] = arguments[c];
      clearTimeout(o), o = setTimeout(function() {
        i.apply(r, g);
      }, n);
    };
  };
  s.default = t;
})(LC);
var Xs = {};
Object.defineProperty(Xs, "__esModule", {
  value: !0
});
Xs.SensorTabIndex = Xs.SensorClassName = Xs.SizeSensorId = void 0;
var UP = "size-sensor-id";
Xs.SizeSensorId = UP;
var OP = "size-sensor-object";
Xs.SensorClassName = OP;
var QP = "-1";
Xs.SensorTabIndex = QP;
Object.defineProperty($h, "__esModule", {
  value: !0
});
$h.createSensor = void 0;
var YP = jP(LC), um = Xs;
function jP(s) {
  return s && s.__esModule ? s : { default: s };
}
var JP = function(t) {
  var e = void 0, i = [], n = function() {
    getComputedStyle(t).position === "static" && (t.style.position = "relative");
    var l = document.createElement("object");
    return l.onload = function() {
      l.contentDocument.defaultView.addEventListener("resize", o), o();
    }, l.style.display = "block", l.style.position = "absolute", l.style.top = "0", l.style.left = "0", l.style.height = "100%", l.style.width = "100%", l.style.overflow = "hidden", l.style.pointerEvents = "none", l.style.zIndex = "-1", l.style.opacity = "0", l.setAttribute("class", um.SensorClassName), l.setAttribute("tabindex", um.SensorTabIndex), l.type = "text/html", t.appendChild(l), l.data = "about:blank", l;
  }, o = (0, YP.default)(function() {
    i.forEach(function(c) {
      c(t);
    });
  }), r = function(l) {
    e || (e = n()), i.indexOf(l) === -1 && i.push(l);
  }, a = function() {
    e && e.parentNode && (e.contentDocument && e.contentDocument.defaultView.removeEventListener("resize", o), e.parentNode.removeChild(e), e = void 0, i = []);
  }, g = function(l) {
    var h = i.indexOf(l);
    h !== -1 && i.splice(h, 1), i.length === 0 && e && a();
  };
  return {
    element: t,
    bind: r,
    destroy: a,
    unbind: g
  };
};
$h.createSensor = JP;
var ed = {};
Object.defineProperty(ed, "__esModule", {
  value: !0
});
ed.createSensor = void 0;
var qP = $P(LC);
function $P(s) {
  return s && s.__esModule ? s : { default: s };
}
var eN = function(t) {
  var e = void 0, i = [], n = (0, qP.default)(function() {
    i.forEach(function(c) {
      c(t);
    });
  }), o = function() {
    var l = new ResizeObserver(n);
    return l.observe(t), n(), l;
  }, r = function(l) {
    e || (e = o()), i.indexOf(l) === -1 && i.push(l);
  }, a = function() {
    e.disconnect(), i = [], e = void 0;
  }, g = function(l) {
    var h = i.indexOf(l);
    h !== -1 && i.splice(h, 1), i.length === 0 && e && a();
  };
  return {
    element: t,
    bind: r,
    destroy: a,
    unbind: g
  };
};
ed.createSensor = eN;
Object.defineProperty(qh, "__esModule", {
  value: !0
});
qh.createSensor = void 0;
var tN = $h, iN = ed, nN = typeof ResizeObserver < "u" ? iN.createSensor : tN.createSensor;
qh.createSensor = nN;
Object.defineProperty(xa, "__esModule", {
  value: !0
});
xa.removeSensor = xa.getSensor = void 0;
var sN = rN(jw), oN = qh, fh = Xs;
function rN(s) {
  return s && s.__esModule ? s : { default: s };
}
var Tg = {}, aN = function(t) {
  var e = t.getAttribute(fh.SizeSensorId);
  if (e && Tg[e])
    return Tg[e];
  var i = (0, sN.default)();
  t.setAttribute(fh.SizeSensorId, i);
  var n = (0, oN.createSensor)(t);
  return Tg[i] = n, n;
};
xa.getSensor = aN;
var gN = function(t) {
  var e = t.element.getAttribute(fh.SizeSensorId);
  t.element.removeAttribute(fh.SizeSensorId), t.destroy(), e && Tg[e] && delete Tg[e];
};
xa.removeSensor = gN;
Object.defineProperty(Cr, "__esModule", {
  value: !0
});
Cr.ver = MC = Cr.clear = GC = Cr.bind = void 0;
var gA = xa, cN = function(t, e) {
  var i = (0, gA.getSensor)(t);
  return i.bind(e), function() {
    i.unbind(e);
  };
}, GC = Cr.bind = cN, lN = function(t) {
  var e = (0, gA.getSensor)(t);
  (0, gA.removeSensor)(e);
}, MC = Cr.clear = lN, hN = "1.0.1";
Cr.ver = hN;
function EC(s, t, e) {
  return Math.max(t, Math.min(e, s));
}
class RC {
  constructor(t = 0, e = 0) {
    RC.prototype.isVector2 = !0, this.x = t, this.y = e;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, n = t.elements;
    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(EC(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y;
    return e * e + i * i;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this;
  }
  rotateAround(t, e) {
    const i = Math.cos(e), n = Math.sin(e), o = this.x - t.x, r = this.y - t.y;
    return this.x = o * i - r * n + t.x, this.y = o * n + r * i + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class dN {
  constructor(t = 0, e = 0, i = 0, n = 1) {
    this.isQuaternion = !0, this._x = t, this._y = e, this._z = i, this._w = n;
  }
  static slerpFlat(t, e, i, n, o, r, a) {
    let g = i[n + 0], c = i[n + 1], l = i[n + 2], h = i[n + 3];
    const d = o[r + 0], C = o[r + 1], p = o[r + 2], m = o[r + 3];
    if (a === 0) {
      t[e + 0] = g, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h;
      return;
    }
    if (a === 1) {
      t[e + 0] = d, t[e + 1] = C, t[e + 2] = p, t[e + 3] = m;
      return;
    }
    if (h !== m || g !== d || c !== C || l !== p) {
      let b = 1 - a;
      const S = g * d + c * C + l * p + h * m, A = S >= 0 ? 1 : -1, u = 1 - S * S;
      if (u > Number.EPSILON) {
        const I = Math.sqrt(u), M = Math.atan2(I, S * A);
        b = Math.sin(b * M) / I, a = Math.sin(a * M) / I;
      }
      const y = a * A;
      if (g = g * b + d * y, c = c * b + C * y, l = l * b + p * y, h = h * b + m * y, b === 1 - a) {
        const I = 1 / Math.sqrt(g * g + c * c + l * l + h * h);
        g *= I, c *= I, l *= I, h *= I;
      }
    }
    t[e] = g, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h;
  }
  static multiplyQuaternionsFlat(t, e, i, n, o, r) {
    const a = i[n], g = i[n + 1], c = i[n + 2], l = i[n + 3], h = o[r], d = o[r + 1], C = o[r + 2], p = o[r + 3];
    return t[e] = a * p + l * h + g * C - c * d, t[e + 1] = g * p + l * d + c * h - a * C, t[e + 2] = c * p + l * C + a * d - g * h, t[e + 3] = l * p - a * h - g * d - c * C, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, e, i, n) {
    return this._x = t, this._y = e, this._z = i, this._w = n, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, e) {
    const i = t._x, n = t._y, o = t._z, r = t._order, a = Math.cos, g = Math.sin, c = a(i / 2), l = a(n / 2), h = a(o / 2), d = g(i / 2), C = g(n / 2), p = g(o / 2);
    switch (r) {
      case "XYZ":
        this._x = d * l * h + c * C * p, this._y = c * C * h - d * l * p, this._z = c * l * p + d * C * h, this._w = c * l * h - d * C * p;
        break;
      case "YXZ":
        this._x = d * l * h + c * C * p, this._y = c * C * h - d * l * p, this._z = c * l * p - d * C * h, this._w = c * l * h + d * C * p;
        break;
      case "ZXY":
        this._x = d * l * h - c * C * p, this._y = c * C * h + d * l * p, this._z = c * l * p + d * C * h, this._w = c * l * h - d * C * p;
        break;
      case "ZYX":
        this._x = d * l * h - c * C * p, this._y = c * C * h + d * l * p, this._z = c * l * p - d * C * h, this._w = c * l * h + d * C * p;
        break;
      case "YZX":
        this._x = d * l * h + c * C * p, this._y = c * C * h + d * l * p, this._z = c * l * p - d * C * h, this._w = c * l * h - d * C * p;
        break;
      case "XZY":
        this._x = d * l * h - c * C * p, this._y = c * C * h - d * l * p, this._z = c * l * p + d * C * h, this._w = c * l * h + d * C * p;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return e !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, e) {
    const i = e / 2, n = Math.sin(i);
    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const e = t.elements, i = e[0], n = e[4], o = e[8], r = e[1], a = e[5], g = e[9], c = e[2], l = e[6], h = e[10], d = i + a + h;
    if (d > 0) {
      const C = 0.5 / Math.sqrt(d + 1);
      this._w = 0.25 / C, this._x = (l - g) * C, this._y = (o - c) * C, this._z = (r - n) * C;
    } else if (i > a && i > h) {
      const C = 2 * Math.sqrt(1 + i - a - h);
      this._w = (l - g) / C, this._x = 0.25 * C, this._y = (n + r) / C, this._z = (o + c) / C;
    } else if (a > h) {
      const C = 2 * Math.sqrt(1 + a - i - h);
      this._w = (o - c) / C, this._x = (n + r) / C, this._y = 0.25 * C, this._z = (g + l) / C;
    } else {
      const C = 2 * Math.sqrt(1 + h - i - a);
      this._w = (r - n) / C, this._x = (o + c) / C, this._y = (g + l) / C, this._z = 0.25 * C;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, e) {
    let i = t.dot(e) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = i)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = i), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(EC(this.dot(t), -1, 1)));
  }
  rotateTowards(t, e) {
    const i = this.angleTo(t);
    if (i === 0)
      return this;
    const n = Math.min(1, e / i);
    return this.slerp(t, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, e) {
    const i = t._x, n = t._y, o = t._z, r = t._w, a = e._x, g = e._y, c = e._z, l = e._w;
    return this._x = i * l + r * a + n * c - o * g, this._y = n * l + r * g + o * a - i * c, this._z = o * l + r * c + i * g - n * a, this._w = r * l - i * a - n * g - o * c, this._onChangeCallback(), this;
  }
  slerp(t, e) {
    if (e === 0)
      return this;
    if (e === 1)
      return this.copy(t);
    const i = this._x, n = this._y, o = this._z, r = this._w;
    let a = r * t._w + i * t._x + n * t._y + o * t._z;
    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1)
      return this._w = r, this._x = i, this._y = n, this._z = o, this;
    const g = 1 - a * a;
    if (g <= Number.EPSILON) {
      const C = 1 - e;
      return this._w = C * r + e * this._w, this._x = C * i + e * this._x, this._y = C * n + e * this._y, this._z = C * o + e * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(g), l = Math.atan2(c, a), h = Math.sin((1 - e) * l) / c, d = Math.sin(e * l) / c;
    return this._w = r * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = o * h + this._z * d, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, e, i) {
    return this.copy(t).slerp(e, i);
  }
  random() {
    const t = Math.random(), e = Math.sqrt(1 - t), i = Math.sqrt(t), n = 2 * Math.PI * Math.random(), o = 2 * Math.PI * Math.random();
    return this.set(
      e * Math.cos(n),
      i * Math.sin(o),
      i * Math.cos(o),
      e * Math.sin(n)
    );
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, e = 0) {
    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
  }
  fromBufferAttribute(t, e) {
    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class sn {
  constructor(t = 0, e = 0, i = 0) {
    sn.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = i;
  }
  set(t, e, i) {
    return i === void 0 && (i = this.z), this.x = t, this.y = e, this.z = i, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, e) {
    switch (t) {
      case 0:
        this.x = e;
        break;
      case 1:
        this.y = e;
        break;
      case 2:
        this.z = e;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, e) {
    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
  }
  addScaledVector(t, e) {
    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, e) {
    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, e) {
    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(Im.setFromEuler(t));
  }
  applyAxisAngle(t, e) {
    return this.applyQuaternion(Im.setFromAxisAngle(t, e));
  }
  applyMatrix3(t) {
    const e = this.x, i = this.y, n = this.z, o = t.elements;
    return this.x = o[0] * e + o[3] * i + o[6] * n, this.y = o[1] * e + o[4] * i + o[7] * n, this.z = o[2] * e + o[5] * i + o[8] * n, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const e = this.x, i = this.y, n = this.z, o = t.elements, r = 1 / (o[3] * e + o[7] * i + o[11] * n + o[15]);
    return this.x = (o[0] * e + o[4] * i + o[8] * n + o[12]) * r, this.y = (o[1] * e + o[5] * i + o[9] * n + o[13]) * r, this.z = (o[2] * e + o[6] * i + o[10] * n + o[14]) * r, this;
  }
  applyQuaternion(t) {
    const e = this.x, i = this.y, n = this.z, o = t.x, r = t.y, a = t.z, g = t.w, c = 2 * (r * n - a * i), l = 2 * (a * e - o * n), h = 2 * (o * i - r * e);
    return this.x = e + g * c + r * h - a * l, this.y = i + g * l + a * c - o * h, this.z = n + g * h + o * l - r * c, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const e = this.x, i = this.y, n = this.z, o = t.elements;
    return this.x = o[0] * e + o[4] * i + o[8] * n, this.y = o[1] * e + o[5] * i + o[9] * n, this.z = o[2] * e + o[6] * i + o[10] * n, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, e) {
    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
  }
  clampScalar(t, e) {
    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
  }
  clampLength(t, e) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, e) {
    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
  }
  lerpVectors(t, e, i) {
    return this.x = t.x + (e.x - t.x) * i, this.y = t.y + (e.y - t.y) * i, this.z = t.z + (e.z - t.z) * i, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, e) {
    const i = t.x, n = t.y, o = t.z, r = e.x, a = e.y, g = e.z;
    return this.x = n * g - o * a, this.y = o * r - i * g, this.z = i * a - n * r, this;
  }
  projectOnVector(t) {
    const e = t.lengthSq();
    if (e === 0)
      return this.set(0, 0, 0);
    const i = t.dot(this) / e;
    return this.copy(t).multiplyScalar(i);
  }
  projectOnPlane(t) {
    return cu.copy(this).projectOnVector(t), this.sub(cu);
  }
  reflect(t) {
    return this.sub(cu.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (e === 0)
      return Math.PI / 2;
    const i = this.dot(t) / e;
    return Math.acos(EC(i, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const e = this.x - t.x, i = this.y - t.y, n = this.z - t.z;
    return e * e + i * i + n * n;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, e, i) {
    const n = Math.sin(e) * t;
    return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, e, i) {
    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this;
  }
  setFromMatrixPosition(t) {
    const e = t.elements;
    return this.x = e[12], this.y = e[13], this.z = e[14], this;
  }
  setFromMatrixScale(t) {
    const e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(), n = this.setFromMatrixColumn(t, 2).length();
    return this.x = e, this.y = i, this.z = n, this;
  }
  setFromMatrixColumn(t, e) {
    return this.fromArray(t.elements, e * 4);
  }
  setFromMatrix3Column(t, e) {
    return this.fromArray(t.elements, e * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, e = 0) {
    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
  }
  toArray(t = [], e = 0) {
    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
  }
  fromBufferAttribute(t, e) {
    return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = (Math.random() - 0.5) * 2, e = Math.random() * Math.PI * 2, i = Math.sqrt(1 - t ** 2);
    return this.x = i * Math.cos(e), this.y = i * Math.sin(e), this.z = t, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const cu = /* @__PURE__ */ new sn(), Im = /* @__PURE__ */ new dN();
function DC(s, t, e = 1e-6) {
  return br(s, t) < e;
}
function br(s, t) {
  return Math.sqrt(
    Math.pow(s[0] - t[0], 2) + Math.pow(s[1] - t[1], 2) + Math.pow((s[2] || 0) - (t[2] || 0), 2)
  );
}
function cA(s, t, e) {
  return e || (e = new RC()), e.fromArray([t[0] - s[0], t[1] - s[1]]), e.normalize(), e;
}
new sn();
new sn();
new sn();
new sn();
new sn();
new sn();
new sn();
new sn();
new sn();
new sn();
const Am = X.EPSILON10;
function Cm(s, t, e) {
  if (s === t)
    return !0;
  if (H(s) && H(t) && Array.isArray(s) && Array.isArray(t)) {
    let i = !0;
    return s.forEach((n, o) => {
      i = i && X.equalsEpsilon(s[o], t[o], e);
    }), i;
  }
  return !1;
}
function lA(s, t, e) {
  if (!s)
    return;
  t = t || !1;
  const i = H(e), n = s.length;
  if (n < 2)
    return s;
  let o, r = s[0], a, g, c = 0, l = -1;
  for (o = 1; o < n; ++o)
    a = s[o], Cm(r, a, Am) ? (H(g) || (g = s.slice(0, o), c = o - 1, l = 0), i && e.push(o)) : (H(g) && (g.push(a), c = o, i && (l = e.length)), r = a);
  return t && Cm(s[0], s[n - 1], Am) && (i && (H(g) ? e.splice(l, 0, c) : e.push(n - 1)), H(g) ? g.length -= 1 : g = s.slice(0, -1)), H(g) ? g : s;
}
const fm = new Ye(), pm = new Ye(), io = new js(), wc = new Zt(new B(0, 0, 1), 0), _c = new Z();
new B();
new J();
new Me();
const uN = new Z(-1, -1);
new Z(-1, 1);
new Z(1, 1);
const IN = new Z(1, -1);
new B();
new B();
new B();
new B();
const cn = new B(), ff = class extends Jh {
  constructor(e, i, n = {}) {
    super(e, n);
    f(this, "isBlankMap", !0);
    f(this, "MERCATOR_LENGTH", 200375083427892e-7);
    f(this, "projectionName", "_web_mercator");
    f(this, "origin", [0, 0]);
    f(this, "center", [0, 0]);
    f(this, "zoom", 0);
    f(this, "pitch", 0);
    f(this, "heading", 0);
    f(this, "bounds", [[-this.MERCATOR_LENGTH, -this.MERCATOR_LENGTH], [this.MERCATOR_LENGTH, this.MERCATOR_LENGTH]]);
    f(this, "near", 100);
    f(this, "_far", 38e3);
    f(this, "fov", 35);
    f(this, "_cameraLocation", new B());
    f(this, "handleViewChange", () => {
      this.onViewChanged && this.onViewChanged();
    });
    f(this, "handleMapResize", () => {
      this.control && this.control.handleResize(this.getResolution()), this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
    });
    f(this, "handleEventClick", (e) => {
      const n = this._engine.event, o = this._getPixelFromEvent(e);
      e.button === 2 ? n._handleRightClick({
        pixel: o,
        event: e
      }) : n._handleClick({
        pixel: o,
        event: e
      });
    });
    f(this, "handleEventDblClick", (e) => {
      const n = this._engine.event, o = this._getPixelFromEvent(e);
      e.button === 2 ? n._handleRightDblClick({
        pixel: o,
        event: e
      }) : n._handleDblClick({
        pixel: o,
        event: e
      });
    });
    f(this, "handleEventPointerDown", (e) => {
      const n = this._engine.event, o = this._getPixelFromEvent(e);
      n._handlePointerDown({
        pixel: o,
        event: e
      });
    });
    f(this, "handleEventPointerUp", (e) => {
      const n = this._engine.event, o = this._getPixelFromEvent(e);
      n._handlePointerUp({
        pixel: o,
        event: e
      });
    });
    f(this, "handleEventMouseMove", (e) => {
      const n = this._engine.event, o = this._getPixelFromEvent(e);
      n._handleMouseMove({
        pixel: o,
        event: e
      });
    });
    f(this, "_getPixelFromEvent", (e) => {
      const i = this._engine.rendering.canvas.getBoundingClientRect(), n = e.clientX - i.left, o = e.clientY - i.top;
      return [n, o];
    });
    this._engine = e, this.domContainer = i;
  }
  afterInit() {
    this.camera.matrixAutoUpdate = !1, this.bindCanvas(), this.handleMapResize(), GC(this.domContainer, this.handleMapResize), this.initControl(), this.resetHome();
  }
  resetHome() {
    this.lookAt(ff.DEFAULT_CENTER, {
      zoom: 4.5,
      pitch: 0,
      heading: 0
    });
  }
  initControl() {
    this.control = new ZP(this), this.control.onEventPointerDown = this.handleEventPointerDown, this.control.onEventPointerUp = this.handleEventPointerUp, this.control.onEventClick = this.handleEventClick, this.control.onEventDblClick = this.handleEventDblClick, this.control.onEventMouseMove = this.handleEventMouseMove;
  }
  bindCanvas() {
    this.domContainer.appendChild(this.canvas);
  }
  releaseCanvas() {
    this.domContainer.removeChild(this.canvas);
  }
  getContainerSize() {
    return [
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    ];
  }
  getResolution() {
    return new Z(this.domContainer.clientWidth, this.domContainer.clientHeight);
  }
  getCenter() {
    return this.unprojectArrayCoordinate(this.center);
  }
  getZoom() {
    return this.zoom;
  }
  getPitch() {
    return this.pitch;
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 128 / Math.pow(2, e);
  }
  getCameraLocation(e) {
    return e || (e = new B()), e.copy(this._cameraLocation), e;
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 128 / e);
  }
  getZoomUnits() {
    return this.getZoomUnitsByZoom(this.zoom);
  }
  getHeading() {
    return this.heading;
  }
  enableControl() {
    this.control.enabled = !0;
  }
  disableControl() {
    this.control.enabled = !1;
  }
  setCameraMatrix() {
    this.handleViewChange();
  }
  _updateCameraLocation() {
    this.projection.unprojectCoordinate(this.camera.position, this._cameraLocation);
  }
  updateCamera() {
    this.computeMapCameraMatrix(this.camera, this.center, this.zoom, this.pitch, this.heading), this._updateCameraLocation();
  }
  computeMapCameraMatrix(e, i, n, o, r) {
    const [a, g] = this.getContainerSize();
    let c = this.zoomUnits = this.getZoomUnitsByZoom(n);
    if (a * c > this.bounds[1][0] - this.bounds[0][0]) {
      let d = (this.bounds[1][0] - this.bounds[0][0]) / a;
      c = this.zoomUnits = d, this.zoom = this.getZoomByZoomUnits(d);
    }
    if (g * c > this.bounds[1][1] - this.bounds[0][1]) {
      let d = (this.bounds[1][1] - this.bounds[0][1]) / g;
      c = this.zoomUnits = d, this.zoom = this.getZoomByZoomUnits(d);
    }
    i[0] - a / 2 * c < this.bounds[0][0] && (i[0] = this.bounds[0][0] + a / 2 * c), i[0] + a / 2 * c > this.bounds[1][0] && (i[0] = this.bounds[1][0] - a / 2 * c), i[1] - g / 2 * c < this.bounds[0][1] && (i[1] = this.bounds[0][1] + g / 2 * c), i[1] + g / 2 * c > this.bounds[1][1] && (i[1] = this.bounds[1][1] - g / 2 * c), this.center = i;
    const l = g / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * c;
    this.cameraDistance = l, e.position.set(0, 0, 0), e.quaternion.set(0, 0, 0, 1), e.up.set(0, 0, 1), e.translateX(i[0]), e.translateY(i[1]), i[2] && e.translateZ(i[2]), e.rotateOnAxis(new B(0, 0, 1), r * Math.PI / 180), e.rotateOnAxis(new B(1, 0, 0), o * Math.PI / 180), e.translateZ(l), e.updateMatrix(), e.updateMatrixWorld(), e.aspect = a / g;
    let h = c;
    h < 1 && (h = 1), e.near = Math.min(Math.max(e.position.z / 1e4, 0.1), 10), e.far = this._far * h, e.updateProjectionMatrix();
  }
  setCenter(e) {
    const i = this.projectArrayCoordinate(e);
    i && (this.center = i), this.setCameraMatrix();
  }
  setProjectionCenter(e) {
    const i = this.unprojectArrayCoordinate(e);
    this.setCenter(i);
  }
  setZoom(e) {
    isNaN(e) || (this.zoom = e), this.setCameraMatrix();
  }
  zoomIn() {
    this.setZoom(this.zoom + 1);
  }
  zoomOut() {
    this.setZoom(this.zoom - 1);
  }
  setHeading(e) {
    this.heading = e, this.setCameraMatrix();
  }
  setPitch(e) {
    this.pitch = e, this.setCameraMatrix();
  }
  setMaxRange(e) {
    console.warn(`setMaxRange is only compatible with 3DMap Control,
            please set options 'map: {is3DControl: true}' when Engine is created`);
  }
  lookAt(e, i = {}) {
    let n = [];
    e.isVector3 ? e.toArray(n) : n = e;
    let o = this.projectArrayCoordinate(n);
    o && (this.center = o), i.heading !== void 0 && (this.heading = i.heading), i.pitch !== void 0 && (this.pitch = i.pitch), i.zoom !== void 0 && (this.zoom = i.zoom), this.setCameraMatrix();
  }
  _getCameraQuaternion(e, i) {
    fm.setFromAxisAngle(new B(0, 0, 1), e * Math.PI / 180), pm.setFromAxisAngle(new B(1, 0, 0), i * Math.PI / 180);
    const n = new Ye();
    return n.multiplyQuaternions(fm, pm), n;
  }
  flyTo(e, i) {
    this.cancelFlight();
    let n = [];
    e.isVector3 ? n = e.toArray() : e.isVector2 ? n = [e.x, e.y, 0] : e instanceof Array && (n = [e[0], e[1], e[2] || 0]), this.projectArrayCoordinate(n, n);
    const o = this._engine, r = o.map, a = this, g = W(i.heading, o.map.getHeading()), c = W(i.pitch, o.map.getPitch()), l = this._getCameraQuaternion(g, c), h = new B(0, 0, -1).applyQuaternion(l).negate(), d = new B().fromArray(n), C = i.range;
    isNaN(C) || d.add(h.multiplyScalar(C));
    const p = {
      destination: d,
      heading: ce.degToRad(g),
      pitch: ce.degToRad(c),
      duration: i.duration,
      complete: function() {
        a._currentFlight = void 0, i.complete && i.complete();
      },
      cancel: i.cancel
    }, m = Ar.createTween(r, p);
    if (m.duration === 0) {
      typeof m.complete == "function" && m.complete();
      return;
    }
    const b = performance.now();
    function S() {
      const u = performance.now() - b, {
        duration: y,
        complete: I,
        update: M,
        easingFunction: G
      } = m;
      if (u >= y) {
        M({
          time: y,
          easingFunction: G
        }), o.removePrepareRenderListener(S), I();
        return;
      }
      M({
        time: u,
        easingFunction: G
      }), o.requestRender();
    }
    o.addPrepareRenderListener(S), m.listener = S, this._currentFlight = m;
  }
  cancelFlight() {
    if (this._currentFlight) {
      const e = this._currentFlight.listener;
      this._engine.removePrepareRenderListener(e), this._currentFlight = void 0;
    }
  }
  setBounds(e) {
    this.bounds = [this.projectArrayCoordinate(e[0]), this.projectArrayCoordinate(e[1])];
  }
  getNdcYFactor() {
    const e = this.getPitch(), i = 45;
    if (e < i)
      return 1;
    const n = 0.5, o = (e - i) / (90 - i), r = 1 - Math.tan(o * Math.PI / 2) * n;
    return Math.max(-0.1, Math.min(r, 1));
  }
  getProjectionBounds() {
    const e = [], i = this.getNdcYFactor();
    io.setFromCamera(uN, this.camera), io.ray.intersectPlane(wc, cn);
    const n = cn.x, o = cn.y;
    io.setFromCamera(IN, this.camera), io.ray.intersectPlane(wc, cn);
    const r = cn.x, a = cn.y;
    _c.set(-1, i), io.setFromCamera(_c, this.camera), io.ray.intersectPlane(wc, cn);
    const g = cn.x, c = cn.y;
    _c.set(1, i), io.setFromCamera(_c, this.camera), io.ray.intersectPlane(wc, cn);
    const l = cn.x, h = cn.y;
    return e[0] = Math.min(n, r, g, l), e[1] = Math.min(o, a, c, h), e[2] = Math.max(n, r, g, l), e[3] = Math.max(o, a, c, h), new Ue(new B(e[0], e[1], 0), new B(e[2], e[3], 0));
  }
  getBounds() {
    const e = this.getProjectionBounds(), i = this.unprojectArrayCoordinate([e.min.x, e.min.y]), n = this.unprojectArrayCoordinate([e.max.x, e.max.y]);
    return new Ue(new B(i[0], i[1], 0), new B(n[0], n[1], 0));
  }
  updateView() {
    this.setCameraMatrix();
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  getProjectionCenter() {
    return [this.center[0], this.center[1]];
  }
  dispose() {
    this.releaseCanvas(), MC(this.domContainer), this._engine.event, this.control.dispose(), super.dispose();
  }
  get far() {
    return this._far;
  }
  set far(e) {
    this._far = e;
  }
};
let lr = ff;
f(lr, "EARTH_RADIUS", 637e4), f(lr, "DEFAULT_CENTER", [107.9, 35.8]);
function Ks(s) {
  return new Z(-s.y, s.x);
}
function Jw(s, t) {
  let e = new Z();
  return e.addVectors(s, t), e.normalize(), Ks(e);
}
function AN(s, t) {
  let e = s.x * t.x + s.y * t.y, i = Math.sqrt(s.x * s.x + s.y * s.y), n = Math.sqrt(t.x * t.x + t.y * t.y), o = Math.acos(e / (i * n));
  return s.x * t.y - t.x * s.y < 0 && (o = 2 * Math.PI - o), o;
}
function CN(s, t, e) {
  const i = s.clone().sub(t), n = Math.cos(e), o = Math.sin(e), r = i.x * n + i.y * o, a = -i.x * o + i.y * n, g = new Z(r, a);
  return g.add(t), g;
}
function fN(s, t, e) {
  const i = [e[0] - t[0], e[1] - t[1]], n = [s[0] - t[0], s[1] - t[1]], r = (i[0] * n[0] + i[1] * n[1]) / Math.sqrt((i[0] * i[0] + i[1] * i[1]) * (n[0] * n[0] + n[1] * n[1])), a = -i[1] * n[0] + i[0] * n[1];
  return r > -0.866 && a < 0;
}
const mm = new Z(), lu = new Z();
class ym {
  constructor(t = {}) {
    f(this, "_lastTime", 0);
    f(this, "_lastPosition", new Z());
    f(this, "_velocity", new Z());
    f(this, "_acceleration", new Z());
    f(this, "_resistance", 3e-3);
    f(this, "_inertiaSpeed", 0);
    f(this, "_inertiaDirection", new Z());
    t.resistance !== void 0 && (this._resistance = t.resistance);
  }
  start(t, e, i) {
    this._lastPosition.set(t, e), this._velocity.set(0, 0), this._acceleration.set(0, 0), i === void 0 ? this._lastTime = performance.now() : this._lastTime = i;
  }
  update(t, e, i) {
    i === void 0 && (i = performance.now());
    const n = i - this._lastTime;
    mm.set(t, e);
    const o = mm.sub(this._lastPosition);
    lu.copy(o).divideScalar(n), this._acceleration.copy(lu).sub(this._velocity), this._lastPosition.set(t, e), this._velocity.copy(lu), this._lastTime = i;
  }
  setInertiaState(t, e, i) {
    this._inertiaSpeed = t, this._inertiaDirection.copy(e), this._lastTime = i;
  }
  startInertia() {
    this._inertiaSpeed = this._velocity.length(), this._inertiaDirection.copy(this._velocity).normalize();
  }
  getInertiaPosition(t) {
    t === void 0 && (t = performance.now());
    const e = t - this._lastTime, i = this._inertiaSpeed;
    let n = i - this._resistance * i * e;
    n < 0 && (n = 0);
    const o = this._inertiaDirection.clone().multiplyScalar(i * e).add(this._lastPosition);
    return this._inertiaSpeed = n, this._lastPosition.copy(o), this._lastTime = t, [o, n];
  }
  get inertiaDirection() {
    return this._inertiaDirection;
  }
}
const xt = {
  NONE: 0,
  PAN: 1,
  ROTATE: 2,
  PITCH: 3,
  ZOOM: 4
}, xc = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
}, Oa = "wheel", Sm = "contextmenu", hu = "dragging";
new Z();
const bi = new Z(), Ui = new js(), Qa = new Zt(new B(0, 0, 1), 0);
new B();
new B();
const bm = new B(), ai = new B(), Ms = new Ys();
new Ys();
Ms.fov = 35;
const Bm = new Z();
class pN {
  constructor(t) {
    f(this, "map");
    f(this, "currentAction");
    f(this, "startX");
    f(this, "startY");
    f(this, "startCenterX");
    f(this, "startCenterY");
    f(this, "startPitch");
    f(this, "startHeading");
    f(this, "startZoom");
    f(this, "startZoomUnits");
    f(this, "startAtTop");
    f(this, "mapWidth");
    f(this, "mapHeight");
    f(this, "startCamera", new Ys());
    f(this, "startCenter", new B());
    f(this, "startNdc", new Z());
    f(this, "startPoint", new B());
    f(this, "startScaleX", 1);
    f(this, "startScaleY", 1);
    f(this, "startBoundX");
    f(this, "startBoundY");
    f(this, "_enabled", !1);
    f(this, "enableInertia", !0);
    f(this, "minPitch", 0);
    f(this, "maxPitch", 89);
    f(this, "zoomSpeed", 5e-3);
    f(this, "headingSpeed", 0.4);
    f(this, "pitchSpeed", 0.3);
    f(this, "doubleClickTimer", null);
    f(this, "clickInterval", 200);
    f(this, "_rotationMode", 1);
    f(this, "_buttonDown", {
      LEFT: !1,
      MIDDLE: !1,
      RIGHT: !1
    });
    f(this, "_primaryStartPosition", new Z());
    f(this, "_primaryPosition", new Z());
    f(this, "_primaryPreviousPosition", new Z());
    f(this, "_positions", /* @__PURE__ */ new Map());
    f(this, "_previousPositions", /* @__PURE__ */ new Map());
    f(this, "_isPinching", !1);
    f(this, "_isTouchHolding", !1);
    f(this, "_lastPinchDist", 0);
    f(this, "_lastSeenTouchEvent", -800);
    f(this, "_whichKindOfPinch");
    f(this, "_pinchConnectPosition", {
      position1: new Z(),
      position2: new Z()
    });
    f(this, "_pinchActionPosition", {
      position1: new Z(),
      position2: new Z()
    });
    f(this, "_pinchActionTimer");
    f(this, "_touchHoldTimer");
    f(this, "_clickPixelTolerance", 5);
    f(this, "_holdPixelTolerance", 25);
    f(this, "init", () => {
      const t = this.map.domContainer;
      t.addEventListener(ye.DOWN, this.handlePointerDownWithThrottle), t.addEventListener(Oa, this.handleWheelWithThrottle), t.addEventListener(Sm, this.handleContextMenu), t.addEventListener(ye.MOVE, this.handlePointerMoveWithThrottle), this.initCursorAnchor();
    });
    f(this, "handlePointerDownWithThrottle", (t) => {
      this._eventThrottle.putEvent(ye.DOWN, t), this._tryToTriggerEvents();
    });
    f(this, "handleWheelWithThrottle", (t) => {
      this._eventThrottle.putEvent(Oa, t), this._tryToTriggerEvents();
    });
    f(this, "handlePointerMoveWithThrottle", (t) => {
      this._eventThrottle.putEvent(ye.MOVE, t), this._tryToTriggerEvents();
    });
    f(this, "handleMouseDraggingWithThrottle", (t) => {
      this._eventThrottle.putEvent(hu, t), this._tryToTriggerEvents();
    });
    f(this, "handlePointerUpWithThrottle", (t) => {
      this._eventThrottle.putEvent(ye.UP, t), this._tryToTriggerEvents();
    });
    f(this, "_tryToTriggerEvents", async () => {
      this._eventThrottle.isEmpty || this._eventThrottle.isBusy || await this._eventThrottle.triggerEvents(this._triggerEvents);
    });
    f(this, "_triggerEvents", async (t) => {
      t[ye.DOWN] && await this.handlePointerDown(t[ye.DOWN]), t[Oa] && await this.handleWheel(t[Oa]), t[ye.MOVE] && await this.handlePointerMove(t[ye.MOVE]), t[hu] && await this.handleMouseDragging(t[hu]), t[ye.UP] && await this.handlePointerUp(t[ye.UP]), this._tryToTriggerEvents();
    });
    f(this, "initCursorAnchor", () => {
      const t = this.cursorAnchor = document.createElement("div");
      t.style.position = "absolute", t.style.width = "40px", t.style.height = "40px", t.style.backgroundColor = "rgba(255, 255, 255, 0.5)", t.style.zIndex = 100, t.style.pointerEvents = "none", t.style.display = "none", this.map.domContainer.appendChild(t);
    });
    f(this, "showCursorAnchor", (t, e) => {
      this._rotationMode <= 1 || (this.cursorAnchor.style.left = t - 20 + "px", this.cursorAnchor.style.top = e - 20 + "px", this.cursorAnchor.style.display = "block");
    });
    f(this, "hideCursorAnchor", () => {
      this.cursorAnchor.style.display = "none";
    });
    f(this, "handleResize", (t) => {
      const [e, i] = this.map.getContainerSize();
      this.mapWidth = e, this.mapHeight = i;
      const n = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = n.left, this.startBoundY = n.top, this.startScaleX = n.width / e, this.startScaleY = n.height / i;
    });
    f(this, "fireTouchEvents", async (t) => {
      const e = this.map;
      let i = this.mapWidth, n = this.mapHeight;
      const o = this._positions, r = o.size, a = this._isPinching;
      if (r !== 1 && this._buttonDown[xc.LEFT]) {
        if (this._buttonDown[xc.LEFT] = !1, this._touchHoldTimer && (clearTimeout(this._touchHoldTimer), this._touchHoldTimer = void 0), t && this.onEventPointerUp && this.onEventPointerUp(t), r === 0 && !this._isTouchHolding && t && this.onEventClick && !this.hasMoved) {
          const g = this._primaryStartPosition, c = Array.from(this._previousPositions.values())[0];
          wm(g, c, this._clickPixelTolerance) && this.onEventClick(t);
        }
        this._isTouchHolding = !1, this.hasMoved = !1, this.currentAction, xt.NONE;
      }
      if (r <= 1 && a && (this._pinchActionTimer && (clearTimeout(this._pinchActionTimer), this._pinchActionTimer = void 0), this._isPinching = !1, this._whichKindOfPinch = void 0, this._lastPinchDist = 0, this.currentAction, xt.NONE), r === 1 && !a) {
        const g = Array.from(o.values())[0];
        this._primaryPosition.copy(g), this._primaryStartPosition.copy(g), this._primaryPreviousPosition.copy(g), this._buttonDown[xc.LEFT] = !0;
        const c = this.map.domContainer.getBoundingClientRect();
        this.startBoundX = c.left, this.startBoundY = c.top, this.startScaleX = c.width / i, this.startScaleY = c.height / n;
        const l = g.x, h = g.y, d = new Z(l / i * 2 - 1, 1 - 2 * h / n), C = await this._pickPosition(d);
        this.startCamera.copy(e.camera), this.startCamera.updateMatrixWorld(), Qa.constant = -C.z, this.startPoint.copy(C), this.currentAction = xt.PAN, t && this.onEventPointerDown && this.onEventPointerDown(t), this.startX = l, this.startY = h, this.startAtTop = h < n / 2, document.addEventListener(ye.UP, this.handlePointerUpWithThrottle), this._touchHoldTimer = setTimeout(function() {
          if (this._enabled && (this._touchHoldTimer = void 0, this._isTouchHolding = !0, t && this.onEventClick)) {
            const p = this._primaryStartPosition, m = Array.from(this._previousPositions.values())[0];
            wm(p, m, this._clickPixelTolerance) && this.onEventClick(t);
          }
        }, this.touchHoldDelayMilliseconds), t.preventDefault();
      }
      if (r === 2 && !a) {
        const g = Array.from(o.values())[0], c = Array.from(o.values())[1];
        this._isPinching = !0;
        const l = e.getProjectionCenter();
        this.startPoint.set(l[0], l[1], l[2]);
        const h = e.decomposeRotation();
        this.startHeading = h.heading, this.startPitch = h.pitch, this.startDistance = e.camera.position.distanceTo(this.startPoint);
        const d = g.x, C = g.y;
        this.showCursorAnchor(d, C), this.currentAction = xt.ROTATE, this.startX = c.x, this.startY = c.y, this._lastPinchDist = g.distanceTo(c), this._pinchConnectPosition.position1.copy(g), this._pinchConnectPosition.position2.copy(c), this._pinchActionTimer = setTimeout(() => {
          this._enabled && (clearTimeout(this._pinchActionTimer), this._pinchActionTimer = void 0);
        }, 150), t.preventDefault();
      }
    });
    f(this, "fireTouchMoveEvents", async (t) => {
      const e = this.map, i = this._positions;
      this._previousPositions;
      const n = i.size;
      if (this.currentAction !== xt.NONE && (this.hasMoved = !0, !(this.onMouseDragging && !this.onMouseDragging()))) {
        if (this.map.domContainer.style.cursor = "grabbing", n === 1 && this._buttonDown[xc.LEFT]) {
          const o = Array.from(i.values())[0], r = o.x, a = o.y;
          this._primaryPosition.copy(o);
          const g = this._primaryPreviousPosition;
          if (this.getNdc(r, a, bi), !this.ndcToPoint(bi, this.startCamera, ai) || ai.distanceTo(e.camera.position) > e.camera.far * 0.8) {
            await this.handlePointerUp();
            return;
          }
          ai.sub(this.startPoint), ai.subVectors(this.startCamera.position, ai), e.camera.position.copy(ai), e.center = [ai.x, ai.y], t && this.onEventMouseMove && this.onEventMouseMove(t), g.copy(o), t.preventDefault();
        } else if (n === 2 && this._isPinching) {
          const o = e.camera, r = Array.from(i.values())[0], a = Array.from(i.values())[1];
          if (this._pinchActionTimer) {
            this._pinchActionPosition.position1.copy(r), this._pinchActionPosition.position2.copy(a);
            return;
          }
          if (this._whichKindOfPinch === void 0) {
            const g = new Z(), c = new Z(), l = new Z();
            g.subVectors(this._pinchConnectPosition.position1, this._pinchConnectPosition.position2), g.normalize(), c.subVectors(this._pinchActionPosition.position1, this._pinchConnectPosition.position1), c.normalize(), l.subVectors(this._pinchActionPosition.position2, this._pinchConnectPosition.position2), l.normalize();
            const h = c.dot(l), d = g.dot(l);
            h > 0.8 ? this._whichKindOfPinch = xt.PITCH : Math.abs(d) < 0.7 ? this._whichKindOfPinch = xt.ROTATE : this._whichKindOfPinch = xt.ZOOM;
          }
          if (this._whichKindOfPinch === xt.PITCH) {
            const c = a.y - this.startY;
            let l = this.startPitch + c * this.pitchSpeed;
            if (l = this.makePitchSafe(l), this._rotationMode <= 1)
              e._cameraLookAt(o, this.startPoint, {
                heading: this.startHeading,
                pitch: l,
                range: this.startDistance
              });
            else {
              e._cameraLookAt(Ms, this.startPoint, {
                heading: this.startHeading,
                pitch: l,
                range: 0.2
              }), this.getNdc(this.startX, this.startY, bi), Ui.setFromCamera(bi, Ms);
              const h = Ui.ray.direction.clone();
              bi.set(0, 0), Ui.setFromCamera(bi, Ms);
              const d = Ui.ray.direction.clone();
              h.angleTo(d);
              const C = new B();
              C.copy(h), C.normalize(), C.multiplyScalar(this.startDistance), o.position.copy(ai.copy(this.startPoint).sub(C)), o.quaternion.copy(Ms.quaternion);
            }
            e.pitch = l;
          } else if (this._whichKindOfPinch === xt.ZOOM) {
            const g = r.distanceTo(a), c = (this._lastPinchDist - g) * 2, l = ce.clamp(c * this.zoomSpeed * -1, -0.5, 0.5);
            this.getNdc((r.x + a.x) / 2, (r.y + a.y) / 2, bi);
            const h = await this._pickPosition(bi), d = o.position.distanceTo(h);
            if (d > o.far * 0.95)
              return;
            let C = l * ce.clamp(d, 0.5, 1e7);
            C + 0.2 > d ? (C = d - 0.2, e.range = 0.2) : e.range = d - C, e.maxRange && e.maxRange < d && l < 0 && (C = 0);
            const p = new B();
            p.subVectors(h, o.position), p.normalize();
            const m = new B();
            m.copy(p).multiplyScalar(C).add(o.position), o.position.copy(m), e.center = [m.x, m.y], this._lastPinchDist = g;
          } else if (this._whichKindOfPinch === xt.ROTATE) {
            const g = new Z();
            g.subVectors(this._pinchConnectPosition.position2, this._pinchConnectPosition.position1), g.normalize();
            const c = new Z();
            c.subVectors(a, r), c.normalize();
            let l = AN(c, g), h = this.startHeading - l / Math.PI * 180;
            h = this.makeHeadingSafe(h), e._cameraLookAt(o, this.startPoint, {
              heading: h,
              pitch: this.startPitch,
              range: this.startDistance
            });
          }
        }
        this.handleCameraBeforeRender(), this.map.updateView();
      }
    });
    f(this, "handlePointerMove", async (t) => {
      if (au(t)) {
        const e = this._positions, i = t.pointerId;
        let n = e.get(i);
        if (!n)
          return;
        let o = this.getPixelPosition(t);
        n.set(o[0], o[1]), await this.fireTouchMoveEvents(t), this._previousPositions.get(i).copy(e.get(i));
      } else
        await this.handleMouseMove(t);
    });
    f(this, "handleMouseMove", async (t) => {
      this.onEventMouseMove && this.onEventMouseMove(t);
    });
    f(this, "handlePointerDown", async (t) => {
      if (au(t)) {
        const e = t.pointerId;
        let i = this.getPixelPosition(t);
        this._positions.set(e, new Z(i[0], i[1])), await this.fireTouchEvents(t), this._previousPositions.set(e, this._positions.get(e).clone());
      } else
        await this.handleMouseDown(t);
    });
    f(this, "handleMouseDown", async (t) => {
      const e = this.map;
      let i = this.mapWidth, n = this.mapHeight;
      const o = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = o.left, this.startBoundY = o.top, this.startScaleX = o.width / i, this.startScaleY = o.height / n;
      const [r, a] = this.getPixelPosition(t), g = new Z(r / i * 2 - 1, 1 - 2 * a / n);
      if (cancelAnimationFrame(this._inertiaAnimationHanlder), this._draggingMovementAggregator.start(r, a), t.button === 0) {
        const c = await this._pickPosition(g);
        this.startCamera.copy(e.camera), this.startCamera.updateMatrixWorld(), Qa.constant = -c.z, this.startPoint.copy(c), this.currentAction = xt.PAN;
      } else if (t.button === 2) {
        if (this._rotationMode === 0) {
          Bm.set(0, 0), Ui.setFromCamera(Bm, e.camera), Ui.ray.intersectPlane(Qa, bm), this.startPoint.copy(bm);
          const c = e.decomposeRotation();
          this.startHeading = c.heading, this.startPitch = c.pitch;
        } else if (this._rotationMode === 1) {
          const c = await this._pickPosition(new Z());
          this.startPoint.copy(c);
          const l = e.decomposeRotation();
          this.startHeading = l.heading, this.startPitch = l.pitch;
        } else {
          const c = await this._pickPosition(g);
          this.startCamera.copy(e.camera), this.startCamera.updateMatrixWorld();
          const l = new B();
          l.subVectors(c, this.startCamera.position), l.normalize(), this.startPoint.copy(c);
          const h = e.decomposeRotationFromDirection(l);
          this.startHeading = h.heading, this.startPitch = h.pitch;
        }
        this.startDistance = e.camera.position.distanceTo(this.startPoint), this.currentAction = xt.ROTATE, this.showCursorAnchor(r, a);
      } else
        this.currentAction = xt.NONE;
      this.currentAction !== xt.NONE && (t && this.onEventPointerDown && (this.hasMoved || this.onEventPointerDown(t)), this.startX = r, this.startY = a, this.startAtTop = a < n / 2, document.addEventListener(ye.MOVE, this.handleMouseDraggingWithThrottle), document.addEventListener(ye.UP, this.handlePointerUpWithThrottle));
    });
    f(this, "_reactDragging", async (t, e) => {
      this.currentAction === xt.PAN ? (this.map.domContainer.style.cursor = "grabbing", await this.handlePan(t, e)) : this.currentAction === xt.ROTATE && (this.map.domContainer.style.cursor = "grabbing", await this.handleRotate(t, e)), this.handleCameraBeforeRender(), this.map.updateView();
    });
    f(this, "handleMouseDragging", async (t) => {
      if (this.currentAction === xt.NONE)
        return;
      this.hasMoved = !0;
      const [e, i] = this.getPixelPosition(t);
      this._draggingMovementAggregator.update(e, i), !(this.onMouseDragging && !this.onMouseDragging()) && await this._reactDragging(e, i);
    });
    f(this, "handlePointerUp", async (t) => {
      if (au(t)) {
        const e = t.pointerId;
        this._positions.delete(e), this.fireTouchEvents(t), this._previousPositions.delete(e);
      } else
        await this.handleMouseUp(t);
    });
    f(this, "_startInertiaAnimation", () => {
      const [t, e] = this._draggingMovementAggregator.getInertiaPosition();
      e > 0.1 ? (this._reactDragging(t.x, t.y), this._inertiaAnimationHanlder = requestAnimationFrame(this._startInertiaAnimation)) : this.currentAction = xt.NONE;
    });
    f(this, "handleMouseUp", async (t) => {
      this.enableInertia && this.currentAction !== xt.NONE ? (this._draggingMovementAggregator.startInertia(), this._startInertiaAnimation()) : this.currentAction = xt.NONE, this.map.domContainer.style.cursor = "default", this.hideCursorAnchor(), document.removeEventListener(ye.MOVE, this.handleMouseDraggingWithThrottle), document.removeEventListener(ye.UP, this.handlePointerUpWithThrottle), t && this.onEventPointerUp && this.onEventPointerUp(t), t && this.onEventClick && (this.hasMoved || this.onEventClick(t)), t && this.onEventDblClick && (!this.hasMoved && this.waitSecondClick ? (this.onEventDblClick(t), this.clearDoubleClickTimer()) : this.waitSecondClick = !0), clearTimeout(this.doubleClickTimer), this.doubleClickTimer = setTimeout(() => {
        this.clearDoubleClickTimer();
      }, this.clickInterval), this.hasMoved = !1;
    });
    f(this, "clearDoubleClickTimer", () => {
      this.doubleClickTimer && clearTimeout(this.doubleClickTimer), this.waitSecondClick = !1, this.doubleClickTimer = null;
    });
    f(this, "handleContextMenu", (t) => {
      t.preventDefault();
    });
    f(this, "_reactZoom", async (t, e, i, n) => {
      await this.handleZoom({
        deltaX: t,
        deltaY: e,
        pixelX: i,
        pixelY: n
      }), this.handleCameraBeforeRender(), this.map.updateView();
    });
    f(this, "_startZoomInertiaAnimation", (t, e) => {
      this._zoomInertiaAnimationHandler = requestAnimationFrame(() => {
        const [i, n] = this._zoomMovementAggregator.getInertiaPosition();
        if (n > 0.1) {
          const o = this._zoomMovementAggregator.inertiaDirection.y < 0;
          this._reactZoom(0, o ? n * -1 : n, t, e), this._startZoomInertiaAnimation(t, e);
        }
      });
    });
    f(this, "handleWheel", async (t) => {
      t.preventDefault(), t.stopPropagation();
      const [e, i] = this.getPixelPosition(t);
      if (cancelAnimationFrame(this._inertiaAnimationHanlder), cancelAnimationFrame(this._zoomInertiaAnimationHandler), this.enableInertia) {
        const n = performance.now(), o = t.deltaY < 0;
        let r = Math.abs(t.deltaY);
        r > 20 && (r = 20), this._zoomMovementAggregator.setInertiaState(r, new Z(0, o ? -1 : 1), n), this._startZoomInertiaAnimation(e, i);
      } else
        this._reactZoom(0, t.deltaY, e, i);
    });
    f(this, "handlePan", async (t, e) => {
      const i = this.map;
      if (this.getNdc(t, e, bi), !this.ndcToPoint(bi, this.startCamera, ai) || ai.distanceTo(i.camera.position) > i.camera.far * 0.9) {
        this.currentAction = xt.NONE, await this.handlePointerUp();
        return;
      }
      ai.sub(this.startPoint), ai.subVectors(this.startCamera.position, ai), i.camera.position.copy(ai), i.center = [ai.x, ai.y];
    });
    f(this, "handleRotate", async (t, e) => {
      const i = this.map, n = i.camera;
      let o = t - this.startX;
      const r = e - this.startY;
      this.startAtTop || (o *= -1);
      let a = this.startHeading + o * this.headingSpeed;
      a = this.makeHeadingSafe(a);
      let g = this.startPitch + r * this.pitchSpeed;
      if (g = this.makePitchSafe(g), this._rotationMode <= 1)
        i._cameraLookAt(n, this.startPoint, {
          heading: a,
          pitch: g,
          range: this.startDistance
        });
      else {
        i._cameraLookAt(Ms, this.startPoint, {
          heading: a,
          pitch: g,
          range: 0.2
        }), this.getNdc(this.startX, this.startY, bi), Ui.setFromCamera(bi, Ms);
        const c = Ui.ray.direction.clone();
        bi.set(0, 0), Ui.setFromCamera(bi, Ms);
        const l = Ui.ray.direction.clone();
        c.angleTo(l);
        const h = new B();
        h.copy(c), h.normalize(), h.multiplyScalar(this.startDistance), n.position.copy(ai.copy(this.startPoint).sub(h)), n.quaternion.copy(Ms.quaternion);
      }
      i.pitch = g, i.heading = a;
    });
    f(this, "handleZoom", async (t) => {
      const e = this.map;
      let i = this.mapWidth, n = this.mapHeight;
      const o = this.map.domContainer.getBoundingClientRect();
      this.startBoundX = o.left, this.startBoundY = o.top, this.startScaleX = o.width / i, this.startScaleY = o.height / n;
      const r = e.camera, a = ce.clamp(t.deltaY * this.zoomSpeed * -1, -0.5, 0.5);
      this.getNdc(t.pixelX, t.pixelY, bi);
      const g = await this._pickPosition(bi), c = r.position.distanceTo(g);
      if (c > r.far * 0.95)
        return;
      let l = a * ce.clamp(c, 0.5, 1e7);
      l + 0.2 > c ? (l = c - 0.2, e.range = 0.2) : e.range = c - l, e.maxRange && e.maxRange < c && a < 0 && (l = 0);
      const h = new B();
      h.subVectors(g, r.position), h.normalize();
      const d = new B();
      d.copy(h).multiplyScalar(l).add(r.position), r.position.copy(d), e.center = [d.x, d.y];
    });
    f(this, "makeHeadingSafe", (t) => (t %= 360, t < 0 && (t += 360), t));
    f(this, "makePitchSafe", (t) => t < this.minPitch ? this.minPitch : t > this.maxPitch ? this.maxPitch : t);
    f(this, "dispose", () => {
      const t = this.map.domContainer;
      t.removeEventListener(ye.DOWN, this.handlePointerDownWithThrottle), t.removeEventListener(Oa, this.handleWheelWithThrottle), t.removeEventListener(Sm, this.handleContextMenu), document.removeEventListener(ye.MOVE, this.handleMouseDraggingWithThrottle), document.removeEventListener(ye.UP, this.handlePointerUpWithThrottle), t.removeEventListener(ye.MOVE, this.handlePointerMoveWithThrottle), this.clearDoubleClickTimer(), this.cursorAnchor.remove();
    });
    this.map = t, this.enabled = !0, this.currentAction = xt.NONE, this._eventThrottle = new Yw(), this._draggingMovementAggregator = new ym(), this._zoomMovementAggregator = new ym({
      resistance: 5e-3
    });
  }
  set enabled(t) {
    t !== this._enabled && (t ? this.init() : this.dispose(), this._enabled = t);
  }
  handleCameraBeforeRender() {
    this.map.camera.updateMatrix(), this.map.camera.updateMatrixWorld();
    let t = !0;
    this.onEventCameraChange && (t = this.onEventCameraChange()), t ? (this.originCamera = this.map.camera.clone(), this.originMap = {
      center: this.map.center,
      pitch: this.map.pitch,
      heading: this.map.heading
    }) : (this.map.camera.copy(this.originCamera, !0), this.map._engine.camera.copy(this.originCamera, !0), this.map.camera.updateMatrix(), this.map.camera.updateMatrixWorld(), this.map.camera.updateProjectionMatrix(), this.map.pitch = this.originMap.pitch, this.map.center = this.originMap.center, this.map.heading = this.originMap.heading);
  }
  getPixelPosition(t) {
    let e = t.clientX, i = t.clientY;
    XP(t) && (e = t.changedTouches[0].clientX, i = t.changedTouches[0].clientY);
    const n = this.currentPixelX = (e - this.startBoundX) / this.startScaleX, o = this.currentPixelY = (i - this.startBoundY) / this.startScaleY;
    return [n, o];
  }
  ndcToPoint(t, e, i) {
    return Ui.setFromCamera(t, e), Ui.ray.intersectsPlane(Qa) ? (Ui.ray.intersectPlane(Qa, i), !0) : !1;
  }
  getNdc(t, e, i) {
    i.x = t / this.mapWidth * 2 - 1, i.y = 1 - e / this.mapHeight * 2;
  }
  async _pickPosition(t) {
    return await this.map._engine.rendering.picking.pickWorldPositionFromNdc(t);
  }
}
function wm(s, t, e) {
  const i = s.x - t.x, n = s.y - t.y;
  return Math.sqrt(i * i + n * n) < e;
}
const mN = new B(0, 0, -1), yN = new B(0, 1, 0), Sg = new js();
Sg.mouse = new Z();
const _m = new Zt(new B(0, 0, 1), 0), ln = new B();
new J();
class SN extends lr {
  constructor() {
    super(...arguments);
    f(this, "isBlankMap3D", !0);
    f(this, "_viewStateDirty", !0);
    f(this, "maxRange");
    f(this, "range");
    f(this, "bounds", []);
    f(this, "getPixelSize", (e) => {
      const [i, n] = this.getContainerSize();
      return Math.tan(ce.degToRad(this.fov / 2)) * e / n * 2;
    });
    f(this, "handleEventCameraChange", () => {
      const [e, i] = this.bounds;
      if (e && i) {
        const [n, o] = e, [r, a] = i, [g, c, l] = this.projectArrayCoordinate(this.getCenter());
        let h = !1;
        return Math.ceil(g) < n && (h = !0), Math.ceil(c) < o && (h = !0), Math.floor(g) > r && (h = !0), Math.floor(c) > a && (h = !0), !h;
      }
      return !0;
    });
  }
  resetHome() {
    this.lookAt(lr.DEFAULT_CENTER, {
      range: 1e7,
      pitch: 0,
      heading: 0
    });
  }
  initControl() {
    this.control = new pN(this), this.control.onEventPointerDown = this.handleEventPointerDown, this.control.onEventPointerUp = this.handleEventPointerUp, this.control.onEventClick = this.handleEventClick, this.control.onEventDblClick = this.handleEventDblClick, this.control.onEventMouseMove = this.handleEventMouseMove, this.control.onEventCameraChange = this.handleEventCameraChange;
  }
  updateView() {
    this.handleViewChange();
  }
  getCenter() {
    return this.unprojectArrayCoordinate(this.getProjectionCenter());
  }
  getProjectionCenter() {
    return Sg.setFromCamera(new Z(), this.camera), Sg.ray.intersectPlane(_m, ln), [ln.x, ln.y, ln.z];
  }
  getPitch() {
    return this.pitch;
  }
  getHeading() {
    return this.heading;
  }
  getRange() {
    return this.getCalcRange();
  }
  getCalcRange() {
    const e = this.getProjectionCenter();
    if (typeof this.camera.position.z == "string")
      throw new Error("camera.position.z is string");
    return this.camera.position.distanceTo(ln.set(e[0], e[1], e[2]));
  }
  getZoom() {
    return this.getZoomByZoomUnits(this.getZoomUnits());
  }
  getZoomUnits() {
    const e = this.getRange();
    return this.getPixelSize(e);
  }
  getCameraDistance(e) {
    if (this.range && !e)
      return this.range;
    if (e) {
      const i = this.getProjectionCenter(), n = this.camera.position.distanceTo(new B(i[0], i[1], i[2]));
      return this.range = n, this.range;
    }
    return Sg.setFromCamera(new Z(), this.camera), Sg.ray.intersectPlane(_m, ln), this.range = this.camera.position.distanceTo(ln), this.range;
  }
  setCenter(e) {
    this.setProjectionCenter(this.projectArrayCoordinate(e));
  }
  setProjectionCenter(e) {
    const i = this.decomposeRotation();
    this._cameraLookAt(this.camera, e, {
      ...i,
      height: this.camera.position.z
    }), this.center = e, this.updateView();
  }
  setZoom(e) {
    const i = this.decomposeRotation(), n = this.getProjectionCenter(), o = this.getZoomUnitsByZoom(e), [r, a] = this.getContainerSize(), g = a / 2 * o / Math.tan(ce.degToRad(this.fov / 2));
    this._cameraLookAt(this.camera, n, {
      ...i,
      range: g * 0.1,
      height: g
    }), this.range = g * 0.1, this.updateView();
  }
  setPitch(e) {
    const i = this.decomposeRotation(), n = this.getProjectionCenter(), o = this.camera.position.distanceTo(ln.set(n[0], n[1], n[2]));
    this._cameraLookAt(this.camera, n, {
      heading: i.heading,
      pitch: e,
      range: o
    }), this.pitch = e, this.updateView();
  }
  setHeading(e) {
    const i = this.decomposeRotation(), n = this.getProjectionCenter(), o = this.camera.position.distanceTo(ln.set(n[0], n[1], n[2]));
    this._cameraLookAt(this.camera, n, {
      heading: e,
      pitch: i.pitch,
      range: o
    }), this.heading = e, this.updateView();
  }
  setRange(e) {
    const i = this.decomposeRotation(), n = this.getProjectionCenter();
    this._cameraLookAt(this.camera, n, {
      ...i,
      range: e
    }), this.range = e, this.updateView();
  }
  setMaxRange(e) {
    this.maxRange = e;
  }
  zoomIn() {
    const e = this.decomposeRotation(), i = this.getProjectionCenter();
    let n = this.camera.position.distanceTo(ln.set(i[0], i[1], i[2])), r = 0.5 * ce.clamp(n, 0.5, 1e7);
    r + 0.2 > n ? (r = n - 0.2, n = 0.2) : n = n - r, this._cameraLookAt(this.camera, i, {
      ...e,
      range: n
    }), this.range = n, this.updateView();
  }
  zoomOut() {
    const e = this.decomposeRotation(), i = this.getProjectionCenter();
    let n = this.camera.position.distanceTo(ln.set(i[0], i[1], i[2])), r = -0.5 * ce.clamp(n, 0.5, 1e7);
    r + 0.2 > n ? (r = n - 0.2, n = 0.2) : n = n - r, this._cameraLookAt(this.camera, i, {
      ...e,
      range: n
    }), this.range = n, this.updateView();
  }
  lookAt(e, i = {}) {
    let n = [];
    e.isVector3 ? e.toArray(n) : n = e;
    let o = this.projectArrayCoordinate(n);
    const {
      heading: r,
      pitch: a,
      range: g
    } = i;
    isNaN(r) || (this.heading = r), isNaN(a) || (this.pitch = a), isNaN(g) || (this.range = g), this._cameraLookAt(this.camera, o, i);
  }
  _cameraLookAt(e, i, n) {
    const {
      heading: o = this.heading,
      pitch: r = this.pitch,
      range: a,
      height: g
    } = n, c = this._getCameraQuaternion(o, r), l = new B(0, 0, -1);
    l.applyQuaternion(c), l.negate();
    const h = ln;
    Array.isArray(i) ? h.set(i[0], i[1], i[2] || 0) : i.isVector3 && h.copy(i), isNaN(a) || h.add(l.multiplyScalar(a)), e.position.copy(h), e.quaternion.copy(c), e.updateMatrix(), e.updateMatrixWorld();
  }
  offsetFromHeadingPitchRange(e = 0, i = 0, n = 0) {
    const o = new Ye();
    o.setFromAxisAngle(new B(0, 0, 1), e * Math.PI / 180);
    const r = new Ye();
    r.setFromAxisAngle(new B(1, 0, 0), i * Math.PI / 180);
    const a = new Ye();
    a.multiplyQuaternions(o, r);
    const g = new B(0, 0, -1);
    g.applyQuaternion(a), g.negate();
    const c = new B();
    return c.copy(g).multiplyScalar(n), c;
  }
  decomposeRotation() {
    const e = this.camera.quaternion, i = mN.clone(), n = yN.clone();
    return i.applyQuaternion(e), i.clampScalar(-1, 1), n.applyQuaternion(e), this.decomposeRotationFromDirection(i, n);
  }
  decomposeRotationFromDirection(e, i) {
    const n = 180 - ce.radToDeg(Math.acos(e.z));
    let o = ce.radToDeg(Math.atan2(e.y, e.x));
    return e.x === 0 && e.y === 0 && (o = ce.radToDeg(Math.atan2(i.y, i.x))), o = (o - 90) % 360, {
      heading: o,
      pitch: n
    };
  }
  setBounds(e) {
    this.bounds = [
      this.projectArrayCoordinate(e[0]).map((i) => Math.ceil(i)),
      this.projectArrayCoordinate(e[1]).map((i) => Math.ceil(i))
    ];
  }
  lockDrag(e) {
    e ? this.control.onMouseDragging = () => !1 : this.control.onMouseDragging = null;
  }
  updateCamera() {
    const e = this.camera;
    e.updateMatrix(), e.updateMatrixWorld();
    const [i, n] = this.getContainerSize();
    e.aspect = i / n;
    const o = e.position.z;
    let r = this.pitch + this.fov / 2, a = 1e6;
    a = o / Math.cos(ce.degToRad(Math.min(r, 89))) * 1.25, e.near = Math.min(Math.max(o / 1e4, 0.1), 10), a < 2e4 && (a = 2e4), e.far = a, e.updateProjectionMatrix(), this._updateCameraLocation();
  }
}
class bN extends Jh {
  constructor(e, i, n) {
    super(e, n);
    f(this, "near", 0.1);
    f(this, "_far", 4e3);
    f(this, "fov", 35);
    f(this, "projectionName", "_bmap_mercator");
    f(this, "handleMapUpdate", () => {
      this.onViewChanged && this.onViewChanged();
    });
    f(this, "handleMapResize", () => {
      this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
    });
    f(this, "handleEventClick", (e) => {
      const i = this._engine.event, n = [e.pixel.x, e.pixel.y], o = [e.latlng.lng, e.latlng.lat], r = [e.point.lng, e.point.lat];
      i._handleClick({
        pixel: n,
        point: o,
        position: r,
        event: e
      });
    });
    f(this, "handleEventRightClick", (e) => {
      const i = this._engine.event, n = [e.pixel.x, e.pixel.y], o = [e.latlng.lng, e.latlng.lat], r = [e.point.lng, e.point.lat];
      i._handleRightClick({
        pixel: n,
        point: o,
        position: r,
        event: e
      });
    });
    f(this, "handleEventDblClick", (e) => {
      const i = this._engine.event, n = [e.pixel.x, e.pixel.y], o = [e.latlng.lng, e.latlng.lat], r = [e.point.lng, e.point.lat];
      i._handleDblClick({
        pixel: n,
        point: o,
        position: r,
        event: e
      });
    });
    f(this, "handleEventRightDblClick", (e) => {
      const i = this._engine.event, n = [e.pixel.x, e.pixel.y], o = [e.latlng.lng, e.latlng.lat], r = [e.point.lng, e.point.lat];
      i._handleRightDblClick({
        pixel: n,
        point: o,
        position: r,
        event: e
      });
    });
    this._engine = e, this.map = i;
  }
  getContainerSize() {
    const e = this.map.getSize();
    return [e.width, e.height];
  }
  getResolution() {
    const e = this.map.getSize();
    return new Z(e.width, e.height);
  }
  afterInit() {
    const e = this.map;
    this.canvas.style.zIndex = "3", e.getContainer().appendChild(this.canvas), e.addEventListener("update", this.handleMapUpdate), e.addEventListener("resize", this.handleMapResize), e.addEventListener("click", this.handleEventClick), e.addEventListener("rightclick", this.handleEventRightClick), e.addEventListener("dblclick", this.handleEventDblClick), e.addEventListener("rightdblclick", this.handleEventRightDblClick), this.handleMapResize();
  }
  getCenter() {
    const e = this.map.getCenter();
    return [e.lng, e.lat];
  }
  getZoom() {
    return this.map.getZoom();
  }
  getZoomUnits() {
    return this.map.getZoomUnits();
  }
  getZoomByZoomUnits(e) {
    return window.BMAPGL_84 ? Math.log2(this.MERCATOR_LENGTH / 128 / e) : 18 - Math.log2(e);
  }
  getZoomUnitsByZoom(e) {
    return this.map.getZoomUnits(e);
  }
  getHeading() {
    return this.map.getHeading();
  }
  getPitch() {
    return this.map.getTilt();
  }
  setCenter(e) {
    this.map.setCenter(e);
  }
  setProjectionCenter(e) {
    const i = this.unprojectArrayCoordinate(e);
    this.setCenter(i);
  }
  setZoom(e) {
    this.map.setZoom(e);
  }
  setPitch(e) {
    this.map.setTilt(e);
  }
  setHeading(e) {
    this.map.setHeading(e);
  }
  setBounds(e) {
    let i = [this.projectArrayCoordinate(e[0]), this.projectArrayCoordinate(e[1])];
    this.map.setBounds(new BMapGL.Point(i[0][0], i[0][1]), new BMapGL.Point(i[1][0], i[1][1]));
  }
  setMaxRange(e) {
    console.warn(`setMaxRange is only compatible with 3DMap Control,
            please set options 'map: {is3DControl: true}' when Engine is created`);
  }
  getBounds() {
    const e = new B(), i = new B(), n = this.map.getBoundsIn();
    return e.set(n.getMin().lng, n.getMin().lat, 0), i.set(n.getMax().lng, n.getMax().lat, 0), new Ue(e, i);
  }
  enableControl() {
    this.map.enableDragging();
  }
  disableControl() {
    this.map.disableDragging();
  }
  zoomIn() {
    this.map.zoomIn();
  }
  zoomOut() {
    this.map.zoomOut();
  }
  updateCamera() {
    this.updateMatrixWorld(), this.updateProjectionMatrix();
  }
  updateMatrixWorld() {
    const e = this.map, i = this.camera, n = e.getCenterIn(), o = [n.lng, n.lat], r = e.getZoomUnits(), a = e.getTilt(), g = e.getHeading(), [c, l] = this.getContainerSize(), h = l / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * r;
    this.cameraDistance = h, i.position.set(0, 0, 0), i.quaternion.set(0, 0, 0, 1), i.up.set(0, 1, 0), i.translateX(o[0]), i.translateY(o[1]), i.rotateOnAxis(new B(0, 0, 1), g * Math.PI / 180), i.rotateOnAxis(new B(1, 0, 0), a * Math.PI / 180), i.translateZ(h), i.updateMatrix(), i.updateMatrixWorld();
  }
  updateProjectionMatrix() {
    const e = this.camera, [i, n] = this.getContainerSize(), o = this.map.getZoomUnits();
    e.aspect = i / n, e.near = 0.1, e.far = this._far * o, e.far < 1e3 && (e.far = 1e3), e.updateProjectionMatrix();
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  getProjectionCenter() {
    const e = this.map.getCenterIn();
    return [e.lng, e.lat];
  }
  dispose() {
    const e = this.map;
    e.getContainer().removeChild(this.canvas), e.removeEventListener("update", this.handleMapUpdate), e.removeEventListener("resize", this.handleMapResize), e.removeEventListener("click", this.handleEventClick), super.dispose();
  }
  get far() {
    return this._far;
  }
  set far(e) {
  }
}
class qw extends Jh {
  constructor(e, i, n) {
    super(e, n);
    f(this, "MERCATOR_LENGTH", 200375083427892e-7);
    f(this, "projectionName", "_web_mercator");
    f(this, "origin", [0, 0]);
    f(this, "center", [0, 0]);
    f(this, "pitch", 0);
    f(this, "heading", 0);
    f(this, "near", 0.1);
    f(this, "_far", 8e3);
    f(this, "fov", 35);
    f(this, "cameraDistance", 1e3);
    f(this, "handleEventClick", (e) => {
      const i = this._engine.event, n = [e.point.x, e.point.y], o = [e.lngLat.lng, e.lngLat.lat], r = this.projectArrayCoordinate(o);
      i._handleClick({
        pixel: n,
        point: o,
        position: r,
        event: e.originalEvent
      });
    });
    f(this, "handleEventDblClick", (e) => {
      const i = this._engine.event, n = [e.point.x, e.point.y], o = [e.lngLat.lng, e.lngLat.lat], r = this.projectArrayCoordinate(o);
      i._handleDblClick({
        pixel: n,
        point: o,
        position: r,
        event: e.originalEvent
      });
    });
    f(this, "handleEventRightClick", (e) => {
      const i = this._engine.event, n = [e.point.x, e.point.y], o = [e.lngLat.lng, e.lngLat.lat], r = this.projectArrayCoordinate(o);
      i._handleRightClick({
        pixel: n,
        point: o,
        position: r,
        event: e.originalEvent
      });
    });
    f(this, "handleMapResize", () => {
      this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
    });
    this._engine = e, this.map = i, this.domContainer = i._container;
  }
  afterInit() {
    this.canvas.style.pointerEvents = "none", this.domContainer.appendChild(this.canvas);
    const e = this.map;
    e.on("render", (i) => {
      this.onViewChanged && this.onViewChanged();
    }), e.on("click", this.handleEventClick), e.on("contextmenu", this.handleEventRightClick), e.on("dblclick", this.handleEventDblClick), e.on("resize", () => {
      this.handleMapResize();
    }), this.handleMapResize();
  }
  getContainerSize() {
    return [
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    ];
  }
  getResolution() {
    return new Z(this.domContainer.clientWidth, this.domContainer.clientHeight);
  }
  setCenter(e) {
    this.map.setCenter(e);
  }
  setZoom(e) {
    this.map.setZoom(e);
  }
  setHeading(e) {
    this.map.setBearing(e);
  }
  setPitch(e) {
    this.map.setPitch(e);
  }
  getCenter() {
    const e = this.map.getCenter();
    return [e.lng, e.lat];
  }
  getZoom() {
    return this.map.getZoom();
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 256 / Math.pow(2, e);
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 256 / e);
  }
  getZoomUnits() {
    return this.getZoomUnitsByZoom(this.map.getZoom());
  }
  getPitch() {
    return this.map.getPitch();
  }
  getHeading() {
    return this.map.getBearing();
  }
  enableControl() {
    this.map.dragPan.enable(), this.map.dragRotate.enable();
  }
  disableControl() {
    this.map.dragPan.disable(), this.map.dragRotate.disable();
  }
  zoomIn() {
    this.setZoom(this.getZoom() + 1);
  }
  zoomOut() {
    this.setZoom(this.getZoom() - 1);
  }
  flyTo(e) {
  }
  updateCamera() {
    this.updateMatrixWorld(), this.updateProjectionMatrix();
  }
  updateMatrixWorld() {
    this.map;
    const e = this.camera, i = this.getCenter(), n = this.getZoomUnits(), o = this.getPitch(), r = this.getHeading(), [a, g] = this.getContainerSize(), c = this.projectArrayCoordinate(i), l = g / 2 / Math.tan(this.fov / 2 * Math.PI / 180) * n;
    this.cameraDistance = l, e.position.set(0, 0, 0), e.quaternion.set(0, 0, 0, 1), e.up.set(0, 1, 0), e.translateX(c[0]), e.translateY(c[1]), e.rotateOnAxis(new B(0, 0, -1), r * Math.PI / 180), e.rotateOnAxis(new B(1, 0, 0), o * Math.PI / 180), e.translateZ(l), e.updateMatrix();
  }
  updateProjectionMatrix() {
    const e = this.camera, i = this.getZoomUnits(), [n, o] = this.getContainerSize();
    e.aspect = n / o, e.fov = this.fov, e.near = this.near * i, e.far = this._far * i, e.updateProjectionMatrix();
  }
  dispose() {
    this.domContainer.removeChild(this.canvas), this._engine.event, super.dispose();
  }
  getProjectionCenter() {
    const e = this.map.getCenter();
    return this.projectArrayCoordinate(e);
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  get far() {
    return this._far;
  }
  set far(e) {
  }
}
f(qw, "EARTH_RADIUS", 637e4);
new B();
class BN extends Wt {
  constructor(t, e) {
    super(), this._ellipsoid = t, this._engine = e;
  }
  onBeforeScenePrepareRender(t, e, i, n) {
  }
  get ellipsoid() {
    return this._ellipsoid;
  }
}
const at = {
  LEFT_DRAG: 0,
  RIGHT_DRAG: 1,
  MIDDLE_DRAG: 2,
  WHEEL: 3,
  PINCH: 4
};
Object.freeze(at);
function wN() {
  return !0;
}
function ko(s, t) {
  t = he(
    t,
    "This object was destroyed, i.e., destroy() was called."
  );
  function e() {
    throw new re(t);
  }
  for (const i in s)
    typeof s[i] == "function" && (s[i] = e);
  s.isDestroyed = wN;
}
const en = {
  SHIFT: 0,
  CTRL: 1,
  ALT: 2
};
Object.freeze(en);
function Ko() {
  this._array = [], this._hash = {};
}
Object.defineProperties(Ko.prototype, {
  length: {
    get: function() {
      return this._array.length;
    }
  },
  values: {
    get: function() {
      return this._array;
    }
  }
});
Ko.prototype.contains = function(s) {
  if (typeof s != "string" && typeof s != "number")
    throw new re("key is required to be a string or number.");
  return F(this._hash[s]);
};
Ko.prototype.set = function(s, t) {
  if (typeof s != "string" && typeof s != "number")
    throw new re("key is required to be a string or number.");
  var e = this._hash[s];
  t !== e && (this.remove(s), this._hash[s] = t, this._array.push(t));
};
Ko.prototype.get = function(s) {
  if (typeof s != "string" && typeof s != "number")
    throw new re("key is required to be a string or number.");
  return this._hash[s];
};
Ko.prototype.remove = function(s) {
  if (F(s) && typeof s != "string" && typeof s != "number")
    throw new re("key is required to be a string or number.");
  var t = this._hash[s], e = F(t);
  if (e) {
    var i = this._array;
    i.splice(i.indexOf(t), 1), delete this._hash[s];
  }
  return e;
};
Ko.prototype.removeAll = function() {
  var s = this._array;
  s.length > 0 && (this._hash = {}, s.length = 0);
};
const it = {
  LEFT_DOWN: 0,
  LEFT_UP: 1,
  LEFT_CLICK: 2,
  LEFT_DOUBLE_CLICK: 3,
  RIGHT_DOWN: 5,
  RIGHT_UP: 6,
  RIGHT_CLICK: 7,
  MIDDLE_DOWN: 10,
  MIDDLE_UP: 11,
  MIDDLE_CLICK: 12,
  MOUSE_MOVE: 15,
  WHEEL: 16,
  PINCH_START: 17,
  PINCH_END: 18,
  PINCH_MOVE: 19
};
Object.freeze(it);
function Vo(s, t, e) {
  var i = s._element;
  if (i === document)
    return e.x = t.clientX, e.y = t.clientY, e;
  var n = i.getBoundingClientRect();
  return e.x = t.clientX - n.left, e.y = t.clientY - n.top, e;
}
function KC(s, t) {
  var e = s;
  return F(t) && (e += "+" + t), e;
}
function Gr(s) {
  if (s.shiftKey)
    return en.SHIFT;
  if (s.ctrlKey)
    return en.CTRL;
  if (s.altKey)
    return en.ALT;
}
const Ft = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
function Oi(s, t, e, i) {
  function n(o) {
    i(s, o);
  }
  e.addEventListener(t, n, {
    capture: !1,
    passive: !1
  }), s._removalFunctions.push(function() {
    e.removeEventListener(t, n, !1);
  });
}
function _N(s) {
  var t = s._element, e = F(t.disableRootEvents) ? t : document;
  typeof PointerEvent < "u" ? (Oi(
    s,
    "pointerdown",
    t,
    MN
  ), Oi(
    s,
    "pointerup",
    t,
    vm
  ), Oi(
    s,
    "pointermove",
    t,
    EN
  ), Oi(
    s,
    "pointercancel",
    t,
    vm
  )) : (Oi(
    s,
    "mousedown",
    t,
    $w
  ), Oi(
    s,
    "mouseup",
    e,
    e_
  ), Oi(
    s,
    "mousemove",
    e,
    t_
  ), Oi(
    s,
    "touchstart",
    t,
    LN
  ), Oi(
    s,
    "touchend",
    e,
    xm
  ), Oi(
    s,
    "touchmove",
    e,
    GN
  ), Oi(
    s,
    "touchcancel",
    e,
    xm
  )), Oi(
    s,
    "dblclick",
    t,
    vN
  );
  var i;
  "onwheel" in t ? i = "wheel" : document.onmousewheel !== void 0 ? i = "mousewheel" : i = "DOMMouseScroll", Oi(s, i, t, TN);
}
function xN(s) {
  for (var t = s._removalFunctions, e = 0; e < t.length; ++e)
    t[e]();
}
var du = {
  position: new Z()
};
function HC(s) {
  s._lastSeenTouchEvent = Date.now();
}
function PC(s) {
  return Date.now() - s._lastSeenTouchEvent > Wn.mouseEmulationIgnoreMilliseconds;
}
function hA(s, t, e) {
  var i = s.x - t.x, n = s.y - t.y, o = Math.sqrt(i * i + n * n);
  return o < e;
}
function $w(s, t) {
  if (!!PC(s)) {
    var e = t.button;
    s._buttonDown[e] = !0;
    var i;
    if (e === Ft.LEFT)
      i = it.LEFT_DOWN;
    else if (e === Ft.MIDDLE)
      i = it.MIDDLE_DOWN;
    else if (e === Ft.RIGHT)
      i = it.RIGHT_DOWN;
    else
      return;
    var n = Vo(
      s,
      t,
      s._primaryPosition
    );
    oe.clone(n, s._primaryStartPosition), oe.clone(n, s._primaryPreviousPosition);
    var o = Gr(t), r = s.getInputAction(
      i,
      o
    );
    F(r) && (oe.clone(n, du.position), du.event = t, r(du), t.preventDefault());
  }
}
var uu = {
  position: new Z()
}, Iu = {
  position: new Z()
};
function Au(s, t, e, i) {
  var n = Gr(i), o = s.getInputAction(
    t,
    n
  ), r = s.getInputAction(
    e,
    n
  );
  if (F(o) || F(r)) {
    var a = Vo(
      s,
      i,
      s._primaryPosition
    );
    if (F(o) && (oe.clone(a, uu.position), uu.event = i, o(uu)), F(r)) {
      var g = s._primaryStartPosition;
      hA(
        g,
        a,
        s._clickPixelTolerance
      ) && (oe.clone(a, Iu.position), Iu.event = i, r(Iu));
    }
  }
}
function e_(s, t) {
  if (!!PC(s)) {
    var e = t.button;
    e !== Ft.LEFT && e !== Ft.MIDDLE && e !== Ft.RIGHT || (s._buttonDown[Ft.LEFT] && (Au(
      s,
      it.LEFT_UP,
      it.LEFT_CLICK,
      t
    ), s._buttonDown[Ft.LEFT] = !1), s._buttonDown[Ft.MIDDLE] && (Au(
      s,
      it.MIDDLE_UP,
      it.MIDDLE_CLICK,
      t
    ), s._buttonDown[Ft.MIDDLE] = !1), s._buttonDown[Ft.RIGHT] && (Au(
      s,
      it.RIGHT_UP,
      it.RIGHT_CLICK,
      t
    ), s._buttonDown[Ft.RIGHT] = !1));
  }
}
var vc = {
  startPosition: new Z(),
  endPosition: new Z()
};
function t_(s, t) {
  if (!!PC(s)) {
    var e = Gr(t), i = Vo(
      s,
      t,
      s._primaryPosition
    ), n = s._primaryPreviousPosition, o = s.getInputAction(
      it.MOUSE_MOVE,
      e
    );
    F(o) && (oe.clone(n, vc.startPosition), oe.clone(i, vc.endPosition), vc.event = t, o(vc)), oe.clone(i, n), (s._buttonDown[Ft.LEFT] || s._buttonDown[Ft.MIDDLE] || s._buttonDown[Ft.RIGHT]) && t.preventDefault();
  }
}
var Cu = {
  position: new Z()
};
function vN(s, t) {
  var e = t.button, i;
  if (e === Ft.LEFT)
    i = it.LEFT_DOUBLE_CLICK;
  else
    return;
  var n = Gr(t), o = s.getInputAction(
    i,
    n
  );
  F(o) && (Vo(s, t, Cu.position), Cu.event = t, o(Cu));
}
function TN(s, t) {
  var e;
  if (F(t.deltaY)) {
    var i = t.deltaMode;
    i === t.DOM_DELTA_PIXEL ? e = -t.deltaY : i === t.DOM_DELTA_LINE ? e = -t.deltaY * 40 : e = -t.deltaY * 120;
  } else
    t.detail > 0 ? e = t.detail * -120 : e = t.wheelDelta;
  if (!!F(e)) {
    var n = Gr(t), o = s.getInputAction(
      it.WHEEL,
      n
    );
    F(o) && (o(e), t.preventDefault());
  }
}
function LN(s, t) {
  HC(s);
  var e = t.changedTouches, i, n = e.length, o, r, a = s._positions;
  for (i = 0; i < n; ++i)
    o = e[i], r = o.identifier, a.set(
      r,
      Vo(s, o, new Z())
    );
  td(s, t);
  var g = s._previousPositions;
  for (i = 0; i < n; ++i)
    o = e[i], r = o.identifier, g.set(
      r,
      oe.clone(a.get(r))
    );
}
function xm(s, t) {
  HC(s);
  var e = t.changedTouches, i, n = e.length, o, r, a = s._positions;
  for (i = 0; i < n; ++i)
    o = e[i], r = o.identifier, a.remove(r);
  td(s, t);
  var g = s._previousPositions;
  for (i = 0; i < n; ++i)
    o = e[i], r = o.identifier, g.remove(r);
}
var fu = {
  position: new Z()
}, Tc = {
  position1: new Z(),
  position2: new Z()
}, pu = {
  position: new Z()
}, mu = {
  position: new Z()
}, yu = {
  position: new Z()
};
function td(s, t) {
  var e = Gr(t), i = s._positions, n = i.length, o, r, a = s._isPinching;
  if (n !== 1 && s._buttonDown[Ft.LEFT]) {
    if (s._buttonDown[Ft.LEFT] = !1, F(s._touchHoldTimer) && (clearTimeout(s._touchHoldTimer), s._touchHoldTimer = void 0), o = s.getInputAction(
      it.LEFT_UP,
      e
    ), F(o) && (oe.clone(
      s._primaryPosition,
      pu.position
    ), pu.event = t, o(pu)), n === 0 && !s._isTouchHolding && (r = s.getInputAction(
      it.LEFT_CLICK,
      e
    ), F(r))) {
      var g = s._primaryStartPosition, c = s._previousPositions.values[0];
      hA(
        g,
        c,
        s._clickPixelTolerance
      ) && (oe.clone(
        s._primaryPosition,
        mu.position
      ), mu.event = t, r(mu));
    }
    s._isTouchHolding = !1;
  }
  if (n === 0 && a && (s._isPinching = !1, o = s.getInputAction(
    it.PINCH_END,
    e
  ), F(o) && o()), n === 1 && !a) {
    var l = i.values[0];
    oe.clone(l, s._primaryPosition), oe.clone(l, s._primaryStartPosition), oe.clone(
      l,
      s._primaryPreviousPosition
    ), s._buttonDown[Ft.LEFT] = !0, o = s.getInputAction(
      it.LEFT_DOWN,
      e
    ), F(o) && (oe.clone(l, fu.position), fu.event = t, o(fu)), s._touchHoldTimer = setTimeout(function() {
      if (!s.isDestroyed() && (s._touchHoldTimer = void 0, s._isTouchHolding = !0, r = s.getInputAction(
        it.RIGHT_CLICK,
        e
      ), F(r))) {
        var h = s._primaryStartPosition, d = s._previousPositions.values[0];
        hA(
          h,
          d,
          s._holdPixelTolerance
        ) && (oe.clone(
          s._primaryPosition,
          yu.position
        ), yu.event = t, r(yu));
      }
    }, Wn.touchHoldDelayMilliseconds), t.preventDefault();
  }
  n === 2 && !a && (s._isPinching = !0, o = s.getInputAction(
    it.PINCH_START,
    e
  ), F(o) && (oe.clone(i.values[0], Tc.position1), oe.clone(i.values[1], Tc.position2), Tc.event = t, o(Tc), t.preventDefault()));
}
function GN(s, t) {
  HC(s);
  var e = t.changedTouches, i, n = e.length, o, r, a = s._positions;
  for (i = 0; i < n; ++i) {
    o = e[i], r = o.identifier;
    var g = a.get(r);
    F(g) && Vo(s, o, g);
  }
  i_(s, t);
  var c = s._previousPositions;
  for (i = 0; i < n; ++i)
    o = e[i], r = o.identifier, oe.clone(
      a.get(r),
      c.get(r)
    );
}
var Lc = {
  startPosition: new Z(),
  endPosition: new Z()
}, Nr = {
  distance: {
    startPosition: new Z(),
    endPosition: new Z()
  },
  angleAndHeight: {
    startPosition: new Z(),
    endPosition: new Z()
  }
};
function i_(s, t) {
  var e = Gr(t), i = s._positions, n = s._previousPositions, o = i.length, r;
  if (o === 1 && s._buttonDown[Ft.LEFT]) {
    var a = i.values[0];
    oe.clone(a, s._primaryPosition);
    var g = s._primaryPreviousPosition;
    r = s.getInputAction(
      it.MOUSE_MOVE,
      e
    ), F(r) && (oe.clone(g, Lc.startPosition), oe.clone(a, Lc.endPosition), Lc.event = t, r(Lc)), oe.clone(a, g), t.preventDefault();
  } else if (o === 2 && s._isPinching && (r = s.getInputAction(
    it.PINCH_MOVE,
    e
  ), F(r))) {
    var c = i.values[0], l = i.values[1], h = n.values[0], d = n.values[1], C = l.x - c.x, p = l.y - c.y, m = Math.sqrt(C * C + p * p) * 0.25, b = d.x - h.x, S = d.y - h.y, A = Math.sqrt(b * b + S * S) * 0.25, u = (l.y + c.y) * 0.125, y = (d.y + h.y) * 0.125, I = Math.atan2(p, C), M = Math.atan2(S, b);
    oe.fromElements(
      0,
      A,
      Nr.distance.startPosition
    ), oe.fromElements(
      0,
      m,
      Nr.distance.endPosition
    ), oe.fromElements(
      M,
      y,
      Nr.angleAndHeight.startPosition
    ), oe.fromElements(
      I,
      u,
      Nr.angleAndHeight.endPosition
    ), Nr.event = t, r(Nr);
  }
}
function MN(s, t) {
  if (t.target.setPointerCapture(t.pointerId), t.pointerType === "touch") {
    var e = s._positions, i = t.pointerId;
    e.set(
      i,
      Vo(s, t, new Z())
    ), td(s, t);
    var n = s._previousPositions;
    n.set(
      i,
      oe.clone(e.get(i))
    );
  } else
    $w(s, t);
}
function vm(s, t) {
  if (t.pointerType === "touch") {
    var e = s._positions, i = t.pointerId;
    e.remove(i), td(s, t);
    var n = s._previousPositions;
    n.remove(i);
  } else
    e_(s, t);
}
function EN(s, t) {
  if (t.pointerType === "touch") {
    var e = s._positions, i = t.pointerId, n = e.get(i);
    if (!F(n))
      return;
    Vo(s, t, n), i_(s, t);
    var o = s._previousPositions;
    oe.clone(
      e.get(i),
      o.get(i)
    );
  } else
    t_(s, t);
}
function Wn(s) {
  this._inputEvents = {}, this._buttonDown = {
    LEFT: !1,
    MIDDLE: !1,
    RIGHT: !1
  }, this._isPinching = !1, this._isTouchHolding = !1, this._lastSeenTouchEvent = -Wn.mouseEmulationIgnoreMilliseconds, this._primaryStartPosition = new Z(), this._primaryPosition = new Z(), this._primaryPreviousPosition = new Z(), this._positions = new Ko(), this._previousPositions = new Ko(), this._removalFunctions = [], this._touchHoldTimer = void 0, this._clickPixelTolerance = 5, this._holdPixelTolerance = 25, this._element = he(s, document), _N(this);
}
Wn.prototype.setInputAction = function(s, t, e) {
  if (!F(s))
    throw new re("action is required.");
  if (!F(t))
    throw new re("type is required.");
  var i = KC(t, e);
  this._inputEvents[i] = s;
};
Wn.prototype.getInputAction = function(s, t) {
  if (!F(s))
    throw new re("type is required.");
  var e = KC(s, t);
  return this._inputEvents[e];
};
Wn.prototype.removeInputAction = function(s, t) {
  if (!F(s))
    throw new re("type is required.");
  var e = KC(s, t);
  delete this._inputEvents[e];
};
Wn.prototype.isDestroyed = function() {
  return !1;
};
Wn.prototype.destroy = function() {
  return xN(this), ko(this);
};
Wn.mouseEmulationIgnoreMilliseconds = 800;
Wn.touchHoldDelayMilliseconds = 1500;
function _i(s, t) {
  let e = s;
  return F(t) && (e += "+" + t), e;
}
function RN(s, t) {
  oe.clone(
    s.distance.startPosition,
    t.distance.startPosition
  ), oe.clone(
    s.distance.endPosition,
    t.distance.endPosition
  ), oe.clone(
    s.angleAndHeight.startPosition,
    t.angleAndHeight.startPosition
  ), oe.clone(
    s.angleAndHeight.endPosition,
    t.angleAndHeight.endPosition
  );
}
function Tm(s, t, e) {
  const i = _i(at.PINCH, t), n = s._update, o = s._isDown, r = s._eventStartPosition, a = s._pressTime, g = s._releaseTime;
  n[i] = !0, o[i] = !1, r[i] = new Z();
  let c = s._movement[i];
  F(c) || (c = s._movement[i] = {}), c.distance = {
    startPosition: new Z(),
    endPosition: new Z()
  }, c.angleAndHeight = {
    startPosition: new Z(),
    endPosition: new Z()
  }, c.prevAngle = 0, s._eventHandler.setInputAction(
    function(l) {
      s._buttonsDown++, o[i] = !0, a[i] = new Date(), oe.lerp(
        l.position1,
        l.position2,
        0.5,
        r[i]
      ), s._rendering.requestRender();
    },
    it.PINCH_START,
    t
  ), s._eventHandler.setInputAction(
    function() {
      s._buttonsDown = Math.max(s._buttonsDown - 1, 0), o[i] = !1, g[i] = new Date(), s._rendering.requestRender();
    },
    it.PINCH_END,
    t
  ), s._eventHandler.setInputAction(
    function(l) {
      if (o[i]) {
        n[i] ? (RN(l, c), n[i] = !1, c.prevAngle = c.angleAndHeight.startPosition.x) : (oe.clone(
          l.distance.endPosition,
          c.distance.endPosition
        ), oe.clone(
          l.angleAndHeight.endPosition,
          c.angleAndHeight.endPosition
        ));
        let h = c.angleAndHeight.endPosition.x;
        const d = c.prevAngle, C = Math.PI * 2;
        for (; h >= d + Math.PI; )
          h -= C;
        for (; h < d - Math.PI; )
          h += C;
        c.angleAndHeight.endPosition.x = -h * e.clientWidth / 12, c.angleAndHeight.startPosition.x = -d * e.clientWidth / 12, s._rendering.requestRender();
      }
    },
    it.PINCH_MOVE,
    t
  );
}
function Lm(s, t) {
  const e = _i(at.WHEEL, t), i = s._pressTime, n = s._releaseTime, o = s._update;
  o[e] = !0;
  let r = s._movement[e];
  F(r) || (r = s._movement[e] = {});
  let a = s._lastMovement[e];
  F(a) || (a = s._lastMovement[e] = {
    startPosition: new Z(),
    endPosition: new Z(),
    valid: !1
  }), r.startPosition = new Z(), oe.clone(oe.ZERO, r.startPosition), r.endPosition = new Z(), s._eventHandler.setInputAction(
    function(g) {
      const c = 7.5 * X.toRadians(g);
      i[e] = n[e] = new Date(), r.endPosition.x = 0, r.endPosition.y = c, oe.clone(r.endPosition, a.endPosition), a.valid = !0, o[e] = !1, s._rendering.requestRender();
    },
    it.WHEEL,
    t
  );
}
function Fr(s, t, e) {
  const i = _i(e, t), n = s._isDown, o = s._eventStartPosition, r = s._pressTime, a = s._releaseTime;
  n[i] = !1, o[i] = new Z();
  let g = s._lastMovement[i];
  F(g) || (g = s._lastMovement[i] = {
    startPosition: new Z(),
    endPosition: new Z(),
    valid: !1
  });
  let c, l;
  e === at.LEFT_DRAG ? (c = it.LEFT_DOWN, l = it.LEFT_UP) : e === at.RIGHT_DRAG ? (c = it.RIGHT_DOWN, l = it.RIGHT_UP) : e === at.MIDDLE_DRAG && (c = it.MIDDLE_DOWN, l = it.MIDDLE_UP), s._eventHandler.setInputAction(
    function(h) {
      s._buttonsDown++, g.valid = !1, n[i] = !0, r[i] = new Date(), oe.clone(h.position, o[i]), h && s.onEventPointerDown && s.onEventPointerDown(h);
    },
    c,
    t
  ), s._eventHandler.setInputAction(
    function(h) {
      s._buttonsDown = Math.max(s._buttonsDown - 1, 0), n[i] = !1, a[i] = new Date(), h && s.onEventPointerUp && s.onEventPointerUp(h), s._rendering.requestRender();
    },
    l,
    t
  );
}
function Gm(s, t) {
  oe.clone(s.startPosition, t.startPosition), oe.clone(s.endPosition, t.endPosition);
}
function Mm(s, t) {
  const e = s._update, i = s._movement, n = s._lastMovement, o = s._isDown;
  for (const r in at)
    if (at.hasOwnProperty(r)) {
      const a = at[r];
      if (F(a)) {
        const g = _i(a, t);
        e[g] = !0, F(s._lastMovement[g]) || (s._lastMovement[g] = {
          startPosition: new Z(),
          endPosition: new Z(),
          valid: !1
        }), F(s._movement[g]) || (s._movement[g] = {
          startPosition: new Z(),
          endPosition: new Z()
        });
      }
    }
  s._eventHandler.setInputAction(
    function(r) {
      for (const a in at)
        if (at.hasOwnProperty(a)) {
          const g = at[a];
          if (F(g)) {
            const c = _i(g, t);
            o[c] ? (e[c] ? (Gm(i[c], n[c]), n[c].valid = !0, Gm(r, i[c]), e[c] = !1) : oe.clone(
              r.endPosition,
              i[c].endPosition
            ), s._rendering.requestRender()) : s.onEventMouseMove && s.onEventMouseMove(r);
          }
        }
      oe.clone(
        r.endPosition,
        s._currentMousePosition
      );
    },
    it.MOUSE_MOVE,
    t
  );
}
function Em(s, t) {
  s._eventHandler.setInputAction(
    function(e) {
      e && s.onEventClick && s.onEventClick(e), s._rendering.requestRender();
    },
    it.LEFT_CLICK,
    t
  ), s._eventHandler.setInputAction(
    function(e) {
      e && s.onEventClick && s.onEventClick(e), s._rendering.requestRender();
    },
    it.RIGHT_CLICK,
    t
  ), s._eventHandler.setInputAction(
    function(e) {
      e && s.onEventDblClick && s.onEventDblClick(e), s._rendering.requestRender();
    },
    it.LEFT_DOUBLE_CLICK,
    t
  );
}
function wn(s, t) {
  if (!F(s))
    throw new re("canvas is required.");
  this._eventHandler = new Wn(s), this._rendering = t, this._update = {}, this._movement = {}, this._lastMovement = {}, this._isDown = {}, this._eventStartPosition = {}, this._pressTime = {}, this._releaseTime = {}, this._buttonsDown = 0, this._currentMousePosition = new Z(), Lm(this, void 0), Tm(this, void 0, s), Fr(this, void 0, at.LEFT_DRAG), Fr(this, void 0, at.RIGHT_DRAG), Fr(this, void 0, at.MIDDLE_DRAG), Mm(this, void 0), Em(this, void 0);
  for (const e in en)
    if (en.hasOwnProperty(e)) {
      const i = en[e];
      F(i) && (Lm(this, i), Tm(this, i, s), Fr(this, i, at.LEFT_DRAG), Fr(this, i, at.RIGHT_DRAG), Fr(this, i, at.MIDDLE_DRAG), Mm(this, i), Em(this, i));
    }
}
Object.defineProperties(wn.prototype, {
  currentMousePosition: {
    get: function() {
      return this._currentMousePosition;
    }
  },
  anyButtonDown: {
    get: function() {
      const s = !this._update[_i(at.WHEEL)] || !this._update[_i(at.WHEEL, en.SHIFT)] || !this._update[_i(at.WHEEL, en.CTRL)] || !this._update[_i(at.WHEEL, en.ALT)];
      return this._buttonsDown > 0 || s;
    }
  }
});
wn.prototype.isMoving = function(s, t) {
  const e = _i(s, t);
  return !this._update[e];
};
wn.prototype.getMovement = function(s, t) {
  const e = _i(s, t);
  return this._movement[e];
};
wn.prototype.getLastMovement = function(s, t) {
  const e = _i(s, t), i = this._lastMovement[e];
  if (i.valid)
    return i;
};
wn.prototype.isButtonDown = function(s, t) {
  const e = _i(s, t);
  return this._isDown[e];
};
wn.prototype.getStartMousePosition = function(s, t) {
  if (s === at.WHEEL)
    return this._currentMousePosition;
  const e = _i(s, t);
  return this._eventStartPosition[e];
};
wn.prototype.getButtonPressTime = function(s, t) {
  const e = _i(s, t);
  return this._pressTime[e];
};
wn.prototype.getButtonReleaseTime = function(s, t) {
  const e = _i(s, t);
  return this._releaseTime[e];
};
wn.prototype.reset = function() {
  for (const s in this._update)
    this._update.hasOwnProperty(s) && (this._update[s] = !0);
};
wn.prototype.isDestroyed = function() {
  return !1;
};
wn.prototype.destroy = function() {
  return this._eventHandler = this._eventHandler && this._eventHandler.destroy(), ko(this);
};
var Dl = {};
Dl.getHeight = function(s, t, e) {
  return (s - e) * t + e;
};
function vi(s, t, e) {
  this.heading = he(s, 0), this.pitch = he(t, 0), this.roll = he(e, 0);
}
vi.fromQuaternion = function(s, t) {
  if (!F(s))
    throw new re("quaternion is required");
  F(t) || (t = new vi());
  const e = 2 * (s.w * s.y - s.z * s.x), i = 1 - 2 * (s.x * s.x + s.y * s.y), n = 2 * (s.w * s.x + s.y * s.z), o = 1 - 2 * (s.y * s.y + s.z * s.z), r = 2 * (s.w * s.z + s.x * s.y);
  return t.heading = -Math.atan2(r, o), t.roll = Math.atan2(n, i), t.pitch = -X.asinClamped(e), t;
};
vi.fromDegrees = function(s, t, e, i) {
  if (!F(s))
    throw new re("heading is required");
  if (!F(t))
    throw new re("pitch is required");
  if (!F(e))
    throw new re("roll is required");
  return F(i) || (i = new vi()), i.heading = s * X.RADIANS_PER_DEGREE, i.pitch = t * X.RADIANS_PER_DEGREE, i.roll = e * X.RADIANS_PER_DEGREE, i;
};
vi.clone = function(s, t) {
  if (!!F(s))
    return F(t) ? (t.heading = s.heading, t.pitch = s.pitch, t.roll = s.roll, t) : new vi(
      s.heading,
      s.pitch,
      s.roll
    );
};
vi.equals = function(s, t) {
  return s === t || F(s) && F(t) && s.heading === t.heading && s.pitch === t.pitch && s.roll === t.roll;
};
vi.equalsEpsilon = function(s, t, e, i) {
  return s === t || F(s) && F(t) && X.equalsEpsilon(
    s.heading,
    t.heading,
    e,
    i
  ) && X.equalsEpsilon(
    s.pitch,
    t.pitch,
    e,
    i
  ) && X.equalsEpsilon(
    s.roll,
    t.roll,
    e,
    i
  );
};
vi.prototype.clone = function(s) {
  return vi.clone(this, s);
};
vi.prototype.equals = function(s) {
  return vi.equals(this, s);
};
vi.prototype.equalsEpsilon = function(s, t, e) {
  return vi.equalsEpsilon(
    this,
    s,
    t,
    e
  );
};
vi.prototype.toString = function() {
  return `(${this.heading}, ${this.pitch}, ${this.roll})`;
};
const Eo = {}, DN = new Me(0, 0, 0, 1), KN = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};
new B(
  Math.PI,
  X.PI_OVER_TWO
);
let Gc = new Me(0, 0, 0, 0);
new B();
const Rm = new Me(0, 0, 0, 0), Dm = new B();
function HN(s, t, e, i) {
  const n = e.viewMatrix, o = _e.multiplyByVector(
    n,
    Us.fromElements(
      s.x,
      s.y,
      s.z,
      1,
      Rm
    ),
    Rm
  ), r = _.multiplyComponents(
    t,
    _.normalize(o, Dm),
    Dm
  );
  return o.x += t.x + r.x, o.y += t.y + r.y, o.z += r.z, _e.multiplyByVector(
    e.frustum.projectionMatrix,
    o,
    i
  );
}
Eo.computeActualEllipsoidPosition = function(s, t, e) {
  if (s.mode === Dt.SCENE3D)
    return _.clone(t, e);
};
Eo.worldToWindowCoordinates = function(s, t, e) {
  return Eo.worldWithEyeOffsetToWindowCoordinates(
    s,
    t,
    _.ZERO,
    e
  );
};
Eo.worldWithEyeOffsetToWindowCoordinates = function(s, t, e, i) {
  if (!F(s))
    throw new re("scene is required.");
  if (!F(t))
    throw new re("position is required.");
  const n = Eo.computeActualEllipsoidPosition(
    s,
    t,
    DN
  );
  if (!F(n))
    return;
  const o = s.canvas, r = KN;
  r.x = 0, r.y = 0, r.width = o.clientWidth, r.height = o.clientHeight;
  const a = s.camera;
  let g = !1;
  if (s.mode, Dt.SCENE2D, s.mode !== Dt.SCENE2D || g) {
    if (Gc = HN(n, e, a, Gc), Gc.z < 0)
      return;
    i = Eo.clipToGLWindowCoordinates(
      r,
      Gc,
      i
    );
  }
  return i.y = o.clientHeight - i.y, i;
};
const Km = new B(), Hm = new B(), Pm = new J();
Eo.clipToGLWindowCoordinates = function(s, t, e) {
  return _.divideByScalar(t, t.w, Km), _e.computeViewportTransformation(s, 0, 1, Pm), _e.multiplyByPoint(Pm, Km, Hm), oe.fromCartesian3(Hm, e);
};
function qg(s) {
  if (!F(s))
    throw new re("scene is required.");
  this.enableInputs = !0, this.enableTranslate = !0, this.enableZoom = !0, this.enableRotate = !0, this.enableTilt = !0, this.enableLook = !0, this.enableFixCenter = !1, this.enableTerrainCollision = !1, this.inertiaSpin = 0.9, this.inertiaTranslate = 0.9, this.inertiaZoom = 0.8, this.maximumMovementRatio = 0.1, this.bounceAnimationTime = 3, this.minimumZoomDistance = 1, this.maximumZoomDistance = Number.POSITIVE_INFINITY, this.translateEventTypes = at.LEFT_DRAG, this.zoomEventTypes = [
    at.MIDDLE_DRAG,
    at.WHEEL,
    at.PINCH
  ], this.rotateEventTypes = at.LEFT_DRAG, this.tiltEventTypes = [
    at.RIGHT_DRAG,
    at.PINCH,
    {
      eventType: at.LEFT_DRAG,
      modifier: en.CTRL
    },
    {
      eventType: at.RIGHT_DRAG,
      modifier: en.CTRL
    }
  ], this.lookEventTypes = {
    eventType: at.LEFT_DRAG,
    modifier: en.SHIFT
  }, this.minimumPickingTerrainHeight = 15e4, this._minimumPickingTerrainHeight = this.minimumPickingTerrainHeight, this.minimumPickingTerrainDistanceWithInertia = 4e3, this.minimumCollisionTerrainHeight = 15e3, this._minimumCollisionTerrainHeight = this.minimumCollisionTerrainHeight, this.minimumTrackBallHeight = 75e5, this._minimumTrackBallHeight = this.minimumTrackBallHeight, this.enableCollisionDetection = !0, this._scene = s, this._globe = void 0, this._ellipsoid = void 0, this._lastGlobeHeight = 0, this._aggregator = new wn(s.canvas, s.rendering), this._lastInertiaSpinMovement = void 0, this._lastInertiaZoomMovement = void 0, this._lastInertiaTranslateMovement = void 0, this._lastInertiaTiltMovement = void 0, this._inertiaDisablers = {
    _lastInertiaZoomMovement: [
      "_lastInertiaSpinMovement",
      "_lastInertiaTranslateMovement",
      "_lastInertiaTiltMovement"
    ],
    _lastInertiaTiltMovement: [
      "_lastInertiaSpinMovement",
      "_lastInertiaTranslateMovement"
    ]
  }, this._horizontalRotationAxis = void 0, this._tiltCenterMousePosition = new Z(-1, -1), this._tiltCenter = new B(), this._translateMousePosition = new Z(), this._rotateMousePosition = new Z(-1, -1), this._rotateStartPosition = new B(), this._strafeStartPosition = new B(), this._strafeMousePosition = new Z(), this._strafeEndMousePosition = new Z(), this._zoomMouseStart = new Z(-1, -1), this._zoomWorldPosition = new B(), this._useZoomWorldPosition = !1, this._panLastMousePosition = new Z(), this._panLastWorldPosition = new B(), this._tiltCVOffMap = !1, this._looking = !1, this._rotating = !1, this._strafing = !1, this._zoomingOnVector = !1, this._zoomingUnderground = !1, this._rotatingZoom = !1, this._adjustedHeightForTerrain = !1, this._cameraUnderground = !1;
  const t = s.mapProjection;
  this._maxCoord = t.project(
    new B(Math.PI, X.PI_OVER_TWO)
  ), this._zoomFactor = 5, this._rotateFactor = void 0, this._rotateRateRangeAdjustment = void 0, this._maximumRotateRate = 1.77, this._minimumRotateRate = 1 / 5e3, this._minimumZoomRate = 20, this._maximumZoomRate = 5906376272e3, this._minimumUndergroundPickDistance = 2e3, this._maximumUndergroundPickDistance = 1e4;
}
function PN(s, t) {
  if (s < 0)
    return 0;
  const e = (1 - t) * 25;
  return Math.exp(-e * s);
}
function NN(s) {
  return oe.equalsEpsilon(
    s.startPosition,
    s.endPosition,
    X.EPSILON14
  );
}
const FN = 0.4;
function kN(s, t, e, i, n, o, r) {
  let a = o[r];
  F(a) || (a = o[r] = {
    startPosition: new Z(),
    endPosition: new Z(),
    motion: new Z(),
    inertiaEnabled: !0
  });
  const g = s.getButtonPressTime(t, e), c = s.getButtonReleaseTime(t, e), l = g && c && (c.getTime() - g.getTime()) / 1e3, h = new Date(), d = c && (h.getTime() - c.getTime()) / 1e3;
  if (g && c && l < FN) {
    const C = PN(d, i), p = s.getLastMovement(t, e);
    if (!F(p) || NN(p) || !a.inertiaEnabled || (a.motion.x = (p.endPosition.x - p.startPosition.x) * 0.5, a.motion.y = (p.endPosition.y - p.startPosition.y) * 0.5, a.startPosition = oe.clone(
      p.startPosition,
      a.startPosition
    ), a.endPosition = oe.multiplyByScalar(
      a.motion,
      C,
      a.endPosition
    ), a.endPosition = oe.add(
      a.startPosition,
      a.endPosition,
      a.endPosition
    ), isNaN(a.endPosition.x) || isNaN(a.endPosition.y) || oe.distance(
      a.startPosition,
      a.endPosition
    ) < 0.5))
      return;
    if (!s.isButtonDown(t, e)) {
      const m = s.getStartMousePosition(t, e);
      n(o, m, a);
    }
  }
}
function VN(s, t) {
  if (F(t)) {
    let e = s[t];
    F(e) && (e.inertiaEnabled = !0);
    const i = s._inertiaDisablers[t];
    if (F(i)) {
      const n = i.length;
      for (let o = 0; o < n; ++o)
        e = s[i[o]], F(e) && (e.inertiaEnabled = !1);
    }
  }
}
const Nm = [];
function Ji(s, t, e, i, n, o) {
  if (!F(e))
    return;
  const r = s._aggregator;
  Array.isArray(e) || (Nm[0] = e, e = Nm);
  const a = e.length;
  for (let g = 0; g < a; ++g) {
    const c = e[g], l = F(c.eventType) ? c.eventType : c, h = c.modifier, d = r.isMoving(l, h) && r.getMovement(l, h), C = r.getStartMousePosition(l, h);
    s.enableInputs && t && (d ? (i(s, C, d), VN(s, o)) : n < 1 && kN(
      r,
      l,
      h,
      n,
      i,
      s,
      o
    ));
  }
}
const Mc = new yt(), zN = new B(), XN = new Z(), WN = new B(), ZN = new Z(), UN = new B(), ON = new B(), QN = new B(), YN = new B(), n_ = new B(), jN = new B(), JN = new B(), qN = new B(), $N = new B(), e2 = new B(), t2 = new B(), i2 = new B(), n2 = new B(), s2 = new B(), o2 = new B(), jo = new B(), Fm = new B(), km = new B(), Kl = {
  orientation: new vi()
}, Vm = new B();
function Su(s, t, e) {
  if (!t.enableFixCenter)
    return;
  const i = s.position.length(), n = X.asinClamped(De.WGS84.maximumRadius / i), o = Math.cos(n) * i, r = s.position.clone().normalize().negate().angleTo(s.directionWC), a = n - r, g = Math.tan(a) * o, c = Math.cos(a) * g, l = Math.sin(a) * g, d = o / Math.cos(a) - l, p = ce.degToRad(t._scene.rendering.camera.fov) / 2 - Math.atan(c / d);
  if (p < 0)
    return;
  let m = i - t._minimumTrackBallHeight * 0.85;
  if (m < 0)
    return;
  const b = 5e6;
  m = ce.clamp(m, 0, b);
  const S = 0.1 + 0.3 * (1 - m / b);
  let A = Math.max(e, 0.1);
  _.negate(s.position, Vm);
  const u = Vm.normalize(), y = _.dot(u, s.directionWC);
  let I = X.acosClamped(y);
  I > 0.1 && (I = p - S / 3), I *= A, !(I < 0) && (s.rotateAroundPoint(t._zoomWorldPosition, s.right, I), Kl.orientation.pitch -= I);
}
async function NC(s, t, e, i, n, o) {
  let r = 1;
  F(o) && (r = X.clamp(
    Math.abs(o),
    0.25,
    1
  ));
  const a = e.endPosition.y - e.startPosition.y, c = a > 0 ? s.minimumZoomDistance * r : 0, l = s.maximumZoomDistance, h = n - c;
  let d = i * h;
  d = X.clamp(
    d,
    s._minimumZoomRate,
    s._maximumZoomRate
  );
  let C = a / s._scene.canvas.clientHeight;
  C = Math.min(C, s.maximumMovementRatio);
  let p = d * C;
  if (s.enableCollisionDetection || s.minimumZoomDistance === 0 || !F(s._globe)) {
    if (p > 0 && Math.abs(n - c) < 1 || p < 0 && Math.abs(n - l) < 1)
      return;
    n - p < c ? p = n - c - 1 : n - p > l && (p = n - l);
  }
  const m = s._scene, b = m.camera, S = m.mode;
  if (s.enableFixCenter && b.positionWC.length() > 6317e4 && a < 0)
    return;
  const A = Kl.orientation;
  A.heading = b.heading, A.pitch = b.pitch, A.roll = b.roll;
  const u = he(
    e.inertiaEnabled,
    oe.equals(t, s._zoomMouseStart)
  );
  let y = s._zoomingOnVector, I = s._rotatingZoom, M;
  if (u || (s._zoomMouseStart = oe.clone(
    t,
    s._zoomMouseStart
  ), F(s._globe) && S === Ge.SCENE2D ? (M = b.getPickRay(t, Mc).origin, M = _.fromElements(
    M.y,
    M.z,
    M.x
  )) : F(s._globe) && (M = await Qs(
    s,
    t,
    zN
  )), F(M) ? (s._useZoomWorldPosition = !0, s._zoomWorldPosition = _.clone(
    M,
    s._zoomWorldPosition
  )) : s._useZoomWorldPosition = !1, y = s._zoomingOnVector = !1, I = s._rotatingZoom = !1, s._zoomingUnderground = s._cameraUnderground), !s._useZoomWorldPosition) {
    S === Ge.SCENE3D && p < 0 && Su(b, s, p), b.zoomIn(p);
    return;
  }
  let G = S === Ge.COLUMBUS_VIEW;
  if (b.positionCartographic.z < 2e6 && (I = !0), !u || I) {
    if (S === Ge.SCENE2D) {
      const x = s._zoomWorldPosition, L = b.position;
      if (!_.equals(x, L) && b.positionCartographic.z < s._maxCoord.x * 2) {
        const E = b.position.x, T = _.subtract(
          x,
          L,
          WN
        );
        _.normalize(T, T);
        const R = _.distance(x, L) * p / (b.getMagnitude() * 0.5);
        b.move(T, R * 0.5), (b.position.x < 0 && E > 0 || b.position.x > 0 && E < 0) && (M = b.getPickRay(t, Mc).origin, M = _.fromElements(
          M.y,
          M.z,
          M.x
        ), s._zoomWorldPosition = _.clone(
          M,
          s._zoomWorldPosition
        ));
      }
    } else if (S === Ge.SCENE3D) {
      const x = _.normalize(
        b.position,
        n_
      );
      if (s._cameraUnderground || s._zoomingUnderground || b.positionCartographic.z < 3e3 && Math.abs(_.dot(b.direction, x)) < 0.6)
        G = !0;
      else {
        const L = m.canvas, E = ZN;
        E.x = L.clientWidth / 2, E.y = L.clientHeight / 2;
        const T = await Qs(
          s,
          E,
          UN
        );
        if (!F(T))
          G = !0;
        else if (b.positionCartographic.z < 1e6)
          if (_.dot(b.direction, x) >= -0.5)
            G = !0;
          else {
            const R = JN;
            _.clone(b.position, R);
            const w = s._zoomWorldPosition;
            let v = jN;
            if (v = _.normalize(w, v), _.dot(v, x) < 0)
              return;
            const D = o2, K = e2;
            _.clone(b.direction, K), _.add(
              R,
              _.multiplyByScalar(K, 1e3, jo),
              D
            );
            const P = t2, k = i2;
            _.subtract(w, R, P), _.normalize(P, k);
            const V = _.dot(
              x,
              k
            );
            if (V >= 0) {
              s._zoomMouseStart.x = -1;
              return;
            }
            const N = Math.acos(-V), z = _.magnitude(R), O = _.magnitude(w), Q = z - p, U = _.magnitude(
              P
            ), $ = Math.asin(
              X.clamp(
                U / O * Math.sin(N),
                -1,
                1
              )
            ), ee = Math.asin(
              X.clamp(
                Q / O * Math.sin(N),
                -1,
                1
              )
            ), se = $ - ee + N, ie = qN;
            _.normalize(R, ie);
            let Y = $N;
            Y = _.cross(k, ie, Y), Y = _.normalize(Y, Y), _.normalize(
              _.cross(ie, Y, jo),
              K
            ), _.multiplyByScalar(
              _.normalize(D, jo),
              _.magnitude(D) - p,
              D
            ), _.normalize(R, R), _.multiplyByScalar(
              R,
              Q,
              R
            );
            const Ie = n2;
            _.multiplyByScalar(
              _.add(
                _.multiplyByScalar(
                  ie,
                  Math.cos(se) - 1,
                  Fm
                ),
                _.multiplyByScalar(
                  K,
                  Math.sin(se),
                  km
                ),
                jo
              ),
              Q,
              Ie
            ), _.add(R, Ie, R), _.normalize(D, ie), _.normalize(
              _.cross(ie, Y, jo),
              K
            );
            const xe = s2;
            _.multiplyByScalar(
              _.add(
                _.multiplyByScalar(
                  ie,
                  Math.cos(se) - 1,
                  Fm
                ),
                _.multiplyByScalar(
                  K,
                  Math.sin(se),
                  km
                ),
                jo
              ),
              _.magnitude(D),
              xe
            ), _.add(D, xe, D), _.clone(R, b.position), _.normalize(
              _.subtract(D, R, jo),
              b.direction
            ), _.clone(b.direction, b.direction), _.cross(b.direction, b.up, b.right), _.cross(b.right, b.direction, b.up), S === Ge.SCENE3D && p < 0 && Su(b, s, p), b.setView(Kl);
            return;
          }
        else {
          const R = _.normalize(
            T,
            ON
          ), w = _.normalize(
            s._zoomWorldPosition,
            QN
          ), v = _.dot(w, R);
          if (v > 0 && v < 1) {
            const D = X.acosClamped(v), K = _.cross(
              w,
              R,
              YN
            ), P = (Math.abs(D) > X.toRadians(20) ? b.positionCartographic.z * 0.75 : b.positionCartographic.z - p) * 2, k = p / P;
            b.rotate(K, D * k);
          }
        }
      }
    }
    s._rotatingZoom = !G;
  }
  if (!u && G || y) {
    let x;
    const L = Eo.worldToWindowCoordinates(
      m,
      s._zoomWorldPosition,
      XN
    );
    S !== Ge.COLUMBUS_VIEW && oe.equals(t, s._zoomMouseStart) && F(L) ? x = b.getPickRay(L, Mc) : x = b.getPickRay(t, Mc);
    const E = x.direction;
    (S === Ge.COLUMBUS_VIEW || S === Ge.SCENE2D) && _.fromElements(
      E.y,
      E.z,
      E.x,
      E
    ), b.move(E, p), s._zoomingOnVector = !0;
  } else
    b.zoomIn(p);
  S === Ge.SCENE3D && p < 0 && Su(b, s, p), s._cameraUnderground || b.setView(Kl);
}
const r2 = new yt(), a2 = new yt(), g2 = new B();
function c2(s, t, e) {
  const n = s._scene.camera;
  let o = n.getPickRay(e.startPosition, r2).origin, r = n.getPickRay(e.endPosition, a2).origin;
  o = _.fromElements(o.y, o.z, o.x, o), r = _.fromElements(r.y, r.z, r.x, r);
  const a = _.subtract(o, r, g2), g = _.magnitude(a);
  g > 0 && (_.normalize(a, a), n.move(a, g));
}
async function zm(s, t, e) {
  F(e.distance) && (e = e.distance);
  const n = s._scene.camera;
  await NC(
    s,
    t,
    e,
    s._zoomFactor,
    n.getMagnitude()
  );
}
new Z();
new Z();
function l2(s) {
  _e.equals(_e.IDENTITY, s._scene.camera.transform) && Ji(
    s,
    s.enableTranslate,
    s.translateEventTypes,
    c2,
    s.inertiaTranslate,
    "_lastInertiaTranslateMovement"
  ), Ji(
    s,
    s.enableZoom,
    s.zoomEventTypes,
    zm,
    s.inertiaZoom,
    "_lastInertiaZoomMovement"
  );
}
const h2 = new yt();
new B();
new B();
async function Qs(s, t, e) {
  let n = await s._scene.rendering.picking.pickWorldPosition(t);
  return _.clone(n, e), e;
}
const d2 = new B();
function ph(s) {
  const t = s._ellipsoid, e = s._scene, i = e.camera, n = e.mode;
  let o = 0;
  if (n === Ge.SCENE3D) {
    const g = t.cartesianToCartographic(
      i.position,
      d2
    );
    F(g) && (o = g.z);
  } else
    o = i.position.z;
  const r = he(s._scene.globeHeight, 0);
  return Math.abs(r - o);
}
const u2 = new B();
function s_(s, t) {
  const e = t.origin, i = t.direction, n = ph(s), o = _.normalize(e, u2);
  let r = Math.abs(_.dot(o, i));
  return r = Math.max(r, 0.5) * 2, n * r;
}
function o_(s, t, e, i) {
  let n = _.distance(t.origin, e);
  const o = ph(s), r = X.clamp(
    o * 5,
    s._minimumUndergroundPickDistance,
    s._maximumUndergroundPickDistance
  );
  return n > r && (n = Math.min(n, o / 5), n = Math.max(n, 100)), yr.getPoint(t, n, i);
}
function r_(s, t, e, i) {
  let n;
  return F(e) ? (n = _.distance(t.origin, e), n > s._maximumUndergroundPickDistance && (n = ph(s))) : n = ph(s), yr.getPoint(t, n, i);
}
const I2 = new Z();
function a_(s, t) {
  const e = t.endPosition, i = oe.subtract(
    t.endPosition,
    t.startPosition,
    I2
  ), n = s._strafeEndMousePosition;
  oe.add(n, i, n), t.endPosition = n, FC(s, t, s._strafeStartPosition), t.endPosition = e;
}
const Xm = new yt(), A2 = new yt(), bu = new B(), C2 = new B(), f2 = new B(), p2 = new B(), m2 = new Zt(new B(1, 0, 0), 0), y2 = new Z(), S2 = new Z();
async function b2(s, t, e) {
  if (_.equals(t, s._translateMousePosition) || (s._looking = !1), _.equals(t, s._strafeMousePosition) || (s._strafing = !1), s._looking) {
    nn(s, t, e);
    return;
  }
  if (s._strafing) {
    a_(s, e);
    return;
  }
  const n = s._scene.camera, o = s._cameraUnderground, r = oe.clone(
    e.startPosition,
    y2
  ), a = oe.clone(e.endPosition, S2);
  let g = n.getPickRay(r, Xm);
  const c = _.clone(_.ZERO, p2), l = _.UNIT_X;
  let h;
  if (n.position.z < s._minimumPickingTerrainHeight && (h = await Qs(s, r, bu), F(h) && (c.x = h.x)), o || c.x > n.position.z && F(h)) {
    let u = h;
    o && (u = r_(
      s,
      g,
      h,
      bu
    )), oe.clone(t, s._strafeMousePosition), oe.clone(t, s._strafeEndMousePosition), _.clone(u, s._strafeStartPosition), s._strafing = !0, FC(s, e, s._strafeStartPosition);
    return;
  }
  const d = ti.fromPointNormal(c, l, m2);
  g = n.getPickRay(r, Xm);
  const C = We.rayPlane(
    g,
    d,
    bu
  ), p = n.getPickRay(a, A2), m = We.rayPlane(
    p,
    d,
    C2
  );
  if (!F(C) || !F(m)) {
    s._looking = !0, nn(s, t, e), oe.clone(t, s._translateMousePosition);
    return;
  }
  const b = _.subtract(
    C,
    m,
    f2
  ), S = b.x;
  b.x = b.y, b.y = b.z, b.z = S;
  const A = _.magnitude(b);
  A > X.EPSILON6 && (_.normalize(b, b), n.move(b, A));
}
const g_ = new Z(), Hl = new yt(), Pl = new B(), B2 = new B(), c_ = new J(), w2 = new J(), _2 = new B(), x2 = new Zt(new B(1, 0, 0), 0), Bu = new B(), dA = new B(), l_ = new J(), v2 = new Ye(), T2 = new qe(), Nl = new B();
async function L2(s, t, e) {
  if (F(e.angleAndHeight) && (e = e.angleAndHeight), oe.equals(t, s._tiltCenterMousePosition) || (s._tiltCVOffMap = !1, s._looking = !1), s._looking) {
    nn(s, t, e);
    return;
  }
  const n = s._scene.camera;
  s._tiltCVOffMap || !s.onMap() || Math.abs(n.position.z) > s._minimumPickingTerrainHeight ? (s._tiltCVOffMap = !0, G2(s, t, e)) : await M2(s, t, e);
}
function G2(s, t, e) {
  const i = s._scene, n = i.camera, o = i.canvas, r = g_;
  r.x = o.clientWidth / 2, r.y = o.clientHeight / 2;
  const a = n.getPickRay(r, Hl), g = _.UNIT_X, c = a.origin, l = a.direction;
  let h;
  const d = _.dot(g, l);
  if (Math.abs(d) > X.EPSILON6 && (h = -_.dot(g, c) / d), !F(h) || h <= 0) {
    s._looking = !0, nn(s, t, e), oe.clone(t, s._tiltCenterMousePosition);
    return;
  }
  const C = _.multiplyByScalar(l, h, Pl);
  _.add(c, C, C);
  const p = i.mapProjection, m = p.ellipsoid;
  _.fromElements(C.y, C.z, C.x, C);
  const b = p.unproject(C, dA);
  m.cartographicToCartesian(b, C);
  const S = Ze.eastNorthUpToFixedFrame(
    C,
    m,
    c_
  ), A = s._globe, u = s._ellipsoid;
  s._globe = void 0, s._ellipsoid = De.UNIT_SPHERE, s._rotateFactor = 1, s._rotateRateRangeAdjustment = 1;
  const y = _e.clone(n.transform, l_);
  n._setTransform(S), tn(s, t, e, _.UNIT_Z), n._setTransform(y), s._globe = A, s._ellipsoid = u;
  const I = u.maximumRadius;
  s._rotateFactor = 1 / I, s._rotateRateRangeAdjustment = I;
}
async function M2(s, t, e) {
  const i = s._scene, n = i.camera, o = s._cameraUnderground, r = i.mapProjection;
  let a, g;
  const c = _.UNIT_X;
  if (oe.equals(t, s._tiltCenterMousePosition))
    a = _.clone(s._tiltCenter, Pl);
  else {
    if (n.position.z < s._minimumPickingTerrainHeight && (a = await Qs(s, t, Pl)), !F(a)) {
      g = n.getPickRay(t, Hl);
      const T = g.origin, R = g.direction;
      let w;
      const v = _.dot(c, R);
      if (Math.abs(v) > X.EPSILON6 && (w = -_.dot(c, T) / v), !F(w) || w <= 0) {
        s._looking = !0, nn(s, t, e), oe.clone(t, s._tiltCenterMousePosition);
        return;
      }
      a = _.multiplyByScalar(R, w, Pl), _.add(T, a, a);
    }
    o && (F(g) || (g = n.getPickRay(t, Hl)), o_(s, g, a, a)), oe.clone(t, s._tiltCenterMousePosition), _.clone(a, s._tiltCenter);
  }
  const l = i.canvas, h = g_;
  h.x = l.clientWidth / 2, h.y = s._tiltCenterMousePosition.y, g = n.getPickRay(h, Hl);
  const d = _.clone(_.ZERO, _2);
  d.x = a.x;
  const C = ti.fromPointNormal(d, c, x2), p = We.rayPlane(
    g,
    C,
    B2
  ), m = r.ellipsoid;
  _.fromElements(a.y, a.z, a.x, a);
  let b = r.unproject(a, dA);
  m.cartographicToCartesian(b, a);
  const S = Ze.eastNorthUpToFixedFrame(
    a,
    m,
    c_
  );
  let A;
  F(p) ? (_.fromElements(
    p.y,
    p.z,
    p.x,
    p
  ), b = r.unproject(p, dA), m.cartographicToCartesian(b, p), A = Ze.eastNorthUpToFixedFrame(
    p,
    m,
    w2
  )) : A = S;
  const u = s._globe, y = s._ellipsoid;
  s._globe = void 0, s._ellipsoid = De.UNIT_SPHERE, s._rotateFactor = 1, s._rotateRateRangeAdjustment = 1;
  let I = _.UNIT_Z;
  const M = _e.clone(n.transform, l_);
  n._setTransform(S);
  const G = _.cross(
    _.UNIT_Z,
    _.normalize(n.position, Bu),
    Bu
  ), x = _.dot(n.right, G);
  if (tn(s, t, e, I, !1, !0), n._setTransform(A), x < 0) {
    const T = e.startPosition.y - e.endPosition.y;
    (o && T < 0 || !o && T > 0) && (I = void 0);
    const R = n.constrainedAxis;
    n.constrainedAxis = void 0, tn(s, t, e, I, !0, !1), n.constrainedAxis = R;
  } else
    tn(s, t, e, I, !0, !1);
  if (F(n.constrainedAxis)) {
    const T = _.cross(
      n.direction,
      n.constrainedAxis,
      Nl
    );
    _.equalsEpsilon(T, _.ZERO, X.EPSILON6) || (_.dot(T, n.right) < 0 && _.negate(T, T), _.cross(T, n.direction, n.up), _.cross(n.direction, n.up, n.right), _.normalize(n.up, n.up), _.normalize(n.right, n.right));
  }
  n._setTransform(M), s._globe = u, s._ellipsoid = y;
  const L = y.maximumRadius;
  s._rotateFactor = 1 / L, s._rotateRateRangeAdjustment = L;
  const E = _.clone(
    n.positionWC,
    Bu
  );
  if (s.enableCollisionDetection && zC(s, !0), !_.equals(n.positionWC, E)) {
    n._setTransform(A), n.worldToCameraCoordinatesPoint(E, E);
    const T = _.magnitudeSquared(E);
    _.magnitudeSquared(n.position) > T && (_.normalize(n.position, n.position), _.multiplyByScalar(
      n.position,
      Math.sqrt(T),
      n.position
    ));
    const R = _.angleBetween(E, n.position), w = _.cross(
      E,
      n.position,
      E
    );
    _.normalize(w, w);
    const v = wi.fromAxisAngle(
      w,
      R,
      v2
    ), D = Ae.fromQuaternion(v, T2);
    Ae.multiplyByVector(D, n.direction, n.direction), Ae.multiplyByVector(D, n.up, n.up), _.cross(n.direction, n.up, n.right), _.cross(n.right, n.direction, n.up), n._setTransform(M);
  }
}
const h_ = new Z(), d_ = new yt(), u_ = new B();
async function E2(s, t, e) {
  F(e.distance) && (e = e.distance);
  const i = s._scene, n = i.camera, o = i.canvas, r = s._cameraUnderground;
  let a;
  r ? a = t : (a = h_, a.x = o.clientWidth / 2, a.y = o.clientHeight / 2);
  const g = n.getPickRay(a, d_), c = g.origin, l = g.direction, h = n.position.z;
  let d;
  h < s._minimumPickingTerrainHeight && (d = await Qs(s, a, u_));
  let C;
  if (F(d) && (C = _.distance(c, d)), r) {
    const p = s_(
      s,
      g
    );
    F(C) ? C = Math.min(C, p) : C = p;
  }
  if (!F(C)) {
    const p = _.UNIT_X;
    C = -_.dot(p, c) / _.dot(p, l);
  }
  await NC(
    s,
    t,
    e,
    s._zoomFactor,
    C
  );
}
function R2(s) {
  const e = s._scene.camera;
  _e.equals(_e.IDENTITY, e.transform) ? (Ji(
    s,
    s.enableTilt,
    s.tiltEventTypes,
    L2,
    s.inertiaSpin,
    "_lastInertiaTiltMovement"
  ), Ji(
    s,
    s.enableTranslate,
    s.translateEventTypes,
    b2,
    s.inertiaTranslate,
    "_lastInertiaTranslateMovement"
  ), Ji(
    s,
    s.enableZoom,
    s.zoomEventTypes,
    E2,
    s.inertiaZoom,
    "_lastInertiaZoomMovement"
  ), Ji(
    s,
    s.enableLook,
    s.lookEventTypes,
    nn
  )) : (Ji(
    s,
    s.enableRotate,
    s.rotateEventTypes,
    tn,
    s.inertiaSpin,
    "_lastInertiaSpinMovement"
  ), Ji(
    s,
    s.enableZoom,
    s.zoomEventTypes,
    A_,
    s.inertiaZoom,
    "_lastInertiaZoomMovement"
  ));
}
const D2 = new yt(), K2 = new Zt(new B(1, 0, 0), 0), H2 = new B(), P2 = new B();
function FC(s, t, e) {
  const i = s._scene, n = i.camera, o = n.getPickRay(t.endPosition, D2);
  let r = _.clone(n.direction, P2);
  i.mode === Ge.COLUMBUS_VIEW && _.fromElements(r.z, r.x, r.y, r);
  const a = ti.fromPointNormal(
    e,
    r,
    K2
  ), g = We.rayPlane(
    o,
    a,
    H2
  );
  !F(g) || (r = _.subtract(e, g, r), i.mode === Ge.COLUMBUS_VIEW && _.fromElements(r.y, r.z, r.x, r), _.add(n.position, r, n.position));
}
const Wm = new B(), I_ = new B(), uA = new B(), IA = new De(), N2 = new B(), F2 = new B(), k2 = new B();
async function V2(s, t, e) {
  const n = s._scene.camera, o = s._cameraUnderground;
  let r = s._ellipsoid;
  if (!_e.equals(n.transform, _e.IDENTITY)) {
    tn(s, t, e);
    return;
  }
  let a, g;
  const c = r.geodeticSurfaceNormal(n.position, N2);
  if (oe.equals(t, s._rotateMousePosition)) {
    if (s._looking)
      nn(s, t, e, c);
    else if (s._rotating)
      tn(s, t, e);
    else if (s._strafing)
      a_(s, e);
    else {
      if (_.magnitude(n.position) < _.magnitude(s._rotateStartPosition))
        return;
      a = _.magnitude(s._rotateStartPosition), g = uA, g.x = g.y = g.z = a, r = De.fromCartesian3(g, IA), await _u(s, t, e, r);
    }
    return;
  }
  s._looking = !1, s._rotating = !1, s._strafing = !1;
  const l = r.cartesianToCartographic(
    n.positionWC,
    I_
  ).z, h = s._globe;
  if (F(h) && l < s._minimumPickingTerrainHeight) {
    const d = await Qs(
      s,
      e.startPosition,
      k2
    );
    if (F(d)) {
      let C = !1;
      const p = n.getPickRay(
        e.startPosition,
        h2
      );
      if (o)
        C = !0, r_(s, p, d, d);
      else {
        const m = r.geodeticSurfaceNormal(d, F2);
        Math.abs(_.dot(p.direction, m)) < 0.05 ? C = !0 : C = _.magnitude(n.position) < _.magnitude(d);
      }
      C ? (oe.clone(t, s._strafeEndMousePosition), _.clone(d, s._strafeStartPosition), s._strafing = !0, FC(s, e, s._strafeStartPosition)) : (a = _.magnitude(d), g = uA, g.x = g.y = g.z = a, r = De.fromCartesian3(g, IA), await _u(s, t, e, r), _.clone(d, s._rotateStartPosition));
    } else
      s._looking = !0, nn(s, t, e, c);
  } else
    F(
      n.pickEllipsoid(
        e.startPosition,
        s._ellipsoid,
        Wm
      )
    ) ? (await _u(s, t, e, s._ellipsoid), _.clone(Wm, s._rotateStartPosition)) : l > s._minimumTrackBallHeight ? (s._rotating = !0, tn(s, t, e)) : (s._looking = !0, nn(s, t, e, c));
  oe.clone(t, s._rotateMousePosition);
}
function tn(s, t, e, i, n, o) {
  n = he(n, !1), o = he(o, !1);
  const r = s._scene, a = r.camera, g = r.canvas, c = a.constrainedAxis;
  F(i) && (a.constrainedAxis = i);
  const l = _.magnitude(a.position);
  let h = s._rotateFactor * (l - s._rotateRateRangeAdjustment);
  h > s._maximumRotateRate && (h = s._maximumRotateRate), h < s._minimumRotateRate && (h = s._minimumRotateRate);
  let d = (e.startPosition.x - e.endPosition.x) / g.clientWidth, C = (e.startPosition.y - e.endPosition.y) / g.clientHeight;
  d = Math.min(d, s.maximumMovementRatio), C = Math.min(
    C,
    s.maximumMovementRatio
  );
  const p = h * d * Math.PI * 2, m = h * C * Math.PI;
  n || a.rotateRight(p), o || a.rotateUp(m), a.constrainedAxis = c;
}
const wu = Us.clone(Us.UNIT_W), Zm = Us.clone(Us.UNIT_W), z2 = new B(), X2 = new B(), Ec = new B(), kr = new B(), Rc = new B(), Um = new B(), W2 = new Z(), Z2 = new Z(), U2 = new Z(), O2 = new Z(), Q2 = new yt();
async function _u(s, t, e, i) {
  const n = s._scene, o = n.camera, r = oe.clone(
    e.startPosition,
    W2
  ), a = oe.clone(
    e.endPosition,
    Z2
  ), g = i.cartesianToCartographic(
    o.positionWC,
    I_
  ).z;
  let c, l;
  if (!e.inertiaEnabled && g < s._minimumPickingTerrainHeight && (c = _.clone(s._panLastWorldPosition, wu), !F(s._globe) && !oe.equalsEpsilon(
    r,
    s._panLastMousePosition
  ) && (c = await Qs(s, r, wu)), !F(s._globe) && F(c))) {
    const h = _.subtract(c, o.positionWC, kr), d = _.multiplyByScalar(
      o.directionWC,
      _.dot(o.directionWC, h),
      kr
    ), C = _.magnitude(d), p = o.frustum.getPixelDimensions(
      n.drawingBufferWidth,
      n.drawingBufferHeight,
      C,
      n.pixelRatio,
      O2
    ), m = oe.subtract(
      a,
      r,
      U2
    ), b = _.multiplyByScalar(
      o.rightWC,
      m.x * p.x,
      kr
    ), S = _.normalize(
      o.positionWC,
      n_
    ), A = o.getPickRay(a, Q2).direction, u = _.subtract(
      A,
      _.projectVector(A, o.rightWC, Rc),
      Rc
    ), y = _.angleBetween(u, o.directionWC);
    let I = 1;
    F(o.frustum.fov) && (I = Math.max(Math.tan(y), 0.1));
    let M = Math.abs(
      _.dot(o.directionWC, S)
    );
    const G = -m.y * p.y * 2 / Math.sqrt(I) * (1 - M), x = _.multiplyByScalar(
      A,
      G,
      Rc
    );
    M = Math.abs(_.dot(o.upWC, S));
    const L = _.multiplyByScalar(
      o.upWC,
      -m.y * (1 - M) * p.y,
      Um
    );
    l = _.add(c, b, Zm), l = _.add(l, x, l), l = _.add(l, L, l), _.clone(l, s._panLastWorldPosition), oe.clone(a, s._panLastMousePosition);
  }
  if ((!F(c) || !F(l)) && (c = o.pickEllipsoid(r, i, wu), l = o.pickEllipsoid(a, i, Zm)), c && (c.w = 1), l && (l.w = 1), !F(c) || !F(l)) {
    s._rotating = !0, tn(s, t, e);
    return;
  }
  if (c = o.worldToCameraCoordinates(c, c), l = o.worldToCameraCoordinates(l, l), c = _.fromCartesian4(c, z2), l = _.fromCartesian4(l, X2), F(o.constrainedAxis)) {
    const h = o.constrainedAxis, d = _.mostOrthogonalAxis(h, Ec);
    _.cross(d, h, d), _.normalize(d, d);
    const C = _.cross(h, d, kr), p = _.magnitude(c), m = _.dot(h, c), b = Math.acos(m / p), S = _.multiplyByScalar(h, m, Rc);
    _.subtract(c, S, S), _.normalize(S, S);
    const A = _.magnitude(l), u = _.dot(h, l), y = Math.acos(u / A), I = _.multiplyByScalar(h, u, Um);
    _.subtract(l, I, I), _.normalize(I, I);
    let M = Math.acos(_.dot(S, d));
    _.dot(S, C) < 0 && (M = X.TWO_PI - M);
    let G = Math.acos(_.dot(I, d));
    _.dot(I, C) < 0 && (G = X.TWO_PI - G);
    const x = M - G;
    let L;
    _.equalsEpsilon(h, o.position, X.EPSILON2) ? L = o.right : L = _.cross(h, o.position, Ec);
    const E = _.cross(h, L, Ec), T = _.dot(
      E,
      _.subtract(c, h, kr)
    ), R = _.dot(
      E,
      _.subtract(l, h, kr)
    );
    let w;
    T > 0 && R > 0 ? w = y - b : T > 0 && R <= 0 ? _.dot(o.position, h) > 0 ? w = -b - y : w = b + y : w = b - y, o.rotateRight(x), o.rotateUp(w);
  } else {
    _.normalize(c, c), _.normalize(l, l);
    const h = _.dot(c, l), d = _.cross(c, l, Ec);
    if (h < 1 && !_.equalsEpsilon(d, _.ZERO, X.EPSILON14)) {
      const C = Math.acos(h);
      o.rotate(d, C);
    }
  }
}
const Y2 = new B(), j2 = new B();
let Om = 0;
async function A_(s, t, e) {
  F(e.distance) && (e = e.distance);
  const i = e.inertiaEnabled, n = s._ellipsoid, o = s._scene, r = o.camera, a = o.canvas, g = s._cameraUnderground;
  let c;
  g ? c = t : (c = h_, c.x = a.clientWidth / 2, c.y = a.clientHeight / 2);
  const l = r.getPickRay(c, d_);
  let h;
  const d = n.cartesianToCartographic(
    r.position,
    j2
  ).z, C = Math.abs(Om) < s.minimumPickingTerrainDistanceWithInertia;
  (i ? C : d < s._minimumPickingTerrainHeight) && (h = await Qs(s, c, u_));
  let m;
  if (F(h) && (m = _.distance(l.origin, h), Om = m), g) {
    const S = s_(
      s,
      l
    );
    F(m) ? m = Math.min(m, S) : m = S;
  }
  F(m) || (m = d);
  const b = _.normalize(
    r.position,
    Y2
  );
  await NC(
    s,
    t,
    e,
    s._zoomFactor,
    m,
    _.dot(b, r.direction)
  );
}
const C_ = new Z(), Fl = new yt(), Lg = new B(), J2 = new B(), f_ = new J(), q2 = new J(), p_ = new J(), $2 = new Ye(), eF = new qe(), kC = new B(), VC = new B();
async function tF(s, t, e) {
  const n = s._scene.camera;
  if (!_e.equals(n.transform, _e.IDENTITY))
    return;
  if (F(e.angleAndHeight) && (e = e.angleAndHeight), oe.equals(t, s._tiltCenterMousePosition) || (s._tiltOnEllipsoid = !1, s._looking = !1), s._looking) {
    const a = s._ellipsoid.geodeticSurfaceNormal(
      n.position,
      VC
    );
    nn(s, t, e, a);
    return;
  }
  const r = s._ellipsoid.cartesianToCartographic(
    n.position,
    kC
  );
  s._tiltOnEllipsoid || r.z > s._minimumCollisionTerrainHeight ? (s._tiltOnEllipsoid = !0, nF(s, t, e)) : await sF(s, t, e);
}
const iF = new B();
function nF(s, t, e) {
  const i = s._ellipsoid, n = s._scene, o = n.camera, r = s.minimumZoomDistance * 0.25, a = i.cartesianToCartographic(
    o.positionWC,
    iF
  ).z;
  if (a - r - 1 < X.EPSILON3 && e.endPosition.y - e.startPosition.y < 0)
    return;
  const g = n.canvas, c = C_;
  c.x = g.clientWidth / 2, c.y = g.clientHeight / 2;
  const l = o.getPickRay(c, Fl);
  let h;
  const d = We.rayEllipsoid(l, i);
  if (F(d))
    h = yr.getPoint(l, d.start, Lg);
  else if (a > s._minimumTrackBallHeight) {
    const A = We.grazingAltitudeLocation(
      l,
      i
    );
    if (!F(A))
      return;
    const u = i.cartesianToCartographic(
      A,
      kC
    );
    u.z = 0, h = i.cartographicToCartesian(
      u,
      Lg
    );
  } else {
    s._looking = !0;
    const A = s._ellipsoid.geodeticSurfaceNormal(
      o.position,
      VC
    );
    nn(s, t, e, A), oe.clone(t, s._tiltCenterMousePosition);
    return;
  }
  const C = Ze.eastNorthUpToFixedFrame(
    h,
    i,
    f_
  ), p = s._globe, m = s._ellipsoid;
  s._globe = void 0, s._ellipsoid = De.UNIT_SPHERE, s._rotateFactor = 1, s._rotateRateRangeAdjustment = 1;
  const b = _e.clone(o.transform, p_);
  o._setTransform(C), tn(s, t, e, _.UNIT_Z), o._setTransform(b), s._globe = p, s._ellipsoid = m;
  const S = m.maximumRadius;
  s._rotateFactor = 1 / S, s._rotateRateRangeAdjustment = S;
}
async function sF(s, t, e) {
  const i = s._ellipsoid, n = s._scene, o = n.camera, r = s._cameraUnderground;
  let a, g, c;
  if (oe.equals(t, s._tiltCenterMousePosition))
    a = _.clone(s._tiltCenter, Lg);
  else {
    if (a = await Qs(s, t, Lg), !F(a)) {
      if (g = o.getPickRay(t, Fl), c = We.rayEllipsoid(g, i), !F(c)) {
        if (i.cartesianToCartographic(
          o.position,
          kC
        ).z <= s._minimumTrackBallHeight) {
          s._looking = !0;
          const R = s._ellipsoid.geodeticSurfaceNormal(
            o.position,
            VC
          );
          nn(s, t, e, R), oe.clone(t, s._tiltCenterMousePosition);
        }
        return;
      }
      a = yr.getPoint(g, c.start, Lg);
    }
    r && (F(g) || (g = o.getPickRay(t, Fl)), o_(s, g, a, a)), oe.clone(t, s._tiltCenterMousePosition), _.clone(a, s._tiltCenter);
  }
  const l = n.canvas, h = C_;
  h.x = l.clientWidth / 2, h.y = s._tiltCenterMousePosition.y, g = o.getPickRay(h, Fl);
  const d = _.magnitude(a), C = _.fromElements(d, d, d, uA), p = De.fromCartesian3(C, IA);
  if (c = We.rayEllipsoid(g, p), !F(c))
    return;
  const m = _.magnitude(g.origin) > d ? c.start : c.stop, b = yr.getPoint(g, m, J2), S = Ze.eastNorthUpToFixedFrame(
    a,
    i,
    f_
  ), A = Ze.eastNorthUpToFixedFrame(
    b,
    p,
    q2
  ), u = s._globe, y = s._ellipsoid;
  s._globe = void 0, s._ellipsoid = De.UNIT_SPHERE, s._rotateFactor = 1, s._rotateRateRangeAdjustment = 1;
  let I = _.UNIT_Z;
  const M = _e.clone(o.transform, p_);
  o._setTransform(A);
  const G = _.cross(
    b,
    o.positionWC,
    Nl
  );
  if (_.dot(o.rightWC, G) < 0) {
    const T = e.startPosition.y - e.endPosition.y;
    (r && T < 0 || !r && T > 0) && (I = void 0);
    const R = o.constrainedAxis;
    o.constrainedAxis = void 0, tn(s, t, e, I, !0, !1), o.constrainedAxis = R;
  } else
    tn(s, t, e, I, !0, !1);
  if (o._setTransform(S), tn(s, t, e, I, !1, !0), F(o.constrainedAxis)) {
    const T = _.cross(
      o.direction,
      o.constrainedAxis,
      Nl
    );
    _.equalsEpsilon(T, _.ZERO, X.EPSILON6) || (_.dot(T, o.right) < 0 && _.negate(T, T), _.cross(T, o.direction, o.up), _.cross(o.direction, o.up, o.right), _.normalize(o.up, o.up), _.normalize(o.right, o.right));
  }
  o._setTransform(M), s._globe = u, s._ellipsoid = y;
  const L = y.maximumRadius;
  s._rotateFactor = 1 / L, s._rotateRateRangeAdjustment = L;
  const E = _.clone(
    o.positionWC,
    Nl
  );
  if (s.enableCollisionDetection && zC(s, !0), !_.equals(o.positionWC, E)) {
    o._setTransform(A), o.worldToCameraCoordinatesPoint(E, E);
    const T = _.magnitudeSquared(E);
    _.magnitudeSquared(o.position) > T && (_.normalize(o.position, o.position), _.multiplyByScalar(
      o.position,
      Math.sqrt(T),
      o.position
    ));
    const R = _.angleBetween(E, o.position), w = _.cross(
      E,
      o.position,
      E
    );
    _.normalize(w, w);
    const v = wi.fromAxisAngle(w, R, $2), D = Ae.fromQuaternion(v, eF);
    Ae.multiplyByVector(D, o.direction, o.direction), Ae.multiplyByVector(D, o.up, o.up), _.cross(o.direction, o.up, o.right), _.cross(o.right, o.direction, o.up), o._setTransform(M);
  }
}
const oF = new Z(), rF = new Z(), Qm = new yt(), Ym = new yt(), aF = new B(), gF = new B();
function nn(s, t, e, i) {
  const o = s._scene.camera, r = oF;
  r.x = e.startPosition.x, r.y = 0;
  const a = rF;
  a.x = e.endPosition.x, a.y = 0;
  let g = o.getPickRay(r, Qm), c = o.getPickRay(a, Ym), l = 0, h, d;
  h = g.direction, d = c.direction;
  let C = _.dot(h, d);
  C < 1 && (l = Math.acos(C)), l = e.startPosition.x > e.endPosition.x ? -l : l;
  const p = s._horizontalRotationAxis;
  if (F(i) ? o.look(i, -l) : F(p) ? o.look(p, -l) : o.lookLeft(l), r.x = 0, r.y = e.startPosition.y, a.x = 0, a.y = e.endPosition.y, g = o.getPickRay(r, Qm), c = o.getPickRay(a, Ym), l = 0, h = g.direction, d = c.direction, C = _.dot(h, d), C < 1 && (l = Math.acos(C)), l = e.startPosition.y > e.endPosition.y ? -l : l, i = he(i, p), F(i)) {
    const m = o.direction, b = _.negate(
      i,
      aF
    ), S = _.equalsEpsilon(
      m,
      i,
      X.EPSILON2
    ), A = _.equalsEpsilon(
      m,
      b,
      X.EPSILON2
    );
    if (!S && !A) {
      C = _.dot(m, i);
      let u = X.acosClamped(C);
      l > 0 && l > u && (l = u - X.EPSILON4), C = _.dot(m, b), u = X.acosClamped(C), l < 0 && -l > u && (l = -u + X.EPSILON4);
      const y = _.cross(i, m, gF);
      o.look(y, l);
    } else
      (S && l < 0 || A && l > 0) && o.look(o.right, -l);
  } else
    o.lookUp(l);
}
function cF(s) {
  Ji(
    s,
    s.enableRotate,
    s.rotateEventTypes,
    V2,
    s.inertiaSpin,
    "_lastInertiaSpinMovement"
  ), Ji(
    s,
    s.enableZoom,
    s.zoomEventTypes,
    A_,
    s.inertiaZoom,
    "_lastInertiaZoomMovement"
  ), Ji(
    s,
    s.enableTilt,
    s.tiltEventTypes,
    tF,
    s.inertiaSpin,
    "_lastInertiaTiltMovement"
  ), Ji(
    s,
    s.enableLook,
    s.lookEventTypes,
    nn
  );
}
const lF = new J(), hF = new B();
function zC(s, t) {
  s._adjustedHeightForTerrain = !0;
  const e = s._scene, i = e.mode, n = e.globe;
  if (!F(n) || i === Ge.SCENE2D || i === Ge.MORPHING)
    return;
  const o = e.camera, r = n.ellipsoid, a = e.mapProjection;
  let g, c;
  _e.equals(o.transform, _e.IDENTITY) || (g = _e.clone(o.transform, lF), c = _.magnitude(o.position), o._setTransform(_e.IDENTITY));
  const l = hF;
  i === Ge.SCENE3D ? r.cartesianToCartographic(o.position, l) : a.unproject(o.position, l);
  let h = !1;
  if (l.z < s._minimumCollisionTerrainHeight) {
    const d = he(s._scene.globeHeight, 0);
    if (F(d)) {
      const C = d + s.minimumZoomDistance, p = d - s._lastGlobeHeight, m = p / s._lastGlobeHeight;
      l.z < C && (t || Math.abs(m) <= 0.1) && (l.z = C, i === Ge.SCENE3D ? r.cartographicToCartesian(l, o.position) : a.project(l, o.position), h = !0), t || Math.abs(m) <= 0.1 ? s._lastGlobeHeight = d : s._lastGlobeHeight += p * 0.1;
    }
  }
  F(g) && (o._setTransform(g), h && (_.normalize(o.position, o.position), _.negate(o.position, o.direction), _.multiplyByScalar(
    o.position,
    Math.max(c, s.minimumZoomDistance),
    o.position
  ), _.normalize(o.direction, o.direction), _.cross(o.direction, o.up, o.right), _.cross(o.right, o.direction, o.up)));
}
function dF(s) {
  const t = s._scene, e = t.camera, i = t.mode, n = e.positionCartographic;
  if (!F(n))
    return !1;
  if (!s.onMap() && n.z < 0)
    return !0;
  if (i === Ge.SCENE2D || i === Ge.MORPHING)
    return !1;
  const o = he(t.globeHeight, 0);
  return F(o) && n.z < o;
}
const uF = new B(), IF = new B(), AF = new B(), CF = new yt();
function fF(s) {
  const t = s._scene;
  if (t.mode === Ge.MORPHING)
    return;
  const i = t.camera.positionCartographic;
  if (!F(i))
    return;
  let n = Number.NEGATIVE_INFINITY;
  const o = t.globe;
  if (F(o)) {
    const a = t.mapProjection.ellipsoid, g = _.fromRadians(
      i.x,
      i.y,
      0,
      a,
      uF
    ), c = CF;
    a.geodeticSurfaceNormal(
      g,
      c.direction
    ), a.getSurfaceNormalIntersectionWithZAxis(
      g,
      111500,
      c.origin
    );
    const l = 7e6;
    c.origin.add(c.direction.clone().multiplyScalar(l)), c.direction.negate(), s._cameraUnderground;
    let h = t.rendering.picking.pickTerrainWorldPosition(c);
    if (!F(h)) {
      let d = We.rayEllipsoid(c, a);
      if (F(d)) {
        let C = d.start > 0 ? d.start : d.stop;
        h = yr.getPoint(c, C, IF);
      }
    }
    F(h) && (n = a.cartesianToCartographic(
      h,
      AF
    ).z);
  }
  if (n > Number.NEGATIVE_INFINITY)
    return n;
}
function pF(s) {
  const t = s._scene;
  s.enableTerrainCollision && (t.globeHeight = fF(s)), t.cameraUnderground = dF(s);
}
qg.prototype.onMap = function() {
  const s = this._scene, t = s.mode, e = s.camera;
  return t === Ge.COLUMBUS_VIEW ? Math.abs(e.position.x) - this._maxCoord.x < 0 && Math.abs(e.position.y) - this._maxCoord.y < 0 : !0;
};
const mF = new B(), yF = new B();
qg.prototype.update = function() {
  const s = this._scene, t = s.camera, e = s.globe, i = s.mode;
  pF(this), _e.equals(t.transform, _e.IDENTITY) ? (this._globe = e, this._ellipsoid = F(this._globe) ? this._globe.ellipsoid : s.mapProjection.ellipsoid) : (this._globe = void 0, this._ellipsoid = De.UNIT_SPHERE);
  const n = F(this._globe) && F(this._globe.terrainExaggeration) ? this._globe.terrainExaggeration : 1, o = F(this._globe) && F(this._globe.terrainExaggerationRelativeHeight) ? this._globe.terrainExaggerationRelativeHeight : 0;
  if (this._minimumCollisionTerrainHeight = Dl.getHeight(
    this.minimumCollisionTerrainHeight,
    n,
    o
  ), this._minimumPickingTerrainHeight = Dl.getHeight(
    this.minimumPickingTerrainHeight,
    n,
    o
  ), this._minimumTrackBallHeight = Dl.getHeight(
    this.minimumTrackBallHeight,
    n,
    o
  ), this._cameraUnderground = s.cameraUnderground && F(this._globe), this._ellipsoid) {
    const g = this._ellipsoid.maximumRadius;
    this._rotateFactor = 1 / g, this._rotateRateRangeAdjustment = g;
  }
  this._adjustedHeightForTerrain = !1;
  const r = _.clone(
    t.positionWC,
    mF
  ), a = _.clone(
    t.directionWC,
    yF
  );
  if (i === Ge.SCENE2D ? l2(this) : i === Ge.COLUMBUS_VIEW ? (this._horizontalRotationAxis = _.UNIT_Z, R2(this)) : i === Ge.SCENE3D && (this._horizontalRotationAxis = void 0, cF(this)), this.enableCollisionDetection && !this._adjustedHeightForTerrain) {
    const g = !_.equals(r, t.positionWC) || !_.equals(a, t.directionWC);
    zC(this, g);
  }
  this._aggregator.reset();
};
qg.prototype.isDestroyed = function() {
  return !1;
};
qg.prototype.destroy = function() {
  return this._aggregator = this._aggregator && this._aggregator.destroy(), ko(this);
};
function us(s, t) {
  this._ellipsoid = s, this._cameraPosition = new B(), this._cameraPositionInScaledSpace = new B(), this._distanceToLimbInScaledSpaceSquared = 0, F(t) && (this.cameraPosition = t);
}
Object.defineProperties(us.prototype, {
  ellipsoid: {
    get: function() {
      return this._ellipsoid;
    }
  },
  cameraPosition: {
    get: function() {
      return this._cameraPosition;
    },
    set: function(s) {
      const e = this._ellipsoid.transformPositionToScaledSpace(
        s,
        this._cameraPositionInScaledSpace
      ), i = _.magnitudeSquared(e) - 1;
      _.clone(s, this._cameraPosition), this._cameraPositionInScaledSpace = e, this._distanceToLimbInScaledSpaceSquared = i;
    }
  }
});
const m_ = new B();
us.prototype.isPointVisible = function(s) {
  const e = this._ellipsoid.transformPositionToScaledSpace(
    s,
    m_
  );
  return XC(
    e,
    this._cameraPositionInScaledSpace,
    this._distanceToLimbInScaledSpaceSquared
  );
};
us.prototype.isScaledSpacePointVisible = function(s) {
  return XC(
    s,
    this._cameraPositionInScaledSpace,
    this._distanceToLimbInScaledSpaceSquared
  );
};
const SF = new _();
us.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid = function(s, t) {
  const e = this._ellipsoid;
  let i, n;
  return F(t) && t < 0 && e.minimumRadius > -t ? (n = SF, n.x = this._cameraPosition.x / (e.radii.x + t), n.y = this._cameraPosition.y / (e.radii.y + t), n.z = this._cameraPosition.z / (e.radii.z + t), i = n.x * n.x + n.y * n.y + n.z * n.z - 1) : (n = this._cameraPositionInScaledSpace, i = this._distanceToLimbInScaledSpaceSquared), XC(
    s,
    n,
    i
  );
};
us.prototype.computeHorizonCullingPoint = function(s, t, e) {
  return b_(
    this._ellipsoid,
    s,
    t,
    e
  );
};
const y_ = De.clone(De.UNIT_SPHERE);
us.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid = function(s, t, e, i) {
  const n = S_(
    this._ellipsoid,
    e,
    y_
  );
  return b_(
    n,
    s,
    t,
    i
  );
};
us.prototype.computeHorizonCullingPointFromVertices = function(s, t, e, i, n) {
  return B_(
    this._ellipsoid,
    s,
    t,
    e,
    i,
    n
  );
};
us.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid = function(s, t, e, i, n, o) {
  const r = S_(
    this._ellipsoid,
    n,
    y_
  );
  return B_(
    r,
    s,
    t,
    e,
    i,
    o
  );
};
const bF = [];
us.prototype.computeHorizonCullingPointFromRectangle = function(s, t, e) {
  const i = Oe.subsample(
    s,
    t,
    0,
    bF
  ), n = new Bn();
  if (n.setFromPoints(i), !(_.magnitude(n.center) < 0.1 * t.minimumRadius))
    return this.computeHorizonCullingPoint(n.center, i, e);
};
const BF = new B();
function S_(s, t, e) {
  if (F(t) && t < 0 && s.minimumRadius > -t) {
    const i = _.fromElements(
      s.radii.x + t,
      s.radii.y + t,
      s.radii.z + t,
      BF
    );
    s = De.fromCartesian3(i, e);
  }
  return s;
}
function b_(s, t, e, i) {
  F(i) || (i = new B());
  const n = x_(
    s,
    t
  );
  let o = 0;
  for (let r = 0, a = e.length; r < a; ++r) {
    const g = e[r], c = w_(
      s,
      g,
      n
    );
    if (c < 0)
      return;
    o = Math.max(o, c);
  }
  return __(n, o, i);
}
const Dc = new B();
function B_(s, t, e, i, n, o) {
  F(o) || (o = new B()), i = he(i, 3), n = he(n, _.ZERO);
  const r = x_(
    s,
    t
  );
  let a = 0;
  for (let g = 0, c = e.length; g < c; g += i) {
    Dc.x = e[g] + n.x, Dc.y = e[g + 1] + n.y, Dc.z = e[g + 2] + n.z;
    const l = w_(
      s,
      Dc,
      r
    );
    if (l < 0)
      return;
    a = Math.max(a, l);
  }
  return __(r, a, o);
}
function XC(s, t, e) {
  const i = t, n = e, o = _.subtract(
    s,
    i,
    m_
  ), r = -_.dot(o, i);
  return !(n < 0 ? r > 0 : r > n && r * r / _.magnitudeSquared(o) > n);
}
const wF = new B(), _F = new B();
function w_(s, t, e) {
  const i = s.transformPositionToScaledSpace(
    t,
    wF
  );
  let n = _.magnitudeSquared(i), o = Math.sqrt(n);
  const r = _.divideByScalar(
    i,
    o,
    _F
  );
  n = Math.max(1, n), o = Math.max(1, o);
  const a = _.dot(r, e), g = _.magnitude(
    _.cross(r, e, r)
  ), c = 1 / o, l = Math.sqrt(n - 1) * c;
  return 1 / (a * c - g * l);
}
function __(s, t, e) {
  if (!(t <= 0 || t === 1 / 0 || isNaN(t)))
    return _.multiplyByScalar(
      s,
      t,
      e
    );
}
const xu = new B();
function x_(s, t) {
  return _.equals(t, _.ZERO) ? t : (s.transformPositionToScaledSpace(
    t,
    xu
  ), _.normalize(xu, xu));
}
new B();
const jt = new B(), xF = new B();
new B();
const Kc = new B(), jm = new B(), Jm = new B(), qm = new B(), vF = new J(), $m = new B(), e0 = new B();
class TF extends Jh {
  constructor(e, i, n) {
    super(e, n);
    f(this, "MERCATOR_LENGTH", 200375083427892e-7);
    f(this, "projectionName", "ecef");
    f(this, "near", 0.1);
    f(this, "fov", 35);
    f(this, "_farScale", 1.2);
    f(this, "handleContextMenu", (e) => {
      e.preventDefault();
    });
    f(this, "handleEventPointerDown", (e) => {
      const n = this._engine.event, o = e.position.x, r = e.position.y;
      n._handlePointerDown({
        pixel: [o, r],
        event: e.event
      });
    });
    f(this, "handleEventPointerUp", (e) => {
      const n = this._engine.event, o = e.position.x, r = e.position.y;
      n._handlePointerUp({
        pixel: [o, r],
        event: e.event
      });
    });
    f(this, "handleEventClick", (e) => {
      const n = this._engine.event, o = e.position.x, r = e.position.y;
      e.event.button === 2 ? n._handleRightClick({
        pixel: [o, r],
        event: e.event
      }) : n._handleClick({
        pixel: [o, r],
        event: e.event
      });
    });
    f(this, "handleEventDblClick", (e) => {
      const n = this._engine.event, o = e.position.x, r = e.position.y;
      e.event.button === 2 ? n._handleRightDblClick({
        pixel: [o, r],
        event: e.event
      }) : n._handleDblClick({
        pixel: [o, r],
        event: e.event
      });
    });
    f(this, "handleEventMouseMove", (e) => {
      const n = this._engine.event, o = e.startPosition.x, r = e.startPosition.y;
      n._handleMouseMove({
        pixel: [o, r],
        event: e
      });
    });
    f(this, "handleViewChange", () => {
      this.onViewChanged && this.onViewChanged();
    });
    f(this, "handleMapResize", () => {
      this.onResolutionChanged && this.onResolutionChanged(this.getResolution());
    });
    this._engine = e, this.domContainer = i, this._ellipsoid = De.WGS84, this.mode = Ge.SCENE3D, this.mapProjection = new Da(this._ellipsoid);
  }
  afterInit() {
    this.bindCanvas(), this.camera.matrixAutoUpdate = !1, this.handleMapResize(), GC(this.domContainer, this.handleMapResize);
    const e = this._ellipsoidCamera = new _o(this);
    e.frustum = this.camera, e.constrainedAxis = _.UNIT_Z, this._globe = new BN(this._ellipsoid, this._engine), this._occluder = new us(this._ellipsoid, this.camera.position), this._initControl();
  }
  bindCanvas() {
    this.domContainer.appendChild(this.canvas);
  }
  releaseCanvas() {
    this.domContainer.removeChild(this.canvas);
  }
  _initControl() {
    const e = this._controllerScene = {
      camera: this._ellipsoidCamera,
      canvas: this.canvas,
      globe: this._globe,
      mode: this.mode,
      globeHeight: 0,
      mapProjection: this.mapProjection,
      rendering: this._engine.rendering
    };
    this._controller = new qg(e), this.canvas.addEventListener("contextmenu", this.handleContextMenu), this._bindEvents();
  }
  _bindEvents() {
    this._controller._aggregator.onEventPointerDown = this.handleEventPointerDown, this._controller._aggregator.onEventPointerUp = this.handleEventPointerUp, this._controller._aggregator.onEventClick = this.handleEventClick, this._controller._aggregator.onEventDblClick = this.handleEventDblClick, this._controller._aggregator.onEventMouseMove = this.handleEventMouseMove;
  }
  getContainerSize() {
    return [
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    ];
  }
  getResolution() {
    return new Z(this.domContainer.clientWidth, this.domContainer.clientHeight);
  }
  getCenter() {
    let e = this.unprojectArrayCoordinate(this.getProjectionCenter());
    return Kw(e) ? e : xF.toArray();
  }
  getProjectionCenter() {
    const [e, i] = this.getContainerSize(), n = new Z(e / 2, i / 2), o = this._ellipsoidCamera.pickEllipsoid(n);
    return o ? [o.x, o.y, o.z] : [0, 0, 0];
  }
  getPitch() {
    return ce.radToDeg(this._ellipsoidCamera.pitch) + 90;
  }
  getHeading() {
    return 360 - ce.radToDeg(this._ellipsoidCamera.heading);
  }
  getRoll() {
    return ce.radToDeg(this._ellipsoidCamera.roll);
  }
  getRange() {
    const e = this.getProjectionCenter();
    return this._ellipsoidCamera.position.distanceTo(jt.set(e[0], e[1], e[2]));
  }
  getZoom() {
    return this.getZoomByZoomUnits(this.getZoomUnits());
  }
  getZoomUnits() {
    const [e, i] = this.getContainerSize();
    return this.getViewHeight() * Math.tan(ce.degToRad(this.fov / 2)) * 2 / i;
  }
  getCameraDistance() {
    return this.getRange();
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 128 / Math.pow(2, e);
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 128 / e);
  }
  getProjectionBounds() {
    const e = this.getProjectionCenter(), i = this._ellipsoidCamera.position.distanceTo(jt.set(e[0], e[1], e[2])), [n, o] = this.getContainerSize(), r = n / o, a = ce.degToRad(this.getHeading()), g = ce.degToRad(Math.max(this.getPitch(), 80)), c = Math.cos(g);
    let l = 2 * i * Math.tan(ce.degToRad(this.fov / 2)), h = l * r;
    h = Math.abs(Math.cos(a)) * h + Math.abs(Math.sin(a)) * l, l = Math.abs(Math.cos(a)) * l + Math.abs(Math.sin(a)) * h, h /= c, l /= c;
    const d = Ze.eastNorthUpToFixedFrame(jt.fromArray(e)), C = vF.extractRotation(d);
    $m.setFromMatrixColumn(C, 0), e0.setFromMatrixColumn(C, 1);
    const p = $m.multiplyScalar(h).add(e0.multiplyScalar(l)), m = new B(), b = new B();
    return m.fromArray(e).sub(p), b.fromArray(e).add(p), new Ue(m, b);
  }
  getBounds() {
    const e = this.getProjectionBounds(), i = this.unprojectArrayCoordinate([e.min.x, e.min.y, e.min.z]), n = this.unprojectArrayCoordinate([e.max.x, e.max.y, e.max.z]);
    return new Ue(new B(i[0], i[1], i[2]), new B(n[0], n[1], n[2]));
  }
  setCenter(e) {
    this.setProjectionCenter(e);
  }
  setProjectionCenter(e) {
    this.setView(e, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  setHeading(e) {
    const i = this.getProjectionCenter(), n = this._ellipsoidCamera.position.distanceTo(jt.set(i[0], i[1], i[2]));
    this.unprojectArrayCoordinate(i, i), jt.fromArray(i), this.lookAt(jt, {
      heading: e,
      pitch: this.getPitch(),
      roll: this.getRoll(),
      range: n
    });
  }
  setPitch(e) {
    const i = this.getProjectionCenter(), n = this._ellipsoidCamera.position.distanceTo(jt.set(i[0], i[1], i[2]));
    this.unprojectArrayCoordinate(i, i), jt.fromArray(i), this.lookAt(jt, {
      heading: this.getHeading(),
      pitch: e,
      roll: this.getRoll(),
      range: n
    });
  }
  setZoom(e) {
    const i = this.getProjectionCenter(), n = this._ellipsoidCamera.directionWC, o = this.getZoomUnitsByZoom(e), [r, a] = this.getContainerSize(), g = a / 2 * o / Math.tan(ce.degToRad(this.fov / 2));
    jt.set(i[0], i[1], i[2]).add(n.clone().normalize().negate().multiplyScalar(g * 0.1)), this.unprojectArrayCoordinate(jt.toArray(), i), jt.fromArray(i), this.setView(jt, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  setRange(e) {
    const i = this.getProjectionCenter();
    this.unprojectArrayCoordinate(i, i), jt.fromArray(i), this.lookAt(jt, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll(),
      range: e
    });
  }
  zoomIn() {
    const e = Kc.set(
      this._ellipsoidCamera.directionWC.x,
      this._ellipsoidCamera.directionWC.y,
      this._ellipsoidCamera.directionWC.z
    );
    let i = this.getRange(), o = 0.5 * ce.clamp(i, 0.5, 1e7);
    o + 0.2 > i && (o = i - 0.2);
    const r = this._ellipsoidCamera.positionWC;
    jt.set(r.x, r.y, r.z).add(e.normalize().multiplyScalar(o)), this.setView(jt, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  zoomOut() {
    const e = Kc.set(
      this._ellipsoidCamera.directionWC.x,
      this._ellipsoidCamera.directionWC.y,
      this._ellipsoidCamera.directionWC.z
    );
    let i = this.getRange(), o = 0.5 * ce.clamp(i, 0.5, 1e7);
    o + 0.2 > i && (o = i - 0.2);
    const r = this._ellipsoidCamera.positionWC;
    jt.set(r.x, r.y, r.z).add(e.normalize().multiplyScalar(-o)), this.setView(jt, {
      heading: this.getHeading(),
      pitch: this.getPitch(),
      roll: this.getRoll()
    });
  }
  updateView() {
    this.handleViewChange();
  }
  flyTo(e, i = {}) {
    const n = this._ellipsoidCamera;
    Kc.copy(n.direction), jm.copy(n.position), Jm.copy(n.up), qm.copy(n.right);
    const o = new B();
    e instanceof Array ? o.set(e[0], e[1], e[2] || 0) : o.copy(e), o.z = o.z || 0, this._ellipsoid.cartographicDegreeToCartesian(o, o), i.heading = W(i.heading, this.getHeading()), i.pitch = W(i.pitch, this.getPitch()), i.heading !== void 0 && (i.heading = ce.degToRad(360 - i.heading)), i.pitch !== void 0 && (i.pitch = ce.degToRad(i.pitch - 90)), n.lookAt(o, i);
    const a = {
      destination: n.position.clone(),
      orientation: {
        heading: i.heading,
        pitch: i.pitch,
        roll: i.roll
      },
      duration: i.duration,
      complete: i.complete
    };
    n.position.copy(jm), n.direction.copy(Kc), n.up.copy(Jm), n.right.copy(qm), n.flyTo(a), this.updateView();
  }
  lookAt(e, i = {}) {
    const n = this._ellipsoidCamera, o = new B();
    e instanceof Array ? o.set(e[0], e[1], e[2] || 0) : o.copy(e), o.z = o.z || 0, this._ellipsoid.cartographicDegreeToCartesian(o, o), i.heading !== void 0 && (i.heading = ce.degToRad(360 - i.heading)), i.pitch = i.pitch || 1e-3, i.pitch = ce.degToRad(i.pitch - 90), n.lookAt(o, i), this._syncFromEllipsoidCamera(), this.updateView();
  }
  setView(e, i = {}) {
    const n = this._ellipsoidCamera, o = new B();
    e instanceof Array ? o.set(e[0], e[1], e[2] || 100) : o.copy(e), o.z = o.z || 0, o.x > -180 && o.x < 180 && o.y > -90 && o.y < 90 && this._ellipsoid.cartographicDegreeToCartesian(o, o);
    const r = {
      destination: o,
      orientation: i
    };
    i.heading !== void 0 && (i.heading = ce.degToRad(360 - i.heading)), i.pitch !== void 0 && (i.pitch = ce.degToRad(i.pitch - 90)), i.roll !== void 0 && (i.roll = ce.degToRad(i.roll)), n.setView(r), this._syncFromEllipsoidCamera(), this.updateView();
  }
  _syncFromEllipsoidCamera() {
    const e = this.camera, i = this._ellipsoidCamera, n = i.viewMatrix, o = i.inverseViewMatrix;
    e.matrixWorld.copy(o), e.matrixWorldInverse.copy(n), e.matrixWorld.decompose(e.position, e.quaternion, e.scale);
  }
  updateCamera() {
    this._controller.update();
    const e = this.camera, i = this._ellipsoidCamera, n = i.viewMatrix, o = i.inverseViewMatrix;
    e.matrixWorld.copy(o), e.matrixWorldInverse.copy(n), e.matrixWorld.decompose(e.position, e.quaternion, e.scale);
    const r = e.position.length(), a = r - this._ellipsoid._maximumRadius;
    let g = r;
    r < 20228866 ? g = r : g = r * this._farScale;
    const [c, l] = this.getContainerSize();
    e.aspect = c / l, this.near = e.near = Math.min(Math.max(a / 1e4, 0.1), 50), e.near = this.near, e.far = g, e.updateProjectionMatrix();
  }
  enableControl() {
    this._controller.enableInputs = !0;
  }
  disableControl() {
    this._controller.enableInputs = !1;
  }
  getViewHeight() {
    return this._ellipsoidCamera.positionCartographic.z;
  }
  getCameraLocation(e) {
    e || (e = new B());
    const i = this._ellipsoidCamera.positionCartographic.x * 180 / Math.PI, n = this._ellipsoidCamera.positionCartographic.y * 180 / Math.PI, o = this._ellipsoidCamera.positionCartographic.z;
    return e.set(i, n, o), e;
  }
  pickSeaLevelWorldPosition(e) {
    return this._ellipsoidCamera.pickEllipsoid(e);
  }
  dispose() {
    this.releaseCanvas(), MC(this.domContainer, this.handleMapResize), this.canvas.removeEventListener("contextmenu", this.handleContextMenu);
  }
  setInputAction(e, i) {
    this.eventHandler.setInputAction(e, i);
  }
  getInputAction(e) {
    return this.eventHandler.getInputAction(e);
  }
  removeInputAction(e) {
    this.eventHandler.removeInputAction(e);
  }
  get occluder() {
    return this._occluder;
  }
  set canvas(e) {
    this._canvas !== e && (this._canvas = e, this._controller && (this._controller.destroy(), this._initControl()));
  }
  get canvas() {
    return this._canvas;
  }
  get farScale() {
    return this._farScale;
  }
  set farScale(e) {
    this._farScale = e;
  }
}
class AA {
  constructor(t) {
    this._grid = t, this._root = null, this._tiles = {}, this._tilesCount = 0;
  }
  getTileByKey(t) {
    if (this._tiles[t])
      return this._tiles[t];
    const [e, i, n] = t.split("-");
    return this._getOrCreateTile(parseInt(e, 10), parseInt(i, 10), parseInt(n, 10));
  }
  getTile(t, e, i) {
    const n = t + "-" + e + "-" + i;
    return this._tiles[n] ? this._tiles[n] : this._getOrCreateTile(t, e, i);
  }
  getTileChildren(t) {
    if (t.children)
      return t.children;
    if (t.z >= this._grid.maxLevel)
      return null;
    const e = this._grid.createTileChildren(t);
    return this._invokeTileCreateHook(e), t.children = e, e;
  }
  _getOrCreateTile(t, e, i) {
    return t > this._grid.maxLevel ? null : this._selectOrCreateAncestralTiles(t, e, i, this.root);
  }
  isAncestralTile(t, e, i, n) {
    const o = this._grid.getQuadTreeLevelGap(n.z, t);
    return e >> o === n.x && i >> o === n.y;
  }
  _selectOrCreateAncestralTiles(t, e, i, n) {
    for (const o of n) {
      if (o.z === t) {
        if (o.x === e && o.y === i)
          return o;
      } else if (o.z > t)
        return null;
      if (this.isAncestralTile(t, e, i, o)) {
        const r = this.getTileChildren(o);
        for (const a of r)
          this._tiles[a.key] = a, this._tilesCount++;
        return this._selectOrCreateAncestralTiles(t, e, i, r);
      }
    }
    return null;
  }
  _invokeTileCreateHook(t) {
    if (!!this.onTileCreated)
      for (const e of t)
        this.onTileCreated(e);
  }
  get root() {
    if (!this._root) {
      this._root = this._grid.getRootTiles();
      for (const t of this._root)
        this._tiles[t.key] = t, this._tilesCount++;
      this._invokeTileCreateHook(this._root);
    }
    return this._root;
  }
}
function $g(s) {
  this.rectangle = Oe.clone(s.rectangle), this.minimumHeight = he(s.minimumHeight, 0), this.maximumHeight = he(s.maximumHeight, 0), this.southwestCornerCartesian = new B(), this.northeastCornerCartesian = new B(), this.westNormal = new B(), this.southNormal = new B(), this.eastNormal = new B(), this.northNormal = new B();
  const t = he(s.ellipsoid, De.WGS84);
  RF(this, s.rectangle, t), this._orientedBoundingBox = void 0, this._boundingSphere = void 0, he(s.computeBoundingVolumes, !0) && this.computeBoundingVolumes(t);
}
Object.defineProperties($g.prototype, {
  boundingVolume: {
    get: function() {
      return this._orientedBoundingBox;
    }
  },
  boundingSphere: {
    get: function() {
      return this._boundingSphere;
    }
  }
});
$g.prototype.computeBoundingVolumes = function(s) {
  this._orientedBoundingBox = ki.fromRectangle(
    this.rectangle,
    this.minimumHeight,
    this.maximumHeight,
    s
  );
};
const t0 = new B(), Hc = new B(), i0 = new B(), LF = new B(), GF = new B(), MF = new B(), EF = new B(), hn = new B(), n0 = new Zt(new B(1, 0, 0), 0), Vr = new yt();
function RF(s, t, e) {
  e.cartographicToCartesian(
    Oe.southwest(t),
    s.southwestCornerCartesian
  ), e.cartographicToCartesian(
    Oe.northeast(t),
    s.northeastCornerCartesian
  ), hn.x = t.west, hn.y = (t.south + t.north) * 0.5, hn.z = 0;
  const i = e.cartographicToCartesian(
    hn,
    MF
  ), n = _.cross(
    i,
    _.UNIT_Z,
    LF
  );
  _.normalize(n, s.westNormal), hn.x = t.east;
  const o = e.cartographicToCartesian(
    hn,
    EF
  ), r = _.cross(
    _.UNIT_Z,
    o,
    t0
  );
  _.normalize(r, s.eastNormal);
  let a = _.subtract(
    i,
    o,
    t0
  );
  _.magnitude(a) === 0 && (a = _.clone(n, a));
  const g = _.normalize(
    a,
    GF
  ), c = t.south;
  let l;
  if (c > 0) {
    hn.x = (t.west + t.east) * 0.5, hn.y = c;
    const m = e.cartographicToCartesian(
      hn,
      Vr.origin
    );
    _.clone(g, Vr.direction);
    const b = ti.fromPointNormal(
      s.southwestCornerCartesian,
      s.westNormal,
      n0
    );
    We.rayPlane(
      Vr,
      b,
      s.southwestCornerCartesian
    ), l = e.geodeticSurfaceNormal(
      m,
      Hc
    );
  } else
    l = e.geodeticSurfaceNormalCartographic(
      Oe.southeast(t),
      Hc
    );
  const h = _.cross(
    l,
    a,
    i0
  );
  _.normalize(h, s.southNormal);
  const d = t.north;
  let C;
  if (d < 0) {
    hn.x = (t.west + t.east) * 0.5, hn.y = d;
    const m = e.cartographicToCartesian(
      hn,
      Vr.origin
    );
    _.negate(g, Vr.direction);
    const b = ti.fromPointNormal(
      s.northeastCornerCartesian,
      s.eastNormal,
      n0
    );
    We.rayPlane(
      Vr,
      b,
      s.northeastCornerCartesian
    ), C = e.geodeticSurfaceNormal(
      m,
      Hc
    );
  } else
    C = e.geodeticSurfaceNormalCartographic(
      Oe.northwest(t),
      Hc
    );
  const p = _.cross(
    a,
    C,
    i0
  );
  _.normalize(p, s.northNormal);
}
const DF = new B(), KF = new B(), HF = new B(0, -1, 0), PF = new B(0, 0, -1), s0 = new B();
function NF(s, t, e, i, n) {
  n = he(n, De.WGS84);
  const o = t, r = n.cartesianToCartographic(t);
  let a = 0;
  if (!Oe.contains(s.rectangle, r)) {
    let h = s.southwestCornerCartesian, d = s.northeastCornerCartesian, C = s.westNormal, p = s.southNormal, m = s.eastNormal, b = s.northNormal;
    e !== Ge.SCENE3D && (h = i.project(
      Oe.southwest(s.rectangle),
      DF
    ), h.z = h.y, h.y = h.x, h.x = 0, d = i.project(
      Oe.northeast(s.rectangle),
      KF
    ), d.z = d.y, d.y = d.x, d.x = 0, C = HF, m = _.UNIT_Y, p = PF, b = _.UNIT_Z);
    const S = _.subtract(
      o,
      h,
      s0
    ), A = _.dot(
      S,
      C
    ), u = _.dot(
      S,
      p
    ), y = _.subtract(
      o,
      d,
      s0
    ), I = _.dot(
      y,
      m
    ), M = _.dot(
      y,
      b
    );
    A > 0 ? a += A * A : I > 0 && (a += I * I), u > 0 ? a += u * u : M > 0 && (a += M * M);
  }
  let g, c, l;
  if (e === Ge.SCENE3D ? (g = r.z, c = s.minimumHeight, l = s.maximumHeight) : (g = o.x, c = 0, l = 0), g > l) {
    const h = g - l;
    a += h * h;
  } else if (g < c) {
    const h = c - g;
    a += h * h;
  }
  return Math.sqrt(a);
}
$g.prototype.distanceToCamera = function(s, t, e, i) {
  return NF(this, s, t, e, i);
};
$g.prototype.intersectPlane = function(s) {
  return this._orientedBoundingBox.intersectPlane(s);
};
class FF {
  constructor() {
    f(this, "_renderTarget", null);
    this._copyMesh = null;
  }
  render(t, e, i, n, o) {
    const r = this._lastOverrideMaterial, a = t.overrideMaterial;
    this._lastOverrideMaterial = a;
    let g = !this._renderTarget;
    r !== a && (t.overrideMaterial = a, g = !0);
    const c = e.rendering.resolution, l = e.rendering.pixelRatio, h = e.rendering.features.antialias.samples;
    this._renderTarget && this._renderTarget.samples !== h && (g = !0), g && (this._renderTarget && this._renderTarget.dispose(), a ? (this._renderTarget = new It(
      c.x * l,
      c.y * l,
      {
        depthBuffer: !0,
        stencilBuffer: !1
      }
    ), this._fakeDepthTexture = new Ga(new Float32Array(4), 1, 1, ur)) : this._renderTarget = new rb(
      c.x * l,
      c.y * l,
      2,
      {
        depthBuffer: !0,
        stencilBuffer: !1
      }
    ), this._renderTarget.samples = h), (this._renderTarget.width !== c.x * l || this._renderTarget.height !== c.y * l) && this._renderTarget.setSize(c.x * l, c.y * l);
    const d = e.renderer, C = d.getRenderTarget(), p = d.autoClear;
    d.autoClear = !1, d.setRenderTarget(this._renderTarget), d.clear();
    const m = o.cameraOffset;
    t.position.set(-m.x, -m.y, -m.z), t.updateMatrix(), t.updateMatrixWorld(), d.render(t, n), t.position.set(0, 0, 0), t.updateMatrix(), t.updateMatrixWorld(), d.setRenderTarget(C), d.autoClear = p;
    const b = this.copyMesh;
    if (b) {
      const S = b.material.uniforms;
      g && (a ? (S.tDiffuse.value = this._renderTarget.texture, S.tDepth.value = this._fakeDepthTexture) : (S.tDiffuse.value = this._renderTarget.texture[0], S.tDepth.value = this._renderTarget.texture[1])), S.viewMatrix.value.copy(n.matrixWorldInverse), S.projectionMatrix.value.copy(n.projectionMatrix);
    }
  }
  get copyMesh() {
    if (!this._copyMesh) {
      const t = new Qe();
      t.setAttribute("position", new ae([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), t.setAttribute("uv", new ae([0, 2, 0, 0, 2, 0], 2));
      const e = new ze({
        name: "GroundSceneCopyShader",
        vertexShader: `
                    varying vec2 vUv;
                    #include <color_pars_vertex>
                    void main() {
                        vUv = uv;
                        gl_Position = vec4(position, 1.0);
                    }
                `,
        fragmentShader: `
                    #include <packing>
                    #include <color_pars_fragment>
                    uniform sampler2D tDiffuse;
                    uniform sampler2D tDepth;
                    uniform mat4 projectionMatrix;
                    uniform float logDepthBufFC;
                    varying vec2 vUv;

                    void main() {
                        gl_FragColor = texelFetch(tDiffuse, ivec2(gl_FragCoord.xy), 0);
                        vec4 depthValue = texelFetch(tDepth, ivec2(gl_FragCoord.xy), 0);
                        gl_FragDepthEXT = unpackRGBAToDepth(depthValue);
                        // \u534A\u900F\u660E\u533A\u57DF\u4E0D\u5199\u5165\u6DF1\u5EA6\uFF0C\u8FB9\u7F18\u7531\u4E8E\u6297\u952F\u9F7F\u4F1A\u4EA7\u751F\u4E00\u4E9B\u534A\u900F\u660E\u533A\u57DF\uFF0C\u6DF1\u5EA6\u503C\u4F1A\u88AB\u5199\u5165\u9519\u8BEF\u503C
                        if (gl_FragColor.a < 0.99) {
                            gl_FragDepthEXT = 1.0;
                        }

                        #include <tonemapping_fragment>
                        #include <colorspace_fragment>
                    }
                `,
        uniforms: {
          tDiffuse: { value: null },
          tDepth: { value: null },
          viewMatrix: { value: new J() },
          projectionMatrix: { value: new J() }
        }
      });
      this._copyMesh = new le(t, e), this._copyMesh.isFSQuad = !0, this._copyMesh.frustumCulled = !1, this._copyMesh.renderOrder = -1e6;
    }
    return this._copyMesh;
  }
}
class v_ {
  constructor(t = {}) {
    f(this, "_logLoadInCurrentFrame", !1);
    f(this, "_loadSiblings", !0);
  }
  beginFrame() {
  }
  endFrame() {
    this._logLoadInCurrentFrame = !1;
  }
  computeTiles(t, e, i, n, o) {
    return {
      selectedTiles: [],
      requestTilesQueue: []
    };
  }
  _pushSelectedTile(t, e, i = !1) {
    e.isMeetSSE !== i ? e.isMeetSSEChanged = !0 : e.isMeetSSEChanged = !1, e.isMeetSSE = i, e.tile._horizonFactor < 0.05 && (e.isMeetSSE = !1), t.push(e);
  }
  get surface() {
    return this._surface;
  }
}
const Pt = class {
  constructor() {
    f(this, "state", 0);
  }
  setInFrustum() {
    this.state |= Pt.STATE_IN_FRUSTUM;
  }
  setNotReady() {
    this.state |= Pt.STATE_NOT_READY;
  }
  setRendered() {
    this.state |= Pt.STATE_RENDERED;
  }
  setChildRendered() {
    this.state |= Pt.STATE_CHILD_RENDERED;
  }
  setForceKeep() {
    this.state |= Pt.STATE_FORCE_KEEP;
  }
  setRenderReady() {
    this.state |= Pt.STATE_RENDER_READY;
  }
  clearInFrustum() {
    this.state &= ~Pt.STATE_IN_FRUSTUM;
  }
  clearNotReady() {
    this.state &= ~Pt.STATE_NOT_READY;
  }
  clearRendered() {
    this.state &= ~Pt.STATE_RENDERED;
  }
  clearChildRendered() {
    this.state &= ~Pt.STATE_CHILD_RENDERED;
  }
  clearForceKeep() {
    this.state &= ~Pt.STATE_FORCE_KEEP;
  }
  clearRenderReady() {
    this.state &= ~Pt.STATE_RENDER_READY;
  }
  isInFrustum() {
    return (this.state & Pt.STATE_IN_FRUSTUM) !== 0;
  }
  isNotReady() {
    return (this.state & Pt.STATE_NOT_READY) !== 0;
  }
  isRendered() {
    return (this.state & Pt.STATE_RENDERED) !== 0;
  }
  isChildRendered() {
    return (this.state & Pt.STATE_CHILD_RENDERED) !== 0;
  }
  isForceKeep() {
    return (this.state & Pt.STATE_FORCE_KEEP) !== 0;
  }
  isRenderReady() {
    return (this.state & Pt.STATE_RENDER_READY) !== 0;
  }
};
let Es = Pt;
f(Es, "STATE_IN_FRUSTUM", 1), f(Es, "STATE_NOT_READY", 2), f(Es, "STATE_RENDERED", 4), f(Es, "STATE_CHILD_RENDERED", 8), f(Es, "STATE_FORCE_KEEP", 16), f(Es, "STATE_RENDER_READY", 32);
function Pc(s, t) {
  let e = !1;
  return s.isOrientedBoundingBox && t.isOrientedBoundingBox ? e = s.intersectsObb(t) || t.intersectsObb(s) : s.isOrientedBoundingBox && t.isBox3 ? e = o0(s, t) : s.isBox3 && t.isOrientedBoundingBox ? e = o0(t, s) : s.isBox3 && t.isBox3 && (e = s.intersectsBox(t)), e;
}
function o0(s, t) {
  const i = s.computeCorners().map((g) => ({
    x: g.x,
    y: g.y,
    z: g.z
  }));
  for (const g of i)
    if (g.x >= t.min.x && g.x <= t.max.x && g.y >= t.min.y && g.y <= t.max.y && g.z >= t.min.z && g.z <= t.max.z)
      return !0;
  const n = [
    new B(t.min.x, t.min.y, t.min.z),
    new B(t.max.x, t.min.y, t.min.z),
    new B(t.min.x, t.max.y, t.min.z),
    new B(t.max.x, t.max.y, t.min.z),
    new B(t.min.x, t.min.y, t.max.z),
    new B(t.max.x, t.min.y, t.max.z),
    new B(t.min.x, t.max.y, t.max.z),
    new B(t.max.x, t.max.y, t.max.z)
  ];
  for (const g of n)
    if (s.distanceSquaredTo(g) === 0)
      return !0;
  const o = [
    new B(1, 0, 0),
    new B(0, 1, 0),
    new B(0, 0, 1)
  ], r = o, a = [...o, ...r];
  for (const g of a) {
    const c = kF(s, g), l = VF(t, g);
    if (!zF(c, l))
      return !1;
  }
  return !0;
}
function kF(s, t) {
  const e = s.computeCorners();
  let i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
  for (const o of e) {
    const r = o.dot(t);
    i = Math.min(i, r), n = Math.max(n, r);
  }
  return { min: i, max: n };
}
function VF(s, t) {
  const e = [
    new B(s.min.x, s.min.y, s.min.z),
    new B(s.max.x, s.min.y, s.min.z),
    new B(s.min.x, s.max.y, s.min.z),
    new B(s.max.x, s.max.y, s.min.z),
    new B(s.min.x, s.min.y, s.max.z),
    new B(s.max.x, s.min.y, s.max.z),
    new B(s.min.x, s.max.y, s.max.z),
    new B(s.max.x, s.max.y, s.max.z)
  ];
  let i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
  for (const o of e) {
    const r = o.dot(t);
    i = Math.min(i, r), n = Math.max(n, r);
  }
  return { min: i, max: n };
}
function zF(s, t) {
  return !(s.max < t.min || t.max < s.min);
}
new js();
new Zt(new B(0, 0, 1), 0);
new Z();
const r0 = new B(), XF = new Z(-1, -1), WF = new Z(1, -1);
new Z(-0.5, -0.5);
new Z(0.5, -0.5);
new B();
const Nc = new Z();
let no = new B(), ms = new B(), so = new B(), ys = new B();
const ZF = new Ue(
  new B(74, 3, -100),
  new B(135, 53, 100)
);
class T_ extends v_ {
  constructor(e = {}) {
    super(e);
    f(this, "isFastTileLoaderStrategy", !0);
    f(this, "_renderedTiles", []);
    f(this, "_renderedTilesMap", /* @__PURE__ */ new Map());
    f(this, "_viewportTilesMap", /* @__PURE__ */ new Map());
    f(this, "_lastViewportZLevel", 0);
    f(this, "_hysteresis", null);
    f(this, "_showDebug", !1);
    f(this, "_isAncestorTile", (e, i) => e.z <= i.z ? !1 : this.surface._quadtree.isAncestralTile(e.z, e.x, e.y, i));
    f(this, "_preserveLastFrameChildrenTiles", (e, i) => {
      const n = this._renderedTiles;
      let o = 0;
      for (const r of n)
        if (this._isAncestorTile(r.dataTile, e)) {
          const a = this._surfaceTileManager.getSurfaceTile(r.tile);
          a && (this._pushSelectedTile(i, a, !1), o++);
        }
      return o;
    });
    f(this, "_isTileRenderedInLastFrame", (e) => this._renderedTilesMap.has(e.key));
    f(this, "_isTileAncestorRenderedInLastFrame", (e) => {
      for (; e.parent; )
        if (e = e.parent, this._renderedTilesMap.has(e.key))
          return !0;
    });
    f(this, "_hideChildrenTiles", (e, i, n) => {
      let o = 0, r, a;
      for (a = e.length - 1; a >= 0; a--)
        r = e[a].dataTile, this._isAncestorTile(r, n) && (e.splice(a, 1), o++);
      for (a = i.length - 1; a >= 0; a--)
        r = i[a], this._isAncestorTile(r, n) && i.splice(a, 1);
      return o;
    });
    f(this, "_traverseViewportTiles", (e, i, n, o, r) => {
      if (!e)
        return;
      const a = this.surface, g = a.engine, { mode: c, mapProjection: l, _ellipsoid: h } = g.map.map, d = g.map.isGlobe;
      for (const C of o) {
        if (c === Dt.SCENE3D && (a.updateTileBoundingRegion(C), a._enableHorizonCulling && a._currentOccluder && (C._occludeePointInScaledSpace || (C._occludeePointInScaledSpace = a._computeOccludeePoint(
          C,
          a._currentOccluder
        )), C._occludeePointInScaledSpace && !a._currentOccluder.isScaledSpacePointVisiblePossiblyUnderEllipsoid(C._occludeePointInScaledSpace, 0))) || !a._computeTileVisibility(i, C))
          continue;
        let p = !1;
        if (d ? C.boundingRegion && C.boundingRegion.boundingVolume && (p = Pc(e, C.boundingRegion.boundingVolume)) : p = Pc(e, C.targetBoundingBox), p) {
          const m = a.computeDistanceToTile(
            C,
            n,
            c,
            l,
            h
          );
          C._distance = m;
          const b = a.screenSpaceError(C) < 2, S = C.z >= a._maxLevel;
          if (C.z >= a._minLevel && (b || S)) {
            r.push(C);
            continue;
          }
          const A = a._quadtree.getTileChildren(C);
          A.length > 0 && this._traverseViewportTiles(
            e,
            i,
            n,
            A,
            r
          );
        }
      }
    });
    this._restrictViewportLevel = W(e.restrictViewportLevel, !0);
  }
  beginFrame() {
    super.beginFrame();
  }
  initDebugMeshes() {
    if (!this.mesh) {
      const e = new XA(1, 32, 32), i = new _t({
        color: new Ce(16711680),
        transparent: !0,
        opacity: 0.9
      });
      (this.mesh = new le(e, i)).scale.set(50, 50, 50);
      const o = new _t({
        color: new Ce(255),
        transparent: !0,
        opacity: 0.9
      }), r = new _t({
        color: new Ce(65280),
        transparent: !0,
        opacity: 0.9
      }), a = this.mesh1 = new le(e, o), g = this.mesh2 = new le(e, r);
      a.scale.set(50, 50, 50), g.scale.set(50, 50, 50);
    }
  }
  getViewportBounds(e) {
    const i = [], n = e.map.getPitch();
    let o = this.getNdcYFactor(n);
    return no = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(XF), so = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(WF), Nc.set(-1, o), ms = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(Nc), Nc.set(1, o), ys = e.rendering.picking.pickSeaLevelWorldPositionFromNdc(Nc), no && so && ms && ys ? (this._showDebug && (this.mesh1.position.copy(ms), this.mesh2.position.copy(ys), this.mesh.scale.setScalar(e.map.getCameraDistance() / 100), this.mesh1.scale.setScalar(e.map.getCameraDistance() / 100), this.mesh2.scale.setScalar(e.map.getCameraDistance() / 100)), i[0] = Math.min(no.x, so.x, ms.x, ys.x), i[1] = Math.min(no.y, so.y, ms.y, ys.y), i[2] = Math.min(no.z, so.z, ms.z, ys.z), i[3] = Math.max(no.x, so.x, ms.x, ys.x), i[4] = Math.max(no.y, so.y, ms.y, ys.y), i[5] = Math.max(no.z, so.z, ms.z, ys.z), new Ue(new B(i[0], i[1], i[2]), new B(i[3], i[4], i[5]))) : null;
  }
  getNdcYFactor(e, i = 30, n = 0.3) {
    if (e < i)
      return 1;
    const o = (e - i) / (90 - i), r = 1 - Math.tan(o * Math.PI / 2) * n;
    return Math.max(-0.2, Math.min(r, 1));
  }
  computeTiles(e, i, n, o) {
    const r = this.surface, a = [], g = [], c = [], l = [], h = this._viewportTilesMap;
    h.clear();
    const d = e.map.getProjectionCenter();
    r0.set(d[0], d[1], d[2]), this._showDebug && this.mesh.position.copy(r0);
    let C = 0;
    if (this._restrictViewportLevel) {
      let p = this.getViewportBounds(e), m = e.map.getViewHeight() > 1e6;
      if (!p && m && (p = e.map.projection.getWorldBoundingBox()), this._traverseViewportTiles(
        p,
        n,
        i,
        r._quadtree.root,
        l
      ), C = this.calcViewportWeightedZLevel(l, h), m && r.tileProvider.isBaiduProvider) {
        let u = e.map.projection.geoBoxToProjectedBox(ZF);
        l.forEach((y) => {
          if (!y.inStrictBounds) {
            let I = !1;
            e.map.isGlobe ? y.boundingRegion && y.boundingRegion.boundingVolume && (I = Pc(
              u,
              y.boundingRegion.boundingVolume
            )) : I = Pc(u, y.targetBoundingBox), y.inStrictBounds = I;
          }
        });
      }
      const b = 0.5;
      let S = W(this._hysteresis, b);
      Math.abs(C - this._lastViewportZLevel) > S ? this._lastViewportZLevel = C : C = this._lastViewportZLevel, C = Math.round(C);
      let A;
      for (let u = 0; u < l.length; u++)
        A = l[u], A.z < C && A.inStrictBounds ? A._shouldSplit = !0 : A.z === C - 1 && (A._shouldSplitOnce = !0);
    }
    for (const p of r._quadtree.root)
      this._computeIntersectTiles(
        n,
        i,
        p,
        g,
        a,
        c,
        C
      );
    return this._logLoadInCurrentFrame, this._renderedTiles = g, this._renderedTilesMap = new Map(
      g.map((p) => [p.dataTile.key, p.dataTile])
    ), {
      selectedTiles: g,
      requestTilesQueue: [a],
      placeholderTiles: c
    };
  }
  calcViewportWeightedZLevel(e, i) {
    const n = this.surface, o = [];
    let r = 0;
    const a = n.engine.map.isGlobe;
    let g;
    for (let l = 0; l < e.length; l++) {
      g = e[l];
      const h = n.projectBoundingBoxToNdc(g), d = n.reverseScreenSpaceErrorZ(g), C = h.map(([m, b]) => [
        Math.max(-1, Math.min(1, m)),
        Math.max(-1, Math.min(1, b))
      ]);
      let p;
      if (a) {
        const m = g.boundingRegion;
        if (m) {
          const b = m.rectangle, S = Math.abs(
            (b.east - b.west) * (Math.sin(b.north) - Math.sin(b.south)) * 6378137 * 6378137
          ), A = this.getPolygonArea(C);
          p = Math.sqrt(S * A);
        } else
          p = this.getPolygonArea(C);
      } else
        p = this.getPolygonArea(C);
      o.push(p), i.set(g, { z: d, area: p });
    }
    const c = o.reduce((l, h) => l + h, 0);
    if (c <= 0)
      return r;
    for (let l = 0; l < e.length; l++) {
      g = e[l];
      const h = i.get(g).area / c;
      i.get(g).areaProportion = h, i.get(g).ratio = h * i.get(g).z;
    }
    return r = e.reduce((l, h) => l + i.get(h).ratio, 0), r;
  }
  _computeIntersectTiles(e, i, n, o, r, a, g) {
    const c = this.surface, l = c.engine, h = c._currentStatistics;
    h.visited += 1, this._logLoadInCurrentFrame;
    const d = new Es(), { mode: C, mapProjection: p, _ellipsoid: m } = l.map.map;
    if (C === Dt.SCENE3D && c.updateTileBoundingRegion(n), !c._computeTileVisibility(e, n))
      return this._logLoadInCurrentFrame, d;
    d.setInFrustum(), this._surfaceTileManager.markTileUsed(n), h.used++;
    let b = c.computeDistanceToTile(n, i, C, p, m);
    n._distance = b;
    const S = this._surfaceTileManager.isTileRenderable(n);
    let A = c.screenSpaceError(n) < 2 && !n._shouldSplit && !n._shouldSplitOnce, u = n.z >= c._maxLevel || n.z >= g && g > 0;
    if (n.z >= c._minLevel && (u || A)) {
      const M = this._surfaceTileManager.getSurfaceTile(n);
      if (S)
        return this._logLoadInCurrentFrame, this._pushSelectedTile(o, M, !n.overMeetSse), delete n.overMeetSse, h.rendered += 1, d.setRendered(), d.setRenderReady(), d;
      this._logLoadInCurrentFrame, r.push(n), a.push(n), h.request += 1, d.setNotReady();
      const G = this._preserveLastFrameChildrenTiles(n, o);
      return G > 0 && (this._logLoadInCurrentFrame, h.rendered += G, d.setForceKeep(), d.setRenderReady()), d;
    }
    const y = c._quadtree.getTileChildren(n);
    if (n.z === c._minLevel - 1 && A)
      for (const M of y)
        M.overMeetSse = !0;
    if (delete n._shouldSplitOnce, n._shouldSplit) {
      delete n._shouldSplit;
      for (const M of y)
        M.z < g ? M._shouldSplit = !0 : delete M._shouldSplit;
    }
    n.childrenInFrustum = [];
    let I = !0;
    for (const M of y) {
      M.parent = n;
      let G = this._computeIntersectTiles(
        e,
        i,
        M,
        o,
        r,
        a,
        g
      );
      !G.isInFrustum() || (n.childrenInFrustum.push(M), G.isForceKeep() && d.setForceKeep(), G.isRenderReady() ? d.setRenderReady() : I = !1, G.isRendered());
    }
    if (d.isForceKeep())
      return d;
    if (!I) {
      let M = !1;
      if (this._isTileRenderedInLastFrame(n) ? (M = !0, S && (this._logLoadInCurrentFrame, this._pushSelectedTile(o, this._surfaceTileManager.getSurfaceTile(n), !1), h.rendered += 1, d.setRenderReady(), d.setRendered())) : this._isTileAncestorRenderedInLastFrame(n) && (M = !0, d.clearRenderReady()), M) {
        const G = this._hideChildrenTiles(o, a, n);
        h.rendered -= G;
      }
    }
    return d;
  }
  getPolygonArea(e) {
    let i = 0;
    const n = e.length;
    for (let o = 0; o < n; o++) {
      const [r, a] = e[o], [g, c] = e[(o + 1) % n];
      i += r * c - g * a;
    }
    return Math.abs(i) / 2;
  }
  set showDebug(e) {
    if (!this.surface.engine)
      return;
    const i = this.surface.engine;
    this.initDebugMeshes(), e ? (i.add(this.mesh1), i.add(this.mesh2), i.add(this.mesh)) : (i.remove(this.mesh1), i.remove(this.mesh2), i.remove(this.mesh)), this._showDebug = e;
  }
  get showDebug() {
    return this._showDebug;
  }
  set restrictViewportLevel(e) {
    this._restrictViewportLevel = e;
  }
  get restrictViewportLevel() {
    return this._restrictViewportLevel;
  }
}
class L_ extends v_ {
  constructor() {
    super(...arguments);
    f(this, "isHierarchicalTileLoaderStrategy", !0);
    f(this, "_computeHierarchicalIntersectTiles", (e, i, n, o, r, a, g, c, l) => {
      const h = this.surface, d = h.engine, C = h._currentStatistics;
      C.visited += 1, this._logLoadInCurrentFrame;
      const { mode: p, mapProjection: m, _ellipsoid: b } = d.map.map;
      let S = h.computeDistanceToTile(n, e, p, m, b);
      n._distance = S, this._surfaceTileManager.isTileComputable(n);
      const A = this._surfaceTileManager.isTileRenderable(n), u = this._surfaceTileManager.isTileStable(n);
      if (!A)
        return this._logLoadInCurrentFrame, r.push(n), !1;
      C.used += 1, this._surfaceTileManager.markTileUsed(n);
      let y = h.screenSpaceError(n) < 2;
      if (n.z >= h._minLevel && (y || n.z >= h._maxLevel)) {
        u || (r.push(n), C.request += 1, this._logLoadInCurrentFrame);
        const x = this._surfaceTileManager.getSurfaceTile(n, l);
        return o.push(x), this._logLoadInCurrentFrame, C.rendered += 1, !0;
      }
      u || (this._logLoadInCurrentFrame, g.push(n));
      const I = h._quadtree.getTileChildren(n);
      if (!I || I.length === 0) {
        const x = this._surfaceTileManager.getSurfaceTile(n, l);
        return o.push(x), this._logLoadInCurrentFrame, C.rendered += 1, !0;
      }
      let M = !0;
      const G = [];
      for (const x of I) {
        if (p === Dt.SCENE3D && h.updateTileBoundingRegion(x), !h._computeTileVisibility(i, x)) {
          if (this._logLoadInCurrentFrame, !this._loadSiblings)
            continue;
          this._surfaceTileManager.markTileUsed(x), C.used++, this._surfaceTileManager.isTileComputable(x) || (a.push(x), this._logLoadInCurrentFrame);
          continue;
        }
        this._surfaceTileManager.isTileComputable(x) || (M = !1, this._logLoadInCurrentFrame), this._logLoadInCurrentFrame, G.push(x), this._surfaceTileManager.markTileUsed(x);
      }
      if (M) {
        for (const x of G)
          this._computeHierarchicalIntersectTiles(
            e,
            i,
            x,
            o,
            r,
            a,
            g,
            c,
            l
          );
        this._logLoadInCurrentFrame;
      } else {
        this._logLoadInCurrentFrame;
        let x;
        p === Dt.SCENE3D ? x = d.map.map._ellipsoidCamera.positionCartographic : x = d.map.unprojectArrayCoordinate(d.camera.position.toArray());
        let L = I;
        I.length === 4 && (L = h._naturalOrderChildTiles(I, x)), this._logLoadInCurrentFrame, L = L.filter((T) => G.includes(T)), L.forEach((T) => {
          this._surfaceTileManager.isTileComputable(T) || (this._logLoadInCurrentFrame, c.push(T), C.visited += 1, C.request += 1, this._logLoadInCurrentFrame);
        });
        const E = this._surfaceTileManager.getSurfaceTile(n, l);
        o.push(E), C.rendered += 1, C.unstable += 1, this._logLoadInCurrentFrame;
      }
      return !0;
    });
  }
  computeTiles(e, i, n, o) {
    const r = this.surface, a = [], g = [], c = [], l = [], h = [];
    for (const d of r._quadtree.root)
      this._surfaceTileManager.isTileRenderable(d) ? this._computeHierarchicalIntersectTiles(
        i,
        n,
        d,
        a,
        c,
        h,
        l,
        g,
        o
      ) : c.push(d);
    return this._logLoadInCurrentFrame, {
      selectedTiles: a,
      requestTilesQueue: [g, c, l, h],
      placeholderTiles: []
    };
  }
  queueTileLoaded(e, i) {
    !this._surfaceTileManager.isTileNeedsLoading(e) || i.push(e);
  }
}
const UF = `#define GLSLIFY 1
#include <common>
#include <logdepthbuf_pars_vertex>

varying vec2 vUv;
#ifdef MVT_USE_VERTEX_ZINDEX
attribute float layerIndex;
varying float vLayerIndex;
#endif

void main() {

	vUv = uv;

    #include <begin_vertex>
    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);

    #ifdef MVT_USE_VERTEX_ZINDEX
        vLayerIndex = layerIndex;
    #endif

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    #include <logdepthbuf_vertex>
}

`, OF = `#define GLSLIFY 1
#include <common>
#include <packing>

varying vec2 vUv;
uniform vec3 color;
uniform vec3 borderColor;
uniform sampler2D map;

#include <logdepthbuf_pars_fragment>
#include <mvt_depth_range_pars_fragment>

void main() {

    vec4 diffuseColor = vec4(color, 1.0);
    vec4 diffuseMap = texture2D(map, vUv);
    if (diffuseMap.a > 0.1) {
        diffuseMap.rgb = borderColor;
    }

    gl_FragColor.rgb = mix(diffuseColor, diffuseMap, diffuseMap.a).rgb;
    gl_FragColor.a = 1.0;

    // if (gl_FragColor.a <= 0.) {
    //     discard;
    // }

    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <mvt_depth_range_fragment>
}

`, QF = we.merge([
  {
    color: { value: [0.95, 0.95, 0.95] },
    borderColor: { value: [0.5, 0.5, 0.5] },
    vertexZIndex: { value: !1 },
    isEmissive: { value: !1 },
    depthRange: { value: new Z(0, 1) },
    map: { value: null }
  }
]);
class YF extends di {
  constructor(t) {
    super(), this.name = "PlaceholderMaterial", this.type = "PlaceholderMaterial", this.isPlaceholderMaterial = !0, this.transparent = !1, this.fragmentShader = OF, this.vertexShader = UF, Object.assign(this.uniforms, we.clone(QF)), oi(this, [
      "isEmissive",
      "map",
      "depthRange"
    ]), Xn(this, [
      "color",
      "borderColor"
    ]), ri(this, [
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"]
    ]), this.setValues(t);
  }
}
const zr = new B(), jF = new B(), JF = new yt(), qF = new B(), $F = new B(), Ki = class {
  constructor(t, e) {
    this.position = t, this.position || (t = new Z()), this.tangentPlane = e, this.tangentPlane || (this.tangentPlane = Ki.NORTH_POLE_TANGENT_PLANE);
  }
  getLatitude(t) {
    t || (t = De.WGS84), zr.x = this.longitude, zr.y = this.conformalLatitude, zr.z = 0;
    const e = this.ellipsoid.cartographicToCartesian(
      zr,
      jF
    );
    return t.cartesianToCartographic(e, zr), zr.y;
  }
  static fromCartesian(t, e) {
    const i = t.z < 0 ? -1 : 1;
    let n = Ki.NORTH_POLE_TANGENT_PLANE, o = Ki.SOUTH_POLE;
    i < 0 && (n = Ki.SOUTH_POLE_TANGENT_PLANE, o = Ki.NORTH_POLE);
    const r = JF;
    r.origin = n.ellipsoid.scaleToGeocentricSurface(
      t,
      r.origin
    ), r.direction = _.subtract(
      r.origin,
      o,
      qF
    ), _.normalize(r.direction, r.direction);
    const a = We.rayPlane(
      r,
      n.plane,
      $F
    ), g = _.subtract(a, o, a), c = _.dot(n.xAxis, g), l = i * _.dot(n.yAxis, g);
    return e ? (e.position = new Z(c, l), e.tangentPlane = n, e) : new Ki(new Z(c, l), n);
  }
  clone(t) {
    return Ki.clone(this, t);
  }
  static clone(t, e) {
    if (!!t)
      return e ? (e.position = t.position, e.tangentPlane = t.tangentPlane, e) : new Ki(
        t.position,
        t.tangentPlane
      );
  }
  get ellipsoid() {
    return this.tangentPlane.ellipsoid;
  }
  get x() {
    return this.position.x;
  }
  get y() {
    return this.position.y;
  }
  get conformalLatitude() {
    const t = this.position.length(), e = 2 * this.ellipsoid.maximumRadius;
    return this.tangentPlane.plane.normal.z * (X.PI_OVER_TWO - 2 * Math.atan2(t, e));
  }
  get longitude() {
    let t = X.PI_OVER_TWO + Math.atan2(this.y, this.x);
    return t > Math.PI && (t -= X.TWO_PI), t;
  }
};
let Mi = Ki;
f(Mi, "HALF_UNIT_SPHERE", Object.freeze(new De(0.5, 0.5, 0.5))), f(Mi, "NORTH_POLE", Object.freeze(new B(0, 0, 0.5))), f(Mi, "SOUTH_POLE", Object.freeze(new B(0, 0, -0.5))), f(Mi, "NORTH_POLE_TANGENT_PLANE", Object.freeze(new Sr(Ki.NORTH_POLE, Ki.HALF_UNIT_SPHERE))), f(Mi, "SOUTH_POLE_TANGENT_PLANE", Object.freeze(new Sr(Ki.SOUTH_POLE, Ki.HALF_UNIT_SPHERE)));
const a0 = new Mi(), ek = new Mi(), dn = {
  northAngle: 0,
  southAngle: 0,
  westOverIdl: 0,
  eastOverIdl: 0
}, tk = new Z(), ik = new Z(), nk = new Mi();
new Z();
const g0 = (s, t, e, i, n) => {
  const o = s.longitude, r = o >= 0 ? o : o + X.TWO_PI;
  i.westOverIdl = Math.min(i.westOverIdl, r), i.eastOverIdl = Math.max(i.eastOverIdl, r), n.west = Math.min(n.west, o), n.east = Math.max(n.east, o);
  const a = s.getLatitude(e);
  let g = a;
  n.south = Math.min(n.south, a), n.north = Math.max(n.north, a);
  const c = oe.subtract(
    t.position,
    s.position,
    tk
  ), l = oe.dot(t.position, c) / oe.dot(c, c);
  if (l > 0 && l < 1) {
    const C = oe.add(
      t.position,
      oe.multiplyByScalar(c, -l, c),
      ik
    ), p = Mi.clone(t, nk);
    p.position = C;
    const m = p.getLatitude(e);
    n.south = Math.min(n.south, m), n.north = Math.max(n.north, m), Math.abs(a) > Math.abs(m) && (g = m);
  }
  const h = t.x * s.y - s.x * t.y;
  let d = Math.sign(h);
  d !== 0 && (d *= oe.angleBetween(t.position, s.position)), g >= 0 && (i.northAngle += d), g <= 0 && (i.southAngle += d);
}, sk = (s, t, e) => {
  if (e || (e = new Oe()), s.length < 3)
    return e;
  e.west = Number.POSITIVE_INFINITY, e.east = Number.NEGATIVE_INFINITY, e.south = Number.POSITIVE_INFINITY, e.north = Number.NEGATIVE_INFINITY, dn.northAngle = 0, dn.southAngle = 0, dn.westOverIdl = Number.POSITIVE_INFINITY, dn.eastOverIdl = Number.NEGATIVE_INFINITY;
  const i = s.length;
  let n = Mi.fromCartesian(
    new B(...s[0]),
    ek
  );
  for (let o = 1; o < i; o++) {
    const r = Mi.fromCartesian(
      new B(...s[o]),
      a0
    );
    g0(
      r,
      n,
      t,
      dn,
      e
    ), n = Mi.clone(r, n);
  }
  return g0(
    Mi.fromCartesian(
      new B(...s[0]),
      a0
    ),
    n,
    t,
    dn,
    e
  ), e.east - e.west > dn.eastOverIdl - dn.westOverIdl && (e.west = dn.westOverIdl, e.east = dn.eastOverIdl, e.east > X.PI && (e.east = e.east - X.TWO_PI), e.west < X.PI && (e.west = e.west + X.TWO_PI)), X.equalsEpsilon(
    Math.abs(dn.northAngle),
    X.TWO_PI,
    X.EPSILON10
  ) && (e.north = X.PI_OVER_TWO, e.east = X.PI, e.west = -X.PI), X.equalsEpsilon(
    Math.abs(dn.southAngle),
    X.TWO_PI,
    X.EPSILON10
  ) && (e.south = -X.PI_OVER_TWO, e.east = X.PI, e.west = -X.PI), e;
}, ok = (s, t) => {
  let e = s[0][0], i = s[0][1], n = s[0][2], o = s[0][0], r = s[0][1], a = s[0][2];
  const g = s.length;
  for (let h = 0; h < g; h++) {
    const d = s[h], C = d[0], p = d[1], m = d[2];
    e = Math.min(C, e), i = Math.min(p, i), n = Math.min(m, n), o = Math.max(C, o), r = Math.max(p, r), a = Math.max(m, a);
  }
  const c = new B(
    (e + o) / 2,
    (i + r) / 2,
    (n + a) / 2
  );
  return new Sr(c, t);
}, rk = (s, t, e) => {
  if (s.height >= X.PI || s.width >= X.PI)
    return;
  const i = t.map((o) => new B(...o));
  return ok(t, e).projectPointsOntoPlane(i);
};
function ak(s) {
  if (s.length < 3)
    throw new Error("\u70B9\u7684\u6570\u91CF\u5FC5\u987B\u5927\u4E8E\u7B49\u4E8E3\u4E2A\u624D\u80FD\u5F62\u6210\u591A\u8FB9\u5F62");
  const t = gk(s), e = s.map((i, n) => {
    const o = Math.atan2(i.y - t.y, i.x - t.x);
    return { index: n, angle: o };
  });
  return e.sort((i, n) => i.angle - n.angle), e.map((i) => i.index);
}
function gk(s, t) {
  t || (t = new Z());
  const e = s.length;
  let i = 0, n = 0;
  return s.forEach((o) => {
    i += o.x, n += o.y;
  }), t.set(i / e, n / e);
}
function ck(s, t, e, i, n, o) {
  const r = s.x, a = s.y, g = t.x, c = t.y, l = e.x, h = e.y, d = i.x, C = i.y, p = (r - g) * (h - C) - (a - c) * (l - d);
  if (Math.abs(p) < 1e-4)
    return null;
  const m = ((r - l) * (h - C) - (a - h) * (l - d)) / p, b = -((r - g) * (a - h) - (a - c) * (r - l)) / p;
  return m >= 0 && m <= 1 && b >= 0 && b <= 1 ? {
    point: s.clone().lerp(t, m),
    uv: n.clone().lerp(o, m)
  } : null;
}
function lk(s, t, e, i) {
  const n = e.x - t.x, o = e.y - t.y, r = i.x - t.x, a = i.y - t.y, g = s.x - t.x, c = s.y - t.y, l = n * a - o * r, h = (g * a - c * r) / l, d = (n * c - o * g) / l;
  return h >= 0 && d >= 0 && h + d <= 1;
}
function G_(s, t, e, i, n) {
  return s.x >= t && s.x <= e && s.y >= i && s.y <= n;
}
function hk(s, t, e, i) {
  return [
    new Z(s, e),
    new Z(t, e),
    new Z(t, i),
    new Z(s, i)
  ];
}
function dk(s) {
  return [
    [s[0], s[1]],
    [s[1], s[2]],
    [s[2], s[3]],
    [s[3], s[0]]
  ];
}
function uk(s, t, e) {
  const i = [];
  s.forEach((A, u) => {
    if (G_(
      A,
      e[0].x,
      e[2].x,
      e[0].y,
      e[2].y
    )) {
      const I = A.x + "," + A.y + "," + A.z;
      i[I] || (i[I] = {
        point: A,
        uv: t[u]
      });
    }
  });
  const n = Math.min(s[0].x, Math.min(s[1].x, s[2].x)), o = Math.max(s[0].x, Math.max(s[1].x, s[2].x)), r = Math.min(s[0].y, Math.min(s[1].y, s[2].y)), a = Math.max(s[0].y, Math.max(s[1].y, s[2].y)), g = Math.min(t[0].x, Math.min(t[1].x, t[2].x)), c = Math.max(t[0].x, Math.max(t[1].x, t[2].x)), l = Math.min(t[0].y, Math.min(t[1].y, t[2].y)), h = Math.max(t[0].y, Math.max(t[1].y, t[2].y)), d = o - n, C = a - r, p = c - g, m = h - l;
  e.forEach((A) => {
    if (lk(A, ...s)) {
      const y = A.x + "," + A.y + "," + A.z;
      if (!i[y]) {
        const I = g + p * (A.x - n) / d, M = l + m * (A.y - r) / C;
        i[y] = {
          point: A,
          uv: new Z(I, M)
        };
      }
    }
  });
  const b = [
    [0, 1],
    [1, 2],
    [2, 0]
  ], S = dk(e);
  return b.forEach(([A, u]) => {
    S.forEach(([y, I]) => {
      const M = s[A], G = s[u], x = t[A], L = t[u], E = ck(M, G, y, I, x, L);
      if (E) {
        const { point: T } = E, R = T.x + "," + T.y + "," + T.z;
        i[R] || (i[R] = E);
      }
    });
  }), Object.values(i);
}
const Ik = new B(), Ak = new B(), Ck = new B();
new B();
new B();
new B();
const Ss = new B(), fk = new Z(), pk = new Z(), mk = new Z(), yk = (s, t, e, i, n, o, r, a, g) => {
  const c = [];
  for (let S = 0; S < s.length; S++) {
    const A = s[S];
    let u = `${A.x},${A.y},${A.z}`;
    g[u] = e[S], G_(A, a[0], a[1], a[0], a[1]) && c.push(S);
  }
  if (c.length === 3)
    return !1;
  const h = hk(a[0], a[1], a[0], a[1]), d = [s[0], s[1], s[2]], C = uk(d, t, h), p = C.map((S) => S.point), m = C.map((S) => S.uv);
  if (p.length > 2) {
    const S = ak(p), A = [];
    for (let u = 0, y = S.length; u < y; u++) {
      const I = S[u], M = p[I], G = m[I], x = `${M.x},${M.y},${M.z}`;
      H(g[x]) || (n.push(M.x, M.y, M.z), i && o.push(G.x, G.y), g[x] = n.length / 3 - 1);
      const L = g[x];
      A.push(L);
    }
    p.length === 3 ? r.push(
      A[1],
      A[2],
      A[0]
    ) : p.length === 4 ? r.push(
      A[2],
      A[3],
      A[0],
      A[0],
      A[1],
      A[2]
    ) : p.length === 5 && r.push(
      A[3],
      A[4],
      A[0],
      A[0],
      A[1],
      A[2],
      A[2],
      A[3],
      A[0]
    );
  }
  return !0;
}, Sk = (s, t, e, i, n = 0, o = [-0.501, 0.501]) => {
  const r = !!e, a = Array.from(t);
  let g = 0;
  const c = s.length;
  let l = null, h = null;
  if (Array.isArray(s[0])) {
    l = [];
    let S = 0;
    for (g = 0; g < c; g++) {
      const A = s[g];
      l[S++] = A[0], l[S++] = A[1], l[S++] = A[2];
    }
  } else
    l = s.slice(0);
  if (r)
    if (Array.isArray(e[0])) {
      h = [];
      let A = 0;
      for (g = 0; g < e.length; g++) {
        const u = e[g];
        h[A++] = u[0], h[A++] = u[1];
      }
    } else
      h = e.slice(0);
  const C = [], p = {}, m = {}, b = i * i;
  for (; a.length > 0; ) {
    const S = a.pop(), A = a.pop(), u = a.pop(), y = Ik.fromArray(l, u * 3), I = Ak.fromArray(l, A * 3), M = Ck.fromArray(l, S * 3);
    let G, x, L;
    r && (G = fk.fromArray(h, u * 2), x = pk.fromArray(h, A * 2), L = mk.fromArray(h, S * 2));
    const E = _.magnitudeSquared(_.subtract(y, I, Ss)), T = _.magnitudeSquared(_.subtract(I, M, Ss)), R = _.magnitudeSquared(_.subtract(M, y, Ss)), w = Math.max(E, T, R);
    let v, D, K;
    if (w > b)
      E === w ? (v = `${Math.min(u, A)} ${Math.max(u, A)}`, g = p[v], g == null && (D = _.add(y, I, Ss), _.multiplyByScalar(D, 0.5, D), l.push(D.x, D.y, D.z), g = l.length / 3 - 1, p[v] = g, r && (K = oe.add(G, x, Ss), oe.multiplyByScalar(K, 0.5, K), h.push(K.x, K.y))), a.push(u, g, S), a.push(g, A, S)) : T === w ? (v = `${Math.min(A, S)} ${Math.max(A, S)}`, g = p[v], g || (D = _.add(I, M, Ss), _.multiplyByScalar(D, 0.5, D), l.push(D.x, D.y, D.z), g = l.length / 3 - 1, p[v] = g, r && (K = oe.add(x, L, Ss), oe.multiplyByScalar(K, 0.5, K), h.push(K.x, K.y))), a.push(A, g, u), a.push(g, S, u)) : R === w && (v = `${Math.min(S, u)} ${Math.max(S, u)}`, g = p[v], g || (D = _.add(M, y, Ss), _.multiplyByScalar(D, 0.5, D), l.push(D.x, D.y, D.z), g = l.length / 3 - 1, p[v] = g, r && (K = oe.add(L, G, Ss), oe.multiplyByScalar(K, 0.5, K), h.push(K.x, K.y))), a.push(S, g, A), a.push(g, u, A));
    else {
      if (yk(
        [y, I, M],
        [G, x, L],
        [u, A, S],
        r,
        l,
        h,
        a,
        o,
        m
      ))
        continue;
      C.push(u + n), C.push(A + n), C.push(S + n);
    }
  }
  return {
    vertices: l,
    uvs: h,
    indices: C
  };
}, mo = new B(), An = new B(), c0 = (s, t, e, i) => s === t || !s || !t ? (i.copy(e), i) : (s.unprojectCoordinate(e, An), mo.copy(An), t.projectCoordinate(mo, i), i), bk = (s, t, e = !0, i = !0) => {
  if (!t.forceProjectCoordinates && t.targetProjectionName === t.sourceProjectionName)
    return;
  const n = t.sourceProjection, o = t.targetProjection, [r, a, g] = t.targetCenter, c = t.forceUseGeoBoundingBox || n.isGeo, l = c ? t.geoBoundingBox : t.projectedBoundingBox;
  let h, d, C, p;
  if (l.isBox3) {
    const S = l.min, A = l.max;
    h = S.x, d = S.y, C = A.x, p = A.y;
  } else
    [h, d, , C, p] = l;
  const m = C - h, b = p - d;
  if (e)
    for (let S = 0, A = s.length - 2; S < A; S += 3) {
      const u = s[S], y = s[S + 1], I = s[S + 2];
      mo.set(h + (u + 0.5) * m, d + (y + 0.5) * b, I), c ? o.projectCoordinate(mo, An) : c0(n, o, mo, An), s[S] = An.x, s[S + 1] = An.y, s[S + 2] = An.z, i && (s[S] -= r, s[S + 1] -= a, s[S + 2] -= g);
    }
  else
    for (let S = 0, A = s.length; S < A; S += 1) {
      const u = s[S], y = u[0], I = u[1], M = u[2];
      mo.set(h + (y + 0.5) * m, d + (I + 0.5) * b, M), c ? o.projectCoordinate(mo, An) : c0(n, o, mo, An), u[0] = An.x, u[1] = An.y, u[2] = An.z, i && (u[0] -= r, u[1] -= a, u[2] -= g);
    }
}, Bk = (s, t, e, i) => {
  if (i.sourceProjectionName === i.targetProjectionName)
    return {
      vertices: s,
      indices: t,
      uvs: e
    };
  let o = 1 / Math.max(2, 16 - i.z);
  return Sk(s, t, e, o);
}, WC = (s, t) => {
  const e = [
    -0.5,
    -0.5,
    0,
    -0.5,
    0.5,
    0,
    0.5,
    0.5,
    0,
    0.5,
    -0.5,
    0
  ], i = [
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0
  ], n = [0, 2, 1, 0, 3, 2], {
    vertices: o,
    uvs: r,
    indices: a
  } = Bk(e, n, i, s);
  bk(o, s);
  const g = {
    vertices: o,
    uvs: r,
    indices: a
  };
  if (t) {
    const c = o.length / 3;
    for (const l of Object.keys(t)) {
      const h = t[l], d = Array.isArray(h), C = d ? h.length : 1, p = [];
      if (d)
        for (let m = 0; m < c; m++)
          for (let b = 0; b < C; b++)
            p.push(h[b]);
      else
        for (let m = 0; m < c; m++)
          p.push(h);
      g[l] = p;
    }
  }
  return g;
}, wk = new Ot();
let _k = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAUdJREFUeNrs2sENwyAQRcE4ckf0RBv04Z7ck30wFXBi/4wU5bScXhQk9hhj9B+xzu/7WjijvZ/b/Jbz/e83kE0AAkAACAABIAAEgAAQAAJAAAgAAVDYfA5ui+eY33R+BuA9PXO++QtwB0AACAABIAAEgAAQAAJAAAgAASAAqrIPED5vH8A+AO4ACAABIAAEgAAQAAJAAAgAASAABEBJ9gHC5+0D2AfAHQABIAAEgAAQAAJAAAgAASAABIAAKMk+QPi8fQD7ALgDIAAEgAAQAAJAAAgAASAABIAAEAAl2QcIn7cPYB8AdwAEgAAQAAJAAAgAASAABIAAEAACoCT7AOHz9gHsA+AOgAAQAAJAAAgAASAABIAAEAACQACUZB8gfN4+gH0A3AEQAAJAAAgAASAABIAAEAACQABUNV8D++I5nmM3nX8EGADa0U/2xPbBVwAAAABJRU5ErkJggg==", vu = null;
class l0 {
  constructor(t = {}) {
    f(this, "_maxCacheSize", 1e3);
    f(this, "handleRemove", (t, e) => {
      t.geometry.dispose();
    });
    if (this._cache = new wa({
      max: this._maxCacheSize,
      onRemove: this.handleRemove
    }), !vu) {
      const e = W(t.backgroundColor, 16382457), i = W(t.borderColor, 13224393);
      vu = wk.load(_k), this._material = new YF({
        color: new Ce(e),
        borderColor: new Ce(i),
        map: vu,
        vertexZIndex: !0,
        enableDepthRange: !0,
        depthRange: new Z(1, 1)
      });
    }
  }
  createMesh(t) {
    let e = null;
    const i = t.grid.targetProjection;
    if (i.isAxisAligned)
      return this._geometry || (this._geometry = new Og(1, 1), this._geometry.setAttribute("layerIndex", new Fe(new Float32Array([0, 0, 0, 0]), 1))), e = new le(this._geometry, this._material), e.position.copy(t.targetCenter), t.targetBoundingBox.getSize(e.scale), e;
    const n = {
      x: t.x,
      y: t.y,
      z: t.z,
      targetProjection: i,
      sourceProjection: t.grid.sourceProjection,
      targetProjectionName: i.name,
      sourceProjectionName: t.grid.sourceProjection.name,
      targetCenter: t.targetCenter.toArray(),
      geoBoundingBox: t.availableGeoBoundingBox,
      forceUseGeoBoundingBox: !0,
      forceProjectCoordinates: !0,
      projectedBoundingBox: t.projectedBoundingBox.isBox3 ? t.projectedBoundingBox : []
    }, o = WC(n, {
      layerIndices: 0
    }), r = new Qe();
    return r.setIndex(o.indices), r.setAttribute("position", new Fe(new Float32Array(o.vertices), 3)), r.setAttribute("layerIndex", new Fe(new Float32Array(o.layerIndices), 1)), r.setAttribute("uv", new Fe(new Float32Array(o.uvs), 2)), e = new le(r, this._material), e.position.copy(t.targetCenter), e;
  }
  get(t) {
    let e = this._cache.get(t.key);
    return e || (e = this.createMesh(t), this._cache.set(t.key, e), e);
  }
  clear() {
    this._cache.clear();
  }
  get maxCacheSize() {
    return this._maxCacheSize;
  }
  set maxCacheSize(t) {
    this._maxCacheSize = t;
  }
  get backgroundColor() {
    return this._material.color;
  }
  set backgroundColor(t) {
    t instanceof Ce ? this._material.color.copy(t) : this._material.color.set(t);
  }
  get borderColor() {
    return this._material.borderColor;
  }
  set borderColor(t) {
    t instanceof Ce ? this._material.borderColor.copy(t) : this._material.borderColor.set(t);
  }
}
const M_ = "fast", E_ = "hierarchical", R_ = "geo", D_ = "web_mercator", K_ = "bd_vector_online", H_ = "bd_vector_offline", _Y = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TILELOADER_STRATEGY_FAST: M_,
  TILELOADER_STRATEGY_HIERARCHICAL: E_,
  MAP_GRID_NAME_GEO: R_,
  MAP_GRID_NAME_WEB_MERCATOR: D_,
  MAP_GRID_NAME_BD_VECTOR_ONLINE: K_,
  MAP_GRID_NAME_BD_VECTOR_OFFLINE: H_
}, Symbol.toStringTag, { value: "Module" })), xk = new Zt(new B(1, 0, 0), 0), vk = [
  new B(),
  new B(),
  new B(),
  new B()
], Xr = new Me(), bs = new B(), Wr = new J(), h0 = new J(), d0 = new J(), u0 = new J();
let Tk = 0;
class P_ extends Wt {
  constructor(e = {}) {
    super(e);
    f(this, "name", "MapSurface");
    f(this, "_lodScaleFactor", 1);
    f(this, "_sseFactor", 0.8);
    f(this, "_minLevel", 0);
    f(this, "_maxLevel", 21);
    f(this, "_surfaceTileManager", null);
    f(this, "_showTileBoundingBox", !1);
    f(this, "_showTileDebugLabel", !1);
    f(this, "_debugLabelIds", {});
    f(this, "_placeholderMeshesLastFrame", []);
    f(this, "_freezeUpdate", !1);
    f(this, "_maxRequestTilesPerFrame", 20);
    f(this, "_enableHorizonCulling", !0);
    f(this, "_selectedTilesMapLastFrame", {});
    f(this, "_selectedTilesLastFrame", []);
    f(this, "_showGroundWireframe", !1);
    this._id = Tk++, this._quadtree = null, this._placeholder = null, this._options = e, this.statistics = {
      visited: 0,
      used: 0,
      rendered: 0,
      request: 0,
      unstable: 0
    }, this._currentStatistics = Object.assign({}, this.statistics), this._objectGroup = new mt(), this.add(this._objectGroup), this._boundingBoxGroup = new mt(), this.add(this._boundingBoxGroup), this._groundObjectGroup = new Kh(), e.strategy === M_ ? this.strategy = new T_(e) : e.strategy === E_ && (this.strategy = new L_(e));
  }
  _getCurrentGrid() {
  }
  computeDistanceToTile(e, i, n, o, r) {
    let a;
    if (n === Dt.SCENE3D) {
      if (this.updateTileBoundingRegion(e), !e.boundingVolumeSourceTile && e.z >= this._minLevel)
        return 9999999999;
      const l = e.boundingRegion, h = l.minimumHeight, d = l.maximumHeight;
      if (e.boundingVolumeSourceTile && e.boundingVolumeSourceTile.tile !== e) {
        const C = this.engine.map.map._ellipsoidCamera.positionCartographic.z, p = Math.abs(C - h), m = Math.abs(C - d);
        p > m ? (l.minimumHeight = h, l.maximumHeight = h) : (l.minimumHeight = d, l.maximumHeight = d);
      }
      return a = l.distanceToCamera(i, n, o, r), a;
    }
    return a = e.targetBoundingBox.distanceToPoint(i), a;
  }
  clearTilesInView() {
    this._groundObjectGroup.clear(), this._boundingBoxGroup.clear();
    const e = this._objectGroup;
    for (const i of this._selectedTilesLastFrame)
      e.remove(i.object), this.onSurfaceTileRemoved(i);
    this._selectedTilesLastFrame = [], this._selectedTilesMapLastFrame = {};
  }
  updateView(e, i, n, o) {
    if (this._freezeUpdate || this.beginFrame(o) === !1)
      return;
    const r = this._getCurrentGrid();
    if (!r)
      return;
    this._quadtree || (this._quadtree = new AA(r), this._quadtree.onTileCreated = this._onTileCreated);
    const a = this._currentOccluder = e.map._map.occluder;
    a && (a.cameraPosition = i);
    let g = this._strategy;
    g._surfaceTileManager || (g._surfaceTileManager = this._surfaceTileManager);
    let { selectedTiles: c, requestTilesQueue: l, placeholderTiles: h } = g.computeTiles(
      e,
      i,
      n,
      o
    ), d = [];
    h.length > 0 && this._shouldRenderPlaceholder && (this._placeholder || (this._placeholder = new l0(this._options), this._placeholder.engine = e), d = h.map((M) => this._placeholder.get(M)));
    let C = this._maxRequestTilesPerFrame;
    const p = Math.min(2, this._currentStatistics.unstable);
    C -= p;
    const m = C;
    for (let M = 0; M < l.length; M++) {
      const G = l[M], x = Math.min(C, G.length);
      this._requestTilesInArray(G, x), C -= x;
    }
    m > C && this._quadMap._engine.requestRender();
    const b = this._selectedTilesLastFrame, S = this._selectedTilesMapLastFrame, A = {};
    for (const M of c)
      A[M.tile.key] = M;
    const u = this._objectGroup;
    let y = this._groundObjectGroup;
    e.scene.overrideMaterial && (y = u);
    const I = this._boundingBoxGroup;
    I.clear();
    for (const M of b)
      if (!A[M.tile.key] && (u.remove(M.object), y.remove(M.groundObject), this.onSurfaceTileRemoved(M), this._showTileDebugLabel)) {
        const G = this._getDebugLabelId(M);
        this._debugLabelIds[G] && (delete this._debugLabelIds[G], e.rendering.label.removeLabel({
          id: G,
          type: "text_flat"
        }));
      }
    for (const M of this._placeholderMeshesLastFrame)
      y.remove(M);
    for (const M of d)
      y.add(M);
    for (const M of c)
      if (!!M) {
        if (this._showTileBoundingBox && I.add(M.boxHelper), this._showTileDebugLabel) {
          const G = this._getDebugLabelId(M);
          if (!this._debugLabelIds[G]) {
            this._debugLabelIds[G] = !0;
            const x = {
              crs: e.map.projectionName,
              id: G,
              position: M.tile.targetCenter,
              text: M.tile.key,
              textSize: 24,
              textFillStyle: [255, 0, 0, 1],
              textStrokeStyle: [255, 255, 255, 1],
              textStrokeWidth: 2,
              type: "text_flat",
              rank: 1e7
            };
            e.rendering.label.addLabel(x);
          }
        }
        S[M.tile.key] ? M.isMeetSSEChanged && this.onSurfaceTileSSEChanged(M) : (M.object && this._objectGroup.add(M.object), M.groundObject && y.add(M.groundObject), this.onSurfaceTileAdded(M));
      }
    this._placeholderMeshesLastFrame = d, this._selectedTilesLastFrame = c, this._selectedTilesMapLastFrame = A, this.endFrame(o);
  }
  _getDebugLabelId(e) {
    return "mapsurface-" + this._id + "-debuglabel-" + e.tile.key;
  }
  _onBeforeSceneRender(e, i, n, o) {
    if (this._groundObjectGroup.children.length === 0) {
      this._groundSceneRenderer && this.remove(this._groundSceneRenderer.copyMesh);
      return;
    }
    this._groundSceneRenderer || (this._groundSceneRenderer = new FF()), this.add(this._groundSceneRenderer.copyMesh), this._groundSceneRenderer.render(this._groundObjectGroup, e, i, n, o);
  }
  _requestTilesInArray(e, i, n = !1) {
    if (i <= 0)
      return;
    let o = e.slice(0, i);
    for (const r of o)
      this._surfaceTileManager.requestSurfaceTile(r, n);
  }
  _selectCurrentFrameRequestTiles(e, i) {
    return e.length < i ? e : (e.sort((n, o) => n.z !== o.z ? o.z - n.z : n._distance - o._distance), e.slice(0, i));
  }
  beginFrame(e) {
    this._currentStatistics.visited = 0, this._currentStatistics.used = 0, this._currentStatistics.rendered = 0, this._currentStatistics.request = 0, this._currentStatistics.unstable = 0, this._strategy.beginFrame();
  }
  endFrame(e) {
    this.statistics.visited = this._currentStatistics.visited, this.statistics.used = this._currentStatistics.used, this.statistics.rendered = this._currentStatistics.rendered, this.statistics.request = this._currentStatistics.request, this.statistics.unstable = this._currentStatistics.unstable, this._strategy.endFrame();
  }
  _computeOccludeePoint(e, i) {
    const o = e.boundingRegion.boundingVolume.center, r = e.geoBoundingBox, a = Oe.fromBox(r), g = this.engine.map.map._ellipsoid, c = vk;
    return _.fromRadians(
      a.west,
      a.south,
      0,
      g,
      c[0]
    ), _.fromRadians(
      a.east,
      a.south,
      0,
      g,
      c[1]
    ), _.fromRadians(
      a.west,
      a.north,
      0,
      g,
      c[2]
    ), _.fromRadians(
      a.east,
      a.north,
      0,
      g,
      c[3]
    ), i.computeHorizonCullingPointPossiblyUnderEllipsoid(
      o,
      c,
      0
    );
  }
  _computeOccludeePoint2(e, i) {
    const n = e.boundingBox, o = e.center, r = n.min, a = n.max, g = [
      r,
      a,
      new B(r.x, r.y, a.z),
      new B(r.x, a.y, r.z)
    ];
    return i.computeHorizonCullingPointPossiblyUnderEllipsoid(
      o,
      g,
      0
    );
  }
  updateTileBoundingRegion(e, i, n) {
    const o = this.engine.map.map._ellipsoid;
    if (!e.boundingRegion) {
      const p = Oe.fromBox(e.geoBoundingBox, new Oe(), !0);
      e.boundingRegion = new $g({
        computeBoundingVolumes: !1,
        rectangle: p,
        ellipsoid: o,
        minimumHeight: 0,
        maximumHeight: 0
      });
    }
    let a = this._surfaceTileManager.getSurfaceTile(e, n);
    const g = a && a.object, c = e._heights, l = e.boundingRegion, h = l.minimumHeight, d = l.maximumHeight;
    let C = !1;
    if (g)
      c && (l.minimumHeight = c[0], l.maximumHeight = c[1]), C = !0;
    else {
      l.minimumHeight = Number.NaN, l.maximumHeight = Number.NaN;
      let p = e.parent;
      for (; p !== void 0; ) {
        const m = p._heights, b = this._surfaceTileManager.getSurfaceTile(p, n);
        if (b) {
          const S = b.object, A = p._heights !== void 0;
          if (S) {
            A ? (l.minimumHeight = m[0], l.maximumHeight = m[1]) : (l.minimumHeight = 0, l.maximumHeight = 0);
            break;
          }
        }
        p = p.parent;
      }
      a = p;
    }
    if (a !== void 0) {
      const p = l._orientedBoundingBox === void 0;
      (l.minimumHeight !== h || l.maximumHeight !== d || p) && l.computeBoundingVolumes(o), e.boundingVolumeSourceTile = a, e.boundingVolumeIsFromMesh = C;
    } else
      l.minimumHeight = 0, l.maximumHeight = 0, l._orientedBoundingBox === void 0 && l.computeBoundingVolumes(o), e.boundingVolumeSourceTile = void 0, e.boundingVolumeIsFromMesh = !1;
  }
  screenSpaceError(e) {
    const i = this.quadMap;
    let n = e.z;
    const o = this.engine.map;
    let r = o.isGlobe, a = 1, g = 2e3, c = !0;
    if (r && (c = e.targetCenter.length() > o.map._ellipsoid.minimumRadius), c) {
      bs.copy(this.engine.camera.position), r ? (Ze.eastNorthUpToFixedFrame(
        e.targetCenter,
        null,
        Wr
      ), Wr.invert(), bs.applyMatrix4(Wr).normalize()) : bs.sub(e.targetCenter).normalize(), a = Math.exp(-this._sseFactor * (1 - ce.clamp(bs.z, 0, 1)));
      let m = ce.clamp(bs.z, 0, 1);
      e._distance < g && (a = 1, m = 1), e._horizonFactor = m;
    }
    const l = e.grid.getPixelSizeByLevel(n), h = e._distance, d = this.engine.rendering.resolution.y, C = i._sseDenominator;
    let p = l * d / (h * C) * this._lodScaleFactor * a;
    return p *= e.targetLODScaleRatio, p;
  }
  reverseScreenSpaceErrorZ(e) {
    const i = this.quadMap, n = this.engine.map;
    let o = n.isGlobe, r = 1, a = 2e3, g = !0, c = 2;
    o && (g = e.targetCenter.length() > n.map._ellipsoid.minimumRadius), g && (bs.copy(this.engine.camera.position), o ? (Ze.eastNorthUpToFixedFrame(
      e.targetCenter,
      null,
      Wr
    ), Wr.invert(), bs.applyMatrix4(Wr).normalize()) : bs.sub(e.targetCenter).normalize(), r = Math.exp(-this._sseFactor * (1 - ce.clamp(bs.z, 0, 1))), e._distance < a && (r = 1));
    const l = e._distance, h = this.engine.rendering.resolution.y, d = i._sseDenominator;
    let C = c * l * d / (h * this._lodScaleFactor * r);
    C /= e.targetLODScaleRatio;
    const p = Math.log2(e.grid.zeroLevelPixelSize * 2 / C);
    return isNaN(p) ? 0 : Math.max(p, 0);
  }
  projectBoundingBoxToNdc(e) {
    const i = this.engine.camera;
    d0.copy(i.matrixWorldInverse), h0.copy(i.projectionMatrix), u0.multiplyMatrices(h0, d0);
    const n = this.engine.map.isGlobe;
    let o;
    if (n) {
      const r = e.boundingRegion;
      if (!r || !r.boundingVolume)
        return [[0, 0], [0, 0], [0, 0], [0, 0]];
      const a = r.boundingVolume.computeCorners();
      o = [
        a[0],
        a[2],
        a[6],
        a[4]
      ];
    } else {
      const r = e.targetBoundingBox;
      o = [
        new B(r.min.x, r.min.y, 0),
        new B(r.min.x, r.max.y, 0),
        new B(r.max.x, r.max.y, 0),
        new B(r.max.x, r.min.y, 0)
      ];
    }
    return o.map((r) => (Xr.set(r.x, r.y, r.z, 1), Xr.applyMatrix4(u0), Xr.divideScalar(Xr.w), [Xr.x, Xr.y]));
  }
  _computeTileVisibility(e, i) {
    const { mode: n } = this.engine.map.map;
    if (n === Dt.SCENE3D) {
      const a = i.boundingRegion.boundingVolume;
      return !(!(this._computeTileVisibility3D(e, a) !== Ci.OUTSIDE) || this._enableHorizonCulling && this._currentOccluder && (i._occludeePointInScaledSpace || (i._occludeePointInScaledSpace = this._computeOccludeePoint(i, this._currentOccluder)), i._occludeePointInScaledSpace && !this._currentOccluder.isScaledSpacePointVisiblePossiblyUnderEllipsoid(i._occludeePointInScaledSpace, 0)));
    }
    const o = i.targetBoundingBox;
    return e.intersectsBox(o);
  }
  _computeTileVisibility3D(e, i) {
    if (!F(i))
      throw new re("boundingVolume is required.");
    const n = e.planes;
    let o = !1;
    for (let r = 0, a = n.length; r < a; ++r) {
      const g = n[r], c = g.normal.clone().normalize(), l = g.constant, h = new Me(...c.toArray(), l), d = i.intersectPlane(
        ti.fromCartesian4(h, xk)
      );
      if (d === Ci.OUTSIDE)
        return Ci.OUTSIDE;
      d === Ci.INTERSECTING && (o = !0);
    }
    return o ? Ci.INTERSECTING : Ci.INSIDE;
  }
  _naturalOrderChildTiles(e, i) {
    const n = e[0], o = e[1], r = e[2], a = e[3], g = i.x / Math.PI * 180, c = i.y / Math.PI * 180;
    return g < n.geoBoundingBox.max.x ? c < n.geoBoundingBox.max.y ? [
      n,
      r,
      o,
      a
    ] : [
      o,
      n,
      a,
      r
    ] : c < n.geoBoundingBox.max.y ? [
      r,
      n,
      a,
      o
    ] : [
      a,
      o,
      r,
      n
    ];
  }
  _createRootTiles() {
    const e = this._getCurrentGrid();
    this._rootTiles = e.getRootTiles();
  }
  showLoadLogInOneFrame() {
    this._strategy._logLoadInCurrentFrame = !0;
  }
  onSurfaceTileAdded(e) {
  }
  onSurfaceTileRemoved(e) {
  }
  onSurfaceTileSSEChanged(e) {
  }
  dispose() {
    this._quadtree = null, this._surfaceTileManager.dispose(), this._surfaceTileManager = null;
  }
  set quadMap(e) {
    this._quadMap = e;
  }
  get quadMap() {
    return this._quadMap;
  }
  get showTileBoundingBox() {
    return this._showTileBoundingBox;
  }
  set showTileBoundingBox(e) {
    this._showTileBoundingBox = e, this._quadMap._engine.requestRender();
  }
  get showTileDebugLabel() {
    return this._showTileDebugLabel;
  }
  set showTileDebugLabel(e) {
    if (this._showTileDebugLabel = e, e === !1) {
      const i = this._quadMap._engine.rendering.label;
      for (const n of Object.keys(this._debugLabelIds))
        i.removeLabel({
          id: n,
          type: "text_flat"
        });
      this._debugLabelIds = {};
    }
    this._quadMap._engine.requestRender();
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get enableHorizonCulling() {
    return this._enableHorizonCulling;
  }
  set enableHorizonCulling(e) {
    this._enableHorizonCulling = e;
  }
  get tileManager() {
    return this._surfaceTileManager;
  }
  get loadSiblings() {
    return this._strategy._loadSiblings;
  }
  set loadSiblings(e) {
    this._strategy._loadSiblings = e;
  }
  get sseFactor() {
    return this._sseFactor;
  }
  set sseFactor(e) {
    this._sseFactor = e;
  }
  get lodScaleFactor() {
    return this._lodScaleFactor;
  }
  set lodScaleFactor(e) {
    this._lodScaleFactor = e;
  }
  get showGroundWireframe() {
    return this._showGroundWireframe;
  }
  set showGroundWireframe(e) {
    this._showGroundWireframe = e, e ? (this._groundWireframeMaterial || (this._groundWireframeMaterial = new _t({
      wireframe: !0,
      color: 16746496
    })), this._groundObjectGroup.overrideMaterial = this._groundWireframeMaterial) : (this._groundObjectGroup.overrideMaterial = null, this._groundWireframeMaterial && (this._groundWireframeMaterial.dispose(), this._groundWireframeMaterial = null));
  }
  set strategy(e) {
    this._strategy = e, this._strategy._surface = this, this._strategy._surfaceTileManager = this._surfaceTileManager;
  }
  get strategy() {
    return this._strategy;
  }
  get placeholder() {
    return this._placeholder || (this._placeholder = new l0(this._options), this._placeholder.engine = this._quadMap._engine), this._placeholder;
  }
}
class N_ {
  constructor(t) {
    f(this, "_surface", null);
    this._surface = t, this._pendingCount = 0;
  }
  getSurfaceTile(t) {
  }
  requestSurfaceTile(t) {
  }
  dispose() {
    console.warn("SurfaceTileManager.dispose not implemented");
  }
  get pendingCount() {
    return this._pendingCount;
  }
}
const Lk = 1, Tu = 2, Ns = 3, I0 = 4, Gk = 5, Fc = new B();
class va {
  constructor(t, e, i, n) {
    f(this, "x");
    f(this, "y");
    f(this, "z");
    f(this, "compeleted", !1);
    f(this, "siblingIndex", 0);
    f(this, "_grid");
    f(this, "_geoBoundingBox");
    f(this, "_projectedCenter");
    f(this, "_projectedBoundingBox");
    f(this, "_targetCenter");
    f(this, "_targetBoundingBox");
    f(this, "_targetLODScaleRatio");
    f(this, "_targetSSESize");
    this._grid = t, this.z = e, this.x = i, this.y = n, this.key = e + "-" + i + "-" + n, this.state = Lk, this.childrenKeys = [], t.getTileLoaderConfig && (this.loaderConfig = t.getTileLoaderConfig(this));
  }
  updateBoundingBoxZ(t, e) {
    const i = this._projectedBoundingBox;
    i.min.z = t, i.max.z = e, i.getCenter(this._projectedCenter);
  }
  get boundingBox() {
    return console.warn("boundingBox is renamed to projectedBoundingBox"), this.projectedBoundingBox;
  }
  set boundingBox(t) {
    console.warn("boundingBox is renamed to projectedBoundingBox"), this.projectedBoundingBox = t;
  }
  get projectedBoundingBox() {
    return this._projectedBoundingBox;
  }
  set projectedBoundingBox(t) {
    if (!t) {
      console.warn("Invalid bounding", t);
      return;
    }
    this._projectedBoundingBox = t, this._projectedCenter || (this._projectedCenter = new B()), t.getCenter(this._projectedCenter);
  }
  get geoBoundingBox() {
    return this._geoBoundingBox;
  }
  set geoBoundingBox(t) {
    this._geoBoundingBox = t;
  }
  get reverseY() {
    return this._reverseY === void 0 && (this._reverseY = this._grid.getTileReverseY(this)), this._reverseY;
  }
  set grid(t) {
    this._grid = t;
  }
  get grid() {
    return this._grid;
  }
  get center() {
    return console.warn("center is renamed to projectedCenter"), this.projectedCenter;
  }
  set center(t) {
    console.warn("center is renamed to projectedCenter"), this.projectedCenter = t;
  }
  get projectedCenter() {
    return this._projectedCenter;
  }
  set projectedCenter(t) {
    this._projectedCenter = t;
  }
  set targetBoundingBox(t) {
    console.warn("targetBoundingBox is readonly");
  }
  get targetBoundingBox() {
    return this._targetBoundingBox || (this._targetBoundingBox = new Ue(), this._grid._engine, this._grid.targetProjection.name !== this._grid.sourceProjection.name ? this._targetBoundingBox = this._grid.targetProjection.geoBoxToProjectedBox(this.geoBoundingBox) : this._targetBoundingBox.copy(this.projectedBoundingBox)), this._targetBoundingBox;
  }
  get targetCenter() {
    return this._targetCenter || (this._targetCenter = new B(), this._grid.targetProjection.name !== this._grid.sourceProjection.name ? this.targetBoundingBox.getCenter(this._targetCenter) : this._projectedBoundingBox.getCenter(this._targetCenter)), this._targetCenter;
  }
  get geoIntersectionOfTargetProjection() {
    const t = this._grid.targetProjection.geoBoundingBox;
    if (!t)
      return Ci.INSIDE;
    const {
      x: e,
      y: i
    } = this.geoBoundingBox.min, {
      x: n,
      y: o
    } = this.geoBoundingBox.max, {
      x: r,
      y: a
    } = t.min, {
      x: g,
      y: c
    } = t.max;
    return n < r || e > g || o < a || i > c ? Ci.OUTSIDE : e >= r && n <= g && i >= a && o <= c ? Ci.INSIDE : Ci.INTERSECT;
  }
  _computeAvailableGeoBoundingBox() {
    const t = this._grid.targetProjection.geoBoundingBox;
    let {
      x: e,
      y: i,
      z: n
    } = this.geoBoundingBox.min, {
      x: o,
      y: r,
      z: a
    } = this.geoBoundingBox.max;
    const {
      x: g,
      y: c
    } = t.min, {
      x: l,
      y: h
    } = t.max;
    e < g && (e = g), o > l && (o = l), i < c && (i = c), r > h && (r = h), this._availableGeoBoundingBox = new Ue(new B(e, i, n), new B(o, r, a));
  }
  get availableGeoBoundingBox() {
    return this.geoIntersectionOfTargetProjection === Ci.OUTSIDE ? null : this.geoIntersectionOfTargetProjection === Ci.INTERSECT ? (this._availableGeoBoundingBox || this._computeAvailableGeoBoundingBox(), this._availableGeoBoundingBox) : this.geoBoundingBox;
  }
  _computeTargetLODScaleRatio() {
    let t;
    if (this._grid.targetProjection.getLODSacleOfGeoBoundingBox && (t = this._grid.targetProjection.getLODSacleOfGeoBoundingBox(this.geoBoundingBox), t !== void 0))
      return t;
    const e = this.projectedBoundingBox;
    let i = e.max.x - e.min.x, n = e.max.y - e.min.y;
    const o = this.targetBoundingBox;
    let r, a;
    o.isOrientedBoundingBox ? (Fc.fromArray(o.halfAxes.elements, 0), r = Fc.length() * 2, Fc.fromArray(o.halfAxes.elements, 3), a = Fc.length() * 2) : (r = o.max.x - o.min.x, a = o.max.y - o.min.y);
    let g = r / i, c = a / n;
    return t = Math.min(g, c), t;
  }
  get targetLODScaleRatio() {
    return this._targetLODScaleRatio === void 0 && (this._grid.sourceProjection.equals(this._grid.targetProjection) ? this._targetLODScaleRatio = 1 : this._targetLODScaleRatio = this._computeTargetLODScaleRatio()), this._targetLODScaleRatio;
  }
}
function Mk(s) {
  Promise.resolve().then(s);
}
class Ek {
  constructor(t) {
    this.maxSize = t || 800, this.minSize = Math.round(this.maxSize * 0.75), this.unloadPercent = 0.05, this.itemSet = /* @__PURE__ */ new Map(), this.itemList = [], this.usedSet = /* @__PURE__ */ new Set(), this.callbacks = /* @__PURE__ */ new Map(), this.unloadPriorityCallback = null;
    const e = this.itemSet;
    this.defaultPriorityCallback = (i) => e.get(i);
  }
  setMaxSize(t) {
    this.maxSize = t, this.minSize = Math.round(this.maxSize * 0.75);
  }
  isFull() {
    return this.itemSet.size >= this.maxSize;
  }
  add(t, e) {
    const i = this.itemSet;
    if (i.has(t) || this.isFull())
      return !1;
    const n = this.usedSet, o = this.itemList, r = this.callbacks;
    return o.push(t), n.add(t), i.set(t, Date.now()), r.set(t, e), !0;
  }
  remove(t) {
    const e = this.usedSet, i = this.itemSet, n = this.itemList, o = this.callbacks;
    if (i.has(t)) {
      o.get(t)(t);
      const r = n.indexOf(t);
      return n.splice(r, 1), e.delete(t), i.delete(t), o.delete(t), !0;
    }
    return !1;
  }
  clear() {
    const t = this.usedSet, e = this.itemSet, i = this.itemList, n = this.callbacks;
    for (let o = 0; o < i.length; o++) {
      const r = i[o];
      n.get(r)(r);
    }
    this.itemList = [], t.clear(), e.clear(), n.clear();
  }
  markUsed(t) {
    const e = this.itemSet, i = this.usedSet;
    e.has(t) && !i.has(t) && (e.set(t, Date.now()), i.add(t));
  }
  markAllUnused() {
    this.usedSet.clear();
  }
  unloadUnusedContent() {
    const t = this.unloadPercent, e = this.minSize, i = this.itemList, n = this.itemSet, o = this.usedSet, r = this.callbacks, a = i.length - o.size, g = i.length - e, c = this.unloadPriorityCallback || this.defaultPriorityCallback;
    if (g > 0 && a > 0) {
      i.sort((p, m) => {
        const b = o.has(p), S = o.has(m);
        return b && S ? 0 : !b && !S ? c(m) - c(p) : b ? 1 : -1;
      });
      const l = Math.min(g, a), h = Math.max(e * t, l * t);
      let d = Math.min(h, a);
      d = Math.ceil(d);
      const C = i.splice(0, d);
      for (let p = 0, m = C.length; p < m; p++) {
        const b = C[p];
        r.get(b)(b), n.delete(b), r.delete(b);
      }
    }
  }
  scheduleUnload(t = !0) {
    this.scheduled || (this.scheduled = !0, Mk(() => {
      this.scheduled = !1, this.unloadUnusedContent(), t && this.markAllUnused();
    }));
  }
}
const Rk = 1e-6;
class id {
  constructor(t, e, i) {
    f(this, "_minLevel", 0);
    f(this, "_maxLevel", 18);
    f(this, "_useGeoSubdivision", !1);
    f(this, "_projectBoxWithFourConrner", !1);
    f(this, "_unprojectBoxWithFourConrner", !1);
    f(this, "_shouldCheckTileBoundingRange", !1);
    f(this, "_pixelSizes", []);
    this._engine = t, this._sourceProjection = e, this._targetProjection = i;
  }
  getRootTiles() {
    return console.warn("getRootTiles is not implemented"), [];
  }
  getRootBoundingBox() {
    return console.warn("getRootBoundingBox is not implemented"), null;
  }
  getPixelSizeByLevel(t) {
    return this._pixelSizes[t];
  }
  getNextLevel(t) {
    return t + 1;
  }
  shouldCreateChildren(t) {
    return !0;
  }
  getNextLevelTileCount(t, e) {
    return Math.pow(2, e - t);
  }
  getQuadTreeLevelGap(t, e) {
    return e - t;
  }
  createTileChildren(t) {
    const e = [];
    t.childrenKeys = [];
    const i = this.getNextLevel(t.z);
    if (!this.shouldCreateChildren(t))
      return [];
    let n = null, o = null;
    if (this._useGeoSubdivision) {
      const C = t.geoBoundingBox;
      n = C.min, o = C.max;
    } else {
      const C = t.projectedBoundingBox;
      n = C.min, o = C.max;
    }
    const r = this.getQuadTreeLevelGap(t.z, i), a = Math.pow(2, r), g = (o.x - n.x) / a, c = (o.y - n.y) / a;
    let l = t.x * a, h = t.y * a, d = null;
    for (let C = 0; C < a; C++)
      for (let p = 0; p < a; p++) {
        const m = new va(this, i, l + C, h + p);
        if (d = new Ue(
          new B(
            n.x + C * g,
            n.y + p * c,
            n.z
          ),
          new B(
            n.x + (C + 1) * g,
            n.y + (p + 1) * c,
            o.z
          )
        ), this._useGeoSubdivision ? (m.geoBoundingBox = d, m.projectedBoundingBox = this._sourceProjection.geoBoxToProjectedBox(d)) : (m.projectedBoundingBox = d, m.geoBoundingBox = this._sourceProjection.projectedBoxToGeoBox(d)), !(this._shouldCheckTileBoundingRange && !this.isTileInBoundingRange(m))) {
          if (this._targetProjection.geoBoundingBox) {
            const b = this._targetProjection.geoBoundingBox;
            if (m.geoBoundingBox.max.x < b.min.x || m.geoBoundingBox.min.x > b.max.x || m.geoBoundingBox.max.y < b.min.y || m.geoBoundingBox.min.y > b.max.y)
              continue;
          }
          m.siblingIndex = C * a + p, m.parentKey = t.key, m.parent = t, e.push(m), t.childrenKeys.push(m.key);
        }
      }
    return e;
  }
  isTileInBoundingRange(t) {
    const e = t.geoBoundingBox, i = e.min, n = e.max;
    return !(i.x > 180 || n.x < -180 || i.y > 90 || n.y < -90);
  }
  getTileSizeAtLevel(t) {
    console.warn("getTileSizeXAtLevel is not implemented");
  }
  getTileCoordX(t, e, i = !1) {
    console.warn("getTileCoordX is not implemented");
  }
  getTileCoordY(t, e, i = !1) {
    console.warn("getTileCoordY is not implemented");
  }
  _alignTileCoord(t) {
    let e = Math.round(t);
    return Math.abs(t - e) < Rk ? e : t;
  }
  computeCoverageTilesCoord(t, e = 0, i = 100) {
    const n = [], o = t.grid;
    let r = null;
    if (o.useGeoSubdivision)
      this._useGeoSubdivision ? r = t.geoBoundingBox : r = this._sourceProjection.geoBoxToProjectedBox(t.geoBoundingBox);
    else if (this._useGeoSubdivision)
      r = t.projectedBoundingBox;
    else {
      let A = o.targetProjection.projectedBoxToGeoBox(t.projectedBoundingBox);
      r = this._sourceProjection.geoBoxToProjectedBox(A);
    }
    let a = this.zeroLevelPixelSize, g = o.zeroLevelPixelSize;
    const c = a / g;
    let l = Math.round(t.z + c - 1);
    const h = Math.max(this._minLevel, e), d = Math.min(this._maxLevel, i);
    l < h && (l = h), l > d && (l = d);
    let C = 0, p = 0, m = 0, b = 0, S = 0;
    for (; l >= h; ) {
      const A = this.getTileSizeAtLevel(l);
      if (p = this._alignTileCoord(this.getTileCoordX(r.min.x, A, !0)), m = this._alignTileCoord(this.getTileCoordY(r.min.y, A, !0)), b = this._alignTileCoord(this.getTileCoordX(r.max.x, A, !0)), S = this._alignTileCoord(this.getTileCoordY(r.max.y, A, !0)), p = Math.floor(p), m = Math.floor(m), b = Math.ceil(b), S = Math.ceil(S), C = (b - p) * (S - m), C < 8)
        break;
      if (l === h)
        return console.warn(`tile count ${C} is too large for one mapped target tile ${t.key}`), [];
      l--;
    }
    for (let A = p; A < b; A++)
      for (let u = m; u < S; u++)
        n.push([
          l,
          A,
          u
        ]);
    return n;
  }
  computeTileCoverageRect(t, e) {
    if (t.z === e.z && t.x === e.x && t.y === e.y)
      return [-1, -1, -1, -1];
    let i = null, n = null;
    t.grid.useGeoSubdivision ? (i = t.geoBoundingBox, n = e.geoBoundingBox) : (i = t.projectedBoundingBox, n = e.projectedBoundingBox);
    const o = i.min, r = i.max, a = n.min, g = n.max, c = (a.x - o.x) / (r.x - o.x), l = (a.y - o.y) / (r.y - o.y), h = (g.x - o.x) / (r.x - o.x), d = (g.y - o.y) / (r.y - o.y);
    return [c, l, h, d];
  }
  updateTileHeights(t, e) {
    t._heights = e, !(t.z < 2) && (this.useGeoSubdivision ? (t.geoBoundingBox.min.z = e[0], t.geoBoundingBox.max.z = e[1], t.projectedBoundingBox = this._sourceProjection.geoBoxToProjectedBox(
      t.geoBoundingBox
    )) : (t.projectedBoundingBox.min.z = e[0], t.projectedBoundingBox.max.z = e[1], t.center.z = (e[0] + e[1]) / 2, t.geoBoundingBox = this.projectionBoxToGlobeBox(
      t.projectedBoundingBox,
      this._unprojectBoxWithFourConrner
    )));
  }
  getTileReverseY(t) {
    return Math.pow(2, t.z) - t.y - 1;
  }
  _updateLODConfig() {
    const t = [];
    let e = this.zeroLevelPixelSize;
    for (let i = 0; i <= this._maxLevel; i++)
      t.push(e), e /= 2;
    this._pixelSizes = t;
  }
  update() {
    this._updateLODConfig();
  }
  set engine(t) {
    this._engine = t;
  }
  get engine() {
    return this._engine;
  }
  set maxLevel(t) {
    this._maxLevel = t;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  set minLevel(t) {
    this._minLevel = t;
  }
  get minLevel() {
    return this._minLevel;
  }
  get useGeoSubdivision() {
    return this._useGeoSubdivision;
  }
  get sourceProjection() {
    return this._sourceProjection;
  }
  get targetProjection() {
    return this._targetProjection;
  }
  get zeroLevelPixelSize() {
    return this._zeroLevelPixelSize || (this._zeroLevelPixelSize = 200375083427892e-7 * 2 / 256), this._zeroLevelPixelSize;
  }
}
const Yn = 200375083427892e-7;
class nd extends id {
  constructor() {
    super(...arguments);
    f(this, "name", D_);
    f(this, "_maxLevel", 21);
    f(this, "_rootBoundingBox", new Ue(
      new B(-Yn, -Yn, -100),
      new B(Yn, Yn, 100)
    ));
  }
  getRootTiles() {
    const e = new va(this, 0, 0, 0);
    return e.projectedBoundingBox = this._rootBoundingBox, e.geoBoundingBox = new Ue(new B(-180, -90, -100), new B(180, 90, 100)), [e];
  }
  getRootBoundingBox() {
    return this._rootBoundingBox;
  }
  getTileSizeAtLevel(e) {
    return Yn / Math.pow(2, e - 1);
  }
  getTileCoordX(e, i, n) {
    return n && (e < -Yn ? e = -Yn : e > Yn && (e = Yn)), (e + Yn) / i;
  }
  getTileCoordY(e, i, n) {
    return this.getTileCoordX(e, i, n);
  }
  get textureMaxLevel() {
    return this._textureMaxLevel;
  }
  set textureMaxLevel(e) {
    this._textureMaxLevel = e;
  }
}
const A0 = 0, Dk = 1, hr = 2, CA = 3;
class ZC {
  constructor(t = {}) {
    f(this, "name", "TileProvider");
    f(this, "_sourceProjection");
    f(this, "_targetProjection");
    f(this, "_quadtree");
    f(this, "_cache");
    f(this, "_grid");
    f(this, "_supportedTargetProjectionNames", []);
    f(this, "_supportAllProjections", !1);
    f(this, "_compatible", !1);
    f(this, "_initState", A0);
    f(this, "_desiredUpperSampleLevel", 100);
    f(this, "_loadingUpperSampleLevel", 1);
    f(this, "_maxCacheSize", 1e3);
    f(this, "_maxLevel");
    f(this, "_minLevel");
    f(this, "_startLevel");
    f(this, "_shouldCheckTileAvailable", !1);
    f(this, "ignoreLoadingState", !1);
    f(this, "_requestingCount", 0);
    f(this, "_maxParallelRequestNum", 6);
    f(this, "enablePeriodRequestLog", !1);
    f(this, "_periodRequestLogCount", 0);
    f(this, "_periodRequestLogStartTime", 0);
    f(this, "_canUpsample", !1);
    f(this, "_useWebMeractorProjectionAndGrid", !1);
    f(this, "handleRemove", (t, e) => {
      this.onTileDispose(t), t.state = Gk, this._markTileStateListenersNeedsUpdate(t), t._stateListenerObjects = [];
    });
    f(this, "_logRequestStart", () => {
      this.enablePeriodRequestLog && (this._requestingCount === 0 && (this._periodRequestLogCount = 0, this._periodRequestLogStartTime = performance.now()), this._periodRequestLogCount++);
    });
    f(this, "_logRequestEnd", () => {
      this.enablePeriodRequestLog && this._requestingCount === 0 && performance.now() - this._periodRequestLogStartTime;
    });
    f(this, "_markTileStateListenersNeedsUpdate", (t) => {
      for (const e of t._stateListenerObjects)
        e.needsUpdate = !0;
    });
    f(this, "_initOrUpdateTileStateListeners", (t, e) => {
      t._stateListenerObjects || (t._stateListenerObjects = []), t._stateListenerObjects.indexOf(e) < 0 && t._stateListenerObjects.push(e);
    });
    t.targetProjection && (this._targetProjection = t.targetProjection), t.minLevel !== void 0 && (this._minLevel = t.minLevel), t.maxLevel !== void 0 && (this._maxLevel = t.maxLevel), t.startLevel !== void 0 && (this._startLevel = t.startLevel), this._maxCacheSize = t.maxCacheSize || 800, this._needFeedback = W(t.needFeedback, !0), this.statistics = {
      loading: 0,
      cached: 0
    };
  }
  _init() {
    if (this._initState === A0) {
      if (this._minLevel === void 0 && (this._minLevel = this._defaultMinLevel || 0), this._startLevel === void 0 && (this._startLevel = this._defaultStartLevel || 0), this._maxLevel === void 0 && (this._maxLevel = this._defaultMaxLevel || 1 / 0), this._initState = Dk, this._supportAllProjections || this._supportedTargetProjectionNames.indexOf(this._targetProjection.name) >= 0)
        this._compatible = !0;
      else {
        this._compatible = !1, console.warn(`${this.name}: not supported target projection ${this._targetProjection.name}, supported target projections: ${this._supportedTargetProjectionNames.join(",")}`), this._inited = !0, this._initState = CA;
        return;
      }
      this._cache = new Ek(this._maxCacheSize), this._asyncInit ? this._asyncInit().then(() => {
        this._inited = !0, this._initState = hr, this._useWebMeractorProjectionAndGrid ? this._initWebMercatorProjectionAndGrid() : this.initProjectionAndGrid(), this._grid.update(), this._quadtree = new AA(this._grid), this._engine.requestRender();
      }).catch((t) => {
        console.error(t), this._inited = !0, this._initState = CA;
      }) : (this._inited = !0, this._initState = hr, this._useWebMeractorProjectionAndGrid ? this._initWebMercatorProjectionAndGrid() : this.initProjectionAndGrid(), this._grid.update(), this._quadtree = new AA(this._grid));
    }
  }
  _initWebMercatorProjectionAndGrid() {
    this._sourceProjection = bn(Mt), this._grid = new nd(this._engine, this._sourceProjection, this._targetProjection);
  }
  initProjectionAndGrid() {
    throw new Error(this.name + ": initProjectionAndGrid should be overriden in subclass or set _useWebMeractorProjectionAndGrid to true");
  }
  _freeResources() {
    this._cache = null, this._grid = null, this._quadtree = null;
  }
  beginFrame(t) {
    this._usedTilesNum = 0, this._usedTiles = {}, this._init(), this._needsClearCache && (this.clearCache(), this._needsClearCache = !1);
  }
  endFrame(t) {
    this._cache && (this._cache.scheduleUnload(), this.statistics.cached = this._cache.itemList.length);
  }
  isReady() {
    return this._initState === hr;
  }
  onTileDispose(t) {
    console.warn("onTileDispose should be overriden in subclass");
  }
  async requestTileData(t, e) {
    if (!(t.z < this._minLevel) && this._initState === hr) {
      if (!t) {
        window.__debug && console.warn("tile not found"), console.warn("tile not found");
        return;
      }
      if (e && this._initOrUpdateTileStateListeners(t, e), t.state !== Tu) {
        if (t.state === Ns) {
          this._markTileStateListenersNeedsUpdate(t);
          return;
        }
        if (t.geoIntersectionOfTargetProjection === Ci.OUTSIDE) {
          t.state = Ns, this._markTileStateListenersNeedsUpdate(t);
          return;
        } else if (t.geoIntersectionOfTargetProjection === Ci.INTERSECT) {
          t.state = Tu;
          return;
        }
        if (t.state === I0)
          if (Date.now() - t._lastFailTime < 9e5) {
            if (t._failTimes > 2)
              return;
          } else
            t._failTimes = 0;
        if (!(this._requestingCount >= this._maxParallelRequestNum)) {
          this._logRequestStart(), this._requestingCount++;
          try {
            t.state = Tu, this.statistics.loading++, this._markTileStateListenersNeedsUpdate(t), window.__debug;
            const i = await this.doRequestTileData(t);
            t.data = i, t.state = Ns, this._cache.add(t, this.handleRemove);
          } catch (i) {
            t.state = I0, t._failTimes || (t._failTimes = 0), t._failTimes++, t._lastFailTime = Date.now(), console.warn(`tile ${t.key} load error in ${this.name}`, i);
          } finally {
            this._markTileStateListenersNeedsUpdate(t), this.statistics.loading--, this._requestingCount--, this._logRequestEnd();
          }
        }
      }
    }
  }
  getGroundTileData(t) {
    return null;
  }
  getTile(t, e, i, n, o) {
    if (!this._compatible)
      return null;
    let r = t, a = e, g = i, c = r - this._maxLevel;
    if (c > 0 && (r = this._maxLevel, a = e >> c, g = i >> c), this._shouldCheckTileAvailable) {
      for (; !this.isTileAvailable(r, a, g); )
        if (c++, r--, a = a >> 1, g = g >> 1, r < 0)
          return null;
    }
    this._canUpsample || (e = a, i = g, t = r);
    const l = this._quadtree.getTile(t, e, i);
    return this._canUpsample && t !== r | e !== a && i !== g && (l.needUpSample = !0), l ? (this._initOrUpdateTileStateListeners(l, o), l) : null;
  }
  markTileUsed(t) {
    this._usedTilesNum++, this._usedTiles[t.key] = !0, this._cache.markUsed(t);
  }
  _tileLevelInRange(t) {
    return t >= this._startLevel && t <= this._maxLevel;
  }
  computeCoverageTilesCoord(t) {
    const e = this._grid, i = t.grid, n = this._sourceProjection, o = i.targetProjection;
    return e.name === i.name && n.name === o.name && this._tileLevelInRange(t.z) ? [[t.z, t.x, t.y]] : this.grid.computeCoverageTilesCoord(t, this._startLevel, this.grid.maxLevel);
  }
  clearCache() {
    this._cache && this._cache.clear();
  }
  get maxCacheSize() {
    return this._maxCacheSize;
  }
  set maxCacheSize(t) {
    this._maxCacheSize = t;
  }
  get desiredUpperSampleLevel() {
    return this._desiredUpperSampleLevel;
  }
  set desiredUpperSampleLevel(t) {
    this._desiredUpperSampleLevel = t;
  }
  get loadingUpperSampleLevel() {
    return this._loadingUpperSampleLevel;
  }
  set loadingUpperSampleLevel(t) {
    this._loadingUpperSampleLevel = t;
  }
  get grid() {
    return this._grid;
  }
  get compatible() {
    return this._compatible;
  }
  get projection() {
    return this._sourceProjection;
  }
  get sourceProjection() {
    return this._sourceProjection;
  }
  get targetProjection() {
    return this._targetProjection;
  }
  set targetProjection(t) {
    this._targetProjection = t;
  }
  get initState() {
    return this._initState;
  }
  get maxLevel() {
    return this._maxLevel;
  }
  set maxLevel(t) {
    this._maxLevel = t;
  }
  get minLevel() {
    return this._minLevel;
  }
  set minLevel(t) {
    this._minLevel = t;
  }
  get maxParallelRequestNum() {
    return this._maxParallelRequestNum;
  }
  set maxParallelRequestNum(t) {
    this._maxParallelRequestNum = t;
  }
  get cacheMaxSize() {
    return this._cache && this._cache.maxSize || 0;
  }
  set cacheMaxSize(t) {
    this._cache && this._cache.setMaxSize(t);
  }
}
const Kk = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;

#include <logdepthbuf_pars_vertex>

void main() {

    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #include <logdepthbuf_vertex>

}

`, Hk = `#define GLSLIFY 1
#include <common>

varying vec2 vUv;

uniform float opacity;

#include <logdepthbuf_pars_fragment>

#if NUM_TEXTURES > 0
    uniform sampler2D diffuseTextures[NUM_TEXTURES];
    uniform vec4 textureTranslationAndScales[NUM_TEXTURES];
    uniform vec4 colorAdjustments[NUM_TEXTURES];
    uniform vec4 boundingRect;
#endif

vec4 sampleAndBlendColor(vec4 oldColor, sampler2D sampleTexture, vec4 translationAndScale, vec4 colorAdjustment) {
    vec2 transformedUv = clamp(vUv, vec2(0.0), vec2(1.0));
    transformedUv *= translationAndScale.zw;
    transformedUv -= translationAndScale.xy;
    if (transformedUv.x < 0.0 || transformedUv.y < 0.0 || transformedUv.x > 1.0 || transformedUv.y > 1.0) {
        return oldColor;
    }
    vec4 sampleColor = texture2D(sampleTexture, transformedUv);
    sampleColor *= colorAdjustment;
    // sampleColor.a *= colorAdjustment.a;
    vec3 mixColor = mix(oldColor.rgb, sampleColor.rgb, sampleColor.a);
    return vec4(mixColor, oldColor.a + sampleColor.a);
}
void main() {

    // gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);
    // return;
    #if NUM_TEXTURES > 0
        if (boundingRect.x > -0.5 && (vUv.x < boundingRect.x || vUv.y < boundingRect.y || vUv.x > boundingRect.z || vUv.y > boundingRect.w)) {
            discard;
        }

    #endif
   
    vec4 color = vec4(0);

    #if NUM_TEXTURES > 0
        color = sampleAndBlendColor(color, diffuseTextures[0], textureTranslationAndScales[0], colorAdjustments[0]);
    #endif
    #if NUM_TEXTURES > 1
        color = sampleAndBlendColor(color, diffuseTextures[1], textureTranslationAndScales[1], colorAdjustments[1]);
    #endif
    #if NUM_TEXTURES > 2
        color = sampleAndBlendColor(color, diffuseTextures[2], textureTranslationAndScales[2], colorAdjustments[2]);
    #endif
    #if NUM_TEXTURES > 3
        color = sampleAndBlendColor(color, diffuseTextures[3], textureTranslationAndScales[3], colorAdjustments[3]);
    #endif
    #if NUM_TEXTURES > 4
        color = sampleAndBlendColor(color, diffuseTextures[4], textureTranslationAndScales[4], colorAdjustments[4]);
    #endif
    #if NUM_TEXTURES > 5
        color = sampleAndBlendColor(color, diffuseTextures[5], textureTranslationAndScales[5], colorAdjustments[5]);
    #endif
    #if NUM_TEXTURES > 6
        color = sampleAndBlendColor(color, diffuseTextures[6], textureTranslationAndScales[6], colorAdjustments[6]);
    #endif
    #if NUM_TEXTURES > 7
        color = sampleAndBlendColor(color, diffuseTextures[7], textureTranslationAndScales[7], colorAdjustments[7]);
    #endif

    gl_FragColor = color;
    // gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);

    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}

`, Pk = we.merge([
  {
    opacity: { value: 1 },
    diffuseTextures: { value: null },
    textureTranslationAndScales: { value: null },
    colorAdjustments: { value: null },
    boundingRect: { value: new Me() }
  }
]);
class Nk extends ze {
  constructor(e = {}) {
    super();
    f(this, "updateTextures", (e, i) => {
      let n = [], o = [], r = [];
      for (const a of e) {
        n.push(a.texture), o.push(new Me(
          a.offsetX,
          a.offsetY,
          a.scaleX,
          a.scaleY
        ));
        const g = a.colorTint;
        r.push(new Me(g[0], g[1], g[2], a.opacity));
      }
      this.uniforms.boundingRect.value.fromArray(i), this.uniforms.diffuseTextures.value = n, this.uniforms.textureTranslationAndScales.value = o, this.uniforms.colorAdjustments.value = r, this.defines.NUM_TEXTURES !== e.length && (this.defines.NUM_TEXTURES = e.length, this.needsUpdate = !0);
    });
    f(this, "forceUpdateTextureCount", (e) => {
      this.defines.NUM_TEXTURES = e, this.needsUpdate = !0;
    });
    this.name = "RasterSurfaceMaterial", this.fragmentShader = Hk, this.vertexShader = Kk, this.defines = {
      NUM_TEXTURES: 0
    }, this.uniforms = we.clone(Pk), e.textures && this.updateTextures(e.textures, e.boundRect);
  }
  get textureCount() {
    return this.defines.NUM_TEXTURES;
  }
  dispose() {
    super.dispose();
  }
}
const Lu = {}, C0 = (s) => {
  if (!Lu[s]) {
    const t = new Nk();
    t.name = "RasterSurfaceMaterial_" + s, t.forceUpdateTextureCount(s), t.onBeforeRender = function(e, i, n, o, r, a) {
      r.userData._boundingRect && (t.uniforms.boundingRect.value = r.userData._boundingRect, t.uniforms.diffuseTextures.value = r.userData._diffuseTextures, t.uniforms.textureTranslationAndScales.value = r.userData._textureTranslationAndScales, t.uniforms.colorAdjustments.value = r.userData._colorAdjustments, t.uniformsNeedUpdate = !0);
    }, Lu[s] = t;
  }
  return Lu[s];
}, f0 = (s, t, e) => {
  let i = [], n = [], o = [];
  for (const r of t) {
    i.push(r.texture), n.push(new Me(
      r.offsetX,
      r.offsetY,
      r.scaleX,
      r.scaleY
    ));
    const a = r.colorTint;
    o.push(new Me(a[0], a[1], a[2], r.opacity));
  }
  s.userData._boundingRect = new Me().fromArray(e), s.userData._diffuseTextures = i, s.userData._textureTranslationAndScales = n, s.userData._colorAdjustments = o;
};
class Fk extends Ma {
  constructor(t, e = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new Qe();
    o.setIndex(new Fe(i, 1)), o.setAttribute("position", new ae(n, 3)), super(o, new _r({ color: e, toneMapped: !1 })), this.obb = t, this.type = "OrientedBoundingBoxHelper", this.needsUpdateOBB = !0;
  }
  setOBB(t, e) {
    this.obb.center.copy(t), this.obb.halfAxes.copy(e), this.needsUpdateOBB = !0;
  }
  updateMatrixWorld(t) {
    if (this.needsUpdateOBB || t) {
      this.needsUpdateOBB = !1;
      const e = this.obb.center, i = this.obb.halfAxes;
      this.position.copy(e);
      const n = new B(), o = new J();
      for (let r = 0; r < 3; r++) {
        let a = r * 3;
        const g = new B(
          i.elements[a],
          i.elements[a + 1],
          i.elements[a + 2]
        );
        n.setComponent(r, g.length()), g.normalize(), a = r * 4, o.elements[a] = g.x, o.elements[a + 1] = g.y, o.elements[a + 2] = g.z;
      }
      this.scale.copy(n), this.quaternion.setFromRotationMatrix(o);
    }
    super.updateMatrixWorld(t);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class F_ {
  constructor(t) {
    this.tile = t;
  }
  get boxHelper() {
    return this._boxHelper || (this.tile.boundingRegion ? this._boxHelper = new Fk(
      this.tile.boundingRegion._orientedBoundingBox,
      16711680
    ) : this.tile.targetBoundingBox ? this._boxHelper = new $l(this.tile.targetBoundingBox, 16711680) : console.warn("No bounding box")), this._boxHelper;
  }
}
const Jo = 0, p0 = 1, Ya = 2;
class kk extends N_ {
  constructor() {
    super(...arguments);
    f(this, "_tiles", /* @__PURE__ */ new WeakMap());
  }
  forceUpdateTileState(e) {
    const i = this._tiles.get(e);
    !i || (i.needsUpdate = !0, this._updateSurfaceTileData(i));
  }
  isTileNeedsLoading(e) {
    if (!this._tiles.get(e))
      return !0;
  }
  isTileComputable(e) {
    const i = this._tiles.get(e);
    return i ? (i.needsUpdate && this._updateSurfaceTileData(i), i.terrainTile && i.terrainTile.state === Ns) : !1;
  }
  isTileRenderable(e) {
    const i = this._tiles.get(e);
    return i ? (i.needsUpdate && this._updateSurfaceTileData(i), i.state !== Jo) : !1;
  }
  isTileStable(e) {
    const i = this._tiles.get(e);
    return i ? (i.needsUpdate && this._updateSurfaceTileData(i), i.state === Ya) : !1;
  }
  markTileUsed(e) {
    const i = this._tiles.get(e);
    if (!i)
      return null;
    const n = this._surface.terrainProvider, o = i.terrainTile;
    o && n.markTileUsed(o);
    const r = i.imageryTiles, a = this._surface.imageryProviders;
    for (let g = 0; g < r.length; ++g) {
      const c = r[g];
      if (!c)
        continue;
      const l = a[g];
      for (let h = 0; h < c.length; ++h) {
        const d = c[h];
        !d || l.markTileUsed(d);
      }
    }
  }
  getSurfaceTile(e, i) {
    const n = this._tiles.get(e);
    if (!n)
      return null;
    if (n.needsUpdate && this._updateSurfaceTileData(n), n.state !== Jo)
      return n;
  }
  _updateSurfaceTileData(e) {
    e.needsUpdate = !1;
    const i = e.state, n = e.terrainTile;
    if (n.state !== Ns) {
      e.state = Jo, this._surface.quadMap._engine.requestRender();
      return;
    }
    const o = e.imageryTiles, r = this._surface.imageryProviders;
    let a = 0, g = 0, c = 0;
    const l = [], h = [];
    for (let p = 0; p < o.length; ++p) {
      const m = o[p], b = r[p];
      if (b.ignoreLoadingState && c++, !m || !b.compatible) {
        l.push(""), a++;
        continue;
      }
      let S = !1, A = !1;
      for (let u = 0; u < m.length; ++u) {
        const y = m[u];
        if (!!y)
          if (y.state === Ns) {
            b.markTileUsed(y);
            const I = this._getTileCoordConfig(n, y);
            h.push({
              texture: y.data,
              opacity: b.opacity,
              colorTint: b.randomColorTint ? [Math.random(), Math.random(), Math.random()] : b.colorTint,
              ...I
            }), l.push(y.key);
          } else {
            let I = this._getUpperSampleReadyTile(y, b);
            if (I) {
              b.markTileUsed(I);
              const M = this._getTileCoordConfig(n, I);
              h.push({
                texture: I.data,
                opacity: b.opacity,
                colorTint: b.randomColorTint ? [Math.random(), Math.random(), Math.random()] : b.colorTint,
                ...M
              }), l.push(I.key), S = !0;
            } else
              l.push(""), A = !0;
          }
      }
      A ? g++ : S || a++;
    }
    const d = l.join("|");
    let C = p0;
    if (a > 0 && a === r.length ? (C = Ya, this._pendingCount--) : g + c === r.length && (C = Jo), C !== Ya && this._surface.quadMap._engine.requestRender(), C === Jo) {
      e.state = C;
      return;
    }
    if (i === Jo) {
      const p = n.data, m = C0(h.length), b = new le(p, m);
      f0(b, h, e.terrainBoundRect), b.position.copy(n.targetCenter), p._heights && !e.tile._heights && e.tile.grid.updateTileHeights(e.tile, p._heights), b.frustumCulled = !1, b.isTerrainTile = !0, e.object = b;
    } else if (d !== e.loadStateKey) {
      const p = e.object, m = C0(h.length);
      p.material = m, f0(p, h, e.terrainBoundRect);
    }
    e.state = C, e.loadStateKey = d;
  }
  _getTileCoordConfig(e, i) {
    const n = e.grid, o = i.grid, r = n.rasterProjection, a = o.sourceProjection;
    if (r.name === a.name && n.name === o.name && e.z === i.z && e.x === i.x && e.y === i.y)
      return {
        offsetX: 0,
        offsetY: 0,
        scaleX: 1,
        scaleY: 1
      };
    let g = null, c = null;
    r.isGeo ? (g = i.geoBoundingBox, c = e.geoBoundingBox) : (g = i.targetBoundingBox, c = e.targetBoundingBox);
    const l = (c.max.x - c.min.x) / (g.max.x - g.min.x), h = (c.max.y - c.min.y) / (g.max.y - g.min.y), d = (g.min.x - c.min.x) / (g.max.x - g.min.x), C = (g.min.y - c.min.y) / (g.max.y - g.min.y);
    return {
      offsetX: d,
      offsetY: C,
      scaleX: l,
      scaleY: h
    };
  }
  _getUpperSampleReadyTile(e, i) {
    let n = i.loadingUpperSampleLevel;
    if (n === 0)
      return null;
    for (e = e.parent; n > 0 && e; ) {
      if (e.state === Ns)
        return e;
      e = e.parent, n--;
    }
    return null;
  }
  _getCoverageTilesFromProvider(e, i) {
    return i.computeCoverageTilesCoord(e);
  }
  _onlyRequestTileContents(e, i = !1) {
    const n = e.terrainTile, o = e.imageryTiles, r = this._surface.terrainProvider, a = this._surface.imageryProviders;
    if (n && r.requestTileData(n, e), !i)
      for (let g = 0; g < o.length; ++g) {
        const c = o[g];
        if (!c)
          continue;
        const l = a[g];
        for (let h = 0; h < c.length; ++h) {
          const d = c[h];
          d && l.requestTileData(d, e);
        }
      }
  }
  requestSurfaceTile(e, i = !1) {
    if (this._tiles.has(e)) {
      const l = this._tiles.get(e);
      if (l.needsUpdate && this._updateSurfaceTileData(l), i) {
        l.state !== p0 && l.state !== Ya && this._onlyRequestTileContents(l, !0);
        return;
      }
      l.state !== Ya && this._onlyRequestTileContents(l);
      return;
    }
    const n = this._surface, o = n.terrainProvider;
    if (o.initState !== hr)
      return;
    const r = n.imageryProviders;
    for (const l of r)
      if (l.initState !== hr && l.initState !== CA)
        return;
    const a = new F_(e);
    a.state = Jo;
    const g = o.getTile(e.z, e.x, e.y, e, a);
    a.terrainBoundRect = o.grid.computeTileCoverageRect(g, e), o.requestTileData(g, a), a.terrainTile = g;
    const c = [];
    for (const l of r) {
      if (!l.compatible) {
        c.push(null);
        continue;
      }
      const h = this._getCoverageTilesFromProvider(e, l), d = [];
      for (const C of h) {
        const p = l.getTile(C[0], C[1], C[2], e, a);
        !p || (d.push(p), i || l.requestTileData(p, a));
      }
      c.push(d);
    }
    a.imageryTiles = c, i && (a.needsUpdate = !0), this._tiles.set(e, a), this._pendingCount++;
  }
  clear() {
    this._tiles = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
  }
}
class Vk extends P_ {
  constructor(e, i, n = {}) {
    super(n);
    f(this, "name", "RasterSurface");
    f(this, "isMapRasterSurface", !0);
    this._terrainProvider = e, this._imageryProviders = i || [], this._surfaceTileManager = new kk(this), this.strategy || (this.strategy = new L_(n));
  }
  addImageryLayer(e) {
    this._imageryProviders.push(e);
  }
  removeImageryLayer(e) {
    const i = this._imageryProviders.indexOf(e);
    i > -1 && this._imageryProviders.splice(i, 1);
  }
  _getCurrentGrid() {
    return this._terrainProvider.grid;
  }
  _updateMaxLevel() {
    let e = 0;
    this._terrainProvider && this._terrainProvider.maxLevel !== 1 / 0 && (e = Math.max(e, this._terrainProvider.maxLevel));
    for (let i = 0; i < this._imageryProviders.length; ++i)
      this._imageryProviders[i].ignoreLevelLimit || this._imageryProviders[i].maxLevel !== 1 / 0 && (e = Math.max(e, this._imageryProviders[i].maxLevel));
    this._maxLevel = e, this._minLevel = this._terrainProvider.minLevel;
  }
  beginFrame(e) {
    if (super.beginFrame(e), !this._terrainProvider)
      return !1;
    const i = this._quadMap._engine, n = i.map.projection;
    let o = null;
    if (this._terrainProvider && (this._terrainProvider._engine = i, this._terrainProvider.targetProjection = n, this._terrainProvider.beginFrame(e), o = this._terrainProvider.rasterProjection, this._terrainProvider.isReady()))
      for (let r = 0; r < this._imageryProviders.length; ++r)
        this._imageryProviders[r]._engine = i, this._imageryProviders[r].targetProjection = o, this._imageryProviders[r].beginFrame(e);
    this._updateMaxLevel();
  }
  endFrame(e) {
    this._terrainProvider && this._terrainProvider.endFrame(e);
    for (let i = 0; i < this._imageryProviders.length; ++i)
      this._imageryProviders[i].endFrame(e);
    super.endFrame(e);
  }
  get terrainProvider() {
    return this._terrainProvider;
  }
  set terrainProvider(e) {
    this._terrainProvider !== e && (this._terrainProvider && this.clearTilesInView(), this._terrainProvider = e, this._surfaceTileManager.clear(), this._quadMap._engine.requestRender());
  }
  get imageryProviders() {
    return this._imageryProviders;
  }
  set imageryProviders(e) {
    this._imageryProviders = e, this._surfaceTileManager.clear(), this._quadMap._engine.requestRender();
  }
}
const kc = 0, Gu = 2;
class zk extends N_ {
  constructor() {
    super(...arguments);
    f(this, "_tiles", /* @__PURE__ */ new WeakMap());
  }
  isTileRenderable(e) {
    const i = this._tiles.get(e);
    return i ? (i.needsUpdate && this._updateSurfaceTileData(i), i.state !== kc) : !1;
  }
  markTileUsed(e) {
    const i = this._tiles.get(e);
    if (!i)
      return null;
    const n = this._surface.tileProvider, o = i.dataTile;
    o && n.markTileUsed(o);
  }
  isTileNeedsLoading(e) {
    return !this.isTileRenderable(e);
  }
  isTileComputable(e) {
    const i = this._tiles.get(e);
    return i ? (i.needsUpdate && this._updateSurfaceTileData(i), i.dataTile && i.dataTile.state === Ns) : !1;
  }
  isTileStable(e) {
    const i = this._tiles.get(e);
    return i ? (i.needsUpdate && this._updateSurfaceTileData(i), i.state === Gu) : !1;
  }
  _updateSurfaceTileData(e) {
    e.needsUpdate = !1;
    const i = e.dataTile, n = this._surface.quadMap._engine;
    if (i.state !== Ns) {
      e.state = kc, n.requestRender();
      return;
    }
    e.state = Gu;
    const o = i.data;
    if (o && o[0]) {
      const r = o[0];
      e.object = r;
    }
    if (o && o[1]) {
      const r = o[1];
      e.groundObject = r;
    }
  }
  getSurfaceTile(e) {
    const i = this._tiles.get(e);
    if (!i)
      return null;
    if (i.needsUpdate && this._updateSurfaceTileData(i), i.state !== kc)
      return i;
  }
  _onlyRequestTileContents(e) {
    const i = e.dataTile, n = this._surface.tileProvider;
    i && n.requestTileData(i, e);
  }
  requestSurfaceTile(e) {
    if (this._tiles.has(e)) {
      const a = this._tiles.get(e);
      a.needsUpdate && this._updateSurfaceTileData(a), a.state !== Gu && this._onlyRequestTileContents(a);
      return;
    }
    const n = this._surface.tileProvider;
    if (n.initState !== hr)
      return;
    const o = new F_(e);
    o.state = kc;
    const r = n.getTile(e.z, e.x, e.y, null, o);
    n.requestTileData(r, o), o.dataTile = r, this._tiles.set(e, o);
  }
  clear() {
    this._tiles = /* @__PURE__ */ new WeakMap();
  }
  dispose() {
  }
}
class Xk extends P_ {
  constructor(e, i = {}) {
    super(i);
    f(this, "name", "VectorSurface");
    f(this, "isMapVectorSurface", !0);
    f(this, "_useTargetProjectionBoundingBox", !0);
    f(this, "_onTileCreated", (e) => {
    });
    this._tileProvider = e, this._surfaceTileManager = new zk(this), this.strategy || (this.strategy = new T_(i));
  }
  _getCurrentGrid() {
    return this._tileProvider.grid;
  }
  beginFrame(e) {
    if (super.beginFrame(e), !this._tileProvider)
      return !1;
    const i = this._quadMap._engine, n = i.map.projection;
    this._tileProvider && (this._shouldRenderPlaceholder = this._tileProvider._shouldRenderPlaceholder, this._tileProvider._engine = i, this._tileProvider.targetProjection = n, this._tileProvider.beginFrame(e)), this._maxLevel = this._tileProvider.maxLevel, this._minLevel = this._tileProvider.minLevel;
  }
  endFrame(e) {
    super.endFrame(e);
  }
  onSurfaceTileAdded(e) {
    this._tileProvider.onSurfaceTileAdded && this._tileProvider.onSurfaceTileAdded(e, this.engine);
  }
  onSurfaceTileRemoved(e) {
    this._tileProvider.onSurfaceTileRemoved && this._tileProvider.onSurfaceTileRemoved(e, this.engine);
  }
  onSurfaceTileSSEChanged(e) {
    this._tileProvider.onSurfaceTileSSEChanged && this._tileProvider.onSurfaceTileSSEChanged(e, this.engine);
  }
  dispose() {
    super.dispose();
  }
  get tileProvider() {
    return this._tileProvider;
  }
  set tileProvider(e) {
    this._tileProvider !== e && (this._tileProvider && this.clearTilesInView(), this._tileProvider = e, this._surfaceTileManager.clear(), this._quadMap._engine.requestRender());
  }
}
class kg extends ZC {
  async doRequestTileData(t) {
  }
  onTileDispose(t) {
    const e = t.data;
    e && e.dispose();
  }
}
kg.heightmapTerrainQuality = 0.25;
kg.getEstimatedLevelZeroGeometricErrorForAHeightmap = function(s, t, e) {
  return s.maximumRadius * 2 * Math.PI * kg.heightmapTerrainQuality / (t * e);
};
class UC extends id {
  constructor() {
    super(...arguments);
    f(this, "name", R_);
    f(this, "_useGeoSubdivision", !0);
    f(this, "_minLevel", 1);
  }
  getRootTiles() {
    const e = new va(this, 1, 0, 0);
    e.geoBoundingBox = new Ue(new B(-180, -90, 0), new B(0, 90, 0)), e.projectedBoundingBox = new Ue(
      new B(-180, -90, 0),
      new B(0, 90, 0)
    );
    const i = new va(this, 1, 1, 0);
    return i.geoBoundingBox = new Ue(new B(0, -90, 0), new B(180, 90, 0)), i.projectedBoundingBox = new Ue(
      new B(0, -90, 0),
      new B(180, 90, 0)
    ), [e, i];
  }
  getTileReverseY(e) {
    return Math.pow(2, e.z - 1) - e.y - 1;
  }
  getTileSizeAtLevel(e) {
    return 360 / Math.pow(2, e);
  }
  getTileCoordX(e, i) {
    return (e + 180) / i;
  }
  getTileCoordY(e, i) {
    return (e + 90) / i;
  }
}
new B();
new B();
class k_ extends kg {
  constructor() {
    super(...arguments);
    f(this, "name", "PlaneTerrainTileProvider");
    f(this, "_supportedTargetProjectionNames", [
      Mt,
      zs,
      hi
    ]);
    f(this, "_levelZeroMaximumGeometricError", kg.getEstimatedLevelZeroGeometricErrorForAHeightmap(
      De.WGS84,
      64,
      2
    ));
  }
  initProjectionAndGrid() {
    this._targetProjection.name === Mt ? (this._sourceProjection = this._targetProjection, this._grid = new nd(this._engine, this._sourceProjection, this._targetProjection)) : (this._sourceProjection = bn(hi), this._grid = new UC(this._engine, this._sourceProjection, this._targetProjection));
    const e = this._targetProjection.name;
    let i = null;
    e === Mt ? i = bn(Mt) : i = bn(hi), this.rasterProjection = i, this._grid.rasterProjection = i;
  }
  doRequestTileData(e) {
    const i = {
      x: e.x,
      y: e.y,
      z: e.z,
      targetProjection: this._targetProjection,
      sourceProjection: this._sourceProjection,
      targetProjectionName: this._targetProjection.name,
      sourceProjectionName: this._sourceProjection.name,
      targetCenter: this._vectorToArray(e.targetCenter),
      geoBoundingBox: this._boxToArray(e.geoBoundingBox),
      forceProjectCoordinates: !0,
      projectedBoundingBox: e.projectedBoundingBox.isBox3 ? this._boxToArray(e.projectedBoundingBox) : []
    }, n = WC(i, {
      normals: [0, 0, 1]
    }), o = new Qe();
    return o.setIndex(n.indices), o.setAttribute("position", new ae(n.vertices, 3)), o.setAttribute("normal", new ae(n.normals, 3)), o.setAttribute("uv", new ae(n.uvs, 2)), o;
  }
  _vectorToArray(e) {
    return [e.x, e.y, e.z];
  }
  _boxToArray(e) {
    return [e.min.x, e.min.y, e.min.z, e.max.x, e.max.y, e.max.z];
  }
}
const Wk = `
// attribute vec3 position;
// attribute vec2 uv;
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`, Zk = `
uniform sampler2D map;
uniform vec3 color;
varying vec2 vUv;
void main() {
    gl_FragColor = texture2D(map, vUv);
    // gl_FragColor = vec4(color, 1.0);
}
`;
class Uk extends ze {
  constructor(t = {}) {
    super(), this.name = "ImageryReprojectMaterial", this.fragmentShader = Zk, this.vertexShader = Wk, this.uniforms = {
      map: {
        value: null
      },
      color: {
        value: new B(1, 1, 1)
      }
    };
  }
  dispose() {
    super.dispose();
  }
}
const Ok = new Zg(-0.5, 0.5, 0.5, -0.5, 0, 1), Qk = new Z(), oo = new B(), qo = new B();
class fA {
  _initResource() {
    this._renderTarget = new It(256, 256), this._renderTarget.name = "ImageryReprojector", this._renderTarget.texture.name = "ImageryReprojector";
    const t = this._geometry = new Og(1, 1, 1, 63);
    this._material = new Uk(), this._mesh = new le(t, this._material);
  }
  reprojectImagery(t, e, i, n, o, r) {
    this._mesh || this._initResource(), this._material.uniforms.map.value = i;
    const a = this._geometry.attributes.uv.array;
    let g = e.projectedBoundingBox.min.y, c = e.projectedBoundingBox.max.y;
    const l = e.geoBoundingBox.min.y, h = e.geoBoundingBox.max.y;
    if (o.name, r.name, o.isGeo) {
      if (r.isGeo)
        throw new Error("Not implemented");
      {
        const p = 1 / (h - l);
        let m = e.targetBoundingBox.min.y, b = e.targetBoundingBox.max.y;
        for (let S = 0; S < 64; ++S) {
          let A = 1 - S / 63, u = ce.lerp(m, b, A);
          oo.set(0, u, 0), o.unprojectCoordinate(oo, qo);
          let y = (qo.y - l) * p;
          a[S * 4 + 1] = y, a[S * 4 + 3] = y;
        }
        throw new Error("Need double check");
      }
    } else {
      const p = 1 / (c - g);
      if (r.isGeo)
        for (let m = 0; m < 64; ++m) {
          let b = 1 - m / 63, S = ce.lerp(l, h, b);
          oo.set(0, S, 0), o.projectCoordinate(oo, qo);
          let A = (qo.y - g) * p;
          a[m * 4 + 1] = A, a[m * 4 + 3] = A;
        }
      else
        for (let m = 0; m < 64; ++m) {
          let b = 1 - m / 63, S = ce.lerp(g, c, b);
          oo.set(0, S, 0), r.unprojectCoordinate(oo, qo), oo.copy(qo), o.projectCoordinate(oo, qo), a[m * 4 + 1] = b, a[m * 4 + 3] = b;
        }
    }
    this._geometry.attributes.uv.needsUpdate = !0;
    const d = this._renderTarget;
    let C = t.getRenderTarget();
    return (d.width !== n.image.width || d.height !== n.image.height) && d.setSize(n.image.width, n.image.height), t.setRenderTarget(d), t.clear(), t.render(this._mesh, Ok), t.copyFramebufferToTexture(Qk, n), t.setRenderTarget(C), d;
  }
  dispose() {
    this._renderTarget.dispose(), this._mesh.geometry.dispose(), this._mesh.material.dispose();
  }
}
fA.DEFAULT = new fA();
let Vc;
function Yk() {
  if (!Vc) {
    const t = new Uint8Array(4);
    for (let e = 0; e < t.length; ++e)
      t[e] = 0;
    Vc = new Ga(t, 1, 1, Hs), Vc.needsUpdate = !0;
  }
  return Vc;
}
const Zr = new B(), Ur = new B(), jk = new Ot();
class OC extends ZC {
  constructor(e = {}) {
    super(e);
    f(this, "name", "ImageryTileProvider");
    f(this, "isImageryTileProvider", !0);
    f(this, "_loadingUpperSampleLevel", 100);
    this._opacity = e.opacity, this._colorTint = e.colorTint || [1, 1, 1], this._randomColorTint = e.randomColorTint || !1, this._opacity === void 0 && (this._opacity = 1);
  }
  getTileURL(e, i, n, o) {
  }
  shouldReproject(e, i, n) {
    const o = e.name, r = i.name;
    if (o === r)
      return !1;
    if (e.isGeo) {
      if (i.isGeo)
        return !1;
      throw new Error("Not implemented");
    } else if (i.isGeo) {
      const a = (n.geoBoundingBox.min.y + n.geoBoundingBox.max.y) / 2, g = (n.projectedBoundingBox.min.y + n.projectedBoundingBox.max.y) / 2;
      return Zr.set(0, a, 0), e.projectCoordinate(Zr, Ur), Math.abs(Ur.y - g) / n.grid.getPixelSizeByLevel(n.z) > 0.1;
    } else {
      const a = (n.projectedBoundingBox.min.y + n.projectedBoundingBox.max.y) / 2;
      return Zr.set(0, a, 0), e.unprojectCoordinate(Zr, Ur), Zr.copy(Ur), i.projectCoordinate(Zr, Ur), Math.abs(Ur.y - a) / n.grid.getPixelSizeByLevel(n.z) > 0.1;
    }
  }
  doRequestTileData(e) {
    const i = this.getTileURL(e.z, e.x, e.y, e);
    return e._url = i, new Promise((n, o) => {
      jk.load(i, (r) => {
        r.colorSpace = gt, r.generateMipmaps = !1;
        let a = 256, g = 256;
        if (r.image && (a = r.image.width, g = r.image.height), this.shouldReproject(this._sourceProjection, this._targetProjection, e)) {
          const c = new oT(a, g);
          c.minFilter = Gt, c.magFilter = Gt, fA.DEFAULT.reprojectImagery(
            this._engine.renderer,
            e,
            r,
            c,
            this._sourceProjection,
            this._targetProjection
          ), c.colorSpace = gt, n(c), r.dispose();
        } else
          n(r);
      }, null, o);
    });
  }
  errorFeedback() {
    return Yk();
  }
  onTileDispose(e) {
    const i = e.data;
    i && i.dispose();
  }
  set opacity(e) {
    this._opacity = e;
  }
  get opacity() {
    return this._opacity;
  }
  set colorTint(e) {
    this._colorTint = e;
  }
  get colorTint() {
    return this._colorTint;
  }
  set randomColorTint(e) {
    this._randomColorTint !== e && (this._randomColorTint = e, this._needsClearCache = !0);
  }
  get randomColorTint() {
    return this._randomColorTint;
  }
}
class Jk extends OC {
  constructor(e) {
    super({
      ...e,
      projection: Mt
    });
    f(this, "name", "BingImageryTileProvider");
    f(this, "_supportedTargetProjectionNames", [Mt, hi]);
    f(this, "_defaultStartLevel", 1);
    f(this, "_defaultMaxLevel", 18);
    f(this, "_maxParallelRequestNum", 24);
    f(this, "_useWebMeractorProjectionAndGrid", !0);
  }
  getTileURL(e, i, n, o) {
    if (e === 0)
      return !1;
    const r = this.quadKey(e, i, o.reverseY);
    return `//ecn.t${r % 4}.tiles.virtualearth.net/tiles/a${r}.jpeg?g=13651`;
  }
  quadKey(e, i, n) {
    let o = "";
    for (let r = e; r > 0; r--) {
      const a = 1 << r - 1;
      let g = 0;
      (i & a) !== 0 && g++, (n & a) !== 0 && (g += 2), o += g;
    }
    return o;
  }
}
const m0 = new J(), y0 = new Nh(), zc = new B(), Mu = new B();
class qk extends Wt {
  constructor(e = {}) {
    super();
    f(this, "isQuadMap", !0);
    f(this, "_freezeUpdate", !1);
    f(this, "_lodScaleFactor", 2);
    f(this, "_cameraFarRatio", 1);
    f(this, "_camera", null);
    f(this, "_lastUpdateTime", 0);
    f(this, "_delayUpdateTime", 15);
    f(this, "_delayUpdateTimeHandler", null);
    f(this, "_restrictedBounds", []);
    f(this, "_engine");
    f(this, "_grid");
    f(this, "_options");
    f(this, "_surfaces", []);
    f(this, "_updateCameraInfo", (e, i) => {
      e.rendering.resolution, i.projectionMatrix.elements;
      const n = i.matrixWorldInverse.elements;
      this._sseDenominator = 2 * Math.tan(0.5 * i.fov / 180 * Math.PI), zc.set(n[2], n[6], n[10]).normalize().negate(), e.map.isGlobe ? Mu.copy(i.position).normalize() : Mu.set(0, 0, 1), this._pitchRatio = zc.dot(Mu);
    });
    f(this, "getKeyByValue", (e, i) => {
      for (let n in e)
        if (e.hasOwnProperty(n) && e[n].includes(i))
          return n === String(i) ? null : n;
      return null;
    });
    f(this, "handleTileLoaded", (e) => {
      const i = e.value;
      this._hirarchical && i._heights && (this._zCache[i.key] = i._heights), this.dispatchEvent(e), this._engine.requestRender();
    });
    f(this, "handleTileDispose", (e) => {
      this.onTileDisposed(e.value), this.dispatchEvent(e);
    });
    f(this, "addRestrictedBoundingBox", (e, i) => {
      const n = this._engine.map;
      let o = n.projectArrayCoordinate(e), r = n.projectArrayCoordinate(i);
      const a = new Ue();
      return a.min.set(o[0], o[1], o[2] || -100), a.max.set(r[0], r[1], o[2] || 100), this._restrictedBounds.push(a), a;
    });
    f(this, "removeRestrictedBounds", (e) => {
      this._restrictedBounds.includes(e) && this._restrictedBounds.splice(e, 1);
    });
    this._options = e;
  }
  addSurface(e) {
    e.quadMap = this, e.engine = this._engine, this._surfaces.push(e), this.add(e);
  }
  addRasterSurface(e, i, n) {
    const o = new Vk(e, i, n);
    return this.addSurface(o), o;
  }
  addVectorSurface(e, i) {
    const n = new Xk(e, i);
    return this.addSurface(n), n;
  }
  removeSurface(e) {
    const i = this._surfaces.indexOf(e);
    if (i > -1) {
      const n = this._surfaces.splice(i, 1)[0];
      n.clearTilesInView(), this.remove(n), n.quadMap = null;
    }
  }
  setTerrainProvider(e) {
    if (!this._rasterSurface) {
      console.warn("No raster surface");
      return;
    }
    this._rasterSurface.terrainProvider = e;
  }
  setImageryProviders(e) {
    if (!this._rasterSurface) {
      console.warn("No raster surface");
      return;
    }
    this._rasterSurface.imageryProviders = e;
  }
  setImageryProvider(e) {
    this.setImageryProviders([e]);
  }
  setVectorProvider(e, i) {
    if (!this._vectorSurface) {
      if (!e)
        return;
      this._vectorSurface = this.addVectorSurface(e, i);
      return;
    }
    this._vectorSurface.tileProvider = e;
  }
  getImageryProviders() {
    return this._rasterSurface ? this._rasterSurface.imageryProviders : null;
  }
  createTileLoader() {
  }
  createGrid(e) {
  }
  afterAddToEngine(e) {
    this._projection = e.map.projection, this._engine = e, this._initDefaultSurfaces();
  }
  _initDefaultSurfaces() {
    const e = this._options;
    if (e.rasterSurface)
      this._rasterSurface = e.rasterSurface, this.addSurface(e.rasterSurface);
    else {
      let i = e.terrainProvider;
      i === void 0 && (i = new k_({}));
      let n = e.imageryProviders;
      n === void 0 && (e.imageryProvider ? n = [e.imageryProvider] : e.imageryProvider === void 0 && (n = [
        new Jk({})
      ])), i && (this._rasterSurface = this.addRasterSurface(i, n));
    }
    e.vectorSurface ? (this._vectorSurface = e.vectorSurface, this.addSurface(e.vectorSurface)) : e.vectorProvider && (this._vectorSurface = this.addVectorSurface(e.vectorProvider, e.vectorSurfaceOptions));
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  onBeforeScenePrepareRender(e, i, n, o) {
    if (this._freezeUpdate || !this.visible) {
      clearTimeout(this._delayUpdateTimeHandler), this._delayUpdateTimeHandler = null;
      return;
    }
    if (this._delayUpdateTimeHandler)
      return;
    const r = Date.now(), a = r - this._lastUpdateTime;
    if (a < this._delayUpdateTime) {
      this._delayUpdateTimeHandler = setTimeout(() => {
        this._delayUpdateTimeHandler = null, e.requestRender();
      }, this._delayUpdateTime - a + 1);
      return;
    }
    let g = n;
    this._cameraFarRatio < 1 && (this._camera || (this._camera = n.clone()), g = this._camera, g.copy(n), g.far = n.far * this._cameraFarRatio, g.updateProjectionMatrix()), this._updateCameraInfo(e, n), this._updateSurfaces(e, i, g, o), this._lastUpdateTime = r;
  }
  onBeforeSceneRender(e, i, n, o) {
    for (let r = 0; r < this._surfaces.length; r++) {
      const a = this._surfaces[r];
      a._onBeforeSceneRender && a._onBeforeSceneRender(e, i, n, o);
    }
  }
  _updateSurfaces(e, i, n, o) {
    m0.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), y0.setFromProjectionMatrix(m0), zc.copy(n.position);
    for (let r = 0; r < this._surfaces.length; r++)
      this._surfaces[r].updateView(e, zc, y0, o);
  }
  onTileAdded(e) {
  }
  onTileRemoved(e) {
  }
  onTileDisposed(e) {
  }
  dispose() {
  }
  printSurfacesStatistics() {
    for (let e = 0; e < this._surfaces.length; e++)
      this._surfaces[e];
  }
  _getCurrentCamera() {
    return this._cameraFarRatio < 1 ? this._camera || this._engine.camera : this._engine.camera;
  }
  showCameraFrustum() {
    const e = this._engine;
    this.destroyCameraHelper();
    const i = this._getCurrentCamera(), n = this._lockedCamera = i.clone(), o = this._cameraHelper = new zA(n);
    e.add(o);
  }
  destroyCameraHelper() {
    const e = this._engine;
    this._cameraHelper && (e.remove(this._cameraHelper), this._cameraHelper.dispose(), this._cameraHelper = null);
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get lodScaleFactor() {
    return this._lodScaleFactor;
  }
  set lodScaleFactor(e) {
    this._lodScaleFactor = e, this._engine.requestRender();
  }
  get cameraFarRatio() {
    return this._cameraFarRatio;
  }
  set cameraFarRatio(e) {
    this._cameraFarRatio = e;
  }
  get rasterSurface() {
    return this._rasterSurface;
  }
  get vectorSurface() {
    return this._vectorSurface;
  }
  get surfaces() {
    return this._surfaces;
  }
}
let ja;
function $k() {
  if (!ja) {
    ja = new mt();
    const s = new le(new Qe(), new _t());
    ja.add(s);
  }
  return [ja, ja];
}
class eV extends ZC {
  constructor() {
    super(...arguments);
    f(this, "isVectorTileProvider", !0);
    f(this, "name", "VectorTileProvider");
  }
  errorFeedback() {
    return $k();
  }
  async doRequestTileData(e) {
  }
  getGroundTileData(e) {
    const i = {
      x: e.x,
      y: e.y,
      z: e.z,
      targetProjection: e.grid.targetProjection,
      sourceProjection: e.grid.sourceProjection,
      targetProjectionName: e.grid.targetProjection.name,
      sourceProjectionName: e.grid.sourceProjection.name,
      targetCenter: e.targetCenter.toArray(),
      geoBoundingBox: e.availableGeoBoundingBox,
      forceUseGeoBoundingBox: !0,
      forceProjectCoordinates: !0,
      projectedBoundingBox: e.projectedBoundingBox.isBox3 ? e.projectedBoundingBox : []
    }, n = WC(i, {
      layerIndices: 0
    }), o = new Qe();
    o.setIndex(n.indices), o.setAttribute("position", new Fe(new Float32Array(n.vertices), 3)), o.setAttribute("layerIndex", new Fe(new Float32Array(n.layerIndices), 1)), o.setAttribute("uv", new Fe(new Float32Array(n.uvs), 2)), this._groundTileMaterial || (this._groundTileMaterial = new _t({
      color: 8947848
    }));
    const r = new le(o, this._groundTileMaterial);
    return r.position.copy(e.targetCenter), [null, r];
  }
}
class V_ {
  constructor(t, e) {
    f(this, "_size", 1);
    f(this, "_workerClass", null);
    f(this, "_workers", []);
    f(this, "_currentRequestId", 0);
    f(this, "_requestMap", {});
    f(this, "_handleWorkerMessage", async (t) => {
      const e = t.data, i = this.getResponseMessageId(e, t);
      if (i == null) {
        console.warn("no valid id in response message", t);
        return;
      }
      const n = this._requestMap[i];
      if (!n) {
        console.warn(`id ${i} not found in pending request`);
        return;
      }
      if (this.onMessageReceived && this.onMessageReceived(e, t), !this.isMessageCompleted(e, t))
        return;
      delete this._requestMap[i];
      const o = n[3];
      this._workers[o].use--;
      const r = await this.onMessageCompleted(e, t, n[2]);
      n[0](r);
    });
    this._workerClass = t, this._size = e;
  }
  getRequestMessageId(t) {
    return this._currentRequestId++;
  }
  getResponseMessageId(t, e) {
    return t.id;
  }
  _getAvailableWorker() {
    if (this._size === 1)
      return this._workers[0].instance;
    let t = -1, e = 1 / 0;
    for (let i = 0; i < this._size; i++) {
      const n = this._workers[i];
      n.use < e && (t = i, e = n.use);
    }
    return [t, this._workers[t].instance];
  }
  initWorkers() {
    if (this._workers.length === 0)
      for (let t = 0; t < this._size; t++) {
        const e = new this._workerClass();
        e.addEventListener("message", this._handleWorkerMessage), e.addEventListener("error", this.onWorkerError), this._workers.push({
          instance: e,
          use: 0
        });
      }
  }
  async postMessage(t, e, i) {
    i == null && (i = this.getRequestMessageId(t)), this.initWorkers();
    const [
      n,
      o
    ] = this._getAvailableWorker();
    return (t.id === void 0 || t.id === null) && (t.id = i), o.postMessage(t, e), this._workers[n].use++, new Promise((r, a) => {
      this._requestMap[i] = [r, a, t, n];
    });
  }
  async onMessageCompleted(t, e) {
    return t;
  }
  isMessageCompleted(t, e) {
    return !0;
  }
  postMessageToAll(t, e) {
    for (const i of this._workers)
      i.instance.postMessage(t, e);
  }
  get size() {
    return this._size;
  }
}
class tV {
  constructor(t, e, i) {
    this.provider = t, this._workerTaskScheduler = new V_(e, i), this._workerTaskScheduler.getResponseMessageId = this.getResponseMessageId, this._workerTaskScheduler.isMessageCompleted = this.isMessageCompleted;
  }
  isMessageCompleted(t, e) {
    return t.type === "responseTile";
  }
  getResponseMessageId(t, e) {
    return t.tileKey;
  }
  _vectorToArray(t) {
    return [t.x, t.y, t.z];
  }
  _boxToArray(t) {
    return [t.min.x, t.min.y, t.min.z, t.max.x, t.max.y, t.max.z];
  }
  async requestTile(t) {
    const e = this.provider;
    let i = e.getTileURL(t.z, t.x, t.y, t);
    const n = {
      type: "requestTile",
      tileKey: t.key,
      sourceProjectionName: e.sourceProjection.name,
      targetProjectionName: e.targetProjection.name,
      projectedBoundingBox: this._boxToArray(t.projectedBoundingBox),
      geoBoundingBox: this._boxToArray(t.geoBoundingBox),
      projectedCenter: this._vectorToArray(t.projectedCenter),
      targetCenter: this._vectorToArray(t.targetCenter),
      id: t.id,
      x: t.x,
      y: t.y,
      z: t.z,
      reverseY: t.reverseY,
      url: i,
      timeStart: performance.now()
    };
    if (e.getFetchOptions) {
      const o = e.getFetchOptions(t);
      n.fetchOptions = o;
    }
    if (e.getWorkerOptions) {
      const o = e.getWorkerOptions(t);
      n.workerOptions = o;
    }
    return await this._workerTaskScheduler.postMessage(n, [], t.key);
  }
  postMessageToAll(t, e) {
    this._workerTaskScheduler.initWorkers(), this._workerTaskScheduler.postMessageToAll(t, e);
  }
}
const z_ = "dmFyIEhpID0gT2JqZWN0LmRlZmluZVByb3BlcnR5Owp2YXIgSmkgPSAocywgdCwgZSkgPT4gdCBpbiBzID8gSGkocywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSA6IHNbdF0gPSBlOwp2YXIgdiA9IChzLCB0LCBlKSA9PiAoSmkocywgdHlwZW9mIHQgIT0gInN5bWJvbCIgPyB0ICsgIiIgOiB0LCBlKSwgZSk7CmZ1bmN0aW9uIENpKHMsIHQsIGUpIHsKICByZXR1cm4gTWF0aC5tYXgodCwgTWF0aC5taW4oZSwgcykpOwp9Ci8qKgogKiBAbGljZW5zZQogKiBDb3B5cmlnaHQgMjAxMC0yMDIzIFRocmVlLmpzIEF1dGhvcnMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVAogKi8KY29uc3QgT2kgPSAiMTU4IiwgUmUgPSAyZTMsIHZuID0gMjAwMSwgbnQgPSBbIjAwIiwgIjAxIiwgIjAyIiwgIjAzIiwgIjA0IiwgIjA1IiwgIjA2IiwgIjA3IiwgIjA4IiwgIjA5IiwgIjBhIiwgIjBiIiwgIjBjIiwgIjBkIiwgIjBlIiwgIjBmIiwgIjEwIiwgIjExIiwgIjEyIiwgIjEzIiwgIjE0IiwgIjE1IiwgIjE2IiwgIjE3IiwgIjE4IiwgIjE5IiwgIjFhIiwgIjFiIiwgIjFjIiwgIjFkIiwgIjFlIiwgIjFmIiwgIjIwIiwgIjIxIiwgIjIyIiwgIjIzIiwgIjI0IiwgIjI1IiwgIjI2IiwgIjI3IiwgIjI4IiwgIjI5IiwgIjJhIiwgIjJiIiwgIjJjIiwgIjJkIiwgIjJlIiwgIjJmIiwgIjMwIiwgIjMxIiwgIjMyIiwgIjMzIiwgIjM0IiwgIjM1IiwgIjM2IiwgIjM3IiwgIjM4IiwgIjM5IiwgIjNhIiwgIjNiIiwgIjNjIiwgIjNkIiwgIjNlIiwgIjNmIiwgIjQwIiwgIjQxIiwgIjQyIiwgIjQzIiwgIjQ0IiwgIjQ1IiwgIjQ2IiwgIjQ3IiwgIjQ4IiwgIjQ5IiwgIjRhIiwgIjRiIiwgIjRjIiwgIjRkIiwgIjRlIiwgIjRmIiwgIjUwIiwgIjUxIiwgIjUyIiwgIjUzIiwgIjU0IiwgIjU1IiwgIjU2IiwgIjU3IiwgIjU4IiwgIjU5IiwgIjVhIiwgIjViIiwgIjVjIiwgIjVkIiwgIjVlIiwgIjVmIiwgIjYwIiwgIjYxIiwgIjYyIiwgIjYzIiwgIjY0IiwgIjY1IiwgIjY2IiwgIjY3IiwgIjY4IiwgIjY5IiwgIjZhIiwgIjZiIiwgIjZjIiwgIjZkIiwgIjZlIiwgIjZmIiwgIjcwIiwgIjcxIiwgIjcyIiwgIjczIiwgIjc0IiwgIjc1IiwgIjc2IiwgIjc3IiwgIjc4IiwgIjc5IiwgIjdhIiwgIjdiIiwgIjdjIiwgIjdkIiwgIjdlIiwgIjdmIiwgIjgwIiwgIjgxIiwgIjgyIiwgIjgzIiwgIjg0IiwgIjg1IiwgIjg2IiwgIjg3IiwgIjg4IiwgIjg5IiwgIjhhIiwgIjhiIiwgIjhjIiwgIjhkIiwgIjhlIiwgIjhmIiwgIjkwIiwgIjkxIiwgIjkyIiwgIjkzIiwgIjk0IiwgIjk1IiwgIjk2IiwgIjk3IiwgIjk4IiwgIjk5IiwgIjlhIiwgIjliIiwgIjljIiwgIjlkIiwgIjllIiwgIjlmIiwgImEwIiwgImExIiwgImEyIiwgImEzIiwgImE0IiwgImE1IiwgImE2IiwgImE3IiwgImE4IiwgImE5IiwgImFhIiwgImFiIiwgImFjIiwgImFkIiwgImFlIiwgImFmIiwgImIwIiwgImIxIiwgImIyIiwgImIzIiwgImI0IiwgImI1IiwgImI2IiwgImI3IiwgImI4IiwgImI5IiwgImJhIiwgImJiIiwgImJjIiwgImJkIiwgImJlIiwgImJmIiwgImMwIiwgImMxIiwgImMyIiwgImMzIiwgImM0IiwgImM1IiwgImM2IiwgImM3IiwgImM4IiwgImM5IiwgImNhIiwgImNiIiwgImNjIiwgImNkIiwgImNlIiwgImNmIiwgImQwIiwgImQxIiwgImQyIiwgImQzIiwgImQ0IiwgImQ1IiwgImQ2IiwgImQ3IiwgImQ4IiwgImQ5IiwgImRhIiwgImRiIiwgImRjIiwgImRkIiwgImRlIiwgImRmIiwgImUwIiwgImUxIiwgImUyIiwgImUzIiwgImU0IiwgImU1IiwgImU2IiwgImU3IiwgImU4IiwgImU5IiwgImVhIiwgImViIiwgImVjIiwgImVkIiwgImVlIiwgImVmIiwgImYwIiwgImYxIiwgImYyIiwgImYzIiwgImY0IiwgImY1IiwgImY2IiwgImY3IiwgImY4IiwgImY5IiwgImZhIiwgImZiIiwgImZjIiwgImZkIiwgImZlIiwgImZmIl07CmxldCBqbiA9IDEyMzQ1Njc7CmNvbnN0IEVpID0gTWF0aC5QSSAvIDE4MCwgQWkgPSAxODAgLyBNYXRoLlBJOwpmdW5jdGlvbiBLaSgpIHsKICBjb25zdCBzID0gTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUgfCAwLCB0ID0gTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUgfCAwLCBlID0gTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUgfCAwLCBuID0gTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTUgfCAwOwogIHJldHVybiAobnRbcyAmIDI1NV0gKyBudFtzID4+IDggJiAyNTVdICsgbnRbcyA+PiAxNiAmIDI1NV0gKyBudFtzID4+IDI0ICYgMjU1XSArICItIiArIG50W3QgJiAyNTVdICsgbnRbdCA+PiA4ICYgMjU1XSArICItIiArIG50W3QgPj4gMTYgJiAxNSB8IDY0XSArIG50W3QgPj4gMjQgJiAyNTVdICsgIi0iICsgbnRbZSAmIDYzIHwgMTI4XSArIG50W2UgPj4gOCAmIDI1NV0gKyAiLSIgKyBudFtlID4+IDE2ICYgMjU1XSArIG50W2UgPj4gMjQgJiAyNTVdICsgbnRbbiAmIDI1NV0gKyBudFtuID4+IDggJiAyNTVdICsgbnRbbiA+PiAxNiAmIDI1NV0gKyBudFtuID4+IDI0ICYgMjU1XSkudG9Mb3dlckNhc2UoKTsKfQpmdW5jdGlvbiB0bihzLCB0LCBlKSB7CiAgcmV0dXJuIE1hdGgubWF4KHQsIE1hdGgubWluKGUsIHMpKTsKfQpmdW5jdGlvbiBSaShzLCB0KSB7CiAgcmV0dXJuIChzICUgdCArIHQpICUgdDsKfQpmdW5jdGlvbiB0cyhzLCB0LCBlLCBuLCBpKSB7CiAgcmV0dXJuIG4gKyAocyAtIHQpICogKGkgLSBuKSAvIChlIC0gdCk7Cn0KZnVuY3Rpb24gZXMocywgdCwgZSkgewogIHJldHVybiBzICE9PSB0ID8gKGUgLSBzKSAvICh0IC0gcykgOiAwOwp9CmZ1bmN0aW9uIE5pKHMsIHQsIGUpIHsKICByZXR1cm4gKDEgLSBlKSAqIHMgKyBlICogdDsKfQpmdW5jdGlvbiBucyhzLCB0LCBlLCBuKSB7CiAgcmV0dXJuIE5pKHMsIHQsIDEgLSBNYXRoLmV4cCgtZSAqIG4pKTsKfQpmdW5jdGlvbiBpcyhzLCB0ID0gMSkgewogIHJldHVybiB0IC0gTWF0aC5hYnMoUmkocywgdCAqIDIpIC0gdCk7Cn0KZnVuY3Rpb24gc3MocywgdCwgZSkgewogIHJldHVybiBzIDw9IHQgPyAwIDogcyA+PSBlID8gMSA6IChzID0gKHMgLSB0KSAvIChlIC0gdCksIHMgKiBzICogKDMgLSAyICogcykpOwp9CmZ1bmN0aW9uIHJzKHMsIHQsIGUpIHsKICByZXR1cm4gcyA8PSB0ID8gMCA6IHMgPj0gZSA/IDEgOiAocyA9IChzIC0gdCkgLyAoZSAtIHQpLCBzICogcyAqIHMgKiAocyAqIChzICogNiAtIDE1KSArIDEwKSk7Cn0KZnVuY3Rpb24gYXMocywgdCkgewogIHJldHVybiBzICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHQgLSBzICsgMSkpOwp9CmZ1bmN0aW9uIG9zKHMsIHQpIHsKICByZXR1cm4gcyArIE1hdGgucmFuZG9tKCkgKiAodCAtIHMpOwp9CmZ1bmN0aW9uIGhzKHMpIHsKICByZXR1cm4gcyAqICgwLjUgLSBNYXRoLnJhbmRvbSgpKTsKfQpmdW5jdGlvbiBjcyhzKSB7CiAgcyAhPT0gdm9pZCAwICYmIChqbiA9IHMpOwogIGxldCB0ID0gam4gKz0gMTgzMTU2NTgxMzsKICByZXR1cm4gdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKSwgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpLCAoKHQgXiB0ID4+PiAxNCkgPj4+IDApIC8gNDI5NDk2NzI5NjsKfQpmdW5jdGlvbiBscyhzKSB7CiAgcmV0dXJuIHMgKiBFaTsKfQpmdW5jdGlvbiB1cyhzKSB7CiAgcmV0dXJuIHMgKiBBaTsKfQpmdW5jdGlvbiBkcyhzKSB7CiAgcmV0dXJuIChzICYgcyAtIDEpID09PSAwICYmIHMgIT09IDA7Cn0KZnVuY3Rpb24geXMocykgewogIHJldHVybiBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cocykgLyBNYXRoLkxOMikpOwp9CmZ1bmN0aW9uIG1zKHMpIHsKICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyhzKSAvIE1hdGguTE4yKSk7Cn0KZnVuY3Rpb24gZnMocywgdCwgZSwgbiwgaSkgewogIGNvbnN0IHIgPSBNYXRoLmNvcywgYSA9IE1hdGguc2luLCBvID0gcihlIC8gMiksIGggPSBhKGUgLyAyKSwgYyA9IHIoKHQgKyBuKSAvIDIpLCBsID0gYSgodCArIG4pIC8gMiksIHUgPSByKCh0IC0gbikgLyAyKSwgZCA9IGEoKHQgLSBuKSAvIDIpLCB5ID0gcigobiAtIHQpIC8gMiksIGYgPSBhKChuIC0gdCkgLyAyKTsKICBzd2l0Y2ggKGkpIHsKICAgIGNhc2UgIlhZWCI6CiAgICAgIHMuc2V0KG8gKiBsLCBoICogdSwgaCAqIGQsIG8gKiBjKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJZWlkiOgogICAgICBzLnNldChoICogZCwgbyAqIGwsIGggKiB1LCBvICogYyk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAiWlhaIjoKICAgICAgcy5zZXQoaCAqIHUsIGggKiBkLCBvICogbCwgbyAqIGMpOwogICAgICBicmVhazsKICAgIGNhc2UgIlhaWCI6CiAgICAgIHMuc2V0KG8gKiBsLCBoICogZiwgaCAqIHksIG8gKiBjKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJZWFkiOgogICAgICBzLnNldChoICogeSwgbyAqIGwsIGggKiBmLCBvICogYyk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAiWllaIjoKICAgICAgcy5zZXQoaCAqIGYsIGggKiB5LCBvICogbCwgbyAqIGMpOwogICAgICBicmVhazsKICAgIGRlZmF1bHQ6CiAgICAgIGNvbnNvbGUud2FybigiVEhSRUUuTWF0aFV0aWxzOiAuc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIgKyBpKTsKICB9Cn0KZnVuY3Rpb24geHMocywgdCkgewogIHN3aXRjaCAodC5jb25zdHJ1Y3RvcikgewogICAgY2FzZSBGbG9hdDMyQXJyYXk6CiAgICAgIHJldHVybiBzOwogICAgY2FzZSBVaW50MzJBcnJheToKICAgICAgcmV0dXJuIHMgLyA0Mjk0OTY3Mjk1OwogICAgY2FzZSBVaW50MTZBcnJheToKICAgICAgcmV0dXJuIHMgLyA2NTUzNTsKICAgIGNhc2UgVWludDhBcnJheToKICAgICAgcmV0dXJuIHMgLyAyNTU7CiAgICBjYXNlIEludDMyQXJyYXk6CiAgICAgIHJldHVybiBNYXRoLm1heChzIC8gMjE0NzQ4MzY0NywgLTEpOwogICAgY2FzZSBJbnQxNkFycmF5OgogICAgICByZXR1cm4gTWF0aC5tYXgocyAvIDMyNzY3LCAtMSk7CiAgICBjYXNlIEludDhBcnJheToKICAgICAgcmV0dXJuIE1hdGgubWF4KHMgLyAxMjcsIC0xKTsKICAgIGRlZmF1bHQ6CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKTsKICB9Cn0KZnVuY3Rpb24gd3MocywgdCkgewogIHN3aXRjaCAodC5jb25zdHJ1Y3RvcikgewogICAgY2FzZSBGbG9hdDMyQXJyYXk6CiAgICAgIHJldHVybiBzOwogICAgY2FzZSBVaW50MzJBcnJheToKICAgICAgcmV0dXJuIE1hdGgucm91bmQocyAqIDQyOTQ5NjcyOTUpOwogICAgY2FzZSBVaW50MTZBcnJheToKICAgICAgcmV0dXJuIE1hdGgucm91bmQocyAqIDY1NTM1KTsKICAgIGNhc2UgVWludDhBcnJheToKICAgICAgcmV0dXJuIE1hdGgucm91bmQocyAqIDI1NSk7CiAgICBjYXNlIEludDMyQXJyYXk6CiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHMgKiAyMTQ3NDgzNjQ3KTsKICAgIGNhc2UgSW50MTZBcnJheToKICAgICAgcmV0dXJuIE1hdGgucm91bmQocyAqIDMyNzY3KTsKICAgIGNhc2UgSW50OEFycmF5OgogICAgICByZXR1cm4gTWF0aC5yb3VuZChzICogMTI3KTsKICAgIGRlZmF1bHQ6CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKTsKICB9Cn0KY29uc3QgTnQgPSB7CiAgREVHMlJBRDogRWksCiAgUkFEMkRFRzogQWksCiAgZ2VuZXJhdGVVVUlEOiBLaSwKICBjbGFtcDogdG4sCiAgZXVjbGlkZWFuTW9kdWxvOiBSaSwKICBtYXBMaW5lYXI6IHRzLAogIGludmVyc2VMZXJwOiBlcywKICBsZXJwOiBOaSwKICBkYW1wOiBucywKICBwaW5ncG9uZzogaXMsCiAgc21vb3Roc3RlcDogc3MsCiAgc21vb3RoZXJzdGVwOiBycywKICByYW5kSW50OiBhcywKICByYW5kRmxvYXQ6IG9zLAogIHJhbmRGbG9hdFNwcmVhZDogaHMsCiAgc2VlZGVkUmFuZG9tOiBjcywKICBkZWdUb1JhZDogbHMsCiAgcmFkVG9EZWc6IHVzLAogIGlzUG93ZXJPZlR3bzogZHMsCiAgY2VpbFBvd2VyT2ZUd286IHlzLAogIGZsb29yUG93ZXJPZlR3bzogbXMsCiAgc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcjogZnMsCiAgbm9ybWFsaXplOiB3cywKICBkZW5vcm1hbGl6ZTogeHMKfTsKY2xhc3MgRiB7CiAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwKSB7CiAgICBGLnByb3RvdHlwZS5pc1ZlY3RvcjIgPSAhMCwgdGhpcy54ID0gdCwgdGhpcy55ID0gZTsKICB9CiAgZ2V0IHdpZHRoKCkgewogICAgcmV0dXJuIHRoaXMueDsKICB9CiAgc2V0IHdpZHRoKHQpIHsKICAgIHRoaXMueCA9IHQ7CiAgfQogIGdldCBoZWlnaHQoKSB7CiAgICByZXR1cm4gdGhpcy55OwogIH0KICBzZXQgaGVpZ2h0KHQpIHsKICAgIHRoaXMueSA9IHQ7CiAgfQogIHNldCh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCwgdGhpcy55ID0gZSwgdGhpczsKICB9CiAgc2V0U2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSB0LCB0aGlzOwogIH0KICBzZXRYKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzOwogIH0KICBzZXRZKHQpIHsKICAgIHJldHVybiB0aGlzLnkgPSB0LCB0aGlzOwogIH0KICBzZXRDb21wb25lbnQodCwgZSkgewogICAgc3dpdGNoICh0KSB7CiAgICAgIGNhc2UgMDoKICAgICAgICB0aGlzLnggPSBlOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDE6CiAgICAgICAgdGhpcy55ID0gZTsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImluZGV4IGlzIG91dCBvZiByYW5nZTogIiArIHQpOwogICAgfQogICAgcmV0dXJuIHRoaXM7CiAgfQogIGdldENvbXBvbmVudCh0KSB7CiAgICBzd2l0Y2ggKHQpIHsKICAgICAgY2FzZSAwOgogICAgICAgIHJldHVybiB0aGlzLng7CiAgICAgIGNhc2UgMToKICAgICAgICByZXR1cm4gdGhpcy55OwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55KTsKICB9CiAgY29weSh0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54LCB0aGlzLnkgPSB0LnksIHRoaXM7CiAgfQogIGFkZCh0KSB7CiAgICByZXR1cm4gdGhpcy54ICs9IHQueCwgdGhpcy55ICs9IHQueSwgdGhpczsKICB9CiAgYWRkU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggKz0gdCwgdGhpcy55ICs9IHQsIHRoaXM7CiAgfQogIGFkZFZlY3RvcnModCwgZSkgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCArIGUueCwgdGhpcy55ID0gdC55ICsgZS55LCB0aGlzOwogIH0KICBhZGRTY2FsZWRWZWN0b3IodCwgZSkgewogICAgcmV0dXJuIHRoaXMueCArPSB0LnggKiBlLCB0aGlzLnkgKz0gdC55ICogZSwgdGhpczsKICB9CiAgc3ViKHQpIHsKICAgIHJldHVybiB0aGlzLnggLT0gdC54LCB0aGlzLnkgLT0gdC55LCB0aGlzOwogIH0KICBzdWJTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCAtPSB0LCB0aGlzLnkgLT0gdCwgdGhpczsKICB9CiAgc3ViVmVjdG9ycyh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54IC0gZS54LCB0aGlzLnkgPSB0LnkgLSBlLnksIHRoaXM7CiAgfQogIG11bHRpcGx5KHQpIHsKICAgIHJldHVybiB0aGlzLnggKj0gdC54LCB0aGlzLnkgKj0gdC55LCB0aGlzOwogIH0KICBtdWx0aXBseVNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54ICo9IHQsIHRoaXMueSAqPSB0LCB0aGlzOwogIH0KICBkaXZpZGUodCkgewogICAgcmV0dXJuIHRoaXMueCAvPSB0LngsIHRoaXMueSAvPSB0LnksIHRoaXM7CiAgfQogIGRpdmlkZVNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gdCk7CiAgfQogIGFwcGx5TWF0cml4Myh0KSB7CiAgICBjb25zdCBlID0gdGhpcy54LCBuID0gdGhpcy55LCBpID0gdC5lbGVtZW50czsKICAgIHJldHVybiB0aGlzLnggPSBpWzBdICogZSArIGlbM10gKiBuICsgaVs2XSwgdGhpcy55ID0gaVsxXSAqIGUgKyBpWzRdICogbiArIGlbN10sIHRoaXM7CiAgfQogIG1pbih0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB0LngpLCB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIHQueSksIHRoaXM7CiAgfQogIG1heCh0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCB0LngpLCB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHQueSksIHRoaXM7CiAgfQogIGNsYW1wKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0LngsIE1hdGgubWluKGUueCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQueSwgTWF0aC5taW4oZS55LCB0aGlzLnkpKSwgdGhpczsKICB9CiAgY2xhbXBTY2FsYXIodCwgZSkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHQsIE1hdGgubWluKGUsIHRoaXMueCkpLCB0aGlzLnkgPSBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCB0aGlzLnkpKSwgdGhpczsKICB9CiAgY2xhbXBMZW5ndGgodCwgZSkgewogICAgY29uc3QgbiA9IHRoaXMubGVuZ3RoKCk7CiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobiB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heCh0LCBNYXRoLm1pbihlLCBuKSkpOwogIH0KICBmbG9vcigpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KSwgdGhpczsKICB9CiAgY2VpbCgpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KSwgdGhpcy55ID0gTWF0aC5jZWlsKHRoaXMueSksIHRoaXM7CiAgfQogIHJvdW5kKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzOwogIH0KICByb3VuZFRvWmVybygpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLnRydW5jKHRoaXMueCksIHRoaXMueSA9IE1hdGgudHJ1bmModGhpcy55KSwgdGhpczsKICB9CiAgbmVnYXRlKCkgewogICAgcmV0dXJuIHRoaXMueCA9IC10aGlzLngsIHRoaXMueSA9IC10aGlzLnksIHRoaXM7CiAgfQogIGRvdCh0KSB7CiAgICByZXR1cm4gdGhpcy54ICogdC54ICsgdGhpcy55ICogdC55OwogIH0KICBjcm9zcyh0KSB7CiAgICByZXR1cm4gdGhpcy54ICogdC55IC0gdGhpcy55ICogdC54OwogIH0KICBsZW5ndGhTcSgpIHsKICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7CiAgfQogIGxlbmd0aCgpIHsKICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTsKICB9CiAgbWFuaGF0dGFuTGVuZ3RoKCkgewogICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCkgKyBNYXRoLmFicyh0aGlzLnkpOwogIH0KICBub3JtYWxpemUoKSB7CiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIodGhpcy5sZW5ndGgoKSB8fCAxKTsKICB9CiAgYW5nbGUoKSB7CiAgICByZXR1cm4gTWF0aC5hdGFuMigtdGhpcy55LCAtdGhpcy54KSArIE1hdGguUEk7CiAgfQogIGFuZ2xlVG8odCkgewogICAgY29uc3QgZSA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFNxKCkgKiB0Lmxlbmd0aFNxKCkpOwogICAgaWYgKGUgPT09IDApCiAgICAgIHJldHVybiBNYXRoLlBJIC8gMjsKICAgIGNvbnN0IG4gPSB0aGlzLmRvdCh0KSAvIGU7CiAgICByZXR1cm4gTWF0aC5hY29zKHRuKG4sIC0xLCAxKSk7CiAgfQogIGRpc3RhbmNlVG8odCkgewogICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHQpKTsKICB9CiAgZGlzdGFuY2VUb1NxdWFyZWQodCkgewogICAgY29uc3QgZSA9IHRoaXMueCAtIHQueCwgbiA9IHRoaXMueSAtIHQueTsKICAgIHJldHVybiBlICogZSArIG4gKiBuOwogIH0KICBtYW5oYXR0YW5EaXN0YW5jZVRvKHQpIHsKICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB0LngpICsgTWF0aC5hYnModGhpcy55IC0gdC55KTsKICB9CiAgc2V0TGVuZ3RoKHQpIHsKICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHQpOwogIH0KICBsZXJwKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggKz0gKHQueCAtIHRoaXMueCkgKiBlLCB0aGlzLnkgKz0gKHQueSAtIHRoaXMueSkgKiBlLCB0aGlzOwogIH0KICBsZXJwVmVjdG9ycyh0LCBlLCBuKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54ICsgKGUueCAtIHQueCkgKiBuLCB0aGlzLnkgPSB0LnkgKyAoZS55IC0gdC55KSAqIG4sIHRoaXM7CiAgfQogIGVxdWFscyh0KSB7CiAgICByZXR1cm4gdC54ID09PSB0aGlzLnggJiYgdC55ID09PSB0aGlzLnk7CiAgfQogIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgcmV0dXJuIHRoaXMueCA9IHRbZV0sIHRoaXMueSA9IHRbZSArIDFdLCB0aGlzOwogIH0KICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgIHJldHVybiB0W2VdID0gdGhpcy54LCB0W2UgKyAxXSA9IHRoaXMueSwgdDsKICB9CiAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC5nZXRYKGUpLCB0aGlzLnkgPSB0LmdldFkoZSksIHRoaXM7CiAgfQogIHJvdGF0ZUFyb3VuZCh0LCBlKSB7CiAgICBjb25zdCBuID0gTWF0aC5jb3MoZSksIGkgPSBNYXRoLnNpbihlKSwgciA9IHRoaXMueCAtIHQueCwgYSA9IHRoaXMueSAtIHQueTsKICAgIHJldHVybiB0aGlzLnggPSByICogbiAtIGEgKiBpICsgdC54LCB0aGlzLnkgPSByICogaSArIGEgKiBuICsgdC55LCB0aGlzOwogIH0KICByYW5kb20oKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yYW5kb20oKSwgdGhpcy55ID0gTWF0aC5yYW5kb20oKSwgdGhpczsKICB9CiAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgeWllbGQgdGhpcy54LCB5aWVsZCB0aGlzLnk7CiAgfQp9CmNsYXNzIEogewogIGNvbnN0cnVjdG9yKHQsIGUsIG4sIGksIHIsIGEsIG8sIGgsIGMpIHsKICAgIEoucHJvdG90eXBlLmlzTWF0cml4MyA9ICEwLCB0aGlzLmVsZW1lbnRzID0gWwogICAgICAxLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAxLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAxCiAgICBdLCB0ICE9PSB2b2lkIDAgJiYgdGhpcy5zZXQodCwgZSwgbiwgaSwgciwgYSwgbywgaCwgYyk7CiAgfQogIHNldCh0LCBlLCBuLCBpLCByLCBhLCBvLCBoLCBjKSB7CiAgICBjb25zdCBsID0gdGhpcy5lbGVtZW50czsKICAgIHJldHVybiBsWzBdID0gdCwgbFsxXSA9IGksIGxbMl0gPSBvLCBsWzNdID0gZSwgbFs0XSA9IHIsIGxbNV0gPSBoLCBsWzZdID0gbiwgbFs3XSA9IGEsIGxbOF0gPSBjLCB0aGlzOwogIH0KICBpZGVudGl0eSgpIHsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgY29weSh0KSB7CiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cywgbiA9IHQuZWxlbWVudHM7CiAgICByZXR1cm4gZVswXSA9IG5bMF0sIGVbMV0gPSBuWzFdLCBlWzJdID0gblsyXSwgZVszXSA9IG5bM10sIGVbNF0gPSBuWzRdLCBlWzVdID0gbls1XSwgZVs2XSA9IG5bNl0sIGVbN10gPSBuWzddLCBlWzhdID0gbls4XSwgdGhpczsKICB9CiAgZXh0cmFjdEJhc2lzKHQsIGUsIG4pIHsKICAgIHJldHVybiB0LnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDApLCBlLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDEpLCBuLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDIpLCB0aGlzOwogIH0KICBzZXRGcm9tTWF0cml4NCh0KSB7CiAgICBjb25zdCBlID0gdC5lbGVtZW50czsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgZVswXSwKICAgICAgZVs0XSwKICAgICAgZVs4XSwKICAgICAgZVsxXSwKICAgICAgZVs1XSwKICAgICAgZVs5XSwKICAgICAgZVsyXSwKICAgICAgZVs2XSwKICAgICAgZVsxMF0KICAgICksIHRoaXM7CiAgfQogIG11bHRpcGx5KHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModGhpcywgdCk7CiAgfQogIHByZW11bHRpcGx5KHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXModCwgdGhpcyk7CiAgfQogIG11bHRpcGx5TWF0cmljZXModCwgZSkgewogICAgY29uc3QgbiA9IHQuZWxlbWVudHMsIGkgPSBlLmVsZW1lbnRzLCByID0gdGhpcy5lbGVtZW50cywgYSA9IG5bMF0sIG8gPSBuWzNdLCBoID0gbls2XSwgYyA9IG5bMV0sIGwgPSBuWzRdLCB1ID0gbls3XSwgZCA9IG5bMl0sIHkgPSBuWzVdLCBmID0gbls4XSwgZyA9IGlbMF0sIF8gPSBpWzNdLCB3ID0gaVs2XSwgeCA9IGlbMV0sIG0gPSBpWzRdLCBNID0gaVs3XSwgeiA9IGlbMl0sIFAgPSBpWzVdLCBUID0gaVs4XTsKICAgIHJldHVybiByWzBdID0gYSAqIGcgKyBvICogeCArIGggKiB6LCByWzNdID0gYSAqIF8gKyBvICogbSArIGggKiBQLCByWzZdID0gYSAqIHcgKyBvICogTSArIGggKiBULCByWzFdID0gYyAqIGcgKyBsICogeCArIHUgKiB6LCByWzRdID0gYyAqIF8gKyBsICogbSArIHUgKiBQLCByWzddID0gYyAqIHcgKyBsICogTSArIHUgKiBULCByWzJdID0gZCAqIGcgKyB5ICogeCArIGYgKiB6LCByWzVdID0gZCAqIF8gKyB5ICogbSArIGYgKiBQLCByWzhdID0gZCAqIHcgKyB5ICogTSArIGYgKiBULCB0aGlzOwogIH0KICBtdWx0aXBseVNjYWxhcih0KSB7CiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgIHJldHVybiBlWzBdICo9IHQsIGVbM10gKj0gdCwgZVs2XSAqPSB0LCBlWzFdICo9IHQsIGVbNF0gKj0gdCwgZVs3XSAqPSB0LCBlWzJdICo9IHQsIGVbNV0gKj0gdCwgZVs4XSAqPSB0LCB0aGlzOwogIH0KICBkZXRlcm1pbmFudCgpIHsKICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzLCBlID0gdFswXSwgbiA9IHRbMV0sIGkgPSB0WzJdLCByID0gdFszXSwgYSA9IHRbNF0sIG8gPSB0WzVdLCBoID0gdFs2XSwgYyA9IHRbN10sIGwgPSB0WzhdOwogICAgcmV0dXJuIGUgKiBhICogbCAtIGUgKiBvICogYyAtIG4gKiByICogbCArIG4gKiBvICogaCArIGkgKiByICogYyAtIGkgKiBhICogaDsKICB9CiAgaW52ZXJ0KCkgewogICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIGUgPSB0WzBdLCBuID0gdFsxXSwgaSA9IHRbMl0sIHIgPSB0WzNdLCBhID0gdFs0XSwgbyA9IHRbNV0sIGggPSB0WzZdLCBjID0gdFs3XSwgbCA9IHRbOF0sIHUgPSBsICogYSAtIG8gKiBjLCBkID0gbyAqIGggLSBsICogciwgeSA9IGMgKiByIC0gYSAqIGgsIGYgPSBlICogdSArIG4gKiBkICsgaSAqIHk7CiAgICBpZiAoZiA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApOwogICAgY29uc3QgZyA9IDEgLyBmOwogICAgcmV0dXJuIHRbMF0gPSB1ICogZywgdFsxXSA9IChpICogYyAtIGwgKiBuKSAqIGcsIHRbMl0gPSAobyAqIG4gLSBpICogYSkgKiBnLCB0WzNdID0gZCAqIGcsIHRbNF0gPSAobCAqIGUgLSBpICogaCkgKiBnLCB0WzVdID0gKGkgKiByIC0gbyAqIGUpICogZywgdFs2XSA9IHkgKiBnLCB0WzddID0gKG4gKiBoIC0gYyAqIGUpICogZywgdFs4XSA9IChhICogZSAtIG4gKiByKSAqIGcsIHRoaXM7CiAgfQogIHRyYW5zcG9zZSgpIHsKICAgIGxldCB0OwogICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICByZXR1cm4gdCA9IGVbMV0sIGVbMV0gPSBlWzNdLCBlWzNdID0gdCwgdCA9IGVbMl0sIGVbMl0gPSBlWzZdLCBlWzZdID0gdCwgdCA9IGVbNV0sIGVbNV0gPSBlWzddLCBlWzddID0gdCwgdGhpczsKICB9CiAgZ2V0Tm9ybWFsTWF0cml4KHQpIHsKICAgIHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KHQpLmludmVydCgpLnRyYW5zcG9zZSgpOwogIH0KICB0cmFuc3Bvc2VJbnRvQXJyYXkodCkgewogICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICByZXR1cm4gdFswXSA9IGVbMF0sIHRbMV0gPSBlWzNdLCB0WzJdID0gZVs2XSwgdFszXSA9IGVbMV0sIHRbNF0gPSBlWzRdLCB0WzVdID0gZVs3XSwgdFs2XSA9IGVbMl0sIHRbN10gPSBlWzVdLCB0WzhdID0gZVs4XSwgdGhpczsKICB9CiAgc2V0VXZUcmFuc2Zvcm0odCwgZSwgbiwgaSwgciwgYSwgbykgewogICAgY29uc3QgaCA9IE1hdGguY29zKHIpLCBjID0gTWF0aC5zaW4ocik7CiAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgIG4gKiBoLAogICAgICBuICogYywKICAgICAgLW4gKiAoaCAqIGEgKyBjICogbykgKyBhICsgdCwKICAgICAgLWkgKiBjLAogICAgICBpICogaCwKICAgICAgLWkgKiAoLWMgKiBhICsgaCAqIG8pICsgbyArIGUsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICksIHRoaXM7CiAgfQogIHNjYWxlKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnByZW11bHRpcGx5KHJuLm1ha2VTY2FsZSh0LCBlKSksIHRoaXM7CiAgfQogIHJvdGF0ZSh0KSB7CiAgICByZXR1cm4gdGhpcy5wcmVtdWx0aXBseShybi5tYWtlUm90YXRpb24oLXQpKSwgdGhpczsKICB9CiAgdHJhbnNsYXRlKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnByZW11bHRpcGx5KHJuLm1ha2VUcmFuc2xhdGlvbih0LCBlKSksIHRoaXM7CiAgfQogIG1ha2VUcmFuc2xhdGlvbih0LCBlKSB7CiAgICByZXR1cm4gdC5pc1ZlY3RvcjIgPyB0aGlzLnNldCgKICAgICAgMSwKICAgICAgMCwKICAgICAgdC54LAogICAgICAwLAogICAgICAxLAogICAgICB0LnksCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICkgOiB0aGlzLnNldCgKICAgICAgMSwKICAgICAgMCwKICAgICAgdCwKICAgICAgMCwKICAgICAgMSwKICAgICAgZSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgbWFrZVJvdGF0aW9uKHQpIHsKICAgIGNvbnN0IGUgPSBNYXRoLmNvcyh0KSwgbiA9IE1hdGguc2luKHQpOwogICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICBlLAogICAgICAtbiwKICAgICAgMCwKICAgICAgbiwKICAgICAgZSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgbWFrZVNjYWxlKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgdCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgZSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgZXF1YWxzKHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBuID0gdC5lbGVtZW50czsKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKQogICAgICBpZiAoZVtpXSAhPT0gbltpXSkKICAgICAgICByZXR1cm4gITE7CiAgICByZXR1cm4gITA7CiAgfQogIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgZm9yIChsZXQgbiA9IDA7IG4gPCA5OyBuKyspCiAgICAgIHRoaXMuZWxlbWVudHNbbl0gPSB0W24gKyBlXTsKICAgIHJldHVybiB0aGlzOwogIH0KICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgIGNvbnN0IG4gPSB0aGlzLmVsZW1lbnRzOwogICAgcmV0dXJuIHRbZV0gPSBuWzBdLCB0W2UgKyAxXSA9IG5bMV0sIHRbZSArIDJdID0gblsyXSwgdFtlICsgM10gPSBuWzNdLCB0W2UgKyA0XSA9IG5bNF0sIHRbZSArIDVdID0gbls1XSwgdFtlICsgNl0gPSBuWzZdLCB0W2UgKyA3XSA9IG5bN10sIHRbZSArIDhdID0gbls4XSwgdDsKICB9CiAgY2xvbmUoKSB7CiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkodGhpcy5lbGVtZW50cyk7CiAgfQp9CmNvbnN0IHJuID0gLyogQF9fUFVSRV9fICovIG5ldyBKKCk7CmNsYXNzIG10IHsKICBjb25zdHJ1Y3Rvcih0ID0gMCwgZSA9IDAsIG4gPSAwLCBpID0gMSkgewogICAgbXQucHJvdG90eXBlLmlzVmVjdG9yNCA9ICEwLCB0aGlzLnggPSB0LCB0aGlzLnkgPSBlLCB0aGlzLnogPSBuLCB0aGlzLncgPSBpOwogIH0KICBnZXQgd2lkdGgoKSB7CiAgICByZXR1cm4gdGhpcy56OwogIH0KICBzZXQgd2lkdGgodCkgewogICAgdGhpcy56ID0gdDsKICB9CiAgZ2V0IGhlaWdodCgpIHsKICAgIHJldHVybiB0aGlzLnc7CiAgfQogIHNldCBoZWlnaHQodCkgewogICAgdGhpcy53ID0gdDsKICB9CiAgc2V0KHQsIGUsIG4sIGkpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSBlLCB0aGlzLnogPSBuLCB0aGlzLncgPSBpLCB0aGlzOwogIH0KICBzZXRTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQsIHRoaXMueSA9IHQsIHRoaXMueiA9IHQsIHRoaXMudyA9IHQsIHRoaXM7CiAgfQogIHNldFgodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQsIHRoaXM7CiAgfQogIHNldFkodCkgewogICAgcmV0dXJuIHRoaXMueSA9IHQsIHRoaXM7CiAgfQogIHNldFoodCkgewogICAgcmV0dXJuIHRoaXMueiA9IHQsIHRoaXM7CiAgfQogIHNldFcodCkgewogICAgcmV0dXJuIHRoaXMudyA9IHQsIHRoaXM7CiAgfQogIHNldENvbXBvbmVudCh0LCBlKSB7CiAgICBzd2l0Y2ggKHQpIHsKICAgICAgY2FzZSAwOgogICAgICAgIHRoaXMueCA9IGU7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMToKICAgICAgICB0aGlzLnkgPSBlOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDI6CiAgICAgICAgdGhpcy56ID0gZTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAzOgogICAgICAgIHRoaXMudyA9IGU7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgIH0KICAgIHJldHVybiB0aGlzOwogIH0KICBnZXRDb21wb25lbnQodCkgewogICAgc3dpdGNoICh0KSB7CiAgICAgIGNhc2UgMDoKICAgICAgICByZXR1cm4gdGhpcy54OwogICAgICBjYXNlIDE6CiAgICAgICAgcmV0dXJuIHRoaXMueTsKICAgICAgY2FzZSAyOgogICAgICAgIHJldHVybiB0aGlzLno7CiAgICAgIGNhc2UgMzoKICAgICAgICByZXR1cm4gdGhpcy53OwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7CiAgfQogIGNvcHkodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55LCB0aGlzLnogPSB0LnosIHRoaXMudyA9IHQudyAhPT0gdm9pZCAwID8gdC53IDogMSwgdGhpczsKICB9CiAgYWRkKHQpIHsKICAgIHJldHVybiB0aGlzLnggKz0gdC54LCB0aGlzLnkgKz0gdC55LCB0aGlzLnogKz0gdC56LCB0aGlzLncgKz0gdC53LCB0aGlzOwogIH0KICBhZGRTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCArPSB0LCB0aGlzLnkgKz0gdCwgdGhpcy56ICs9IHQsIHRoaXMudyArPSB0LCB0aGlzOwogIH0KICBhZGRWZWN0b3JzKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggKyBlLngsIHRoaXMueSA9IHQueSArIGUueSwgdGhpcy56ID0gdC56ICsgZS56LCB0aGlzLncgPSB0LncgKyBlLncsIHRoaXM7CiAgfQogIGFkZFNjYWxlZFZlY3Rvcih0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ICs9IHQueCAqIGUsIHRoaXMueSArPSB0LnkgKiBlLCB0aGlzLnogKz0gdC56ICogZSwgdGhpcy53ICs9IHQudyAqIGUsIHRoaXM7CiAgfQogIHN1Yih0KSB7CiAgICByZXR1cm4gdGhpcy54IC09IHQueCwgdGhpcy55IC09IHQueSwgdGhpcy56IC09IHQueiwgdGhpcy53IC09IHQudywgdGhpczsKICB9CiAgc3ViU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggLT0gdCwgdGhpcy55IC09IHQsIHRoaXMueiAtPSB0LCB0aGlzLncgLT0gdCwgdGhpczsKICB9CiAgc3ViVmVjdG9ycyh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54IC0gZS54LCB0aGlzLnkgPSB0LnkgLSBlLnksIHRoaXMueiA9IHQueiAtIGUueiwgdGhpcy53ID0gdC53IC0gZS53LCB0aGlzOwogIH0KICBtdWx0aXBseSh0KSB7CiAgICByZXR1cm4gdGhpcy54ICo9IHQueCwgdGhpcy55ICo9IHQueSwgdGhpcy56ICo9IHQueiwgdGhpcy53ICo9IHQudywgdGhpczsKICB9CiAgbXVsdGlwbHlTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCAqPSB0LCB0aGlzLnkgKj0gdCwgdGhpcy56ICo9IHQsIHRoaXMudyAqPSB0LCB0aGlzOwogIH0KICBhcHBseU1hdHJpeDQodCkgewogICAgY29uc3QgZSA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgciA9IHRoaXMudywgYSA9IHQuZWxlbWVudHM7CiAgICByZXR1cm4gdGhpcy54ID0gYVswXSAqIGUgKyBhWzRdICogbiArIGFbOF0gKiBpICsgYVsxMl0gKiByLCB0aGlzLnkgPSBhWzFdICogZSArIGFbNV0gKiBuICsgYVs5XSAqIGkgKyBhWzEzXSAqIHIsIHRoaXMueiA9IGFbMl0gKiBlICsgYVs2XSAqIG4gKyBhWzEwXSAqIGkgKyBhWzE0XSAqIHIsIHRoaXMudyA9IGFbM10gKiBlICsgYVs3XSAqIG4gKyBhWzExXSAqIGkgKyBhWzE1XSAqIHIsIHRoaXM7CiAgfQogIGRpdmlkZVNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcigxIC8gdCk7CiAgfQogIHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uKHQpIHsKICAgIHRoaXMudyA9IDIgKiBNYXRoLmFjb3ModC53KTsKICAgIGNvbnN0IGUgPSBNYXRoLnNxcnQoMSAtIHQudyAqIHQudyk7CiAgICByZXR1cm4gZSA8IDFlLTQgPyAodGhpcy54ID0gMSwgdGhpcy55ID0gMCwgdGhpcy56ID0gMCkgOiAodGhpcy54ID0gdC54IC8gZSwgdGhpcy55ID0gdC55IC8gZSwgdGhpcy56ID0gdC56IC8gZSksIHRoaXM7CiAgfQogIHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeCh0KSB7CiAgICBsZXQgZSwgbiwgaSwgcjsKICAgIGNvbnN0IGggPSB0LmVsZW1lbnRzLCBjID0gaFswXSwgbCA9IGhbNF0sIHUgPSBoWzhdLCBkID0gaFsxXSwgeSA9IGhbNV0sIGYgPSBoWzldLCBnID0gaFsyXSwgXyA9IGhbNl0sIHcgPSBoWzEwXTsKICAgIGlmIChNYXRoLmFicyhsIC0gZCkgPCAwLjAxICYmIE1hdGguYWJzKHUgLSBnKSA8IDAuMDEgJiYgTWF0aC5hYnMoZiAtIF8pIDwgMC4wMSkgewogICAgICBpZiAoTWF0aC5hYnMobCArIGQpIDwgMC4xICYmIE1hdGguYWJzKHUgKyBnKSA8IDAuMSAmJiBNYXRoLmFicyhmICsgXykgPCAwLjEgJiYgTWF0aC5hYnMoYyArIHkgKyB3IC0gMykgPCAwLjEpCiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KDEsIDAsIDAsIDApLCB0aGlzOwogICAgICBlID0gTWF0aC5QSTsKICAgICAgY29uc3QgbSA9IChjICsgMSkgLyAyLCBNID0gKHkgKyAxKSAvIDIsIHogPSAodyArIDEpIC8gMiwgUCA9IChsICsgZCkgLyA0LCBUID0gKHUgKyBnKSAvIDQsIGIgPSAoZiArIF8pIC8gNDsKICAgICAgcmV0dXJuIG0gPiBNICYmIG0gPiB6ID8gbSA8IDAuMDEgPyAobiA9IDAsIGkgPSAwLjcwNzEwNjc4MSwgciA9IDAuNzA3MTA2NzgxKSA6IChuID0gTWF0aC5zcXJ0KG0pLCBpID0gUCAvIG4sIHIgPSBUIC8gbikgOiBNID4geiA/IE0gPCAwLjAxID8gKG4gPSAwLjcwNzEwNjc4MSwgaSA9IDAsIHIgPSAwLjcwNzEwNjc4MSkgOiAoaSA9IE1hdGguc3FydChNKSwgbiA9IFAgLyBpLCByID0gYiAvIGkpIDogeiA8IDAuMDEgPyAobiA9IDAuNzA3MTA2NzgxLCBpID0gMC43MDcxMDY3ODEsIHIgPSAwKSA6IChyID0gTWF0aC5zcXJ0KHopLCBuID0gVCAvIHIsIGkgPSBiIC8gciksIHRoaXMuc2V0KG4sIGksIHIsIGUpLCB0aGlzOwogICAgfQogICAgbGV0IHggPSBNYXRoLnNxcnQoKF8gLSBmKSAqIChfIC0gZikgKyAodSAtIGcpICogKHUgLSBnKSArIChkIC0gbCkgKiAoZCAtIGwpKTsKICAgIHJldHVybiBNYXRoLmFicyh4KSA8IDFlLTMgJiYgKHggPSAxKSwgdGhpcy54ID0gKF8gLSBmKSAvIHgsIHRoaXMueSA9ICh1IC0gZykgLyB4LCB0aGlzLnogPSAoZCAtIGwpIC8geCwgdGhpcy53ID0gTWF0aC5hY29zKChjICsgeSArIHcgLSAxKSAvIDIpLCB0aGlzOwogIH0KICBtaW4odCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgdC54KSwgdGhpcy55ID0gTWF0aC5taW4odGhpcy55LCB0LnkpLCB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIHQueiksIHRoaXMudyA9IE1hdGgubWluKHRoaXMudywgdC53KSwgdGhpczsKICB9CiAgbWF4KHQpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIHQueCksIHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgdC55KSwgdGhpcy56ID0gTWF0aC5tYXgodGhpcy56LCB0LnopLCB0aGlzLncgPSBNYXRoLm1heCh0aGlzLncsIHQudyksIHRoaXM7CiAgfQogIGNsYW1wKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0LngsIE1hdGgubWluKGUueCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQueSwgTWF0aC5taW4oZS55LCB0aGlzLnkpKSwgdGhpcy56ID0gTWF0aC5tYXgodC56LCBNYXRoLm1pbihlLnosIHRoaXMueikpLCB0aGlzLncgPSBNYXRoLm1heCh0LncsIE1hdGgubWluKGUudywgdGhpcy53KSksIHRoaXM7CiAgfQogIGNsYW1wU2NhbGFyKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCB0aGlzLngpKSwgdGhpcy55ID0gTWF0aC5tYXgodCwgTWF0aC5taW4oZSwgdGhpcy55KSksIHRoaXMueiA9IE1hdGgubWF4KHQsIE1hdGgubWluKGUsIHRoaXMueikpLCB0aGlzLncgPSBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCB0aGlzLncpKSwgdGhpczsKICB9CiAgY2xhbXBMZW5ndGgodCwgZSkgewogICAgY29uc3QgbiA9IHRoaXMubGVuZ3RoKCk7CiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobiB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heCh0LCBNYXRoLm1pbihlLCBuKSkpOwogIH0KICBmbG9vcigpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56ID0gTWF0aC5mbG9vcih0aGlzLnopLCB0aGlzLncgPSBNYXRoLmZsb29yKHRoaXMudyksIHRoaXM7CiAgfQogIGNlaWwoKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCksIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLmNlaWwodGhpcy56KSwgdGhpcy53ID0gTWF0aC5jZWlsKHRoaXMudyksIHRoaXM7CiAgfQogIHJvdW5kKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueiksIHRoaXMudyA9IE1hdGgucm91bmQodGhpcy53KSwgdGhpczsKICB9CiAgcm91bmRUb1plcm8oKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC50cnVuYyh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLnRydW5jKHRoaXMueSksIHRoaXMueiA9IE1hdGgudHJ1bmModGhpcy56KSwgdGhpcy53ID0gTWF0aC50cnVuYyh0aGlzLncpLCB0aGlzOwogIH0KICBuZWdhdGUoKSB7CiAgICByZXR1cm4gdGhpcy54ID0gLXRoaXMueCwgdGhpcy55ID0gLXRoaXMueSwgdGhpcy56ID0gLXRoaXMueiwgdGhpcy53ID0gLXRoaXMudywgdGhpczsKICB9CiAgZG90KHQpIHsKICAgIHJldHVybiB0aGlzLnggKiB0LnggKyB0aGlzLnkgKiB0LnkgKyB0aGlzLnogKiB0LnogKyB0aGlzLncgKiB0Lnc7CiAgfQogIGxlbmd0aFNxKCkgewogICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudzsKICB9CiAgbGVuZ3RoKCkgewogICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpOwogIH0KICBtYW5oYXR0YW5MZW5ndGgoKSB7CiAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSkgKyBNYXRoLmFicyh0aGlzLnopICsgTWF0aC5hYnModGhpcy53KTsKICB9CiAgbm9ybWFsaXplKCkgewogICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7CiAgfQogIHNldExlbmd0aCh0KSB7CiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih0KTsKICB9CiAgbGVycCh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ICs9ICh0LnggLSB0aGlzLngpICogZSwgdGhpcy55ICs9ICh0LnkgLSB0aGlzLnkpICogZSwgdGhpcy56ICs9ICh0LnogLSB0aGlzLnopICogZSwgdGhpcy53ICs9ICh0LncgLSB0aGlzLncpICogZSwgdGhpczsKICB9CiAgbGVycFZlY3RvcnModCwgZSwgbikgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCArIChlLnggLSB0LngpICogbiwgdGhpcy55ID0gdC55ICsgKGUueSAtIHQueSkgKiBuLCB0aGlzLnogPSB0LnogKyAoZS56IC0gdC56KSAqIG4sIHRoaXMudyA9IHQudyArIChlLncgLSB0LncpICogbiwgdGhpczsKICB9CiAgZXF1YWxzKHQpIHsKICAgIHJldHVybiB0LnggPT09IHRoaXMueCAmJiB0LnkgPT09IHRoaXMueSAmJiB0LnogPT09IHRoaXMueiAmJiB0LncgPT09IHRoaXMudzsKICB9CiAgZnJvbUFycmF5KHQsIGUgPSAwKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdFtlXSwgdGhpcy55ID0gdFtlICsgMV0sIHRoaXMueiA9IHRbZSArIDJdLCB0aGlzLncgPSB0W2UgKyAzXSwgdGhpczsKICB9CiAgdG9BcnJheSh0ID0gW10sIGUgPSAwKSB7CiAgICByZXR1cm4gdFtlXSA9IHRoaXMueCwgdFtlICsgMV0gPSB0aGlzLnksIHRbZSArIDJdID0gdGhpcy56LCB0W2UgKyAzXSA9IHRoaXMudywgdDsKICB9CiAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC5nZXRYKGUpLCB0aGlzLnkgPSB0LmdldFkoZSksIHRoaXMueiA9IHQuZ2V0WihlKSwgdGhpcy53ID0gdC5nZXRXKGUpLCB0aGlzOwogIH0KICByYW5kb20oKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yYW5kb20oKSwgdGhpcy55ID0gTWF0aC5yYW5kb20oKSwgdGhpcy56ID0gTWF0aC5yYW5kb20oKSwgdGhpcy53ID0gTWF0aC5yYW5kb20oKSwgdGhpczsKICB9CiAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgeWllbGQgdGhpcy54LCB5aWVsZCB0aGlzLnksIHlpZWxkIHRoaXMueiwgeWllbGQgdGhpcy53OwogIH0KfQpjbGFzcyBYdCB7CiAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwLCBuID0gMCwgaSA9IDEpIHsKICAgIHRoaXMuaXNRdWF0ZXJuaW9uID0gITAsIHRoaXMuX3ggPSB0LCB0aGlzLl95ID0gZSwgdGhpcy5feiA9IG4sIHRoaXMuX3cgPSBpOwogIH0KICBzdGF0aWMgc2xlcnBGbGF0KHQsIGUsIG4sIGksIHIsIGEsIG8pIHsKICAgIGxldCBoID0gbltpICsgMF0sIGMgPSBuW2kgKyAxXSwgbCA9IG5baSArIDJdLCB1ID0gbltpICsgM107CiAgICBjb25zdCBkID0gclthICsgMF0sIHkgPSByW2EgKyAxXSwgZiA9IHJbYSArIDJdLCBnID0gclthICsgM107CiAgICBpZiAobyA9PT0gMCkgewogICAgICB0W2UgKyAwXSA9IGgsIHRbZSArIDFdID0gYywgdFtlICsgMl0gPSBsLCB0W2UgKyAzXSA9IHU7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmIChvID09PSAxKSB7CiAgICAgIHRbZSArIDBdID0gZCwgdFtlICsgMV0gPSB5LCB0W2UgKyAyXSA9IGYsIHRbZSArIDNdID0gZzsKICAgICAgcmV0dXJuOwogICAgfQogICAgaWYgKHUgIT09IGcgfHwgaCAhPT0gZCB8fCBjICE9PSB5IHx8IGwgIT09IGYpIHsKICAgICAgbGV0IF8gPSAxIC0gbzsKICAgICAgY29uc3QgdyA9IGggKiBkICsgYyAqIHkgKyBsICogZiArIHUgKiBnLCB4ID0gdyA+PSAwID8gMSA6IC0xLCBtID0gMSAtIHcgKiB3OwogICAgICBpZiAobSA+IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgY29uc3QgeiA9IE1hdGguc3FydChtKSwgUCA9IE1hdGguYXRhbjIoeiwgdyAqIHgpOwogICAgICAgIF8gPSBNYXRoLnNpbihfICogUCkgLyB6LCBvID0gTWF0aC5zaW4obyAqIFApIC8gejsKICAgICAgfQogICAgICBjb25zdCBNID0gbyAqIHg7CiAgICAgIGlmIChoID0gaCAqIF8gKyBkICogTSwgYyA9IGMgKiBfICsgeSAqIE0sIGwgPSBsICogXyArIGYgKiBNLCB1ID0gdSAqIF8gKyBnICogTSwgXyA9PT0gMSAtIG8pIHsKICAgICAgICBjb25zdCB6ID0gMSAvIE1hdGguc3FydChoICogaCArIGMgKiBjICsgbCAqIGwgKyB1ICogdSk7CiAgICAgICAgaCAqPSB6LCBjICo9IHosIGwgKj0geiwgdSAqPSB6OwogICAgICB9CiAgICB9CiAgICB0W2VdID0gaCwgdFtlICsgMV0gPSBjLCB0W2UgKyAyXSA9IGwsIHRbZSArIDNdID0gdTsKICB9CiAgc3RhdGljIG11bHRpcGx5UXVhdGVybmlvbnNGbGF0KHQsIGUsIG4sIGksIHIsIGEpIHsKICAgIGNvbnN0IG8gPSBuW2ldLCBoID0gbltpICsgMV0sIGMgPSBuW2kgKyAyXSwgbCA9IG5baSArIDNdLCB1ID0gclthXSwgZCA9IHJbYSArIDFdLCB5ID0gclthICsgMl0sIGYgPSByW2EgKyAzXTsKICAgIHJldHVybiB0W2VdID0gbyAqIGYgKyBsICogdSArIGggKiB5IC0gYyAqIGQsIHRbZSArIDFdID0gaCAqIGYgKyBsICogZCArIGMgKiB1IC0gbyAqIHksIHRbZSArIDJdID0gYyAqIGYgKyBsICogeSArIG8gKiBkIC0gaCAqIHUsIHRbZSArIDNdID0gbCAqIGYgLSBvICogdSAtIGggKiBkIC0gYyAqIHksIHQ7CiAgfQogIGdldCB4KCkgewogICAgcmV0dXJuIHRoaXMuX3g7CiAgfQogIHNldCB4KHQpIHsKICAgIHRoaXMuX3ggPSB0LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7CiAgfQogIGdldCB5KCkgewogICAgcmV0dXJuIHRoaXMuX3k7CiAgfQogIHNldCB5KHQpIHsKICAgIHRoaXMuX3kgPSB0LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7CiAgfQogIGdldCB6KCkgewogICAgcmV0dXJuIHRoaXMuX3o7CiAgfQogIHNldCB6KHQpIHsKICAgIHRoaXMuX3ogPSB0LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7CiAgfQogIGdldCB3KCkgewogICAgcmV0dXJuIHRoaXMuX3c7CiAgfQogIHNldCB3KHQpIHsKICAgIHRoaXMuX3cgPSB0LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7CiAgfQogIHNldCh0LCBlLCBuLCBpKSB7CiAgICByZXR1cm4gdGhpcy5feCA9IHQsIHRoaXMuX3kgPSBlLCB0aGlzLl96ID0gbiwgdGhpcy5fdyA9IGksIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgY2xvbmUoKSB7CiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyk7CiAgfQogIGNvcHkodCkgewogICAgcmV0dXJuIHRoaXMuX3ggPSB0LngsIHRoaXMuX3kgPSB0LnksIHRoaXMuX3ogPSB0LnosIHRoaXMuX3cgPSB0LncsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgc2V0RnJvbUV1bGVyKHQsIGUpIHsKICAgIGNvbnN0IG4gPSB0Ll94LCBpID0gdC5feSwgciA9IHQuX3osIGEgPSB0Ll9vcmRlciwgbyA9IE1hdGguY29zLCBoID0gTWF0aC5zaW4sIGMgPSBvKG4gLyAyKSwgbCA9IG8oaSAvIDIpLCB1ID0gbyhyIC8gMiksIGQgPSBoKG4gLyAyKSwgeSA9IGgoaSAvIDIpLCBmID0gaChyIC8gMik7CiAgICBzd2l0Y2ggKGEpIHsKICAgICAgY2FzZSAiWFlaIjoKICAgICAgICB0aGlzLl94ID0gZCAqIGwgKiB1ICsgYyAqIHkgKiBmLCB0aGlzLl95ID0gYyAqIHkgKiB1IC0gZCAqIGwgKiBmLCB0aGlzLl96ID0gYyAqIGwgKiBmICsgZCAqIHkgKiB1LCB0aGlzLl93ID0gYyAqIGwgKiB1IC0gZCAqIHkgKiBmOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJZWFoiOgogICAgICAgIHRoaXMuX3ggPSBkICogbCAqIHUgKyBjICogeSAqIGYsIHRoaXMuX3kgPSBjICogeSAqIHUgLSBkICogbCAqIGYsIHRoaXMuX3ogPSBjICogbCAqIGYgLSBkICogeSAqIHUsIHRoaXMuX3cgPSBjICogbCAqIHUgKyBkICogeSAqIGY7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlpYWSI6CiAgICAgICAgdGhpcy5feCA9IGQgKiBsICogdSAtIGMgKiB5ICogZiwgdGhpcy5feSA9IGMgKiB5ICogdSArIGQgKiBsICogZiwgdGhpcy5feiA9IGMgKiBsICogZiArIGQgKiB5ICogdSwgdGhpcy5fdyA9IGMgKiBsICogdSAtIGQgKiB5ICogZjsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiWllYIjoKICAgICAgICB0aGlzLl94ID0gZCAqIGwgKiB1IC0gYyAqIHkgKiBmLCB0aGlzLl95ID0gYyAqIHkgKiB1ICsgZCAqIGwgKiBmLCB0aGlzLl96ID0gYyAqIGwgKiBmIC0gZCAqIHkgKiB1LCB0aGlzLl93ID0gYyAqIGwgKiB1ICsgZCAqIHkgKiBmOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJZWlgiOgogICAgICAgIHRoaXMuX3ggPSBkICogbCAqIHUgKyBjICogeSAqIGYsIHRoaXMuX3kgPSBjICogeSAqIHUgKyBkICogbCAqIGYsIHRoaXMuX3ogPSBjICogbCAqIGYgLSBkICogeSAqIHUsIHRoaXMuX3cgPSBjICogbCAqIHUgLSBkICogeSAqIGY7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlhaWSI6CiAgICAgICAgdGhpcy5feCA9IGQgKiBsICogdSAtIGMgKiB5ICogZiwgdGhpcy5feSA9IGMgKiB5ICogdSAtIGQgKiBsICogZiwgdGhpcy5feiA9IGMgKiBsICogZiArIGQgKiB5ICogdSwgdGhpcy5fdyA9IGMgKiBsICogdSArIGQgKiB5ICogZjsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICBjb25zb2xlLndhcm4oIlRIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiICsgYSk7CiAgICB9CiAgICByZXR1cm4gZSAhPT0gITEgJiYgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBzZXRGcm9tQXhpc0FuZ2xlKHQsIGUpIHsKICAgIGNvbnN0IG4gPSBlIC8gMiwgaSA9IE1hdGguc2luKG4pOwogICAgcmV0dXJuIHRoaXMuX3ggPSB0LnggKiBpLCB0aGlzLl95ID0gdC55ICogaSwgdGhpcy5feiA9IHQueiAqIGksIHRoaXMuX3cgPSBNYXRoLmNvcyhuKSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBzZXRGcm9tUm90YXRpb25NYXRyaXgodCkgewogICAgY29uc3QgZSA9IHQuZWxlbWVudHMsIG4gPSBlWzBdLCBpID0gZVs0XSwgciA9IGVbOF0sIGEgPSBlWzFdLCBvID0gZVs1XSwgaCA9IGVbOV0sIGMgPSBlWzJdLCBsID0gZVs2XSwgdSA9IGVbMTBdLCBkID0gbiArIG8gKyB1OwogICAgaWYgKGQgPiAwKSB7CiAgICAgIGNvbnN0IHkgPSAwLjUgLyBNYXRoLnNxcnQoZCArIDEpOwogICAgICB0aGlzLl93ID0gMC4yNSAvIHksIHRoaXMuX3ggPSAobCAtIGgpICogeSwgdGhpcy5feSA9IChyIC0gYykgKiB5LCB0aGlzLl96ID0gKGEgLSBpKSAqIHk7CiAgICB9IGVsc2UgaWYgKG4gPiBvICYmIG4gPiB1KSB7CiAgICAgIGNvbnN0IHkgPSAyICogTWF0aC5zcXJ0KDEgKyBuIC0gbyAtIHUpOwogICAgICB0aGlzLl93ID0gKGwgLSBoKSAvIHksIHRoaXMuX3ggPSAwLjI1ICogeSwgdGhpcy5feSA9IChpICsgYSkgLyB5LCB0aGlzLl96ID0gKHIgKyBjKSAvIHk7CiAgICB9IGVsc2UgaWYgKG8gPiB1KSB7CiAgICAgIGNvbnN0IHkgPSAyICogTWF0aC5zcXJ0KDEgKyBvIC0gbiAtIHUpOwogICAgICB0aGlzLl93ID0gKHIgLSBjKSAvIHksIHRoaXMuX3ggPSAoaSArIGEpIC8geSwgdGhpcy5feSA9IDAuMjUgKiB5LCB0aGlzLl96ID0gKGggKyBsKSAvIHk7CiAgICB9IGVsc2UgewogICAgICBjb25zdCB5ID0gMiAqIE1hdGguc3FydCgxICsgdSAtIG4gLSBvKTsKICAgICAgdGhpcy5fdyA9IChhIC0gaSkgLyB5LCB0aGlzLl94ID0gKHIgKyBjKSAvIHksIHRoaXMuX3kgPSAoaCArIGwpIC8geSwgdGhpcy5feiA9IDAuMjUgKiB5OwogICAgfQogICAgcmV0dXJuIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgc2V0RnJvbVVuaXRWZWN0b3JzKHQsIGUpIHsKICAgIGxldCBuID0gdC5kb3QoZSkgKyAxOwogICAgcmV0dXJuIG4gPCBOdW1iZXIuRVBTSUxPTiA/IChuID0gMCwgTWF0aC5hYnModC54KSA+IE1hdGguYWJzKHQueikgPyAodGhpcy5feCA9IC10LnksIHRoaXMuX3kgPSB0LngsIHRoaXMuX3ogPSAwLCB0aGlzLl93ID0gbikgOiAodGhpcy5feCA9IDAsIHRoaXMuX3kgPSAtdC56LCB0aGlzLl96ID0gdC55LCB0aGlzLl93ID0gbikpIDogKHRoaXMuX3ggPSB0LnkgKiBlLnogLSB0LnogKiBlLnksIHRoaXMuX3kgPSB0LnogKiBlLnggLSB0LnggKiBlLnosIHRoaXMuX3ogPSB0LnggKiBlLnkgLSB0LnkgKiBlLngsIHRoaXMuX3cgPSBuKSwgdGhpcy5ub3JtYWxpemUoKTsKICB9CiAgYW5nbGVUbyh0KSB7CiAgICByZXR1cm4gMiAqIE1hdGguYWNvcyhNYXRoLmFicyh0bih0aGlzLmRvdCh0KSwgLTEsIDEpKSk7CiAgfQogIHJvdGF0ZVRvd2FyZHModCwgZSkgewogICAgY29uc3QgbiA9IHRoaXMuYW5nbGVUbyh0KTsKICAgIGlmIChuID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGNvbnN0IGkgPSBNYXRoLm1pbigxLCBlIC8gbik7CiAgICByZXR1cm4gdGhpcy5zbGVycCh0LCBpKSwgdGhpczsKICB9CiAgaWRlbnRpdHkoKSB7CiAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMSk7CiAgfQogIGludmVydCgpIHsKICAgIHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpOwogIH0KICBjb25qdWdhdGUoKSB7CiAgICByZXR1cm4gdGhpcy5feCAqPSAtMSwgdGhpcy5feSAqPSAtMSwgdGhpcy5feiAqPSAtMSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBkb3QodCkgewogICAgcmV0dXJuIHRoaXMuX3ggKiB0Ll94ICsgdGhpcy5feSAqIHQuX3kgKyB0aGlzLl96ICogdC5feiArIHRoaXMuX3cgKiB0Ll93OwogIH0KICBsZW5ndGhTcSgpIHsKICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdzsKICB9CiAgbGVuZ3RoKCkgewogICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyk7CiAgfQogIG5vcm1hbGl6ZSgpIHsKICAgIGxldCB0ID0gdGhpcy5sZW5ndGgoKTsKICAgIHJldHVybiB0ID09PSAwID8gKHRoaXMuX3ggPSAwLCB0aGlzLl95ID0gMCwgdGhpcy5feiA9IDAsIHRoaXMuX3cgPSAxKSA6ICh0ID0gMSAvIHQsIHRoaXMuX3ggPSB0aGlzLl94ICogdCwgdGhpcy5feSA9IHRoaXMuX3kgKiB0LCB0aGlzLl96ID0gdGhpcy5feiAqIHQsIHRoaXMuX3cgPSB0aGlzLl93ICogdCksIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgbXVsdGlwbHkodCkgewogICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLCB0KTsKICB9CiAgcHJlbXVsdGlwbHkodCkgewogICAgcmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyh0LCB0aGlzKTsKICB9CiAgbXVsdGlwbHlRdWF0ZXJuaW9ucyh0LCBlKSB7CiAgICBjb25zdCBuID0gdC5feCwgaSA9IHQuX3ksIHIgPSB0Ll96LCBhID0gdC5fdywgbyA9IGUuX3gsIGggPSBlLl95LCBjID0gZS5feiwgbCA9IGUuX3c7CiAgICByZXR1cm4gdGhpcy5feCA9IG4gKiBsICsgYSAqIG8gKyBpICogYyAtIHIgKiBoLCB0aGlzLl95ID0gaSAqIGwgKyBhICogaCArIHIgKiBvIC0gbiAqIGMsIHRoaXMuX3ogPSByICogbCArIGEgKiBjICsgbiAqIGggLSBpICogbywgdGhpcy5fdyA9IGEgKiBsIC0gbiAqIG8gLSBpICogaCAtIHIgKiBjLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHNsZXJwKHQsIGUpIHsKICAgIGlmIChlID09PSAwKQogICAgICByZXR1cm4gdGhpczsKICAgIGlmIChlID09PSAxKQogICAgICByZXR1cm4gdGhpcy5jb3B5KHQpOwogICAgY29uc3QgbiA9IHRoaXMuX3gsIGkgPSB0aGlzLl95LCByID0gdGhpcy5feiwgYSA9IHRoaXMuX3c7CiAgICBsZXQgbyA9IGEgKiB0Ll93ICsgbiAqIHQuX3ggKyBpICogdC5feSArIHIgKiB0Ll96OwogICAgaWYgKG8gPCAwID8gKHRoaXMuX3cgPSAtdC5fdywgdGhpcy5feCA9IC10Ll94LCB0aGlzLl95ID0gLXQuX3ksIHRoaXMuX3ogPSAtdC5feiwgbyA9IC1vKSA6IHRoaXMuY29weSh0KSwgbyA+PSAxKQogICAgICByZXR1cm4gdGhpcy5fdyA9IGEsIHRoaXMuX3ggPSBuLCB0aGlzLl95ID0gaSwgdGhpcy5feiA9IHIsIHRoaXM7CiAgICBjb25zdCBoID0gMSAtIG8gKiBvOwogICAgaWYgKGggPD0gTnVtYmVyLkVQU0lMT04pIHsKICAgICAgY29uc3QgeSA9IDEgLSBlOwogICAgICByZXR1cm4gdGhpcy5fdyA9IHkgKiBhICsgZSAqIHRoaXMuX3csIHRoaXMuX3ggPSB5ICogbiArIGUgKiB0aGlzLl94LCB0aGlzLl95ID0geSAqIGkgKyBlICogdGhpcy5feSwgdGhpcy5feiA9IHkgKiByICsgZSAqIHRoaXMuX3osIHRoaXMubm9ybWFsaXplKCksIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICAgIH0KICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoaCksIGwgPSBNYXRoLmF0YW4yKGMsIG8pLCB1ID0gTWF0aC5zaW4oKDEgLSBlKSAqIGwpIC8gYywgZCA9IE1hdGguc2luKGUgKiBsKSAvIGM7CiAgICByZXR1cm4gdGhpcy5fdyA9IGEgKiB1ICsgdGhpcy5fdyAqIGQsIHRoaXMuX3ggPSBuICogdSArIHRoaXMuX3ggKiBkLCB0aGlzLl95ID0gaSAqIHUgKyB0aGlzLl95ICogZCwgdGhpcy5feiA9IHIgKiB1ICsgdGhpcy5feiAqIGQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgc2xlcnBRdWF0ZXJuaW9ucyh0LCBlLCBuKSB7CiAgICByZXR1cm4gdGhpcy5jb3B5KHQpLnNsZXJwKGUsIG4pOwogIH0KICByYW5kb20oKSB7CiAgICBjb25zdCB0ID0gTWF0aC5yYW5kb20oKSwgZSA9IE1hdGguc3FydCgxIC0gdCksIG4gPSBNYXRoLnNxcnQodCksIGkgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCksIHIgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7CiAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgIGUgKiBNYXRoLmNvcyhpKSwKICAgICAgbiAqIE1hdGguc2luKHIpLAogICAgICBuICogTWF0aC5jb3MociksCiAgICAgIGUgKiBNYXRoLnNpbihpKQogICAgKTsKICB9CiAgZXF1YWxzKHQpIHsKICAgIHJldHVybiB0Ll94ID09PSB0aGlzLl94ICYmIHQuX3kgPT09IHRoaXMuX3kgJiYgdC5feiA9PT0gdGhpcy5feiAmJiB0Ll93ID09PSB0aGlzLl93OwogIH0KICBmcm9tQXJyYXkodCwgZSA9IDApIHsKICAgIHJldHVybiB0aGlzLl94ID0gdFtlXSwgdGhpcy5feSA9IHRbZSArIDFdLCB0aGlzLl96ID0gdFtlICsgMl0sIHRoaXMuX3cgPSB0W2UgKyAzXSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgIHJldHVybiB0W2VdID0gdGhpcy5feCwgdFtlICsgMV0gPSB0aGlzLl95LCB0W2UgKyAyXSA9IHRoaXMuX3osIHRbZSArIDNdID0gdGhpcy5fdywgdDsKICB9CiAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy5feCA9IHQuZ2V0WChlKSwgdGhpcy5feSA9IHQuZ2V0WShlKSwgdGhpcy5feiA9IHQuZ2V0WihlKSwgdGhpcy5fdyA9IHQuZ2V0VyhlKSwgdGhpczsKICB9CiAgdG9KU09OKCkgewogICAgcmV0dXJuIHRoaXMudG9BcnJheSgpOwogIH0KICBfb25DaGFuZ2UodCkgewogICAgcmV0dXJuIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSB0LCB0aGlzOwogIH0KICBfb25DaGFuZ2VDYWxsYmFjaygpIHsKICB9CiAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgeWllbGQgdGhpcy5feCwgeWllbGQgdGhpcy5feSwgeWllbGQgdGhpcy5feiwgeWllbGQgdGhpcy5fdzsKICB9Cn0KY2xhc3MgcCB7CiAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwLCBuID0gMCkgewogICAgcC5wcm90b3R5cGUuaXNWZWN0b3IzID0gITAsIHRoaXMueCA9IHQsIHRoaXMueSA9IGUsIHRoaXMueiA9IG47CiAgfQogIHNldCh0LCBlLCBuKSB7CiAgICByZXR1cm4gbiA9PT0gdm9pZCAwICYmIChuID0gdGhpcy56KSwgdGhpcy54ID0gdCwgdGhpcy55ID0gZSwgdGhpcy56ID0gbiwgdGhpczsKICB9CiAgc2V0U2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSB0LCB0aGlzLnogPSB0LCB0aGlzOwogIH0KICBzZXRYKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzOwogIH0KICBzZXRZKHQpIHsKICAgIHJldHVybiB0aGlzLnkgPSB0LCB0aGlzOwogIH0KICBzZXRaKHQpIHsKICAgIHJldHVybiB0aGlzLnogPSB0LCB0aGlzOwogIH0KICBzZXRDb21wb25lbnQodCwgZSkgewogICAgc3dpdGNoICh0KSB7CiAgICAgIGNhc2UgMDoKICAgICAgICB0aGlzLnggPSBlOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDE6CiAgICAgICAgdGhpcy55ID0gZTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAyOgogICAgICAgIHRoaXMueiA9IGU7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgIH0KICAgIHJldHVybiB0aGlzOwogIH0KICBnZXRDb21wb25lbnQodCkgewogICAgc3dpdGNoICh0KSB7CiAgICAgIGNhc2UgMDoKICAgICAgICByZXR1cm4gdGhpcy54OwogICAgICBjYXNlIDE6CiAgICAgICAgcmV0dXJuIHRoaXMueTsKICAgICAgY2FzZSAyOgogICAgICAgIHJldHVybiB0aGlzLno7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgIH0KICB9CiAgY2xvbmUoKSB7CiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMueik7CiAgfQogIGNvcHkodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55LCB0aGlzLnogPSB0LnosIHRoaXM7CiAgfQogIGFkZCh0KSB7CiAgICByZXR1cm4gdGhpcy54ICs9IHQueCwgdGhpcy55ICs9IHQueSwgdGhpcy56ICs9IHQueiwgdGhpczsKICB9CiAgYWRkU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggKz0gdCwgdGhpcy55ICs9IHQsIHRoaXMueiArPSB0LCB0aGlzOwogIH0KICBhZGRWZWN0b3JzKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggKyBlLngsIHRoaXMueSA9IHQueSArIGUueSwgdGhpcy56ID0gdC56ICsgZS56LCB0aGlzOwogIH0KICBhZGRTY2FsZWRWZWN0b3IodCwgZSkgewogICAgcmV0dXJuIHRoaXMueCArPSB0LnggKiBlLCB0aGlzLnkgKz0gdC55ICogZSwgdGhpcy56ICs9IHQueiAqIGUsIHRoaXM7CiAgfQogIHN1Yih0KSB7CiAgICByZXR1cm4gdGhpcy54IC09IHQueCwgdGhpcy55IC09IHQueSwgdGhpcy56IC09IHQueiwgdGhpczsKICB9CiAgc3ViU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggLT0gdCwgdGhpcy55IC09IHQsIHRoaXMueiAtPSB0LCB0aGlzOwogIH0KICBzdWJWZWN0b3JzKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggLSBlLngsIHRoaXMueSA9IHQueSAtIGUueSwgdGhpcy56ID0gdC56IC0gZS56LCB0aGlzOwogIH0KICBtdWx0aXBseSh0KSB7CiAgICByZXR1cm4gdGhpcy54ICo9IHQueCwgdGhpcy55ICo9IHQueSwgdGhpcy56ICo9IHQueiwgdGhpczsKICB9CiAgbXVsdGlwbHlTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCAqPSB0LCB0aGlzLnkgKj0gdCwgdGhpcy56ICo9IHQsIHRoaXM7CiAgfQogIG11bHRpcGx5VmVjdG9ycyh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54ICogZS54LCB0aGlzLnkgPSB0LnkgKiBlLnksIHRoaXMueiA9IHQueiAqIGUueiwgdGhpczsKICB9CiAgYXBwbHlFdWxlcih0KSB7CiAgICByZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oa24uc2V0RnJvbUV1bGVyKHQpKTsKICB9CiAgYXBwbHlBeGlzQW5nbGUodCwgZSkgewogICAgcmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKGtuLnNldEZyb21BeGlzQW5nbGUodCwgZSkpOwogIH0KICBhcHBseU1hdHJpeDModCkgewogICAgY29uc3QgZSA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgciA9IHQuZWxlbWVudHM7CiAgICByZXR1cm4gdGhpcy54ID0gclswXSAqIGUgKyByWzNdICogbiArIHJbNl0gKiBpLCB0aGlzLnkgPSByWzFdICogZSArIHJbNF0gKiBuICsgcls3XSAqIGksIHRoaXMueiA9IHJbMl0gKiBlICsgcls1XSAqIG4gKyByWzhdICogaSwgdGhpczsKICB9CiAgYXBwbHlOb3JtYWxNYXRyaXgodCkgewogICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXgzKHQpLm5vcm1hbGl6ZSgpOwogIH0KICBhcHBseU1hdHJpeDQodCkgewogICAgY29uc3QgZSA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgciA9IHQuZWxlbWVudHMsIGEgPSAxIC8gKHJbM10gKiBlICsgcls3XSAqIG4gKyByWzExXSAqIGkgKyByWzE1XSk7CiAgICByZXR1cm4gdGhpcy54ID0gKHJbMF0gKiBlICsgcls0XSAqIG4gKyByWzhdICogaSArIHJbMTJdKSAqIGEsIHRoaXMueSA9IChyWzFdICogZSArIHJbNV0gKiBuICsgcls5XSAqIGkgKyByWzEzXSkgKiBhLCB0aGlzLnogPSAoclsyXSAqIGUgKyByWzZdICogbiArIHJbMTBdICogaSArIHJbMTRdKSAqIGEsIHRoaXM7CiAgfQogIGFwcGx5UXVhdGVybmlvbih0KSB7CiAgICBjb25zdCBlID0gdGhpcy54LCBuID0gdGhpcy55LCBpID0gdGhpcy56LCByID0gdC54LCBhID0gdC55LCBvID0gdC56LCBoID0gdC53LCBjID0gMiAqIChhICogaSAtIG8gKiBuKSwgbCA9IDIgKiAobyAqIGUgLSByICogaSksIHUgPSAyICogKHIgKiBuIC0gYSAqIGUpOwogICAgcmV0dXJuIHRoaXMueCA9IGUgKyBoICogYyArIGEgKiB1IC0gbyAqIGwsIHRoaXMueSA9IG4gKyBoICogbCArIG8gKiBjIC0gciAqIHUsIHRoaXMueiA9IGkgKyBoICogdSArIHIgKiBsIC0gYSAqIGMsIHRoaXM7CiAgfQogIHByb2plY3QodCkgewogICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGRJbnZlcnNlKS5hcHBseU1hdHJpeDQodC5wcm9qZWN0aW9uTWF0cml4KTsKICB9CiAgdW5wcm9qZWN0KHQpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCh0LnByb2plY3Rpb25NYXRyaXhJbnZlcnNlKS5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZCk7CiAgfQogIHRyYW5zZm9ybURpcmVjdGlvbih0KSB7CiAgICBjb25zdCBlID0gdGhpcy54LCBuID0gdGhpcy55LCBpID0gdGhpcy56LCByID0gdC5lbGVtZW50czsKICAgIHJldHVybiB0aGlzLnggPSByWzBdICogZSArIHJbNF0gKiBuICsgcls4XSAqIGksIHRoaXMueSA9IHJbMV0gKiBlICsgcls1XSAqIG4gKyByWzldICogaSwgdGhpcy56ID0gclsyXSAqIGUgKyByWzZdICogbiArIHJbMTBdICogaSwgdGhpcy5ub3JtYWxpemUoKTsKICB9CiAgZGl2aWRlKHQpIHsKICAgIHJldHVybiB0aGlzLnggLz0gdC54LCB0aGlzLnkgLz0gdC55LCB0aGlzLnogLz0gdC56LCB0aGlzOwogIH0KICBkaXZpZGVTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHQpOwogIH0KICBtaW4odCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWluKHRoaXMueCwgdC54KSwgdGhpcy55ID0gTWF0aC5taW4odGhpcy55LCB0LnkpLCB0aGlzLnogPSBNYXRoLm1pbih0aGlzLnosIHQueiksIHRoaXM7CiAgfQogIG1heCh0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCB0LngpLCB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHQueSksIHRoaXMueiA9IE1hdGgubWF4KHRoaXMueiwgdC56KSwgdGhpczsKICB9CiAgY2xhbXAodCwgZSkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHQueCwgTWF0aC5taW4oZS54LCB0aGlzLngpKSwgdGhpcy55ID0gTWF0aC5tYXgodC55LCBNYXRoLm1pbihlLnksIHRoaXMueSkpLCB0aGlzLnogPSBNYXRoLm1heCh0LnosIE1hdGgubWluKGUueiwgdGhpcy56KSksIHRoaXM7CiAgfQogIGNsYW1wU2NhbGFyKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCB0aGlzLngpKSwgdGhpcy55ID0gTWF0aC5tYXgodCwgTWF0aC5taW4oZSwgdGhpcy55KSksIHRoaXMueiA9IE1hdGgubWF4KHQsIE1hdGgubWluKGUsIHRoaXMueikpLCB0aGlzOwogIH0KICBjbGFtcExlbmd0aCh0LCBlKSB7CiAgICBjb25zdCBuID0gdGhpcy5sZW5ndGgoKTsKICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihuIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KHQsIE1hdGgubWluKGUsIG4pKSk7CiAgfQogIGZsb29yKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KSwgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpLCB0aGlzLnogPSBNYXRoLmZsb29yKHRoaXMueiksIHRoaXM7CiAgfQogIGNlaWwoKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCksIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLmNlaWwodGhpcy56KSwgdGhpczsKICB9CiAgcm91bmQoKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSksIHRoaXMueiA9IE1hdGgucm91bmQodGhpcy56KSwgdGhpczsKICB9CiAgcm91bmRUb1plcm8oKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC50cnVuYyh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLnRydW5jKHRoaXMueSksIHRoaXMueiA9IE1hdGgudHJ1bmModGhpcy56KSwgdGhpczsKICB9CiAgbmVnYXRlKCkgewogICAgcmV0dXJuIHRoaXMueCA9IC10aGlzLngsIHRoaXMueSA9IC10aGlzLnksIHRoaXMueiA9IC10aGlzLnosIHRoaXM7CiAgfQogIGRvdCh0KSB7CiAgICByZXR1cm4gdGhpcy54ICogdC54ICsgdGhpcy55ICogdC55ICsgdGhpcy56ICogdC56OwogIH0KICBsZW5ndGhTcSgpIHsKICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7CiAgfQogIGxlbmd0aCgpIHsKICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56KTsKICB9CiAgbWFuaGF0dGFuTGVuZ3RoKCkgewogICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCkgKyBNYXRoLmFicyh0aGlzLnkpICsgTWF0aC5hYnModGhpcy56KTsKICB9CiAgbm9ybWFsaXplKCkgewogICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7CiAgfQogIHNldExlbmd0aCh0KSB7CiAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcih0KTsKICB9CiAgbGVycCh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ICs9ICh0LnggLSB0aGlzLngpICogZSwgdGhpcy55ICs9ICh0LnkgLSB0aGlzLnkpICogZSwgdGhpcy56ICs9ICh0LnogLSB0aGlzLnopICogZSwgdGhpczsKICB9CiAgbGVycFZlY3RvcnModCwgZSwgbikgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCArIChlLnggLSB0LngpICogbiwgdGhpcy55ID0gdC55ICsgKGUueSAtIHQueSkgKiBuLCB0aGlzLnogPSB0LnogKyAoZS56IC0gdC56KSAqIG4sIHRoaXM7CiAgfQogIGNyb3NzKHQpIHsKICAgIHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyh0aGlzLCB0KTsKICB9CiAgY3Jvc3NWZWN0b3JzKHQsIGUpIHsKICAgIGNvbnN0IG4gPSB0LngsIGkgPSB0LnksIHIgPSB0LnosIGEgPSBlLngsIG8gPSBlLnksIGggPSBlLno7CiAgICByZXR1cm4gdGhpcy54ID0gaSAqIGggLSByICogbywgdGhpcy55ID0gciAqIGEgLSBuICogaCwgdGhpcy56ID0gbiAqIG8gLSBpICogYSwgdGhpczsKICB9CiAgcHJvamVjdE9uVmVjdG9yKHQpIHsKICAgIGNvbnN0IGUgPSB0Lmxlbmd0aFNxKCk7CiAgICBpZiAoZSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDApOwogICAgY29uc3QgbiA9IHQuZG90KHRoaXMpIC8gZTsKICAgIHJldHVybiB0aGlzLmNvcHkodCkubXVsdGlwbHlTY2FsYXIobik7CiAgfQogIHByb2plY3RPblBsYW5lKHQpIHsKICAgIHJldHVybiBhbi5jb3B5KHRoaXMpLnByb2plY3RPblZlY3Rvcih0KSwgdGhpcy5zdWIoYW4pOwogIH0KICByZWZsZWN0KHQpIHsKICAgIHJldHVybiB0aGlzLnN1Yihhbi5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKDIgKiB0aGlzLmRvdCh0KSkpOwogIH0KICBhbmdsZVRvKHQpIHsKICAgIGNvbnN0IGUgPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpICogdC5sZW5ndGhTcSgpKTsKICAgIGlmIChlID09PSAwKQogICAgICByZXR1cm4gTWF0aC5QSSAvIDI7CiAgICBjb25zdCBuID0gdGhpcy5kb3QodCkgLyBlOwogICAgcmV0dXJuIE1hdGguYWNvcyh0bihuLCAtMSwgMSkpOwogIH0KICBkaXN0YW5jZVRvKHQpIHsKICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh0KSk7CiAgfQogIGRpc3RhbmNlVG9TcXVhcmVkKHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLnggLSB0LngsIG4gPSB0aGlzLnkgLSB0LnksIGkgPSB0aGlzLnogLSB0Lno7CiAgICByZXR1cm4gZSAqIGUgKyBuICogbiArIGkgKiBpOwogIH0KICBtYW5oYXR0YW5EaXN0YW5jZVRvKHQpIHsKICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB0LngpICsgTWF0aC5hYnModGhpcy55IC0gdC55KSArIE1hdGguYWJzKHRoaXMueiAtIHQueik7CiAgfQogIHNldEZyb21TcGhlcmljYWwodCkgewogICAgcmV0dXJuIHRoaXMuc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyh0LnJhZGl1cywgdC5waGksIHQudGhldGEpOwogIH0KICBzZXRGcm9tU3BoZXJpY2FsQ29vcmRzKHQsIGUsIG4pIHsKICAgIGNvbnN0IGkgPSBNYXRoLnNpbihlKSAqIHQ7CiAgICByZXR1cm4gdGhpcy54ID0gaSAqIE1hdGguc2luKG4pLCB0aGlzLnkgPSBNYXRoLmNvcyhlKSAqIHQsIHRoaXMueiA9IGkgKiBNYXRoLmNvcyhuKSwgdGhpczsKICB9CiAgc2V0RnJvbUN5bGluZHJpY2FsKHQpIHsKICAgIHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LnJhZGl1cywgdC50aGV0YSwgdC55KTsKICB9CiAgc2V0RnJvbUN5bGluZHJpY2FsQ29vcmRzKHQsIGUsIG4pIHsKICAgIHJldHVybiB0aGlzLnggPSB0ICogTWF0aC5zaW4oZSksIHRoaXMueSA9IG4sIHRoaXMueiA9IHQgKiBNYXRoLmNvcyhlKSwgdGhpczsKICB9CiAgc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHQpIHsKICAgIGNvbnN0IGUgPSB0LmVsZW1lbnRzOwogICAgcmV0dXJuIHRoaXMueCA9IGVbMTJdLCB0aGlzLnkgPSBlWzEzXSwgdGhpcy56ID0gZVsxNF0sIHRoaXM7CiAgfQogIHNldEZyb21NYXRyaXhTY2FsZSh0KSB7CiAgICBjb25zdCBlID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsIDApLmxlbmd0aCgpLCBuID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsIDEpLmxlbmd0aCgpLCBpID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKHQsIDIpLmxlbmd0aCgpOwogICAgcmV0dXJuIHRoaXMueCA9IGUsIHRoaXMueSA9IG4sIHRoaXMueiA9IGksIHRoaXM7CiAgfQogIHNldEZyb21NYXRyaXhDb2x1bW4odCwgZSkgewogICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KHQuZWxlbWVudHMsIGUgKiA0KTsKICB9CiAgc2V0RnJvbU1hdHJpeDNDb2x1bW4odCwgZSkgewogICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KHQuZWxlbWVudHMsIGUgKiAzKTsKICB9CiAgc2V0RnJvbUV1bGVyKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0Ll94LCB0aGlzLnkgPSB0Ll95LCB0aGlzLnogPSB0Ll96LCB0aGlzOwogIH0KICBzZXRGcm9tQ29sb3IodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQuciwgdGhpcy55ID0gdC5nLCB0aGlzLnogPSB0LmIsIHRoaXM7CiAgfQogIGVxdWFscyh0KSB7CiAgICByZXR1cm4gdC54ID09PSB0aGlzLnggJiYgdC55ID09PSB0aGlzLnkgJiYgdC56ID09PSB0aGlzLno7CiAgfQogIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgcmV0dXJuIHRoaXMueCA9IHRbZV0sIHRoaXMueSA9IHRbZSArIDFdLCB0aGlzLnogPSB0W2UgKyAyXSwgdGhpczsKICB9CiAgdG9BcnJheSh0ID0gW10sIGUgPSAwKSB7CiAgICByZXR1cm4gdFtlXSA9IHRoaXMueCwgdFtlICsgMV0gPSB0aGlzLnksIHRbZSArIDJdID0gdGhpcy56LCB0OwogIH0KICBmcm9tQnVmZmVyQXR0cmlidXRlKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LmdldFgoZSksIHRoaXMueSA9IHQuZ2V0WShlKSwgdGhpcy56ID0gdC5nZXRaKGUpLCB0aGlzOwogIH0KICByYW5kb20oKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yYW5kb20oKSwgdGhpcy55ID0gTWF0aC5yYW5kb20oKSwgdGhpcy56ID0gTWF0aC5yYW5kb20oKSwgdGhpczsKICB9CiAgcmFuZG9tRGlyZWN0aW9uKCkgewogICAgY29uc3QgdCA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIsIGUgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsIG4gPSBNYXRoLnNxcnQoMSAtIHQgKiogMik7CiAgICByZXR1cm4gdGhpcy54ID0gbiAqIE1hdGguY29zKGUpLCB0aGlzLnkgPSBuICogTWF0aC5zaW4oZSksIHRoaXMueiA9IHQsIHRoaXM7CiAgfQogICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgIHlpZWxkIHRoaXMueCwgeWllbGQgdGhpcy55LCB5aWVsZCB0aGlzLno7CiAgfQp9CmNvbnN0IGFuID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIGtuID0gLyogQF9fUFVSRV9fICovIG5ldyBYdCgpOwpjbGFzcyBTZSB7CiAgY29uc3RydWN0b3IodCA9IG5ldyBwKDEgLyAwLCAxIC8gMCwgMSAvIDApLCBlID0gbmV3IHAoLTEgLyAwLCAtMSAvIDAsIC0xIC8gMCkpIHsKICAgIHRoaXMuaXNCb3gzID0gITAsIHRoaXMubWluID0gdCwgdGhpcy5tYXggPSBlOwogIH0KICBzZXQodCwgZSkgewogICAgcmV0dXJuIHRoaXMubWluLmNvcHkodCksIHRoaXMubWF4LmNvcHkoZSksIHRoaXM7CiAgfQogIHNldEZyb21BcnJheSh0KSB7CiAgICB0aGlzLm1ha2VFbXB0eSgpOwogICAgZm9yIChsZXQgZSA9IDAsIG4gPSB0Lmxlbmd0aDsgZSA8IG47IGUgKz0gMykKICAgICAgdGhpcy5leHBhbmRCeVBvaW50KFB0LmZyb21BcnJheSh0LCBlKSk7CiAgICByZXR1cm4gdGhpczsKICB9CiAgc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSh0KSB7CiAgICB0aGlzLm1ha2VFbXB0eSgpOwogICAgZm9yIChsZXQgZSA9IDAsIG4gPSB0LmNvdW50OyBlIDwgbjsgZSsrKQogICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoUHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSk7CiAgICByZXR1cm4gdGhpczsKICB9CiAgc2V0RnJvbVBvaW50cyh0KSB7CiAgICB0aGlzLm1ha2VFbXB0eSgpOwogICAgZm9yIChsZXQgZSA9IDAsIG4gPSB0Lmxlbmd0aDsgZSA8IG47IGUrKykKICAgICAgdGhpcy5leHBhbmRCeVBvaW50KHRbZV0pOwogICAgcmV0dXJuIHRoaXM7CiAgfQogIHNldEZyb21DZW50ZXJBbmRTaXplKHQsIGUpIHsKICAgIGNvbnN0IG4gPSBQdC5jb3B5KGUpLm11bHRpcGx5U2NhbGFyKDAuNSk7CiAgICByZXR1cm4gdGhpcy5taW4uY29weSh0KS5zdWIobiksIHRoaXMubWF4LmNvcHkodCkuYWRkKG4pLCB0aGlzOwogIH0KICBzZXRGcm9tT2JqZWN0KHQsIGUgPSAhMSkgewogICAgcmV0dXJuIHRoaXMubWFrZUVtcHR5KCksIHRoaXMuZXhwYW5kQnlPYmplY3QodCwgZSk7CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTsKICB9CiAgY29weSh0KSB7CiAgICByZXR1cm4gdGhpcy5taW4uY29weSh0Lm1pbiksIHRoaXMubWF4LmNvcHkodC5tYXgpLCB0aGlzOwogIH0KICBtYWtlRW1wdHkoKSB7CiAgICByZXR1cm4gdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gMSAvIDAsIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0xIC8gMCwgdGhpczsKICB9CiAgaXNFbXB0eSgpIHsKICAgIHJldHVybiB0aGlzLm1heC54IDwgdGhpcy5taW4ueCB8fCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSB8fCB0aGlzLm1heC56IDwgdGhpcy5taW4uejsKICB9CiAgZ2V0Q2VudGVyKHQpIHsKICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHQuc2V0KDAsIDAsIDApIDogdC5hZGRWZWN0b3JzKHRoaXMubWluLCB0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoMC41KTsKICB9CiAgZ2V0U2l6ZSh0KSB7CiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0LnNldCgwLCAwLCAwKSA6IHQuc3ViVmVjdG9ycyh0aGlzLm1heCwgdGhpcy5taW4pOwogIH0KICBleHBhbmRCeVBvaW50KHQpIHsKICAgIHJldHVybiB0aGlzLm1pbi5taW4odCksIHRoaXMubWF4Lm1heCh0KSwgdGhpczsKICB9CiAgZXhwYW5kQnlWZWN0b3IodCkgewogICAgcmV0dXJuIHRoaXMubWluLnN1Yih0KSwgdGhpcy5tYXguYWRkKHQpLCB0aGlzOwogIH0KICBleHBhbmRCeVNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy5taW4uYWRkU2NhbGFyKC10KSwgdGhpcy5tYXguYWRkU2NhbGFyKHQpLCB0aGlzOwogIH0KICBleHBhbmRCeU9iamVjdCh0LCBlID0gITEpIHsKICAgIHQudXBkYXRlV29ybGRNYXRyaXgoITEsICExKTsKICAgIGNvbnN0IG4gPSB0Lmdlb21ldHJ5OwogICAgaWYgKG4gIT09IHZvaWQgMCkgewogICAgICBjb25zdCByID0gbi5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7CiAgICAgIGlmIChlID09PSAhMCAmJiByICE9PSB2b2lkIDAgJiYgdC5pc0luc3RhbmNlZE1lc2ggIT09ICEwKQogICAgICAgIGZvciAobGV0IGEgPSAwLCBvID0gci5jb3VudDsgYSA8IG87IGErKykKICAgICAgICAgIHQuaXNNZXNoID09PSAhMCA/IHQuZ2V0VmVydGV4UG9zaXRpb24oYSwgUHQpIDogUHQuZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLCBhKSwgUHQuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLCB0aGlzLmV4cGFuZEJ5UG9pbnQoUHQpOwogICAgICBlbHNlCiAgICAgICAgdC5ib3VuZGluZ0JveCAhPT0gdm9pZCAwID8gKHQuYm91bmRpbmdCb3ggPT09IG51bGwgJiYgdC5jb21wdXRlQm91bmRpbmdCb3goKSwgTmUuY29weSh0LmJvdW5kaW5nQm94KSkgOiAobi5ib3VuZGluZ0JveCA9PT0gbnVsbCAmJiBuLmNvbXB1dGVCb3VuZGluZ0JveCgpLCBOZS5jb3B5KG4uYm91bmRpbmdCb3gpKSwgTmUuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLCB0aGlzLnVuaW9uKE5lKTsKICAgIH0KICAgIGNvbnN0IGkgPSB0LmNoaWxkcmVuOwogICAgZm9yIChsZXQgciA9IDAsIGEgPSBpLmxlbmd0aDsgciA8IGE7IHIrKykKICAgICAgdGhpcy5leHBhbmRCeU9iamVjdChpW3JdLCBlKTsKICAgIHJldHVybiB0aGlzOwogIH0KICBjb250YWluc1BvaW50KHQpIHsKICAgIHJldHVybiAhKHQueCA8IHRoaXMubWluLnggfHwgdC54ID4gdGhpcy5tYXgueCB8fCB0LnkgPCB0aGlzLm1pbi55IHx8IHQueSA+IHRoaXMubWF4LnkgfHwgdC56IDwgdGhpcy5taW4ueiB8fCB0LnogPiB0aGlzLm1heC56KTsKICB9CiAgY29udGFpbnNCb3godCkgewogICAgcmV0dXJuIHRoaXMubWluLnggPD0gdC5taW4ueCAmJiB0Lm1heC54IDw9IHRoaXMubWF4LnggJiYgdGhpcy5taW4ueSA8PSB0Lm1pbi55ICYmIHQubWF4LnkgPD0gdGhpcy5tYXgueSAmJiB0aGlzLm1pbi56IDw9IHQubWluLnogJiYgdC5tYXgueiA8PSB0aGlzLm1heC56OwogIH0KICBnZXRQYXJhbWV0ZXIodCwgZSkgewogICAgcmV0dXJuIGUuc2V0KAogICAgICAodC54IC0gdGhpcy5taW4ueCkgLyAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLAogICAgICAodC55IC0gdGhpcy5taW4ueSkgLyAodGhpcy5tYXgueSAtIHRoaXMubWluLnkpLAogICAgICAodC56IC0gdGhpcy5taW4ueikgLyAodGhpcy5tYXgueiAtIHRoaXMubWluLnopCiAgICApOwogIH0KICBpbnRlcnNlY3RzQm94KHQpIHsKICAgIHJldHVybiAhKHQubWF4LnggPCB0aGlzLm1pbi54IHx8IHQubWluLnggPiB0aGlzLm1heC54IHx8IHQubWF4LnkgPCB0aGlzLm1pbi55IHx8IHQubWluLnkgPiB0aGlzLm1heC55IHx8IHQubWF4LnogPCB0aGlzLm1pbi56IHx8IHQubWluLnogPiB0aGlzLm1heC56KTsKICB9CiAgaW50ZXJzZWN0c1NwaGVyZSh0KSB7CiAgICByZXR1cm4gdGhpcy5jbGFtcFBvaW50KHQuY2VudGVyLCBQdCksIFB0LmRpc3RhbmNlVG9TcXVhcmVkKHQuY2VudGVyKSA8PSB0LnJhZGl1cyAqIHQucmFkaXVzOwogIH0KICBpbnRlcnNlY3RzUGxhbmUodCkgewogICAgbGV0IGUsIG47CiAgICByZXR1cm4gdC5ub3JtYWwueCA+IDAgPyAoZSA9IHQubm9ybWFsLnggKiB0aGlzLm1pbi54LCBuID0gdC5ub3JtYWwueCAqIHRoaXMubWF4LngpIDogKGUgPSB0Lm5vcm1hbC54ICogdGhpcy5tYXgueCwgbiA9IHQubm9ybWFsLnggKiB0aGlzLm1pbi54KSwgdC5ub3JtYWwueSA+IDAgPyAoZSArPSB0Lm5vcm1hbC55ICogdGhpcy5taW4ueSwgbiArPSB0Lm5vcm1hbC55ICogdGhpcy5tYXgueSkgOiAoZSArPSB0Lm5vcm1hbC55ICogdGhpcy5tYXgueSwgbiArPSB0Lm5vcm1hbC55ICogdGhpcy5taW4ueSksIHQubm9ybWFsLnogPiAwID8gKGUgKz0gdC5ub3JtYWwueiAqIHRoaXMubWluLnosIG4gKz0gdC5ub3JtYWwueiAqIHRoaXMubWF4LnopIDogKGUgKz0gdC5ub3JtYWwueiAqIHRoaXMubWF4LnosIG4gKz0gdC5ub3JtYWwueiAqIHRoaXMubWluLnopLCBlIDw9IC10LmNvbnN0YW50ICYmIG4gPj0gLXQuY29uc3RhbnQ7CiAgfQogIGludGVyc2VjdHNUcmlhbmdsZSh0KSB7CiAgICBpZiAodGhpcy5pc0VtcHR5KCkpCiAgICAgIHJldHVybiAhMTsKICAgIHRoaXMuZ2V0Q2VudGVyKGdlKSwgTGUuc3ViVmVjdG9ycyh0aGlzLm1heCwgZ2UpLCBvZS5zdWJWZWN0b3JzKHQuYSwgZ2UpLCBoZS5zdWJWZWN0b3JzKHQuYiwgZ2UpLCBjZS5zdWJWZWN0b3JzKHQuYywgZ2UpLCBEdC5zdWJWZWN0b3JzKGhlLCBvZSksIFV0LnN1YlZlY3RvcnMoY2UsIGhlKSwgSHQuc3ViVmVjdG9ycyhvZSwgY2UpOwogICAgbGV0IGUgPSBbCiAgICAgIDAsCiAgICAgIC1EdC56LAogICAgICBEdC55LAogICAgICAwLAogICAgICAtVXQueiwKICAgICAgVXQueSwKICAgICAgMCwKICAgICAgLUh0LnosCiAgICAgIEh0LnksCiAgICAgIER0LnosCiAgICAgIDAsCiAgICAgIC1EdC54LAogICAgICBVdC56LAogICAgICAwLAogICAgICAtVXQueCwKICAgICAgSHQueiwKICAgICAgMCwKICAgICAgLUh0LngsCiAgICAgIC1EdC55LAogICAgICBEdC54LAogICAgICAwLAogICAgICAtVXQueSwKICAgICAgVXQueCwKICAgICAgMCwKICAgICAgLUh0LnksCiAgICAgIEh0LngsCiAgICAgIDAKICAgIF07CiAgICByZXR1cm4gIW9uKGUsIG9lLCBoZSwgY2UsIExlKSB8fCAoZSA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXSwgIW9uKGUsIG9lLCBoZSwgY2UsIExlKSkgPyAhMSA6IChxZS5jcm9zc1ZlY3RvcnMoRHQsIFV0KSwgZSA9IFtxZS54LCBxZS55LCBxZS56XSwgb24oZSwgb2UsIGhlLCBjZSwgTGUpKTsKICB9CiAgY2xhbXBQb2ludCh0LCBlKSB7CiAgICByZXR1cm4gZS5jb3B5KHQpLmNsYW1wKHRoaXMubWluLCB0aGlzLm1heCk7CiAgfQogIGRpc3RhbmNlVG9Qb2ludCh0KSB7CiAgICByZXR1cm4gdGhpcy5jbGFtcFBvaW50KHQsIFB0KS5kaXN0YW5jZVRvKHQpOwogIH0KICBnZXRCb3VuZGluZ1NwaGVyZSh0KSB7CiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0Lm1ha2VFbXB0eSgpIDogKHRoaXMuZ2V0Q2VudGVyKHQuY2VudGVyKSwgdC5yYWRpdXMgPSB0aGlzLmdldFNpemUoUHQpLmxlbmd0aCgpICogMC41KSwgdDsKICB9CiAgaW50ZXJzZWN0KHQpIHsKICAgIHJldHVybiB0aGlzLm1pbi5tYXgodC5taW4pLCB0aGlzLm1heC5taW4odC5tYXgpLCB0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLm1ha2VFbXB0eSgpLCB0aGlzOwogIH0KICB1bmlvbih0KSB7CiAgICByZXR1cm4gdGhpcy5taW4ubWluKHQubWluKSwgdGhpcy5tYXgubWF4KHQubWF4KSwgdGhpczsKICB9CiAgYXBwbHlNYXRyaXg0KHQpIHsKICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHRoaXMgOiAocXRbMF0uc2V0KHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSwgcXRbMV0uc2V0KHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSwgcXRbMl0uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSwgcXRbM10uc2V0KHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSwgcXRbNF0uc2V0KHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSwgcXRbNV0uc2V0KHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSwgcXRbNl0uc2V0KHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnopLmFwcGx5TWF0cml4NCh0KSwgcXRbN10uc2V0KHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWF4LnopLmFwcGx5TWF0cml4NCh0KSwgdGhpcy5zZXRGcm9tUG9pbnRzKHF0KSwgdGhpcyk7CiAgfQogIHRyYW5zbGF0ZSh0KSB7CiAgICByZXR1cm4gdGhpcy5taW4uYWRkKHQpLCB0aGlzLm1heC5hZGQodCksIHRoaXM7CiAgfQogIGVxdWFscyh0KSB7CiAgICByZXR1cm4gdC5taW4uZXF1YWxzKHRoaXMubWluKSAmJiB0Lm1heC5lcXVhbHModGhpcy5tYXgpOwogIH0KfQpjb25zdCBxdCA9IFsKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwKICAvKiBAX19QVVJFX18gKi8gbmV3IHAoKQpdLCBQdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgcCgpLCBOZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2UoKSwgb2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgY2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgRHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgVXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgSHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgZ2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgTGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgcWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgSnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKTsKZnVuY3Rpb24gb24ocywgdCwgZSwgbiwgaSkgewogIGZvciAobGV0IHIgPSAwLCBhID0gcy5sZW5ndGggLSAzOyByIDw9IGE7IHIgKz0gMykgewogICAgSnQuZnJvbUFycmF5KHMsIHIpOwogICAgY29uc3QgbyA9IGkueCAqIE1hdGguYWJzKEp0LngpICsgaS55ICogTWF0aC5hYnMoSnQueSkgKyBpLnogKiBNYXRoLmFicyhKdC56KSwgaCA9IHQuZG90KEp0KSwgYyA9IGUuZG90KEp0KSwgbCA9IG4uZG90KEp0KTsKICAgIGlmIChNYXRoLm1heCgtTWF0aC5tYXgoaCwgYywgbCksIE1hdGgubWluKGgsIGMsIGwpKSA+IG8pCiAgICAgIHJldHVybiAhMTsKICB9CiAgcmV0dXJuICEwOwp9CmNvbnN0IHZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIGhuID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIHZlID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIFd0ID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIGNuID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIGplID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCksIGxuID0gLyogQF9fUFVSRV9fICovIG5ldyBwKCk7CmNsYXNzIGVuIHsKICBjb25zdHJ1Y3Rvcih0ID0gbmV3IHAoKSwgZSA9IG5ldyBwKDAsIDAsIC0xKSkgewogICAgdGhpcy5vcmlnaW4gPSB0LCB0aGlzLmRpcmVjdGlvbiA9IGU7CiAgfQogIHNldCh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0KSwgdGhpcy5kaXJlY3Rpb24uY29weShlKSwgdGhpczsKICB9CiAgY29weSh0KSB7CiAgICByZXR1cm4gdGhpcy5vcmlnaW4uY29weSh0Lm9yaWdpbiksIHRoaXMuZGlyZWN0aW9uLmNvcHkodC5kaXJlY3Rpb24pLCB0aGlzOwogIH0KICBhdCh0LCBlKSB7CiAgICByZXR1cm4gZS5jb3B5KHRoaXMub3JpZ2luKS5hZGRTY2FsZWRWZWN0b3IodGhpcy5kaXJlY3Rpb24sIHQpOwogIH0KICBsb29rQXQodCkgewogICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uLmNvcHkodCkuc3ViKHRoaXMub3JpZ2luKS5ub3JtYWxpemUoKSwgdGhpczsKICB9CiAgcmVjYXN0KHQpIHsKICAgIHJldHVybiB0aGlzLm9yaWdpbi5jb3B5KHRoaXMuYXQodCwgdnQpKSwgdGhpczsKICB9CiAgY2xvc2VzdFBvaW50VG9Qb2ludCh0LCBlKSB7CiAgICBlLnN1YlZlY3RvcnModCwgdGhpcy5vcmlnaW4pOwogICAgY29uc3QgbiA9IGUuZG90KHRoaXMuZGlyZWN0aW9uKTsKICAgIHJldHVybiBuIDwgMCA/IGUuY29weSh0aGlzLm9yaWdpbikgOiBlLmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbiwgbik7CiAgfQogIGRpc3RhbmNlVG9Qb2ludCh0KSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQodCkpOwogIH0KICBkaXN0YW5jZVNxVG9Qb2ludCh0KSB7CiAgICBjb25zdCBlID0gdnQuc3ViVmVjdG9ycyh0LCB0aGlzLm9yaWdpbikuZG90KHRoaXMuZGlyZWN0aW9uKTsKICAgIHJldHVybiBlIDwgMCA/IHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKHQpIDogKHZ0LmNvcHkodGhpcy5vcmlnaW4pLmFkZFNjYWxlZFZlY3Rvcih0aGlzLmRpcmVjdGlvbiwgZSksIHZ0LmRpc3RhbmNlVG9TcXVhcmVkKHQpKTsKICB9CiAgZGlzdGFuY2VTcVRvU2VnbWVudCh0LCBlLCBuLCBpKSB7CiAgICBobi5jb3B5KHQpLmFkZChlKS5tdWx0aXBseVNjYWxhcigwLjUpLCB2ZS5jb3B5KGUpLnN1Yih0KS5ub3JtYWxpemUoKSwgV3QuY29weSh0aGlzLm9yaWdpbikuc3ViKGhuKTsKICAgIGNvbnN0IHIgPSB0LmRpc3RhbmNlVG8oZSkgKiAwLjUsIGEgPSAtdGhpcy5kaXJlY3Rpb24uZG90KHZlKSwgbyA9IFd0LmRvdCh0aGlzLmRpcmVjdGlvbiksIGggPSAtV3QuZG90KHZlKSwgYyA9IFd0Lmxlbmd0aFNxKCksIGwgPSBNYXRoLmFicygxIC0gYSAqIGEpOwogICAgbGV0IHUsIGQsIHksIGY7CiAgICBpZiAobCA+IDApCiAgICAgIGlmICh1ID0gYSAqIGggLSBvLCBkID0gYSAqIG8gLSBoLCBmID0gciAqIGwsIHUgPj0gMCkKICAgICAgICBpZiAoZCA+PSAtZikKICAgICAgICAgIGlmIChkIDw9IGYpIHsKICAgICAgICAgICAgY29uc3QgZyA9IDEgLyBsOwogICAgICAgICAgICB1ICo9IGcsIGQgKj0gZywgeSA9IHUgKiAodSArIGEgKiBkICsgMiAqIG8pICsgZCAqIChhICogdSArIGQgKyAyICogaCkgKyBjOwogICAgICAgICAgfSBlbHNlCiAgICAgICAgICAgIGQgPSByLCB1ID0gTWF0aC5tYXgoMCwgLShhICogZCArIG8pKSwgeSA9IC11ICogdSArIGQgKiAoZCArIDIgKiBoKSArIGM7CiAgICAgICAgZWxzZQogICAgICAgICAgZCA9IC1yLCB1ID0gTWF0aC5tYXgoMCwgLShhICogZCArIG8pKSwgeSA9IC11ICogdSArIGQgKiAoZCArIDIgKiBoKSArIGM7CiAgICAgIGVsc2UKICAgICAgICBkIDw9IC1mID8gKHUgPSBNYXRoLm1heCgwLCAtKC1hICogciArIG8pKSwgZCA9IHUgPiAwID8gLXIgOiBNYXRoLm1pbihNYXRoLm1heCgtciwgLWgpLCByKSwgeSA9IC11ICogdSArIGQgKiAoZCArIDIgKiBoKSArIGMpIDogZCA8PSBmID8gKHUgPSAwLCBkID0gTWF0aC5taW4oTWF0aC5tYXgoLXIsIC1oKSwgciksIHkgPSBkICogKGQgKyAyICogaCkgKyBjKSA6ICh1ID0gTWF0aC5tYXgoMCwgLShhICogciArIG8pKSwgZCA9IHUgPiAwID8gciA6IE1hdGgubWluKE1hdGgubWF4KC1yLCAtaCksIHIpLCB5ID0gLXUgKiB1ICsgZCAqIChkICsgMiAqIGgpICsgYyk7CiAgICBlbHNlCiAgICAgIGQgPSBhID4gMCA/IC1yIDogciwgdSA9IE1hdGgubWF4KDAsIC0oYSAqIGQgKyBvKSksIHkgPSAtdSAqIHUgKyBkICogKGQgKyAyICogaCkgKyBjOwogICAgcmV0dXJuIG4gJiYgbi5jb3B5KHRoaXMub3JpZ2luKS5hZGRTY2FsZWRWZWN0b3IodGhpcy5kaXJlY3Rpb24sIHUpLCBpICYmIGkuY29weShobikuYWRkU2NhbGVkVmVjdG9yKHZlLCBkKSwgeTsKICB9CiAgaW50ZXJzZWN0U3BoZXJlKHQsIGUpIHsKICAgIHZ0LnN1YlZlY3RvcnModC5jZW50ZXIsIHRoaXMub3JpZ2luKTsKICAgIGNvbnN0IG4gPSB2dC5kb3QodGhpcy5kaXJlY3Rpb24pLCBpID0gdnQuZG90KHZ0KSAtIG4gKiBuLCByID0gdC5yYWRpdXMgKiB0LnJhZGl1czsKICAgIGlmIChpID4gcikKICAgICAgcmV0dXJuIG51bGw7CiAgICBjb25zdCBhID0gTWF0aC5zcXJ0KHIgLSBpKSwgbyA9IG4gLSBhLCBoID0gbiArIGE7CiAgICByZXR1cm4gaCA8IDAgPyBudWxsIDogbyA8IDAgPyB0aGlzLmF0KGgsIGUpIDogdGhpcy5hdChvLCBlKTsKICB9CiAgaW50ZXJzZWN0c1NwaGVyZSh0KSB7CiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCh0LmNlbnRlcikgPD0gdC5yYWRpdXMgKiB0LnJhZGl1czsKICB9CiAgZGlzdGFuY2VUb1BsYW5lKHQpIHsKICAgIGNvbnN0IGUgPSB0Lm5vcm1hbC5kb3QodGhpcy5kaXJlY3Rpb24pOwogICAgaWYgKGUgPT09IDApCiAgICAgIHJldHVybiB0LmRpc3RhbmNlVG9Qb2ludCh0aGlzLm9yaWdpbikgPT09IDAgPyAwIDogbnVsbDsKICAgIGNvbnN0IG4gPSAtKHRoaXMub3JpZ2luLmRvdCh0Lm5vcm1hbCkgKyB0LmNvbnN0YW50KSAvIGU7CiAgICByZXR1cm4gbiA+PSAwID8gbiA6IG51bGw7CiAgfQogIGludGVyc2VjdFBsYW5lKHQsIGUpIHsKICAgIGNvbnN0IG4gPSB0aGlzLmRpc3RhbmNlVG9QbGFuZSh0KTsKICAgIHJldHVybiBuID09PSBudWxsID8gbnVsbCA6IHRoaXMuYXQobiwgZSk7CiAgfQogIGludGVyc2VjdHNQbGFuZSh0KSB7CiAgICBjb25zdCBlID0gdC5kaXN0YW5jZVRvUG9pbnQodGhpcy5vcmlnaW4pOwogICAgcmV0dXJuIGUgPT09IDAgfHwgdC5ub3JtYWwuZG90KHRoaXMuZGlyZWN0aW9uKSAqIGUgPCAwOwogIH0KICBpbnRlcnNlY3RCb3godCwgZSkgewogICAgbGV0IG4sIGksIHIsIGEsIG8sIGg7CiAgICBjb25zdCBjID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsIGwgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSwgdSA9IDEgLyB0aGlzLmRpcmVjdGlvbi56LCBkID0gdGhpcy5vcmlnaW47CiAgICByZXR1cm4gYyA+PSAwID8gKG4gPSAodC5taW4ueCAtIGQueCkgKiBjLCBpID0gKHQubWF4LnggLSBkLngpICogYykgOiAobiA9ICh0Lm1heC54IC0gZC54KSAqIGMsIGkgPSAodC5taW4ueCAtIGQueCkgKiBjKSwgbCA+PSAwID8gKHIgPSAodC5taW4ueSAtIGQueSkgKiBsLCBhID0gKHQubWF4LnkgLSBkLnkpICogbCkgOiAociA9ICh0Lm1heC55IC0gZC55KSAqIGwsIGEgPSAodC5taW4ueSAtIGQueSkgKiBsKSwgbiA+IGEgfHwgciA+IGkgfHwgKChyID4gbiB8fCBpc05hTihuKSkgJiYgKG4gPSByKSwgKGEgPCBpIHx8IGlzTmFOKGkpKSAmJiAoaSA9IGEpLCB1ID49IDAgPyAobyA9ICh0Lm1pbi56IC0gZC56KSAqIHUsIGggPSAodC5tYXgueiAtIGQueikgKiB1KSA6IChvID0gKHQubWF4LnogLSBkLnopICogdSwgaCA9ICh0Lm1pbi56IC0gZC56KSAqIHUpLCBuID4gaCB8fCBvID4gaSkgfHwgKChvID4gbiB8fCBuICE9PSBuKSAmJiAobiA9IG8pLCAoaCA8IGkgfHwgaSAhPT0gaSkgJiYgKGkgPSBoKSwgaSA8IDApID8gbnVsbCA6IHRoaXMuYXQobiA+PSAwID8gbiA6IGksIGUpOwogIH0KICBpbnRlcnNlY3RzQm94KHQpIHsKICAgIHJldHVybiB0aGlzLmludGVyc2VjdEJveCh0LCB2dCkgIT09IG51bGw7CiAgfQogIGludGVyc2VjdFRyaWFuZ2xlKHQsIGUsIG4sIGksIHIpIHsKICAgIGNuLnN1YlZlY3RvcnMoZSwgdCksIGplLnN1YlZlY3RvcnMobiwgdCksIGxuLmNyb3NzVmVjdG9ycyhjbiwgamUpOwogICAgbGV0IGEgPSB0aGlzLmRpcmVjdGlvbi5kb3QobG4pLCBvOwogICAgaWYgKGEgPiAwKSB7CiAgICAgIGlmIChpKQogICAgICAgIHJldHVybiBudWxsOwogICAgICBvID0gMTsKICAgIH0gZWxzZSBpZiAoYSA8IDApCiAgICAgIG8gPSAtMSwgYSA9IC1hOwogICAgZWxzZQogICAgICByZXR1cm4gbnVsbDsKICAgIFd0LnN1YlZlY3RvcnModGhpcy5vcmlnaW4sIHQpOwogICAgY29uc3QgaCA9IG8gKiB0aGlzLmRpcmVjdGlvbi5kb3QoamUuY3Jvc3NWZWN0b3JzKFd0LCBqZSkpOwogICAgaWYgKGggPCAwKQogICAgICByZXR1cm4gbnVsbDsKICAgIGNvbnN0IGMgPSBvICogdGhpcy5kaXJlY3Rpb24uZG90KGNuLmNyb3NzKFd0KSk7CiAgICBpZiAoYyA8IDAgfHwgaCArIGMgPiBhKQogICAgICByZXR1cm4gbnVsbDsKICAgIGNvbnN0IGwgPSAtbyAqIFd0LmRvdChsbik7CiAgICByZXR1cm4gbCA8IDAgPyBudWxsIDogdGhpcy5hdChsIC8gYSwgcik7CiAgfQogIGFwcGx5TWF0cml4NCh0KSB7CiAgICByZXR1cm4gdGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KHQpLCB0aGlzLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24odCksIHRoaXM7CiAgfQogIGVxdWFscyh0KSB7CiAgICByZXR1cm4gdC5vcmlnaW4uZXF1YWxzKHRoaXMub3JpZ2luKSAmJiB0LmRpcmVjdGlvbi5lcXVhbHModGhpcy5kaXJlY3Rpb24pOwogIH0KICBjbG9uZSgpIHsKICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkodGhpcyk7CiAgfQp9CmNsYXNzIGF0IHsKICBjb25zdHJ1Y3Rvcih0LCBlLCBuLCBpLCByLCBhLCBvLCBoLCBjLCBsLCB1LCBkLCB5LCBmLCBnLCBfKSB7CiAgICBhdC5wcm90b3R5cGUuaXNNYXRyaXg0ID0gITAsIHRoaXMuZWxlbWVudHMgPSBbCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgIF0sIHQgIT09IHZvaWQgMCAmJiB0aGlzLnNldCh0LCBlLCBuLCBpLCByLCBhLCBvLCBoLCBjLCBsLCB1LCBkLCB5LCBmLCBnLCBfKTsKICB9CiAgc2V0KHQsIGUsIG4sIGksIHIsIGEsIG8sIGgsIGMsIGwsIHUsIGQsIHksIGYsIGcsIF8pIHsKICAgIGNvbnN0IHcgPSB0aGlzLmVsZW1lbnRzOwogICAgcmV0dXJuIHdbMF0gPSB0LCB3WzRdID0gZSwgd1s4XSA9IG4sIHdbMTJdID0gaSwgd1sxXSA9IHIsIHdbNV0gPSBhLCB3WzldID0gbywgd1sxM10gPSBoLCB3WzJdID0gYywgd1s2XSA9IGwsIHdbMTBdID0gdSwgd1sxNF0gPSBkLCB3WzNdID0geSwgd1s3XSA9IGYsIHdbMTFdID0gZywgd1sxNV0gPSBfLCB0aGlzOwogIH0KICBpZGVudGl0eSgpIHsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgY2xvbmUoKSB7CiAgICByZXR1cm4gbmV3IGF0KCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpOwogIH0KICBjb3B5KHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBuID0gdC5lbGVtZW50czsKICAgIHJldHVybiBlWzBdID0gblswXSwgZVsxXSA9IG5bMV0sIGVbMl0gPSBuWzJdLCBlWzNdID0gblszXSwgZVs0XSA9IG5bNF0sIGVbNV0gPSBuWzVdLCBlWzZdID0gbls2XSwgZVs3XSA9IG5bN10sIGVbOF0gPSBuWzhdLCBlWzldID0gbls5XSwgZVsxMF0gPSBuWzEwXSwgZVsxMV0gPSBuWzExXSwgZVsxMl0gPSBuWzEyXSwgZVsxM10gPSBuWzEzXSwgZVsxNF0gPSBuWzE0XSwgZVsxNV0gPSBuWzE1XSwgdGhpczsKICB9CiAgY29weVBvc2l0aW9uKHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBuID0gdC5lbGVtZW50czsKICAgIHJldHVybiBlWzEyXSA9IG5bMTJdLCBlWzEzXSA9IG5bMTNdLCBlWzE0XSA9IG5bMTRdLCB0aGlzOwogIH0KICBzZXRGcm9tTWF0cml4Myh0KSB7CiAgICBjb25zdCBlID0gdC5lbGVtZW50czsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgZVswXSwKICAgICAgZVszXSwKICAgICAgZVs2XSwKICAgICAgMCwKICAgICAgZVsxXSwKICAgICAgZVs0XSwKICAgICAgZVs3XSwKICAgICAgMCwKICAgICAgZVsyXSwKICAgICAgZVs1XSwKICAgICAgZVs4XSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgZXh0cmFjdEJhc2lzKHQsIGUsIG4pIHsKICAgIHJldHVybiB0LnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMCksIGUuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAxKSwgbi5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDIpLCB0aGlzOwogIH0KICBtYWtlQmFzaXModCwgZSwgbikgewogICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICB0LngsCiAgICAgIGUueCwKICAgICAgbi54LAogICAgICAwLAogICAgICB0LnksCiAgICAgIGUueSwKICAgICAgbi55LAogICAgICAwLAogICAgICB0LnosCiAgICAgIGUueiwKICAgICAgbi56LAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAxCiAgICApLCB0aGlzOwogIH0KICBleHRyYWN0Um90YXRpb24odCkgewogICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHMsIG4gPSB0LmVsZW1lbnRzLCBpID0gMSAvIGxlLnNldEZyb21NYXRyaXhDb2x1bW4odCwgMCkubGVuZ3RoKCksIHIgPSAxIC8gbGUuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAxKS5sZW5ndGgoKSwgYSA9IDEgLyBsZS5zZXRGcm9tTWF0cml4Q29sdW1uKHQsIDIpLmxlbmd0aCgpOwogICAgcmV0dXJuIGVbMF0gPSBuWzBdICogaSwgZVsxXSA9IG5bMV0gKiBpLCBlWzJdID0gblsyXSAqIGksIGVbM10gPSAwLCBlWzRdID0gbls0XSAqIHIsIGVbNV0gPSBuWzVdICogciwgZVs2XSA9IG5bNl0gKiByLCBlWzddID0gMCwgZVs4XSA9IG5bOF0gKiBhLCBlWzldID0gbls5XSAqIGEsIGVbMTBdID0gblsxMF0gKiBhLCBlWzExXSA9IDAsIGVbMTJdID0gMCwgZVsxM10gPSAwLCBlWzE0XSA9IDAsIGVbMTVdID0gMSwgdGhpczsKICB9CiAgbWFrZVJvdGF0aW9uRnJvbUV1bGVyKHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBuID0gdC54LCBpID0gdC55LCByID0gdC56LCBhID0gTWF0aC5jb3MobiksIG8gPSBNYXRoLnNpbihuKSwgaCA9IE1hdGguY29zKGkpLCBjID0gTWF0aC5zaW4oaSksIGwgPSBNYXRoLmNvcyhyKSwgdSA9IE1hdGguc2luKHIpOwogICAgaWYgKHQub3JkZXIgPT09ICJYWVoiKSB7CiAgICAgIGNvbnN0IGQgPSBhICogbCwgeSA9IGEgKiB1LCBmID0gbyAqIGwsIGcgPSBvICogdTsKICAgICAgZVswXSA9IGggKiBsLCBlWzRdID0gLWggKiB1LCBlWzhdID0gYywgZVsxXSA9IHkgKyBmICogYywgZVs1XSA9IGQgLSBnICogYywgZVs5XSA9IC1vICogaCwgZVsyXSA9IGcgLSBkICogYywgZVs2XSA9IGYgKyB5ICogYywgZVsxMF0gPSBhICogaDsKICAgIH0gZWxzZSBpZiAodC5vcmRlciA9PT0gIllYWiIpIHsKICAgICAgY29uc3QgZCA9IGggKiBsLCB5ID0gaCAqIHUsIGYgPSBjICogbCwgZyA9IGMgKiB1OwogICAgICBlWzBdID0gZCArIGcgKiBvLCBlWzRdID0gZiAqIG8gLSB5LCBlWzhdID0gYSAqIGMsIGVbMV0gPSBhICogdSwgZVs1XSA9IGEgKiBsLCBlWzldID0gLW8sIGVbMl0gPSB5ICogbyAtIGYsIGVbNl0gPSBnICsgZCAqIG8sIGVbMTBdID0gYSAqIGg7CiAgICB9IGVsc2UgaWYgKHQub3JkZXIgPT09ICJaWFkiKSB7CiAgICAgIGNvbnN0IGQgPSBoICogbCwgeSA9IGggKiB1LCBmID0gYyAqIGwsIGcgPSBjICogdTsKICAgICAgZVswXSA9IGQgLSBnICogbywgZVs0XSA9IC1hICogdSwgZVs4XSA9IGYgKyB5ICogbywgZVsxXSA9IHkgKyBmICogbywgZVs1XSA9IGEgKiBsLCBlWzldID0gZyAtIGQgKiBvLCBlWzJdID0gLWEgKiBjLCBlWzZdID0gbywgZVsxMF0gPSBhICogaDsKICAgIH0gZWxzZSBpZiAodC5vcmRlciA9PT0gIlpZWCIpIHsKICAgICAgY29uc3QgZCA9IGEgKiBsLCB5ID0gYSAqIHUsIGYgPSBvICogbCwgZyA9IG8gKiB1OwogICAgICBlWzBdID0gaCAqIGwsIGVbNF0gPSBmICogYyAtIHksIGVbOF0gPSBkICogYyArIGcsIGVbMV0gPSBoICogdSwgZVs1XSA9IGcgKiBjICsgZCwgZVs5XSA9IHkgKiBjIC0gZiwgZVsyXSA9IC1jLCBlWzZdID0gbyAqIGgsIGVbMTBdID0gYSAqIGg7CiAgICB9IGVsc2UgaWYgKHQub3JkZXIgPT09ICJZWlgiKSB7CiAgICAgIGNvbnN0IGQgPSBhICogaCwgeSA9IGEgKiBjLCBmID0gbyAqIGgsIGcgPSBvICogYzsKICAgICAgZVswXSA9IGggKiBsLCBlWzRdID0gZyAtIGQgKiB1LCBlWzhdID0gZiAqIHUgKyB5LCBlWzFdID0gdSwgZVs1XSA9IGEgKiBsLCBlWzldID0gLW8gKiBsLCBlWzJdID0gLWMgKiBsLCBlWzZdID0geSAqIHUgKyBmLCBlWzEwXSA9IGQgLSBnICogdTsKICAgIH0gZWxzZSBpZiAodC5vcmRlciA9PT0gIlhaWSIpIHsKICAgICAgY29uc3QgZCA9IGEgKiBoLCB5ID0gYSAqIGMsIGYgPSBvICogaCwgZyA9IG8gKiBjOwogICAgICBlWzBdID0gaCAqIGwsIGVbNF0gPSAtdSwgZVs4XSA9IGMgKiBsLCBlWzFdID0gZCAqIHUgKyBnLCBlWzVdID0gYSAqIGwsIGVbOV0gPSB5ICogdSAtIGYsIGVbMl0gPSBmICogdSAtIHksIGVbNl0gPSBvICogbCwgZVsxMF0gPSBnICogdSArIGQ7CiAgICB9CiAgICByZXR1cm4gZVszXSA9IDAsIGVbN10gPSAwLCBlWzExXSA9IDAsIGVbMTJdID0gMCwgZVsxM10gPSAwLCBlWzE0XSA9IDAsIGVbMTVdID0gMSwgdGhpczsKICB9CiAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24odCkgewogICAgcmV0dXJuIHRoaXMuY29tcG9zZSh6cywgdCwgZ3MpOwogIH0KICBsb29rQXQodCwgZSwgbikgewogICAgY29uc3QgaSA9IHRoaXMuZWxlbWVudHM7CiAgICByZXR1cm4geXQuc3ViVmVjdG9ycyh0LCBlKSwgeXQubGVuZ3RoU3EoKSA9PT0gMCAmJiAoeXQueiA9IDEpLCB5dC5ub3JtYWxpemUoKSwgRnQuY3Jvc3NWZWN0b3JzKG4sIHl0KSwgRnQubGVuZ3RoU3EoKSA9PT0gMCAmJiAoTWF0aC5hYnMobi56KSA9PT0gMSA/IHl0LnggKz0gMWUtNCA6IHl0LnogKz0gMWUtNCwgeXQubm9ybWFsaXplKCksIEZ0LmNyb3NzVmVjdG9ycyhuLCB5dCkpLCBGdC5ub3JtYWxpemUoKSwga2UuY3Jvc3NWZWN0b3JzKHl0LCBGdCksIGlbMF0gPSBGdC54LCBpWzRdID0ga2UueCwgaVs4XSA9IHl0LngsIGlbMV0gPSBGdC55LCBpWzVdID0ga2UueSwgaVs5XSA9IHl0LnksIGlbMl0gPSBGdC56LCBpWzZdID0ga2UueiwgaVsxMF0gPSB5dC56LCB0aGlzOwogIH0KICBtdWx0aXBseSh0KSB7CiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIHQpOwogIH0KICBwcmVtdWx0aXBseSh0KSB7CiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsIHRoaXMpOwogIH0KICBtdWx0aXBseU1hdHJpY2VzKHQsIGUpIHsKICAgIGNvbnN0IG4gPSB0LmVsZW1lbnRzLCBpID0gZS5lbGVtZW50cywgciA9IHRoaXMuZWxlbWVudHMsIGEgPSBuWzBdLCBvID0gbls0XSwgaCA9IG5bOF0sIGMgPSBuWzEyXSwgbCA9IG5bMV0sIHUgPSBuWzVdLCBkID0gbls5XSwgeSA9IG5bMTNdLCBmID0gblsyXSwgZyA9IG5bNl0sIF8gPSBuWzEwXSwgdyA9IG5bMTRdLCB4ID0gblszXSwgbSA9IG5bN10sIE0gPSBuWzExXSwgeiA9IG5bMTVdLCBQID0gaVswXSwgVCA9IGlbNF0sIGIgPSBpWzhdLCBOID0gaVsxMl0sIEkgPSBpWzFdLCBDID0gaVs1XSwgTyA9IGlbOV0sIFIgPSBpWzEzXSwgRCA9IGlbMl0sIFUgPSBpWzZdLCBMID0gaVsxMF0sIHEgPSBpWzE0XSwgayA9IGlbM10sIFcgPSBpWzddLCBYID0gaVsxMV0sIFogPSBpWzE1XTsKICAgIHJldHVybiByWzBdID0gYSAqIFAgKyBvICogSSArIGggKiBEICsgYyAqIGssIHJbNF0gPSBhICogVCArIG8gKiBDICsgaCAqIFUgKyBjICogVywgcls4XSA9IGEgKiBiICsgbyAqIE8gKyBoICogTCArIGMgKiBYLCByWzEyXSA9IGEgKiBOICsgbyAqIFIgKyBoICogcSArIGMgKiBaLCByWzFdID0gbCAqIFAgKyB1ICogSSArIGQgKiBEICsgeSAqIGssIHJbNV0gPSBsICogVCArIHUgKiBDICsgZCAqIFUgKyB5ICogVywgcls5XSA9IGwgKiBiICsgdSAqIE8gKyBkICogTCArIHkgKiBYLCByWzEzXSA9IGwgKiBOICsgdSAqIFIgKyBkICogcSArIHkgKiBaLCByWzJdID0gZiAqIFAgKyBnICogSSArIF8gKiBEICsgdyAqIGssIHJbNl0gPSBmICogVCArIGcgKiBDICsgXyAqIFUgKyB3ICogVywgclsxMF0gPSBmICogYiArIGcgKiBPICsgXyAqIEwgKyB3ICogWCwgclsxNF0gPSBmICogTiArIGcgKiBSICsgXyAqIHEgKyB3ICogWiwgclszXSA9IHggKiBQICsgbSAqIEkgKyBNICogRCArIHogKiBrLCByWzddID0geCAqIFQgKyBtICogQyArIE0gKiBVICsgeiAqIFcsIHJbMTFdID0geCAqIGIgKyBtICogTyArIE0gKiBMICsgeiAqIFgsIHJbMTVdID0geCAqIE4gKyBtICogUiArIE0gKiBxICsgeiAqIFosIHRoaXM7CiAgfQogIG11bHRpcGx5U2NhbGFyKHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzOwogICAgcmV0dXJuIGVbMF0gKj0gdCwgZVs0XSAqPSB0LCBlWzhdICo9IHQsIGVbMTJdICo9IHQsIGVbMV0gKj0gdCwgZVs1XSAqPSB0LCBlWzldICo9IHQsIGVbMTNdICo9IHQsIGVbMl0gKj0gdCwgZVs2XSAqPSB0LCBlWzEwXSAqPSB0LCBlWzE0XSAqPSB0LCBlWzNdICo9IHQsIGVbN10gKj0gdCwgZVsxMV0gKj0gdCwgZVsxNV0gKj0gdCwgdGhpczsKICB9CiAgZGV0ZXJtaW5hbnQoKSB7CiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cywgZSA9IHRbMF0sIG4gPSB0WzRdLCBpID0gdFs4XSwgciA9IHRbMTJdLCBhID0gdFsxXSwgbyA9IHRbNV0sIGggPSB0WzldLCBjID0gdFsxM10sIGwgPSB0WzJdLCB1ID0gdFs2XSwgZCA9IHRbMTBdLCB5ID0gdFsxNF0sIGYgPSB0WzNdLCBnID0gdFs3XSwgXyA9IHRbMTFdLCB3ID0gdFsxNV07CiAgICByZXR1cm4gZiAqICgrciAqIGggKiB1IC0gaSAqIGMgKiB1IC0gciAqIG8gKiBkICsgbiAqIGMgKiBkICsgaSAqIG8gKiB5IC0gbiAqIGggKiB5KSArIGcgKiAoK2UgKiBoICogeSAtIGUgKiBjICogZCArIHIgKiBhICogZCAtIGkgKiBhICogeSArIGkgKiBjICogbCAtIHIgKiBoICogbCkgKyBfICogKCtlICogYyAqIHUgLSBlICogbyAqIHkgLSByICogYSAqIHUgKyBuICogYSAqIHkgKyByICogbyAqIGwgLSBuICogYyAqIGwpICsgdyAqICgtaSAqIG8gKiBsIC0gZSAqIGggKiB1ICsgZSAqIG8gKiBkICsgaSAqIGEgKiB1IC0gbiAqIGEgKiBkICsgbiAqIGggKiBsKTsKICB9CiAgdHJhbnNwb3NlKCkgewogICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHM7CiAgICBsZXQgZTsKICAgIHJldHVybiBlID0gdFsxXSwgdFsxXSA9IHRbNF0sIHRbNF0gPSBlLCBlID0gdFsyXSwgdFsyXSA9IHRbOF0sIHRbOF0gPSBlLCBlID0gdFs2XSwgdFs2XSA9IHRbOV0sIHRbOV0gPSBlLCBlID0gdFszXSwgdFszXSA9IHRbMTJdLCB0WzEyXSA9IGUsIGUgPSB0WzddLCB0WzddID0gdFsxM10sIHRbMTNdID0gZSwgZSA9IHRbMTFdLCB0WzExXSA9IHRbMTRdLCB0WzE0XSA9IGUsIHRoaXM7CiAgfQogIHNldFBvc2l0aW9uKHQsIGUsIG4pIHsKICAgIGNvbnN0IGkgPSB0aGlzLmVsZW1lbnRzOwogICAgcmV0dXJuIHQuaXNWZWN0b3IzID8gKGlbMTJdID0gdC54LCBpWzEzXSA9IHQueSwgaVsxNF0gPSB0LnopIDogKGlbMTJdID0gdCwgaVsxM10gPSBlLCBpWzE0XSA9IG4pLCB0aGlzOwogIH0KICBpbnZlcnQoKSB7CiAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cywgZSA9IHRbMF0sIG4gPSB0WzFdLCBpID0gdFsyXSwgciA9IHRbM10sIGEgPSB0WzRdLCBvID0gdFs1XSwgaCA9IHRbNl0sIGMgPSB0WzddLCBsID0gdFs4XSwgdSA9IHRbOV0sIGQgPSB0WzEwXSwgeSA9IHRbMTFdLCBmID0gdFsxMl0sIGcgPSB0WzEzXSwgXyA9IHRbMTRdLCB3ID0gdFsxNV0sIHggPSB1ICogXyAqIGMgLSBnICogZCAqIGMgKyBnICogaCAqIHkgLSBvICogXyAqIHkgLSB1ICogaCAqIHcgKyBvICogZCAqIHcsIG0gPSBmICogZCAqIGMgLSBsICogXyAqIGMgLSBmICogaCAqIHkgKyBhICogXyAqIHkgKyBsICogaCAqIHcgLSBhICogZCAqIHcsIE0gPSBsICogZyAqIGMgLSBmICogdSAqIGMgKyBmICogbyAqIHkgLSBhICogZyAqIHkgLSBsICogbyAqIHcgKyBhICogdSAqIHcsIHogPSBmICogdSAqIGggLSBsICogZyAqIGggLSBmICogbyAqIGQgKyBhICogZyAqIGQgKyBsICogbyAqIF8gLSBhICogdSAqIF8sIFAgPSBlICogeCArIG4gKiBtICsgaSAqIE0gKyByICogejsKICAgIGlmIChQID09PSAwKQogICAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7CiAgICBjb25zdCBUID0gMSAvIFA7CiAgICByZXR1cm4gdFswXSA9IHggKiBULCB0WzFdID0gKGcgKiBkICogciAtIHUgKiBfICogciAtIGcgKiBpICogeSArIG4gKiBfICogeSArIHUgKiBpICogdyAtIG4gKiBkICogdykgKiBULCB0WzJdID0gKG8gKiBfICogciAtIGcgKiBoICogciArIGcgKiBpICogYyAtIG4gKiBfICogYyAtIG8gKiBpICogdyArIG4gKiBoICogdykgKiBULCB0WzNdID0gKHUgKiBoICogciAtIG8gKiBkICogciAtIHUgKiBpICogYyArIG4gKiBkICogYyArIG8gKiBpICogeSAtIG4gKiBoICogeSkgKiBULCB0WzRdID0gbSAqIFQsIHRbNV0gPSAobCAqIF8gKiByIC0gZiAqIGQgKiByICsgZiAqIGkgKiB5IC0gZSAqIF8gKiB5IC0gbCAqIGkgKiB3ICsgZSAqIGQgKiB3KSAqIFQsIHRbNl0gPSAoZiAqIGggKiByIC0gYSAqIF8gKiByIC0gZiAqIGkgKiBjICsgZSAqIF8gKiBjICsgYSAqIGkgKiB3IC0gZSAqIGggKiB3KSAqIFQsIHRbN10gPSAoYSAqIGQgKiByIC0gbCAqIGggKiByICsgbCAqIGkgKiBjIC0gZSAqIGQgKiBjIC0gYSAqIGkgKiB5ICsgZSAqIGggKiB5KSAqIFQsIHRbOF0gPSBNICogVCwgdFs5XSA9IChmICogdSAqIHIgLSBsICogZyAqIHIgLSBmICogbiAqIHkgKyBlICogZyAqIHkgKyBsICogbiAqIHcgLSBlICogdSAqIHcpICogVCwgdFsxMF0gPSAoYSAqIGcgKiByIC0gZiAqIG8gKiByICsgZiAqIG4gKiBjIC0gZSAqIGcgKiBjIC0gYSAqIG4gKiB3ICsgZSAqIG8gKiB3KSAqIFQsIHRbMTFdID0gKGwgKiBvICogciAtIGEgKiB1ICogciAtIGwgKiBuICogYyArIGUgKiB1ICogYyArIGEgKiBuICogeSAtIGUgKiBvICogeSkgKiBULCB0WzEyXSA9IHogKiBULCB0WzEzXSA9IChsICogZyAqIGkgLSBmICogdSAqIGkgKyBmICogbiAqIGQgLSBlICogZyAqIGQgLSBsICogbiAqIF8gKyBlICogdSAqIF8pICogVCwgdFsxNF0gPSAoZiAqIG8gKiBpIC0gYSAqIGcgKiBpIC0gZiAqIG4gKiBoICsgZSAqIGcgKiBoICsgYSAqIG4gKiBfIC0gZSAqIG8gKiBfKSAqIFQsIHRbMTVdID0gKGEgKiB1ICogaSAtIGwgKiBvICogaSArIGwgKiBuICogaCAtIGUgKiB1ICogaCAtIGEgKiBuICogZCArIGUgKiBvICogZCkgKiBULCB0aGlzOwogIH0KICBzY2FsZSh0KSB7CiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cywgbiA9IHQueCwgaSA9IHQueSwgciA9IHQuejsKICAgIHJldHVybiBlWzBdICo9IG4sIGVbNF0gKj0gaSwgZVs4XSAqPSByLCBlWzFdICo9IG4sIGVbNV0gKj0gaSwgZVs5XSAqPSByLCBlWzJdICo9IG4sIGVbNl0gKj0gaSwgZVsxMF0gKj0gciwgZVszXSAqPSBuLCBlWzddICo9IGksIGVbMTFdICo9IHIsIHRoaXM7CiAgfQogIGdldE1heFNjYWxlT25BeGlzKCkgewogICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIGUgPSB0WzBdICogdFswXSArIHRbMV0gKiB0WzFdICsgdFsyXSAqIHRbMl0sIG4gPSB0WzRdICogdFs0XSArIHRbNV0gKiB0WzVdICsgdFs2XSAqIHRbNl0sIGkgPSB0WzhdICogdFs4XSArIHRbOV0gKiB0WzldICsgdFsxMF0gKiB0WzEwXTsKICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoZSwgbiwgaSkpOwogIH0KICBtYWtlVHJhbnNsYXRpb24odCwgZSwgbikgewogICAgcmV0dXJuIHQuaXNWZWN0b3IzID8gdGhpcy5zZXQoCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIHQueCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMCwKICAgICAgdC55LAogICAgICAwLAogICAgICAwLAogICAgICAxLAogICAgICB0LnosCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICkgOiB0aGlzLnNldCgKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgdCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMCwKICAgICAgZSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMSwKICAgICAgbiwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgbWFrZVJvdGF0aW9uWCh0KSB7CiAgICBjb25zdCBlID0gTWF0aC5jb3ModCksIG4gPSBNYXRoLnNpbih0KTsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgZSwKICAgICAgLW4sCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIG4sCiAgICAgIGUsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICksIHRoaXM7CiAgfQogIG1ha2VSb3RhdGlvblkodCkgewogICAgY29uc3QgZSA9IE1hdGguY29zKHQpLCBuID0gTWF0aC5zaW4odCk7CiAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgIGUsCiAgICAgIDAsCiAgICAgIG4sCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIC1uLAogICAgICAwLAogICAgICBlLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAwLAogICAgICAxCiAgICApLCB0aGlzOwogIH0KICBtYWtlUm90YXRpb25aKHQpIHsKICAgIGNvbnN0IGUgPSBNYXRoLmNvcyh0KSwgbiA9IE1hdGguc2luKHQpOwogICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICBlLAogICAgICAtbiwKICAgICAgMCwKICAgICAgMCwKICAgICAgbiwKICAgICAgZSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMSwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMCwKICAgICAgMQogICAgKSwgdGhpczsKICB9CiAgbWFrZVJvdGF0aW9uQXhpcyh0LCBlKSB7CiAgICBjb25zdCBuID0gTWF0aC5jb3MoZSksIGkgPSBNYXRoLnNpbihlKSwgciA9IDEgLSBuLCBhID0gdC54LCBvID0gdC55LCBoID0gdC56LCBjID0gciAqIGEsIGwgPSByICogbzsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgYyAqIGEgKyBuLAogICAgICBjICogbyAtIGkgKiBoLAogICAgICBjICogaCArIGkgKiBvLAogICAgICAwLAogICAgICBjICogbyArIGkgKiBoLAogICAgICBsICogbyArIG4sCiAgICAgIGwgKiBoIC0gaSAqIGEsCiAgICAgIDAsCiAgICAgIGMgKiBoIC0gaSAqIG8sCiAgICAgIGwgKiBoICsgaSAqIGEsCiAgICAgIHIgKiBoICogaCArIG4sCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICksIHRoaXM7CiAgfQogIG1ha2VTY2FsZSh0LCBlLCBuKSB7CiAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgIHQsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIGUsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIG4sCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICksIHRoaXM7CiAgfQogIG1ha2VTaGVhcih0LCBlLCBuLCBpLCByLCBhKSB7CiAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgIDEsCiAgICAgIG4sCiAgICAgIHIsCiAgICAgIDAsCiAgICAgIHQsCiAgICAgIDEsCiAgICAgIGEsCiAgICAgIDAsCiAgICAgIGUsCiAgICAgIGksCiAgICAgIDEsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDAsCiAgICAgIDEKICAgICksIHRoaXM7CiAgfQogIGNvbXBvc2UodCwgZSwgbikgewogICAgY29uc3QgaSA9IHRoaXMuZWxlbWVudHMsIHIgPSBlLl94LCBhID0gZS5feSwgbyA9IGUuX3osIGggPSBlLl93LCBjID0gciArIHIsIGwgPSBhICsgYSwgdSA9IG8gKyBvLCBkID0gciAqIGMsIHkgPSByICogbCwgZiA9IHIgKiB1LCBnID0gYSAqIGwsIF8gPSBhICogdSwgdyA9IG8gKiB1LCB4ID0gaCAqIGMsIG0gPSBoICogbCwgTSA9IGggKiB1LCB6ID0gbi54LCBQID0gbi55LCBUID0gbi56OwogICAgcmV0dXJuIGlbMF0gPSAoMSAtIChnICsgdykpICogeiwgaVsxXSA9ICh5ICsgTSkgKiB6LCBpWzJdID0gKGYgLSBtKSAqIHosIGlbM10gPSAwLCBpWzRdID0gKHkgLSBNKSAqIFAsIGlbNV0gPSAoMSAtIChkICsgdykpICogUCwgaVs2XSA9IChfICsgeCkgKiBQLCBpWzddID0gMCwgaVs4XSA9IChmICsgbSkgKiBULCBpWzldID0gKF8gLSB4KSAqIFQsIGlbMTBdID0gKDEgLSAoZCArIGcpKSAqIFQsIGlbMTFdID0gMCwgaVsxMl0gPSB0LngsIGlbMTNdID0gdC55LCBpWzE0XSA9IHQueiwgaVsxNV0gPSAxLCB0aGlzOwogIH0KICBkZWNvbXBvc2UodCwgZSwgbikgewogICAgY29uc3QgaSA9IHRoaXMuZWxlbWVudHM7CiAgICBsZXQgciA9IGxlLnNldChpWzBdLCBpWzFdLCBpWzJdKS5sZW5ndGgoKTsKICAgIGNvbnN0IGEgPSBsZS5zZXQoaVs0XSwgaVs1XSwgaVs2XSkubGVuZ3RoKCksIG8gPSBsZS5zZXQoaVs4XSwgaVs5XSwgaVsxMF0pLmxlbmd0aCgpOwogICAgdGhpcy5kZXRlcm1pbmFudCgpIDwgMCAmJiAociA9IC1yKSwgdC54ID0gaVsxMl0sIHQueSA9IGlbMTNdLCB0LnogPSBpWzE0XSwgYnQuY29weSh0aGlzKTsKICAgIGNvbnN0IGMgPSAxIC8gciwgbCA9IDEgLyBhLCB1ID0gMSAvIG87CiAgICByZXR1cm4gYnQuZWxlbWVudHNbMF0gKj0gYywgYnQuZWxlbWVudHNbMV0gKj0gYywgYnQuZWxlbWVudHNbMl0gKj0gYywgYnQuZWxlbWVudHNbNF0gKj0gbCwgYnQuZWxlbWVudHNbNV0gKj0gbCwgYnQuZWxlbWVudHNbNl0gKj0gbCwgYnQuZWxlbWVudHNbOF0gKj0gdSwgYnQuZWxlbWVudHNbOV0gKj0gdSwgYnQuZWxlbWVudHNbMTBdICo9IHUsIGUuc2V0RnJvbVJvdGF0aW9uTWF0cml4KGJ0KSwgbi54ID0gciwgbi55ID0gYSwgbi56ID0gbywgdGhpczsKICB9CiAgbWFrZVBlcnNwZWN0aXZlKHQsIGUsIG4sIGksIHIsIGEsIG8gPSBSZSkgewogICAgY29uc3QgaCA9IHRoaXMuZWxlbWVudHMsIGMgPSAyICogciAvIChlIC0gdCksIGwgPSAyICogciAvIChuIC0gaSksIHUgPSAoZSArIHQpIC8gKGUgLSB0KSwgZCA9IChuICsgaSkgLyAobiAtIGkpOwogICAgbGV0IHksIGY7CiAgICBpZiAobyA9PT0gUmUpCiAgICAgIHkgPSAtKGEgKyByKSAvIChhIC0gciksIGYgPSAtMiAqIGEgKiByIC8gKGEgLSByKTsKICAgIGVsc2UgaWYgKG8gPT09IHZuKQogICAgICB5ID0gLWEgLyAoYSAtIHIpLCBmID0gLWEgKiByIC8gKGEgLSByKTsKICAgIGVsc2UKICAgICAgdGhyb3cgbmV3IEVycm9yKCJUSFJFRS5NYXRyaXg0Lm1ha2VQZXJzcGVjdGl2ZSgpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiICsgbyk7CiAgICByZXR1cm4gaFswXSA9IGMsIGhbNF0gPSAwLCBoWzhdID0gdSwgaFsxMl0gPSAwLCBoWzFdID0gMCwgaFs1XSA9IGwsIGhbOV0gPSBkLCBoWzEzXSA9IDAsIGhbMl0gPSAwLCBoWzZdID0gMCwgaFsxMF0gPSB5LCBoWzE0XSA9IGYsIGhbM10gPSAwLCBoWzddID0gMCwgaFsxMV0gPSAtMSwgaFsxNV0gPSAwLCB0aGlzOwogIH0KICBtYWtlT3J0aG9ncmFwaGljKHQsIGUsIG4sIGksIHIsIGEsIG8gPSBSZSkgewogICAgY29uc3QgaCA9IHRoaXMuZWxlbWVudHMsIGMgPSAxIC8gKGUgLSB0KSwgbCA9IDEgLyAobiAtIGkpLCB1ID0gMSAvIChhIC0gciksIGQgPSAoZSArIHQpICogYywgeSA9IChuICsgaSkgKiBsOwogICAgbGV0IGYsIGc7CiAgICBpZiAobyA9PT0gUmUpCiAgICAgIGYgPSAoYSArIHIpICogdSwgZyA9IC0yICogdTsKICAgIGVsc2UgaWYgKG8gPT09IHZuKQogICAgICBmID0gciAqIHUsIGcgPSAtMSAqIHU7CiAgICBlbHNlCiAgICAgIHRocm93IG5ldyBFcnJvcigiVEhSRUUuTWF0cml4NC5tYWtlT3J0aG9ncmFwaGljKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIgKyBvKTsKICAgIHJldHVybiBoWzBdID0gMiAqIGMsIGhbNF0gPSAwLCBoWzhdID0gMCwgaFsxMl0gPSAtZCwgaFsxXSA9IDAsIGhbNV0gPSAyICogbCwgaFs5XSA9IDAsIGhbMTNdID0gLXksIGhbMl0gPSAwLCBoWzZdID0gMCwgaFsxMF0gPSBnLCBoWzE0XSA9IC1mLCBoWzNdID0gMCwgaFs3XSA9IDAsIGhbMTFdID0gMCwgaFsxNV0gPSAxLCB0aGlzOwogIH0KICBlcXVhbHModCkgewogICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHMsIG4gPSB0LmVsZW1lbnRzOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKQogICAgICBpZiAoZVtpXSAhPT0gbltpXSkKICAgICAgICByZXR1cm4gITE7CiAgICByZXR1cm4gITA7CiAgfQogIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgZm9yIChsZXQgbiA9IDA7IG4gPCAxNjsgbisrKQogICAgICB0aGlzLmVsZW1lbnRzW25dID0gdFtuICsgZV07CiAgICByZXR1cm4gdGhpczsKICB9CiAgdG9BcnJheSh0ID0gW10sIGUgPSAwKSB7CiAgICBjb25zdCBuID0gdGhpcy5lbGVtZW50czsKICAgIHJldHVybiB0W2VdID0gblswXSwgdFtlICsgMV0gPSBuWzFdLCB0W2UgKyAyXSA9IG5bMl0sIHRbZSArIDNdID0gblszXSwgdFtlICsgNF0gPSBuWzRdLCB0W2UgKyA1XSA9IG5bNV0sIHRbZSArIDZdID0gbls2XSwgdFtlICsgN10gPSBuWzddLCB0W2UgKyA4XSA9IG5bOF0sIHRbZSArIDldID0gbls5XSwgdFtlICsgMTBdID0gblsxMF0sIHRbZSArIDExXSA9IG5bMTFdLCB0W2UgKyAxMl0gPSBuWzEyXSwgdFtlICsgMTNdID0gblsxM10sIHRbZSArIDE0XSA9IG5bMTRdLCB0W2UgKyAxNV0gPSBuWzE1XSwgdDsKICB9Cn0KY29uc3QgbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgYnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IGF0KCksIHpzID0gLyogQF9fUFVSRV9fICovIG5ldyBwKDAsIDAsIDApLCBncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgcCgxLCAxLCAxKSwgRnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwga2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgeXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgdW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgTXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IHAoKSwgcHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IEooKTsKY2xhc3MgemUgewogIGNvbnN0cnVjdG9yKHQgPSBuZXcgcCgxLCAwLCAwKSwgZSA9IDApIHsKICAgIHRoaXMuaXNQbGFuZSA9ICEwLCB0aGlzLm5vcm1hbCA9IHQsIHRoaXMuY29uc3RhbnQgPSBlOwogIH0KICBzZXQodCwgZSkgewogICAgcmV0dXJuIHRoaXMubm9ybWFsLmNvcHkodCksIHRoaXMuY29uc3RhbnQgPSBlLCB0aGlzOwogIH0KICBzZXRDb21wb25lbnRzKHQsIGUsIG4sIGkpIHsKICAgIHJldHVybiB0aGlzLm5vcm1hbC5zZXQodCwgZSwgbiksIHRoaXMuY29uc3RhbnQgPSBpLCB0aGlzOwogIH0KICBzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy5ub3JtYWwuY29weSh0KSwgdGhpcy5jb25zdGFudCA9IC1lLmRvdCh0aGlzLm5vcm1hbCksIHRoaXM7CiAgfQogIHNldEZyb21Db3BsYW5hclBvaW50cyh0LCBlLCBuKSB7CiAgICBjb25zdCBpID0gdW4uc3ViVmVjdG9ycyhuLCBlKS5jcm9zcyhNcy5zdWJWZWN0b3JzKHQsIGUpKS5ub3JtYWxpemUoKTsKICAgIHJldHVybiB0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KGksIHQpLCB0aGlzOwogIH0KICBjb3B5KHQpIHsKICAgIHJldHVybiB0aGlzLm5vcm1hbC5jb3B5KHQubm9ybWFsKSwgdGhpcy5jb25zdGFudCA9IHQuY29uc3RhbnQsIHRoaXM7CiAgfQogIG5vcm1hbGl6ZSgpIHsKICAgIGNvbnN0IHQgPSAxIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7CiAgICByZXR1cm4gdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIodCksIHRoaXMuY29uc3RhbnQgKj0gdCwgdGhpczsKICB9CiAgbmVnYXRlKCkgewogICAgcmV0dXJuIHRoaXMuY29uc3RhbnQgKj0gLTEsIHRoaXMubm9ybWFsLm5lZ2F0ZSgpLCB0aGlzOwogIH0KICBkaXN0YW5jZVRvUG9pbnQodCkgewogICAgcmV0dXJuIHRoaXMubm9ybWFsLmRvdCh0KSArIHRoaXMuY29uc3RhbnQ7CiAgfQogIGRpc3RhbmNlVG9TcGhlcmUodCkgewogICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KHQuY2VudGVyKSAtIHQucmFkaXVzOwogIH0KICBwcm9qZWN0UG9pbnQodCwgZSkgewogICAgcmV0dXJuIGUuY29weSh0KS5hZGRTY2FsZWRWZWN0b3IodGhpcy5ub3JtYWwsIC10aGlzLmRpc3RhbmNlVG9Qb2ludCh0KSk7CiAgfQogIGludGVyc2VjdExpbmUodCwgZSkgewogICAgY29uc3QgbiA9IHQuZGVsdGEodW4pLCBpID0gdGhpcy5ub3JtYWwuZG90KG4pOwogICAgaWYgKGkgPT09IDApCiAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCh0LnN0YXJ0KSA9PT0gMCA/IGUuY29weSh0LnN0YXJ0KSA6IG51bGw7CiAgICBjb25zdCByID0gLSh0LnN0YXJ0LmRvdCh0aGlzLm5vcm1hbCkgKyB0aGlzLmNvbnN0YW50KSAvIGk7CiAgICByZXR1cm4gciA8IDAgfHwgciA+IDEgPyBudWxsIDogZS5jb3B5KHQuc3RhcnQpLmFkZFNjYWxlZFZlY3RvcihuLCByKTsKICB9CiAgaW50ZXJzZWN0c0xpbmUodCkgewogICAgY29uc3QgZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KHQuc3RhcnQpLCBuID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQodC5lbmQpOwogICAgcmV0dXJuIGUgPCAwICYmIG4gPiAwIHx8IG4gPCAwICYmIGUgPiAwOwogIH0KICBpbnRlcnNlY3RzQm94KHQpIHsKICAgIHJldHVybiB0LmludGVyc2VjdHNQbGFuZSh0aGlzKTsKICB9CiAgaW50ZXJzZWN0c1NwaGVyZSh0KSB7CiAgICByZXR1cm4gdC5pbnRlcnNlY3RzUGxhbmUodGhpcyk7CiAgfQogIGNvcGxhbmFyUG9pbnQodCkgewogICAgcmV0dXJuIHQuY29weSh0aGlzLm5vcm1hbCkubXVsdGlwbHlTY2FsYXIoLXRoaXMuY29uc3RhbnQpOwogIH0KICBhcHBseU1hdHJpeDQodCwgZSkgewogICAgY29uc3QgbiA9IGUgfHwgcHMuZ2V0Tm9ybWFsTWF0cml4KHQpLCBpID0gdGhpcy5jb3BsYW5hclBvaW50KHVuKS5hcHBseU1hdHJpeDQodCksIHIgPSB0aGlzLm5vcm1hbC5hcHBseU1hdHJpeDMobikubm9ybWFsaXplKCk7CiAgICByZXR1cm4gdGhpcy5jb25zdGFudCA9IC1pLmRvdChyKSwgdGhpczsKICB9CiAgdHJhbnNsYXRlKHQpIHsKICAgIHJldHVybiB0aGlzLmNvbnN0YW50IC09IHQuZG90KHRoaXMubm9ybWFsKSwgdGhpczsKICB9CiAgZXF1YWxzKHQpIHsKICAgIHJldHVybiB0Lm5vcm1hbC5lcXVhbHModGhpcy5ub3JtYWwpICYmIHQuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQ7CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTsKICB9Cn0KdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyA8ICJ1IiAmJiBfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoInJlZ2lzdGVyIiwgeyBkZXRhaWw6IHsKICByZXZpc2lvbjogT2kKfSB9KSk7CnR5cGVvZiB3aW5kb3cgPCAidSIgJiYgKHdpbmRvdy5fX1RIUkVFX18gPyBjb25zb2xlLndhcm4oIldBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4iKSA6IHdpbmRvdy5fX1RIUkVFX18gPSBPaSk7CmNsYXNzIF9zIHsKICBjb25zdHJ1Y3Rvcih0ID0gMCwgZSA9IDAsIG4gPSAwLCBpID0gMSkgewogICAgdGhpcy5pc1F1YXRlcm5pb24gPSAhMCwgdGhpcy5feCA9IHQsIHRoaXMuX3kgPSBlLCB0aGlzLl96ID0gbiwgdGhpcy5fdyA9IGk7CiAgfQogIHN0YXRpYyBzbGVycEZsYXQodCwgZSwgbiwgaSwgciwgYSwgbykgewogICAgbGV0IGggPSBuW2kgKyAwXSwgYyA9IG5baSArIDFdLCBsID0gbltpICsgMl0sIHUgPSBuW2kgKyAzXTsKICAgIGNvbnN0IGQgPSByW2EgKyAwXSwgeSA9IHJbYSArIDFdLCBmID0gclthICsgMl0sIGcgPSByW2EgKyAzXTsKICAgIGlmIChvID09PSAwKSB7CiAgICAgIHRbZSArIDBdID0gaCwgdFtlICsgMV0gPSBjLCB0W2UgKyAyXSA9IGwsIHRbZSArIDNdID0gdTsKICAgICAgcmV0dXJuOwogICAgfQogICAgaWYgKG8gPT09IDEpIHsKICAgICAgdFtlICsgMF0gPSBkLCB0W2UgKyAxXSA9IHksIHRbZSArIDJdID0gZiwgdFtlICsgM10gPSBnOwogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAodSAhPT0gZyB8fCBoICE9PSBkIHx8IGMgIT09IHkgfHwgbCAhPT0gZikgewogICAgICBsZXQgXyA9IDEgLSBvOwogICAgICBjb25zdCB3ID0gaCAqIGQgKyBjICogeSArIGwgKiBmICsgdSAqIGcsIHggPSB3ID49IDAgPyAxIDogLTEsIG0gPSAxIC0gdyAqIHc7CiAgICAgIGlmIChtID4gTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICBjb25zdCB6ID0gTWF0aC5zcXJ0KG0pLCBQID0gTWF0aC5hdGFuMih6LCB3ICogeCk7CiAgICAgICAgXyA9IE1hdGguc2luKF8gKiBQKSAvIHosIG8gPSBNYXRoLnNpbihvICogUCkgLyB6OwogICAgICB9CiAgICAgIGNvbnN0IE0gPSBvICogeDsKICAgICAgaWYgKGggPSBoICogXyArIGQgKiBNLCBjID0gYyAqIF8gKyB5ICogTSwgbCA9IGwgKiBfICsgZiAqIE0sIHUgPSB1ICogXyArIGcgKiBNLCBfID09PSAxIC0gbykgewogICAgICAgIGNvbnN0IHogPSAxIC8gTWF0aC5zcXJ0KGggKiBoICsgYyAqIGMgKyBsICogbCArIHUgKiB1KTsKICAgICAgICBoICo9IHosIGMgKj0geiwgbCAqPSB6LCB1ICo9IHo7CiAgICAgIH0KICAgIH0KICAgIHRbZV0gPSBoLCB0W2UgKyAxXSA9IGMsIHRbZSArIDJdID0gbCwgdFtlICsgM10gPSB1OwogIH0KICBzdGF0aWMgbXVsdGlwbHlRdWF0ZXJuaW9uc0ZsYXQodCwgZSwgbiwgaSwgciwgYSkgewogICAgY29uc3QgbyA9IG5baV0sIGggPSBuW2kgKyAxXSwgYyA9IG5baSArIDJdLCBsID0gbltpICsgM10sIHUgPSByW2FdLCBkID0gclthICsgMV0sIHkgPSByW2EgKyAyXSwgZiA9IHJbYSArIDNdOwogICAgcmV0dXJuIHRbZV0gPSBvICogZiArIGwgKiB1ICsgaCAqIHkgLSBjICogZCwgdFtlICsgMV0gPSBoICogZiArIGwgKiBkICsgYyAqIHUgLSBvICogeSwgdFtlICsgMl0gPSBjICogZiArIGwgKiB5ICsgbyAqIGQgLSBoICogdSwgdFtlICsgM10gPSBsICogZiAtIG8gKiB1IC0gaCAqIGQgLSBjICogeSwgdDsKICB9CiAgZ2V0IHgoKSB7CiAgICByZXR1cm4gdGhpcy5feDsKICB9CiAgc2V0IHgodCkgewogICAgdGhpcy5feCA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICB9CiAgZ2V0IHkoKSB7CiAgICByZXR1cm4gdGhpcy5feTsKICB9CiAgc2V0IHkodCkgewogICAgdGhpcy5feSA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICB9CiAgZ2V0IHooKSB7CiAgICByZXR1cm4gdGhpcy5fejsKICB9CiAgc2V0IHoodCkgewogICAgdGhpcy5feiA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICB9CiAgZ2V0IHcoKSB7CiAgICByZXR1cm4gdGhpcy5fdzsKICB9CiAgc2V0IHcodCkgewogICAgdGhpcy5fdyA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICB9CiAgc2V0KHQsIGUsIG4sIGkpIHsKICAgIHJldHVybiB0aGlzLl94ID0gdCwgdGhpcy5feSA9IGUsIHRoaXMuX3ogPSBuLCB0aGlzLl93ID0gaSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBjbG9uZSgpIHsKICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93KTsKICB9CiAgY29weSh0KSB7CiAgICByZXR1cm4gdGhpcy5feCA9IHQueCwgdGhpcy5feSA9IHQueSwgdGhpcy5feiA9IHQueiwgdGhpcy5fdyA9IHQudywgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBzZXRGcm9tRXVsZXIodCwgZSkgewogICAgY29uc3QgbiA9IHQuX3gsIGkgPSB0Ll95LCByID0gdC5feiwgYSA9IHQuX29yZGVyLCBvID0gTWF0aC5jb3MsIGggPSBNYXRoLnNpbiwgYyA9IG8obiAvIDIpLCBsID0gbyhpIC8gMiksIHUgPSBvKHIgLyAyKSwgZCA9IGgobiAvIDIpLCB5ID0gaChpIC8gMiksIGYgPSBoKHIgLyAyKTsKICAgIHN3aXRjaCAoYSkgewogICAgICBjYXNlICJYWVoiOgogICAgICAgIHRoaXMuX3ggPSBkICogbCAqIHUgKyBjICogeSAqIGYsIHRoaXMuX3kgPSBjICogeSAqIHUgLSBkICogbCAqIGYsIHRoaXMuX3ogPSBjICogbCAqIGYgKyBkICogeSAqIHUsIHRoaXMuX3cgPSBjICogbCAqIHUgLSBkICogeSAqIGY7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIllYWiI6CiAgICAgICAgdGhpcy5feCA9IGQgKiBsICogdSArIGMgKiB5ICogZiwgdGhpcy5feSA9IGMgKiB5ICogdSAtIGQgKiBsICogZiwgdGhpcy5feiA9IGMgKiBsICogZiAtIGQgKiB5ICogdSwgdGhpcy5fdyA9IGMgKiBsICogdSArIGQgKiB5ICogZjsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiWlhZIjoKICAgICAgICB0aGlzLl94ID0gZCAqIGwgKiB1IC0gYyAqIHkgKiBmLCB0aGlzLl95ID0gYyAqIHkgKiB1ICsgZCAqIGwgKiBmLCB0aGlzLl96ID0gYyAqIGwgKiBmICsgZCAqIHkgKiB1LCB0aGlzLl93ID0gYyAqIGwgKiB1IC0gZCAqIHkgKiBmOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJaWVgiOgogICAgICAgIHRoaXMuX3ggPSBkICogbCAqIHUgLSBjICogeSAqIGYsIHRoaXMuX3kgPSBjICogeSAqIHUgKyBkICogbCAqIGYsIHRoaXMuX3ogPSBjICogbCAqIGYgLSBkICogeSAqIHUsIHRoaXMuX3cgPSBjICogbCAqIHUgKyBkICogeSAqIGY7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIllaWCI6CiAgICAgICAgdGhpcy5feCA9IGQgKiBsICogdSArIGMgKiB5ICogZiwgdGhpcy5feSA9IGMgKiB5ICogdSArIGQgKiBsICogZiwgdGhpcy5feiA9IGMgKiBsICogZiAtIGQgKiB5ICogdSwgdGhpcy5fdyA9IGMgKiBsICogdSAtIGQgKiB5ICogZjsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiWFpZIjoKICAgICAgICB0aGlzLl94ID0gZCAqIGwgKiB1IC0gYyAqIHkgKiBmLCB0aGlzLl95ID0gYyAqIHkgKiB1IC0gZCAqIGwgKiBmLCB0aGlzLl96ID0gYyAqIGwgKiBmICsgZCAqIHkgKiB1LCB0aGlzLl93ID0gYyAqIGwgKiB1ICsgZCAqIHkgKiBmOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIGNvbnNvbGUud2FybigiVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIgKyBhKTsKICAgIH0KICAgIHJldHVybiBlICE9PSAhMSAmJiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHNldEZyb21BeGlzQW5nbGUodCwgZSkgewogICAgY29uc3QgbiA9IGUgLyAyLCBpID0gTWF0aC5zaW4obik7CiAgICByZXR1cm4gdGhpcy5feCA9IHQueCAqIGksIHRoaXMuX3kgPSB0LnkgKiBpLCB0aGlzLl96ID0gdC56ICogaSwgdGhpcy5fdyA9IE1hdGguY29zKG4pLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHNldEZyb21Sb3RhdGlvbk1hdHJpeCh0KSB7CiAgICBjb25zdCBlID0gdC5lbGVtZW50cywgbiA9IGVbMF0sIGkgPSBlWzRdLCByID0gZVs4XSwgYSA9IGVbMV0sIG8gPSBlWzVdLCBoID0gZVs5XSwgYyA9IGVbMl0sIGwgPSBlWzZdLCB1ID0gZVsxMF0sIGQgPSBuICsgbyArIHU7CiAgICBpZiAoZCA+IDApIHsKICAgICAgY29uc3QgeSA9IDAuNSAvIE1hdGguc3FydChkICsgMSk7CiAgICAgIHRoaXMuX3cgPSAwLjI1IC8geSwgdGhpcy5feCA9IChsIC0gaCkgKiB5LCB0aGlzLl95ID0gKHIgLSBjKSAqIHksIHRoaXMuX3ogPSAoYSAtIGkpICogeTsKICAgIH0gZWxzZSBpZiAobiA+IG8gJiYgbiA+IHUpIHsKICAgICAgY29uc3QgeSA9IDIgKiBNYXRoLnNxcnQoMSArIG4gLSBvIC0gdSk7CiAgICAgIHRoaXMuX3cgPSAobCAtIGgpIC8geSwgdGhpcy5feCA9IDAuMjUgKiB5LCB0aGlzLl95ID0gKGkgKyBhKSAvIHksIHRoaXMuX3ogPSAociArIGMpIC8geTsKICAgIH0gZWxzZSBpZiAobyA+IHUpIHsKICAgICAgY29uc3QgeSA9IDIgKiBNYXRoLnNxcnQoMSArIG8gLSBuIC0gdSk7CiAgICAgIHRoaXMuX3cgPSAociAtIGMpIC8geSwgdGhpcy5feCA9IChpICsgYSkgLyB5LCB0aGlzLl95ID0gMC4yNSAqIHksIHRoaXMuX3ogPSAoaCArIGwpIC8geTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHkgPSAyICogTWF0aC5zcXJ0KDEgKyB1IC0gbiAtIG8pOwogICAgICB0aGlzLl93ID0gKGEgLSBpKSAvIHksIHRoaXMuX3ggPSAociArIGMpIC8geSwgdGhpcy5feSA9IChoICsgbCkgLyB5LCB0aGlzLl96ID0gMC4yNSAqIHk7CiAgICB9CiAgICByZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBzZXRGcm9tVW5pdFZlY3RvcnModCwgZSkgewogICAgbGV0IG4gPSB0LmRvdChlKSArIDE7CiAgICByZXR1cm4gbiA8IE51bWJlci5FUFNJTE9OID8gKG4gPSAwLCBNYXRoLmFicyh0LngpID4gTWF0aC5hYnModC56KSA/ICh0aGlzLl94ID0gLXQueSwgdGhpcy5feSA9IHQueCwgdGhpcy5feiA9IDAsIHRoaXMuX3cgPSBuKSA6ICh0aGlzLl94ID0gMCwgdGhpcy5feSA9IC10LnosIHRoaXMuX3ogPSB0LnksIHRoaXMuX3cgPSBuKSkgOiAodGhpcy5feCA9IHQueSAqIGUueiAtIHQueiAqIGUueSwgdGhpcy5feSA9IHQueiAqIGUueCAtIHQueCAqIGUueiwgdGhpcy5feiA9IHQueCAqIGUueSAtIHQueSAqIGUueCwgdGhpcy5fdyA9IG4pLCB0aGlzLm5vcm1hbGl6ZSgpOwogIH0KICBhbmdsZVRvKHQpIHsKICAgIHJldHVybiAyICogTWF0aC5hY29zKE1hdGguYWJzKENpKHRoaXMuZG90KHQpLCAtMSwgMSkpKTsKICB9CiAgcm90YXRlVG93YXJkcyh0LCBlKSB7CiAgICBjb25zdCBuID0gdGhpcy5hbmdsZVRvKHQpOwogICAgaWYgKG4gPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgY29uc3QgaSA9IE1hdGgubWluKDEsIGUgLyBuKTsKICAgIHJldHVybiB0aGlzLnNsZXJwKHQsIGkpLCB0aGlzOwogIH0KICBpZGVudGl0eSgpIHsKICAgIHJldHVybiB0aGlzLnNldCgwLCAwLCAwLCAxKTsKICB9CiAgaW52ZXJ0KCkgewogICAgcmV0dXJuIHRoaXMuY29uanVnYXRlKCk7CiAgfQogIGNvbmp1Z2F0ZSgpIHsKICAgIHJldHVybiB0aGlzLl94ICo9IC0xLCB0aGlzLl95ICo9IC0xLCB0aGlzLl96ICo9IC0xLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIGRvdCh0KSB7CiAgICByZXR1cm4gdGhpcy5feCAqIHQuX3ggKyB0aGlzLl95ICogdC5feSArIHRoaXMuX3ogKiB0Ll96ICsgdGhpcy5fdyAqIHQuX3c7CiAgfQogIGxlbmd0aFNxKCkgewogICAgcmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93OwogIH0KICBsZW5ndGgoKSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93KTsKICB9CiAgbm9ybWFsaXplKCkgewogICAgbGV0IHQgPSB0aGlzLmxlbmd0aCgpOwogICAgcmV0dXJuIHQgPT09IDAgPyAodGhpcy5feCA9IDAsIHRoaXMuX3kgPSAwLCB0aGlzLl96ID0gMCwgdGhpcy5fdyA9IDEpIDogKHQgPSAxIC8gdCwgdGhpcy5feCA9IHRoaXMuX3ggKiB0LCB0aGlzLl95ID0gdGhpcy5feSAqIHQsIHRoaXMuX3ogPSB0aGlzLl96ICogdCwgdGhpcy5fdyA9IHRoaXMuX3cgKiB0KSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBtdWx0aXBseSh0KSB7CiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsIHQpOwogIH0KICBwcmVtdWx0aXBseSh0KSB7CiAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHQsIHRoaXMpOwogIH0KICBtdWx0aXBseVF1YXRlcm5pb25zKHQsIGUpIHsKICAgIGNvbnN0IG4gPSB0Ll94LCBpID0gdC5feSwgciA9IHQuX3osIGEgPSB0Ll93LCBvID0gZS5feCwgaCA9IGUuX3ksIGMgPSBlLl96LCBsID0gZS5fdzsKICAgIHJldHVybiB0aGlzLl94ID0gbiAqIGwgKyBhICogbyArIGkgKiBjIC0gciAqIGgsIHRoaXMuX3kgPSBpICogbCArIGEgKiBoICsgciAqIG8gLSBuICogYywgdGhpcy5feiA9IHIgKiBsICsgYSAqIGMgKyBuICogaCAtIGkgKiBvLCB0aGlzLl93ID0gYSAqIGwgLSBuICogbyAtIGkgKiBoIC0gciAqIGMsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgc2xlcnAodCwgZSkgewogICAgaWYgKGUgPT09IDApCiAgICAgIHJldHVybiB0aGlzOwogICAgaWYgKGUgPT09IDEpCiAgICAgIHJldHVybiB0aGlzLmNvcHkodCk7CiAgICBjb25zdCBuID0gdGhpcy5feCwgaSA9IHRoaXMuX3ksIHIgPSB0aGlzLl96LCBhID0gdGhpcy5fdzsKICAgIGxldCBvID0gYSAqIHQuX3cgKyBuICogdC5feCArIGkgKiB0Ll95ICsgciAqIHQuX3o7CiAgICBpZiAobyA8IDAgPyAodGhpcy5fdyA9IC10Ll93LCB0aGlzLl94ID0gLXQuX3gsIHRoaXMuX3kgPSAtdC5feSwgdGhpcy5feiA9IC10Ll96LCBvID0gLW8pIDogdGhpcy5jb3B5KHQpLCBvID49IDEpCiAgICAgIHJldHVybiB0aGlzLl93ID0gYSwgdGhpcy5feCA9IG4sIHRoaXMuX3kgPSBpLCB0aGlzLl96ID0gciwgdGhpczsKICAgIGNvbnN0IGggPSAxIC0gbyAqIG87CiAgICBpZiAoaCA8PSBOdW1iZXIuRVBTSUxPTikgewogICAgICBjb25zdCB5ID0gMSAtIGU7CiAgICAgIHJldHVybiB0aGlzLl93ID0geSAqIGEgKyBlICogdGhpcy5fdywgdGhpcy5feCA9IHkgKiBuICsgZSAqIHRoaXMuX3gsIHRoaXMuX3kgPSB5ICogaSArIGUgKiB0aGlzLl95LCB0aGlzLl96ID0geSAqIHIgKyBlICogdGhpcy5feiwgdGhpcy5ub3JtYWxpemUoKSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgY29uc3QgYyA9IE1hdGguc3FydChoKSwgbCA9IE1hdGguYXRhbjIoYywgbyksIHUgPSBNYXRoLnNpbigoMSAtIGUpICogbCkgLyBjLCBkID0gTWF0aC5zaW4oZSAqIGwpIC8gYzsKICAgIHJldHVybiB0aGlzLl93ID0gYSAqIHUgKyB0aGlzLl93ICogZCwgdGhpcy5feCA9IG4gKiB1ICsgdGhpcy5feCAqIGQsIHRoaXMuX3kgPSBpICogdSArIHRoaXMuX3kgKiBkLCB0aGlzLl96ID0gciAqIHUgKyB0aGlzLl96ICogZCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBzbGVycFF1YXRlcm5pb25zKHQsIGUsIG4pIHsKICAgIHJldHVybiB0aGlzLmNvcHkodCkuc2xlcnAoZSwgbik7CiAgfQogIHJhbmRvbSgpIHsKICAgIGNvbnN0IHQgPSBNYXRoLnJhbmRvbSgpLCBlID0gTWF0aC5zcXJ0KDEgLSB0KSwgbiA9IE1hdGguc3FydCh0KSwgaSA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKSwgciA9IDIgKiBNYXRoLlBJICogTWF0aC5yYW5kb20oKTsKICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgZSAqIE1hdGguY29zKGkpLAogICAgICBuICogTWF0aC5zaW4ociksCiAgICAgIG4gKiBNYXRoLmNvcyhyKSwKICAgICAgZSAqIE1hdGguc2luKGkpCiAgICApOwogIH0KICBlcXVhbHModCkgewogICAgcmV0dXJuIHQuX3ggPT09IHRoaXMuX3ggJiYgdC5feSA9PT0gdGhpcy5feSAmJiB0Ll96ID09PSB0aGlzLl96ICYmIHQuX3cgPT09IHRoaXMuX3c7CiAgfQogIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgcmV0dXJuIHRoaXMuX3ggPSB0W2VdLCB0aGlzLl95ID0gdFtlICsgMV0sIHRoaXMuX3ogPSB0W2UgKyAyXSwgdGhpcy5fdyA9IHRbZSArIDNdLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHRvQXJyYXkodCA9IFtdLCBlID0gMCkgewogICAgcmV0dXJuIHRbZV0gPSB0aGlzLl94LCB0W2UgKyAxXSA9IHRoaXMuX3ksIHRbZSArIDJdID0gdGhpcy5feiwgdFtlICsgM10gPSB0aGlzLl93LCB0OwogIH0KICBmcm9tQnVmZmVyQXR0cmlidXRlKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLl94ID0gdC5nZXRYKGUpLCB0aGlzLl95ID0gdC5nZXRZKGUpLCB0aGlzLl96ID0gdC5nZXRaKGUpLCB0aGlzLl93ID0gdC5nZXRXKGUpLCB0aGlzOwogIH0KICB0b0pTT04oKSB7CiAgICByZXR1cm4gdGhpcy50b0FycmF5KCk7CiAgfQogIF9vbkNoYW5nZSh0KSB7CiAgICByZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjayA9IHQsIHRoaXM7CiAgfQogIF9vbkNoYW5nZUNhbGxiYWNrKCkgewogIH0KICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICB5aWVsZCB0aGlzLl94LCB5aWVsZCB0aGlzLl95LCB5aWVsZCB0aGlzLl96LCB5aWVsZCB0aGlzLl93OwogIH0KfQpjbGFzcyB6dCB7CiAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwLCBuID0gMCkgewogICAgenQucHJvdG90eXBlLmlzVmVjdG9yMyA9ICEwLCB0aGlzLnggPSB0LCB0aGlzLnkgPSBlLCB0aGlzLnogPSBuOwogIH0KICBzZXQodCwgZSwgbikgewogICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHRoaXMueiksIHRoaXMueCA9IHQsIHRoaXMueSA9IGUsIHRoaXMueiA9IG4sIHRoaXM7CiAgfQogIHNldFNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCwgdGhpcy55ID0gdCwgdGhpcy56ID0gdCwgdGhpczsKICB9CiAgc2V0WCh0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCwgdGhpczsKICB9CiAgc2V0WSh0KSB7CiAgICByZXR1cm4gdGhpcy55ID0gdCwgdGhpczsKICB9CiAgc2V0Wih0KSB7CiAgICByZXR1cm4gdGhpcy56ID0gdCwgdGhpczsKICB9CiAgc2V0Q29tcG9uZW50KHQsIGUpIHsKICAgIHN3aXRjaCAodCkgewogICAgICBjYXNlIDA6CiAgICAgICAgdGhpcy54ID0gZTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAxOgogICAgICAgIHRoaXMueSA9IGU7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMjoKICAgICAgICB0aGlzLnogPSBlOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgICByZXR1cm4gdGhpczsKICB9CiAgZ2V0Q29tcG9uZW50KHQpIHsKICAgIHN3aXRjaCAodCkgewogICAgICBjYXNlIDA6CiAgICAgICAgcmV0dXJuIHRoaXMueDsKICAgICAgY2FzZSAxOgogICAgICAgIHJldHVybiB0aGlzLnk7CiAgICAgIGNhc2UgMjoKICAgICAgICByZXR1cm4gdGhpcy56OwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnopOwogIH0KICBjb3B5KHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LngsIHRoaXMueSA9IHQueSwgdGhpcy56ID0gdC56LCB0aGlzOwogIH0KICBhZGQodCkgewogICAgcmV0dXJuIHRoaXMueCArPSB0LngsIHRoaXMueSArPSB0LnksIHRoaXMueiArPSB0LnosIHRoaXM7CiAgfQogIGFkZFNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54ICs9IHQsIHRoaXMueSArPSB0LCB0aGlzLnogKz0gdCwgdGhpczsKICB9CiAgYWRkVmVjdG9ycyh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54ICsgZS54LCB0aGlzLnkgPSB0LnkgKyBlLnksIHRoaXMueiA9IHQueiArIGUueiwgdGhpczsKICB9CiAgYWRkU2NhbGVkVmVjdG9yKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggKz0gdC54ICogZSwgdGhpcy55ICs9IHQueSAqIGUsIHRoaXMueiArPSB0LnogKiBlLCB0aGlzOwogIH0KICBzdWIodCkgewogICAgcmV0dXJuIHRoaXMueCAtPSB0LngsIHRoaXMueSAtPSB0LnksIHRoaXMueiAtPSB0LnosIHRoaXM7CiAgfQogIHN1YlNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54IC09IHQsIHRoaXMueSAtPSB0LCB0aGlzLnogLT0gdCwgdGhpczsKICB9CiAgc3ViVmVjdG9ycyh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54IC0gZS54LCB0aGlzLnkgPSB0LnkgLSBlLnksIHRoaXMueiA9IHQueiAtIGUueiwgdGhpczsKICB9CiAgbXVsdGlwbHkodCkgewogICAgcmV0dXJuIHRoaXMueCAqPSB0LngsIHRoaXMueSAqPSB0LnksIHRoaXMueiAqPSB0LnosIHRoaXM7CiAgfQogIG11bHRpcGx5U2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggKj0gdCwgdGhpcy55ICo9IHQsIHRoaXMueiAqPSB0LCB0aGlzOwogIH0KICBtdWx0aXBseVZlY3RvcnModCwgZSkgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCAqIGUueCwgdGhpcy55ID0gdC55ICogZS55LCB0aGlzLnogPSB0LnogKiBlLnosIHRoaXM7CiAgfQogIGFwcGx5RXVsZXIodCkgewogICAgcmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKEJuLnNldEZyb21FdWxlcih0KSk7CiAgfQogIGFwcGx5QXhpc0FuZ2xlKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihCbi5zZXRGcm9tQXhpc0FuZ2xlKHQsIGUpKTsKICB9CiAgYXBwbHlNYXRyaXgzKHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLngsIG4gPSB0aGlzLnksIGkgPSB0aGlzLnosIHIgPSB0LmVsZW1lbnRzOwogICAgcmV0dXJuIHRoaXMueCA9IHJbMF0gKiBlICsgclszXSAqIG4gKyByWzZdICogaSwgdGhpcy55ID0gclsxXSAqIGUgKyByWzRdICogbiArIHJbN10gKiBpLCB0aGlzLnogPSByWzJdICogZSArIHJbNV0gKiBuICsgcls4XSAqIGksIHRoaXM7CiAgfQogIGFwcGx5Tm9ybWFsTWF0cml4KHQpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4Myh0KS5ub3JtYWxpemUoKTsKICB9CiAgYXBwbHlNYXRyaXg0KHQpIHsKICAgIGNvbnN0IGUgPSB0aGlzLngsIG4gPSB0aGlzLnksIGkgPSB0aGlzLnosIHIgPSB0LmVsZW1lbnRzLCBhID0gMSAvIChyWzNdICogZSArIHJbN10gKiBuICsgclsxMV0gKiBpICsgclsxNV0pOwogICAgcmV0dXJuIHRoaXMueCA9IChyWzBdICogZSArIHJbNF0gKiBuICsgcls4XSAqIGkgKyByWzEyXSkgKiBhLCB0aGlzLnkgPSAoclsxXSAqIGUgKyByWzVdICogbiArIHJbOV0gKiBpICsgclsxM10pICogYSwgdGhpcy56ID0gKHJbMl0gKiBlICsgcls2XSAqIG4gKyByWzEwXSAqIGkgKyByWzE0XSkgKiBhLCB0aGlzOwogIH0KICBhcHBseVF1YXRlcm5pb24odCkgewogICAgY29uc3QgZSA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgciA9IHQueCwgYSA9IHQueSwgbyA9IHQueiwgaCA9IHQudywgYyA9IDIgKiAoYSAqIGkgLSBvICogbiksIGwgPSAyICogKG8gKiBlIC0gciAqIGkpLCB1ID0gMiAqIChyICogbiAtIGEgKiBlKTsKICAgIHJldHVybiB0aGlzLnggPSBlICsgaCAqIGMgKyBhICogdSAtIG8gKiBsLCB0aGlzLnkgPSBuICsgaCAqIGwgKyBvICogYyAtIHIgKiB1LCB0aGlzLnogPSBpICsgaCAqIHUgKyByICogbCAtIGEgKiBjLCB0aGlzOwogIH0KICBwcm9qZWN0KHQpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KHQucHJvamVjdGlvbk1hdHJpeCk7CiAgfQogIHVucHJvamVjdCh0KSB7CiAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQodC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSkuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpOwogIH0KICB0cmFuc2Zvcm1EaXJlY3Rpb24odCkgewogICAgY29uc3QgZSA9IHRoaXMueCwgbiA9IHRoaXMueSwgaSA9IHRoaXMueiwgciA9IHQuZWxlbWVudHM7CiAgICByZXR1cm4gdGhpcy54ID0gclswXSAqIGUgKyByWzRdICogbiArIHJbOF0gKiBpLCB0aGlzLnkgPSByWzFdICogZSArIHJbNV0gKiBuICsgcls5XSAqIGksIHRoaXMueiA9IHJbMl0gKiBlICsgcls2XSAqIG4gKyByWzEwXSAqIGksIHRoaXMubm9ybWFsaXplKCk7CiAgfQogIGRpdmlkZSh0KSB7CiAgICByZXR1cm4gdGhpcy54IC89IHQueCwgdGhpcy55IC89IHQueSwgdGhpcy56IC89IHQueiwgdGhpczsKICB9CiAgZGl2aWRlU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyB0KTsKICB9CiAgbWluKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHQueCksIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdC55KSwgdGhpcy56ID0gTWF0aC5taW4odGhpcy56LCB0LnopLCB0aGlzOwogIH0KICBtYXgodCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdC54KSwgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB0LnkpLCB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIHQueiksIHRoaXM7CiAgfQogIGNsYW1wKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0LngsIE1hdGgubWluKGUueCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQueSwgTWF0aC5taW4oZS55LCB0aGlzLnkpKSwgdGhpcy56ID0gTWF0aC5tYXgodC56LCBNYXRoLm1pbihlLnosIHRoaXMueikpLCB0aGlzOwogIH0KICBjbGFtcFNjYWxhcih0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodCwgTWF0aC5taW4oZSwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQsIE1hdGgubWluKGUsIHRoaXMueSkpLCB0aGlzLnogPSBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCB0aGlzLnopKSwgdGhpczsKICB9CiAgY2xhbXBMZW5ndGgodCwgZSkgewogICAgY29uc3QgbiA9IHRoaXMubGVuZ3RoKCk7CiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobiB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heCh0LCBNYXRoLm1pbihlLCBuKSkpOwogIH0KICBmbG9vcigpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56ID0gTWF0aC5mbG9vcih0aGlzLnopLCB0aGlzOwogIH0KICBjZWlsKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KSwgdGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueiksIHRoaXM7CiAgfQogIHJvdW5kKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueiksIHRoaXM7CiAgfQogIHJvdW5kVG9aZXJvKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgudHJ1bmModGhpcy54KSwgdGhpcy55ID0gTWF0aC50cnVuYyh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnRydW5jKHRoaXMueiksIHRoaXM7CiAgfQogIG5lZ2F0ZSgpIHsKICAgIHJldHVybiB0aGlzLnggPSAtdGhpcy54LCB0aGlzLnkgPSAtdGhpcy55LCB0aGlzLnogPSAtdGhpcy56LCB0aGlzOwogIH0KICBkb3QodCkgewogICAgcmV0dXJuIHRoaXMueCAqIHQueCArIHRoaXMueSAqIHQueSArIHRoaXMueiAqIHQuejsKICB9CiAgbGVuZ3RoU3EoKSB7CiAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56OwogIH0KICBsZW5ndGgoKSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7CiAgfQogIG1hbmhhdHRhbkxlbmd0aCgpIHsKICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KSArIE1hdGguYWJzKHRoaXMueik7CiAgfQogIG5vcm1hbGl6ZSgpIHsKICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpIHx8IDEpOwogIH0KICBzZXRMZW5ndGgodCkgewogICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCk7CiAgfQogIGxlcnAodCwgZSkgewogICAgcmV0dXJuIHRoaXMueCArPSAodC54IC0gdGhpcy54KSAqIGUsIHRoaXMueSArPSAodC55IC0gdGhpcy55KSAqIGUsIHRoaXMueiArPSAodC56IC0gdGhpcy56KSAqIGUsIHRoaXM7CiAgfQogIGxlcnBWZWN0b3JzKHQsIGUsIG4pIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggKyAoZS54IC0gdC54KSAqIG4sIHRoaXMueSA9IHQueSArIChlLnkgLSB0LnkpICogbiwgdGhpcy56ID0gdC56ICsgKGUueiAtIHQueikgKiBuLCB0aGlzOwogIH0KICBjcm9zcyh0KSB7CiAgICByZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnModGhpcywgdCk7CiAgfQogIGNyb3NzVmVjdG9ycyh0LCBlKSB7CiAgICBjb25zdCBuID0gdC54LCBpID0gdC55LCByID0gdC56LCBhID0gZS54LCBvID0gZS55LCBoID0gZS56OwogICAgcmV0dXJuIHRoaXMueCA9IGkgKiBoIC0gciAqIG8sIHRoaXMueSA9IHIgKiBhIC0gbiAqIGgsIHRoaXMueiA9IG4gKiBvIC0gaSAqIGEsIHRoaXM7CiAgfQogIHByb2plY3RPblZlY3Rvcih0KSB7CiAgICBjb25zdCBlID0gdC5sZW5ndGhTcSgpOwogICAgaWYgKGUgPT09IDApCiAgICAgIHJldHVybiB0aGlzLnNldCgwLCAwLCAwKTsKICAgIGNvbnN0IG4gPSB0LmRvdCh0aGlzKSAvIGU7CiAgICByZXR1cm4gdGhpcy5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKG4pOwogIH0KICBwcm9qZWN0T25QbGFuZSh0KSB7CiAgICByZXR1cm4gZG4uY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IodCksIHRoaXMuc3ViKGRuKTsKICB9CiAgcmVmbGVjdCh0KSB7CiAgICByZXR1cm4gdGhpcy5zdWIoZG4uY29weSh0KS5tdWx0aXBseVNjYWxhcigyICogdGhpcy5kb3QodCkpKTsKICB9CiAgYW5nbGVUbyh0KSB7CiAgICBjb25zdCBlID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIHQubGVuZ3RoU3EoKSk7CiAgICBpZiAoZSA9PT0gMCkKICAgICAgcmV0dXJuIE1hdGguUEkgLyAyOwogICAgY29uc3QgbiA9IHRoaXMuZG90KHQpIC8gZTsKICAgIHJldHVybiBNYXRoLmFjb3MoQ2kobiwgLTEsIDEpKTsKICB9CiAgZGlzdGFuY2VUbyh0KSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodCkpOwogIH0KICBkaXN0YW5jZVRvU3F1YXJlZCh0KSB7CiAgICBjb25zdCBlID0gdGhpcy54IC0gdC54LCBuID0gdGhpcy55IC0gdC55LCBpID0gdGhpcy56IC0gdC56OwogICAgcmV0dXJuIGUgKiBlICsgbiAqIG4gKyBpICogaTsKICB9CiAgbWFuaGF0dGFuRGlzdGFuY2VUbyh0KSB7CiAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdC54KSArIE1hdGguYWJzKHRoaXMueSAtIHQueSkgKyBNYXRoLmFicyh0aGlzLnogLSB0LnopOwogIH0KICBzZXRGcm9tU3BoZXJpY2FsKHQpIHsKICAgIHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHModC5yYWRpdXMsIHQucGhpLCB0LnRoZXRhKTsKICB9CiAgc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyh0LCBlLCBuKSB7CiAgICBjb25zdCBpID0gTWF0aC5zaW4oZSkgKiB0OwogICAgcmV0dXJuIHRoaXMueCA9IGkgKiBNYXRoLnNpbihuKSwgdGhpcy55ID0gTWF0aC5jb3MoZSkgKiB0LCB0aGlzLnogPSBpICogTWF0aC5jb3MobiksIHRoaXM7CiAgfQogIHNldEZyb21DeWxpbmRyaWNhbCh0KSB7CiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHModC5yYWRpdXMsIHQudGhldGEsIHQueSk7CiAgfQogIHNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LCBlLCBuKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCAqIE1hdGguc2luKGUpLCB0aGlzLnkgPSBuLCB0aGlzLnogPSB0ICogTWF0aC5jb3MoZSksIHRoaXM7CiAgfQogIHNldEZyb21NYXRyaXhQb3NpdGlvbih0KSB7CiAgICBjb25zdCBlID0gdC5lbGVtZW50czsKICAgIHJldHVybiB0aGlzLnggPSBlWzEyXSwgdGhpcy55ID0gZVsxM10sIHRoaXMueiA9IGVbMTRdLCB0aGlzOwogIH0KICBzZXRGcm9tTWF0cml4U2NhbGUodCkgewogICAgY29uc3QgZSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAwKS5sZW5ndGgoKSwgbiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAxKS5sZW5ndGgoKSwgaSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAyKS5sZW5ndGgoKTsKICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSBuLCB0aGlzLnogPSBpLCB0aGlzOwogIH0KICBzZXRGcm9tTWF0cml4Q29sdW1uKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLCBlICogNCk7CiAgfQogIHNldEZyb21NYXRyaXgzQ29sdW1uKHQsIGUpIHsKICAgIHJldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLCBlICogMyk7CiAgfQogIHNldEZyb21FdWxlcih0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC5feCwgdGhpcy55ID0gdC5feSwgdGhpcy56ID0gdC5feiwgdGhpczsKICB9CiAgc2V0RnJvbUNvbG9yKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnIsIHRoaXMueSA9IHQuZywgdGhpcy56ID0gdC5iLCB0aGlzOwogIH0KICBlcXVhbHModCkgewogICAgcmV0dXJuIHQueCA9PT0gdGhpcy54ICYmIHQueSA9PT0gdGhpcy55ICYmIHQueiA9PT0gdGhpcy56OwogIH0KICBmcm9tQXJyYXkodCwgZSA9IDApIHsKICAgIHJldHVybiB0aGlzLnggPSB0W2VdLCB0aGlzLnkgPSB0W2UgKyAxXSwgdGhpcy56ID0gdFtlICsgMl0sIHRoaXM7CiAgfQogIHRvQXJyYXkodCA9IFtdLCBlID0gMCkgewogICAgcmV0dXJuIHRbZV0gPSB0aGlzLngsIHRbZSArIDFdID0gdGhpcy55LCB0W2UgKyAyXSA9IHRoaXMueiwgdDsKICB9CiAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC5nZXRYKGUpLCB0aGlzLnkgPSB0LmdldFkoZSksIHRoaXMueiA9IHQuZ2V0WihlKSwgdGhpczsKICB9CiAgcmFuZG9tKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucmFuZG9tKCksIHRoaXMueSA9IE1hdGgucmFuZG9tKCksIHRoaXMueiA9IE1hdGgucmFuZG9tKCksIHRoaXM7CiAgfQogIHJhbmRvbURpcmVjdGlvbigpIHsKICAgIGNvbnN0IHQgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLCBlID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLCBuID0gTWF0aC5zcXJ0KDEgLSB0ICoqIDIpOwogICAgcmV0dXJuIHRoaXMueCA9IG4gKiBNYXRoLmNvcyhlKSwgdGhpcy55ID0gbiAqIE1hdGguc2luKGUpLCB0aGlzLnogPSB0LCB0aGlzOwogIH0KICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICB5aWVsZCB0aGlzLngsIHlpZWxkIHRoaXMueSwgeWllbGQgdGhpcy56OwogIH0KfQpjb25zdCBkbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgenQoKSwgQm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IF9zKCk7CmZ1bmN0aW9uIFNzKHMpIHsKICByZXR1cm4gcyAhPSBudWxsOwp9CmZ1bmN0aW9uIEEocykgewogIHJldHVybiBzICE9IG51bGw7Cn0KZnVuY3Rpb24gRyhzLCB0KSB7CiAgcmV0dXJuIHMgIT0gbnVsbCA/IHMgOiB0Owp9CkcuRU1QVFlfT0JKRUNUID0gT2JqZWN0LmZyZWV6ZSh7fSk7CmZ1bmN0aW9uIGoocykgewogIHRoaXMubmFtZSA9ICJEZXZlbG9wZXJFcnJvciIsIHRoaXMubWVzc2FnZSA9IHM7CiAgbGV0IHQ7CiAgdHJ5IHsKICAgIHRocm93IG5ldyBFcnJvcigpOwogIH0gY2F0Y2ggKGUpIHsKICAgIHQgPSBlLnN0YWNrOwogIH0KICB0aGlzLnN0YWNrID0gdDsKfQpBKE9iamVjdC5jcmVhdGUpICYmIChqLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSwgai5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBqKTsKai5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICBsZXQgcyA9IHRoaXMubmFtZSArICI6ICIgKyB0aGlzLm1lc3NhZ2U7CiAgcmV0dXJuIEEodGhpcy5zdGFjaykgJiYgKHMgKz0gYApgICsgdGhpcy5zdGFjay50b1N0cmluZygpKSwgczsKfTsKai50aHJvd0luc3RhbnRpYXRpb25FcnJvciA9IGZ1bmN0aW9uKCkgewogIHRocm93IG5ldyBqKAogICAgIlRoaXMgZnVuY3Rpb24gZGVmaW5lcyBhbiBpbnRlcmZhY2UgYW5kIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiIKICApOwp9Owpjb25zdCBLID0gY2xhc3MgewogIHN0YXRpYyBlcXVhbHNFcHNpbG9uKHQsIGUsIG4sIGkpIHsKICAgIG4gPSBHKG4sIDApLCBpID0gRyhpLCBuKTsKICAgIGNvbnN0IHIgPSBNYXRoLmFicyh0IC0gZSk7CiAgICByZXR1cm4gciA8PSBpIHx8IHIgPD0gbiAqIE1hdGgubWF4KE1hdGguYWJzKHQpLCBNYXRoLmFicyhlKSk7CiAgfQogIHN0YXRpYyB0b1JhZGlhbnModCkgewogICAgcmV0dXJuIE50LmRlZ1RvUmFkKHQpOwogIH0KICBzdGF0aWMgY2xhbXAodCwgZSwgbikgewogICAgcmV0dXJuIHQgPCBlID8gZSA6IHQgPiBuID8gbiA6IHQ7CiAgfQogIHN0YXRpYyBhY29zQ2xhbXBlZCh0KSB7CiAgICByZXR1cm4gTWF0aC5hY29zKEsuY2xhbXAodCwgLTEsIDEpKTsKICB9CiAgc3RhdGljIGFzaW5DbGFtcGVkKHQpIHsKICAgIHJldHVybiBNYXRoLmFzaW4oSy5jbGFtcCh0LCAtMSwgMSkpOwogIH0KICBzdGF0aWMgc2lnbih0KSB7CiAgICByZXR1cm4gTWF0aC5zaWduKHQpOwogIH0KICBzdGF0aWMgemVyb1RvVHdvUGkodCkgewogICAgaWYgKHQgPj0gMCAmJiB0IDw9IEsuVFdPX1BJKQogICAgICByZXR1cm4gdDsKICAgIGNvbnN0IGUgPSBLLm1vZCh0LCBLLlRXT19QSSk7CiAgICByZXR1cm4gTWF0aC5hYnMoZSkgPCBLLkVQU0lMT04xNCAmJiBNYXRoLmFicyh0KSA+IEsuRVBTSUxPTjE0ID8gSy5UV09fUEkgOiBlOwogIH0KICBzdGF0aWMgbW9kKHQsIGUpIHsKICAgIHJldHVybiBLLnNpZ24odCkgPT09IEsuc2lnbihlKSAmJiBNYXRoLmFicyh0KSA8IE1hdGguYWJzKGUpID8gdCA6ICh0ICUgZSArIGUpICUgZTsKICB9CiAgc3RhdGljIGNob3JkTGVuZ3RoKHQsIGUpIHsKICAgIHJldHVybiAyICogZSAqIE1hdGguc2luKHQgKiAwLjUpOwogIH0KICBzdGF0aWMgbmVnYXRpdmVQaVRvUGkodCkgewogICAgaWYgKCFBKHQpKQogICAgICB0aHJvdyBuZXcgaigiYW5nbGUgaXMgcmVxdWlyZWQuIik7CiAgICByZXR1cm4gdCA+PSAtSy5QSSAmJiB0IDw9IEsuUEkgPyB0IDogSy56ZXJvVG9Ud29QaSh0ICsgSy5QSSkgLSBLLlBJOwogIH0KICBzdGF0aWMgbm9ybWFsaXplKHQsIGUsIG4pIHsKICAgIHJldHVybiBuID0gTWF0aC5tYXgobiAtIGUsIDApLCBuID09PSAwID8gMCA6IEsuY2xhbXAoKHQgLSBlKSAvIG4sIDAsIDEpOwogIH0KfTsKbGV0IEUgPSBLOwp2KEUsICJFUFNJTE9OMSIsIDAuMSksIHYoRSwgIkVQU0lMT04yIiwgMC4wMSksIHYoRSwgIkVQU0lMT04zIiwgMWUtMyksIHYoRSwgIkVQU0lMT040IiwgMWUtNCksIHYoRSwgIkVQU0lMT041IiwgMWUtNSksIHYoRSwgIkVQU0lMT042IiwgMWUtNiksIHYoRSwgIkVQU0lMT043IiwgMWUtNyksIHYoRSwgIkVQU0lMT044IiwgMWUtOCksIHYoRSwgIkVQU0lMT045IiwgMWUtOSksIHYoRSwgIkVQU0lMT04xMCIsIDFlLTEwKSwgdihFLCAiRVBTSUxPTjExIiwgMWUtMTEpLCB2KEUsICJFUFNJTE9OMTIiLCAxZS0xMiksIHYoRSwgIkVQU0lMT04xMyIsIDFlLTEzKSwgdihFLCAiRVBTSUxPTjE0IiwgMWUtMTQpLCB2KEUsICJFUFNJTE9OMTUiLCAxZS0xNSksIHYoRSwgIkVQU0lMT04xNiIsIDFlLTE2KSwgdihFLCAiRVBTSUxPTjE3IiwgMWUtMTcpLCB2KEUsICJFUFNJTE9OMTgiLCAxZS0xOCksIHYoRSwgIkVQU0lMT04xOSIsIDFlLTE5KSwgdihFLCAiRVBTSUxPTjIwIiwgMWUtMjApLCB2KEUsICJFUFNJTE9OMjEiLCAxZS0yMSksIHYoRSwgIlBJIiwgTWF0aC5QSSksIHYoRSwgIk9ORV9PVkVSX1BJIiwgMSAvIE1hdGguUEkpLCB2KEUsICJQSV9PVkVSX1RXTyIsIE1hdGguUEkgLyAyKSwgdihFLCAiUElfT1ZFUl9USFJFRSIsIE1hdGguUEkgLyAzKSwgdihFLCAiUElfT1ZFUl9GT1VSIiwgTWF0aC5QSSAvIDQpLCB2KEUsICJQSV9PVkVSX1NJWCIsIE1hdGguUEkgLyA2KSwgdihFLCAiVEhSRUVfUElfT1ZFUl9UV08iLCAzICogTWF0aC5QSSAvIDIpLCB2KEUsICJUV09fUEkiLCAyICogTWF0aC5QSSksIHYoRSwgIk9ORV9PVkVSX1RXT19QSSIsIDEgLyAoMiAqIE1hdGguUEkpKSwgdihFLCAiUkFESUFOU19QRVJfREVHUkVFIiwgTWF0aC5QSSAvIDE4MCk7CmZ1bmN0aW9uIFBzKHMpIHsKICBjb25zdCB0ID0gc1swXSwgZSA9IHNbcy5sZW5ndGggLSAxXTsKICByZXR1cm4gTGkodCwgZSk7Cn0KZnVuY3Rpb24gTGkocywgdCwgZSA9IDFlLTYpIHsKICByZXR1cm4gcWkocywgdCkgPCBlOwp9CmZ1bmN0aW9uIHFpKHMsIHQpIHsKICByZXR1cm4gTWF0aC5zcXJ0KAogICAgTWF0aC5wb3coc1swXSAtIHRbMF0sIDIpICsgTWF0aC5wb3coc1sxXSAtIHRbMV0sIDIpICsgTWF0aC5wb3coKHNbMl0gfHwgMCkgLSAodFsyXSB8fCAwKSwgMikKICApOwp9Cm5ldyB6dCgpOwpuZXcgenQoKTsKbmV3IHp0KCk7Cm5ldyB6dCgpOwpuZXcgenQoKTsKbmV3IHp0KCk7Cm5ldyB6dCgpOwpuZXcgenQoKTsKbmV3IHp0KCk7Cm5ldyB6dCgpOwpmdW5jdGlvbiBEbihzLCB0LCBlKSB7CiAgY29uc3QgbiA9IFtlWzBdIC0gdFswXSwgZVsxXSAtIHRbMV1dLCBpID0gW3NbMF0gLSB0WzBdLCBzWzFdIC0gdFsxXV0sIGEgPSAoblswXSAqIGlbMF0gKyBuWzFdICogaVsxXSkgLyBNYXRoLnNxcnQoKG5bMF0gKiBuWzBdICsgblsxXSAqIG5bMV0pICogKGlbMF0gKiBpWzBdICsgaVsxXSAqIGlbMV0pKSwgbyA9IC1uWzFdICogaVswXSArIG5bMF0gKiBpWzFdOwogIHJldHVybiBhID4gLTAuODY2ICYmIG8gPCAwOwp9CmNvbnN0IHluID0gbmV3IHAoKSwgT3QgPSBuZXcgcCgpLCBqdCA9IG5ldyBwKCksIFVuID0gbmV3IHAoKSwgYnMgPSBuZXcgcCgpLCBUcyA9IChzLCB0LCBlLCBuLCBpLCByLCBhLCBvLCBoLCBjLCBsLCB1LCBkLCB5KSA9PiB7CiAgY29uc3QgZiA9IGQudGFyZ2V0Q2VudGVyLCBnID0gZC50YXJnZXRQcm9qZWN0aW9uLCB7IHNvdXJjZVByb2plY3Rpb25OYW1lOiBfLCB0YXJnZXRQcm9qZWN0aW9uTmFtZTogdyB9ID0gZDsKICBsZXQgeCA9IDA7CiAgeW4uZnJvbUFycmF5KGYpLCBPdC5mcm9tQXJyYXkoYSksIGp0LmZyb21BcnJheShvKTsKICBsZXQgbSA9IHUudmFsdWU7CiAgaS5wdXNoKG0sIG0pLCByLnB1c2goCiAgICBtLAogICAgMSwKICAgIG0sCiAgICAwCiAgKTsKICBjb25zdCBNID0gZy5nZXRQcm9qZWN0ZWRTdXJmYWNlTm9ybWFsKE90LCBVbiksIHogPSBicy5jb3B5KGp0KS5zdWIoT3QpLCBQID0gVW4uY3Jvc3NWZWN0b3JzKE0sIHopLm5vcm1hbGl6ZSgpOwogIHJldHVybiBfICE9PSB3ICYmIChPdC5zdWIoeW4pLCBqdC5zdWIoeW4pKSwgZS5wdXNoKFAueCwgUC55LCBQLnosIC1QLngsIC1QLnksIC1QLnopLCBzLnB1c2goCiAgICBPdC54LAogICAgT3QueSwKICAgIE90LnosCiAgICBPdC54LAogICAgT3QueSwKICAgIE90LnoKICApLCB0LnB1c2goaCwgaCksIHggKz0gMiwgbCB8fCAobi5wdXNoKGMgKyAwIC0gMiwgYyArIDEgLSAyLCBjICsgMiAtIDIpLCBuLnB1c2goYyArIDIgLSAyLCBjICsgMSAtIDIsIGMgKyAzIC0gMikpLCBuLnB1c2goYywgYyArIDEsIGMgKyAyKSwgZS5wdXNoKFAueCwgUC55LCBQLnosIC1QLngsIC1QLnksIC1QLnopLCBzLnB1c2goCiAgICBqdC54LAogICAganQueSwKICAgIGp0LnosCiAgICBqdC54LAogICAganQueSwKICAgIGp0LnoKICApLCB0LnB1c2goaCwgaCksIG0gKz0gcWkoYSwgbykgLyB5LCBpLnB1c2gobSwgbSksIHIucHVzaCgKICAgIG0sCiAgICAxLAogICAgbSwKICAgIDAKICApLCB1LnZhbHVlID0gbSwgeCArPSAyLCBuLnB1c2goYyArIDIsIGMgKyAxLCBjICsgMyksIHg7Cn07CmZ1bmN0aW9uIElzKHMsIHQsIGUsIG4sIGkgPSAxKSB7CiAgbGV0IHIgPSAwLCBhID0gbnVsbCwgbyA9IG51bGwsIGggPSBudWxsLCBjID0gbnVsbDsKICBjb25zdCBsID0gW10sIHUgPSBbXSwgZCA9IFtdLCB5ID0gW10sIGYgPSBbXSwgZyA9IFtdOwogIGxldCBfOwogIGNvbnN0IHcgPSB7IHZhbHVlOiAwIH07CiAgbGV0IHggPSAhMDsKICBmb3IgKGxldCBtID0gMSwgTSA9IHMubGVuZ3RoIC0gMTsgbSA8PSBNOyBtKyspIHsKICAgIGlmIChhID0gYyB8fCBzW20gLSAxXSwgbyA9IHNbbV0sIGggPSBzW20gKyAxXSwgaCAmJiBMaShvLCBoKSkgewogICAgICBjID0gYTsKICAgICAgY29udGludWU7CiAgICB9CiAgICBsZXQgeiA9IDA7CiAgICB6ID0gVHMoCiAgICAgIGwsCiAgICAgIHksCiAgICAgIHUsCiAgICAgIGQsCiAgICAgIGYsCiAgICAgIGcsCiAgICAgIGEsCiAgICAgIG8sCiAgICAgIHQsCiAgICAgIHIsCiAgICAgIHgsCiAgICAgIHcsCiAgICAgIGUsCiAgICAgIGkKICAgICksIHogIT09IC0xICYmIChyICs9IHosIGMgPSBudWxsKSwgeCA9ICExOwogIH0KICByZXR1cm4gbiAmJiAoXyA9IG5ldyBBcnJheShmLmxlbmd0aCkuZmlsbCh3LnZhbHVlKSksIHsKICAgIHZlcnRpY2VzOiBsLAogICAgaW5kaWNlczogZCwKICAgIG5vcm1hbHM6IHUsCiAgICB3aWR0aHM6IHksCiAgICBsZW5ndGhzOiBmLAogICAgdG90YWxMZW5ndGhzOiBfLAogICAgdXZzOiBnCiAgfTsKfQpmdW5jdGlvbiBXbihzLCB0LCBlKSB7CiAgZSB8fCAoZSA9IHQubGVuZ3RoKTsKICBjb25zdCBuID0gZSAqIHMsIGkgPSBuZXcgQXJyYXkobik7CiAgZm9yIChsZXQgciA9IDAsIGEgPSBuIC0gZSArIDE7IHIgPCBhOyByICs9IGUpCiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGU7IG8rKykKICAgICAgaVtyICsgb10gPSB0W29dOwogIHJldHVybiBpOwp9CmZ1bmN0aW9uIENzKHMgPSAiIiwgdCwgZSA9IDMpIHsKICBmdW5jdGlvbiBuKGksIHIpIHsKICAgIHJldHVybiBlLS0sIGZldGNoKGksIHIpLnRoZW4oKGEpID0+IHsKICAgICAgaWYgKGEuc3RhdHVzID09PSAyMDApCiAgICAgICAgcmV0dXJuIGE7CiAgICB9KS5jYXRjaCgoYSkgPT4gewogICAgICBpZiAoZSA+IDApCiAgICAgICAgcmV0dXJuIG4oaSwgcik7CiAgICB9KTsKICB9CiAgcmV0dXJuIG4ocywgdCk7Cn0KbGV0IE9zID0gMywgRXMgPSA0LCBtbiA9IDcsIEFzID0gOCwgUnMgPSAxNSwgTnMgPSAxNiwgTHMgPSAxOCwgcXMgPSAxOSwgdnMgPSAyMCwganMgPSAyNCwga3MgPSAyNSwgQnMgPSBmdW5jdGlvbigpIHsKICBsZXQgcyA9IG5ldyBUZXh0RGVjb2RlcigidXRmLTgiKSwgdCwgZSwgbiA9IDE7CiAgZnVuY3Rpb24gaSh4KSB7CiAgICBsZXQgbSA9IHt9OwogICAgdCA9IG5ldyBVaW50MzJBcnJheSh4KSwgZSA9IG5ldyBJbnQzMkFycmF5KHgpLCBuID0gdFswXSwgbS52ZXJzaW9uID0gdFswXTsKICAgIGxldCBNID0gdFsxXTsKICAgIG0uaGVpZ2h0ID0gdFsyXSwgbS5pbmRvb3JoZWlnaHQgPSB0WzNdOwogICAgbGV0IHogPSB3KHgsIE0gKyAxICsgMSwgMCwgeC5ieXRlTGVuZ3RoKTsKICAgIHJldHVybiBtLmdlb2xheWVyID0gZCh4LCB6WzBdKSwgbS5pbmRvb3JCdWlsZGluZ3MgPSByKHgsIHpbMV0pLCBtLmxhYmVscCA9IGwoeCwgelsyXSksIHpbM11bMV0gJiYgKG0ucG5nID0gcy5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoeCwgelszXVswXSwgelszXVsxXSkpKSwgels0XVsxXSAmJiAobS5pbmRvb3JwbmcgPSBzLmRlY29kZShuZXcgVWludDhBcnJheSh4LCB6WzRdWzBdLCB6WzRdWzFdKSkpLCB0ID0gbnVsbCwgZSA9IG51bGwsIG07CiAgfQogIGZ1bmN0aW9uIHIoeCwgbSkgewogICAgbGV0IE0gPSBbXSwgeiA9IHcoeCwgMCwgbVswXSwgbVswXSArIG1bMV0pOwogICAgZm9yIChsZXQgUCA9IDA7IFAgPCB6Lmxlbmd0aDsgUCsrKQogICAgICBNW1BdID0gYSh4LCB6W1BdKTsKICAgIHJldHVybiBNOwogIH0KICBmdW5jdGlvbiBhKHgsIG0pIHsKICAgIGxldCBNID0ge30sIHogPSB3KHgsIDAsIG1bMF0sIG1bMF0gKyBtWzFdKTsKICAgIHJldHVybiBNLmluZG9vckZsb29ycyA9IGgoeCwgelswXSksIE0uaW5kb29yRGVzID0gbyh4LCB6WzFdKSwgTTsKICB9CiAgZnVuY3Rpb24gbyh4LCBtKSB7CiAgICBsZXQgTSA9IG1bMF0gLyA0LCB6ID0gdFtNXSwgUCA9IHsKICAgICAgZ2xhc3NTdHlsZWlkOiB0W00gKyAxXSwKICAgICAgdHdpbmtsZU5vcm06IHRbTSArIDJdLAogICAgICBzZWxlY3RlZEZsb29yU3R5bGVpZDogdFtNICsgM10KICAgIH0sIFQgPSB3KHgsIHogKyAxLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICBQLmluZG9vckJpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBuZXcgVWludDhBcnJheSh4LCBUWzBdWzBdLCBUWzBdWzFdKSksIFAuaW5kb29yRGVmYXVsdGZsciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBuZXcgVWludDhBcnJheSh4LCBUWzFdWzBdLCBUWzFdWzFdKSk7CiAgICBsZXQgYiA9IHcoeCwgMCwgVFsyXVswXSwgVFsyXVswXSArIFRbMl1bMV0pOwogICAgUC5pbmRvb3JCb3VuZGFyeSA9IFtdOwogICAgZm9yIChsZXQgQyA9IDA7IEMgPCBiLmxlbmd0aDsgQysrKQogICAgICBQLmluZG9vckJvdW5kYXJ5W0NdID0gZyh4LCBiW0NdLCBtbik7CiAgICBsZXQgTiA9IHcoeCwgMCwgVFszXVswXSwgVFszXVswXSArIFRbM11bMV0pOwogICAgUC5pbmRvb3JGbG9vcnMgPSBbXTsKICAgIGZvciAobGV0IEMgPSAwOyBDIDwgTi5sZW5ndGg7IEMrKykKICAgICAgUC5pbmRvb3JGbG9vcnNbQ10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgbmV3IFVpbnQ4QXJyYXkoeCwgTltDXVswXSwgTltDXVsxXSkpOwogICAgUC5tcG9pTmFtZSA9IHMuZGVjb2RlKG5ldyBVaW50OEFycmF5KHgsIFRbNF1bMF0sIFRbNF1bMV0pKSwgUC5tcG9pID0gbmV3IFVpbnQzMkFycmF5KHgsIFRbNV1bMF0sIFRbNV1bMV0gLyA0KTsKICAgIGxldCBJID0gdyh4LCAwLCBUWzZdWzBdLCBUWzZdWzFdKTsKICAgIFAuaW5kb29yQm91bmRhcnlVcCA9IFtdOwogICAgZm9yIChsZXQgQyA9IDA7IEMgPCBJLmxlbmd0aDsgQysrKQogICAgICBQLmluZG9vckJvdW5kYXJ5VXBbQ10gPSBnKHgsIElbQ10sIG1uKTsKICAgIHJldHVybiBQLmluZG9vckVhY2hmbG9vckhlaWdodCA9IG5ldyBJbnQzMkFycmF5KHgsIFRbN11bMF0sIFRbN11bMV0gLyA0KSwgUDsKICB9CiAgZnVuY3Rpb24gaCh4LCBtKSB7CiAgICBsZXQgTSA9IFtdLCB6ID0gdyh4LCAwLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICBmb3IgKGxldCBQID0gMDsgUCA8IHoubGVuZ3RoOyBQKyspCiAgICAgIE1bUF0gPSBjKHgsIHpbUF0pOwogICAgcmV0dXJuIE07CiAgfQogIGZ1bmN0aW9uIGMoeCwgbSkgewogICAgbGV0IE0gPSBtWzBdIC8gNCwgeiA9IHRbTV0sIFAgPSB7CiAgICAgIGN1cnJlbnRGbG9vcklkeDogZVtNICsgMV0KICAgIH0sIFQgPSB3KHgsIHogKyAxLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICByZXR1cm4gUC5jdXJyZW50Rmxvb3IgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgbmV3IFVpbnQ4QXJyYXkoeCwgVFswXVswXSwgVFswXVsxXSkpLCBQLmdlb2xheWVyID0gZCh4LCBUWzFdKSwgUDsKICB9CiAgZnVuY3Rpb24gbCh4LCBtKSB7CiAgICBsZXQgTSA9IFtdLCB6ID0gdyh4LCAwLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICBmb3IgKGxldCBQID0gMDsgUCA8IHoubGVuZ3RoOyBQKyspCiAgICAgIE1bUF0gPSB1KHgsIHpbUF0pOwogICAgcmV0dXJuIE07CiAgfQogIGZ1bmN0aW9uIHUoeCwgbSkgewogICAgbGV0IE0gPSBtWzBdIC8gNCwgeiA9IHRbTV0sIFAgPSB7CiAgICAgIHN0eWxlSWQ6IGVbTSArIDFdLAogICAgICByYW5rOiBlW00gKyAyXSwKICAgICAgbmFtZUxlbjogZVtNICsgM10KICAgIH0sIFQgPSB3KHgsIHogKyAxLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICBUWzBdWzFdICYmIChQLm5hbWUgPSBzLmRlY29kZShuZXcgVWludDhBcnJheSh4LCBUWzBdWzBdLCBUWzBdWzFdKSkpLCBQLnggPSBuZXcgSW50MzJBcnJheSh4LCBUWzFdWzBdLCBUWzFdWzFdIC8gNCksIFAuYW5nbGUgPSBuZXcgVWludDE2QXJyYXkoeCwgVFsyXVswXSwgVFsyXVsxXSAvIDIpLCBQLnJldmVyc2UgPSBuZXcgVWludDE2QXJyYXkoeCwgVFszXVswXSwgVFszXVsxXSAvIDIpLCBQLnRyYWNlciA9IG5ldyBVaW50MTZBcnJheSh4LCBUWzRdWzBdLCBUWzRdWzFdIC8gMiksIFAuenZlY3RvciA9IG5ldyBJbnQxNkFycmF5KHgsIFRbNV1bMF0sIFRbNV1bMV0gLyAyKTsKICAgIGxldCBiID0gdyh4LCAwLCBUWzZdWzBdLCBUWzZdWzBdICsgVFs2XVsxXSk7CiAgICBQLnBvcyA9IFtdOwogICAgZm9yIChsZXQgTiA9IDA7IE4gPCBiLmxlbmd0aDsgTisrKQogICAgICBQLnBvc1tOXSA9IG5ldyBVaW50MTZBcnJheSh4LCBiW05dWzBdLCBiW05dWzFdIC8gMik7CiAgICByZXR1cm4gUDsKICB9CiAgZnVuY3Rpb24gZCh4LCBtKSB7CiAgICBsZXQgTSA9IFtdLCB6ID0gdyh4LCAwLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICBmb3IgKGxldCBQID0gMDsgUCA8IHoubGVuZ3RoOyBQKyspCiAgICAgIE1bUF0gPSB5KHgsIHpbUF0pOwogICAgcmV0dXJuIE07CiAgfQogIGZ1bmN0aW9uIHkoeCwgbSkgewogICAgbGV0IE0gPSB7fSwgeiA9IG1bMF0gLyA0LCBQID0gdFt6XTsKICAgIE0uY2F0YWxvZ1R5cGUgPSB0W3ogKyAxXSwgTS5yYW5rID0gdFt6ICsgMl07CiAgICBsZXQgVCA9IHcoeCwgUCArIDEsIG1bMF0sIG1bMF0gKyBtWzFdKTsKICAgIGlmIChULmxlbmd0aCkKICAgICAgaWYgKE0uY2F0YWxvZ1R5cGUgPT09IExzKQogICAgICAgIE0uYXJyb3dwID0gewogICAgICAgICAgeDogbmV3IEludDMyQXJyYXkoeCwgVFswXVswXSwgVFswXVsxXSAvIDQpLAogICAgICAgICAgdHJhY2VyOiBuZXcgSW50MzJBcnJheSh4LCBUWzFdWzBdLCBUWzFdWzFdIC8gNCksCiAgICAgICAgICB6dmVjdG9yOiBuZXcgSW50MTZBcnJheSh4LCBUWzJdWzBdLCBUWzJdWzFdIC8gMikKICAgICAgICB9OwogICAgICBlbHNlIHsKICAgICAgICBNLmdlb29iamVjdHNldFNldCA9IFtdOwogICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgVC5sZW5ndGg7IGIrKykKICAgICAgICAgIE0uZ2Vvb2JqZWN0c2V0U2V0W2JdID0gZih4LCBUW2JdLCBNLmNhdGFsb2dUeXBlKTsKICAgICAgfQogICAgcmV0dXJuIE07CiAgfQogIGZ1bmN0aW9uIGYoeCwgbSwgTSkgewogICAgbGV0IHogPSB7fSwgUCA9IG1bMF0gLyA0LCBUID0gdFtQXTsKICAgIHouc3R5bGVJZCA9IHRbUCArIDFdOwogICAgbGV0IGIgPSB3KHgsIFQgKyAxLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICB6Lmdlb09iamVjdFNldCA9IFtdOwogICAgZm9yIChsZXQgTiA9IDA7IE4gPCBiLmxlbmd0aDsgTisrKQogICAgICB6Lmdlb09iamVjdFNldFtOXSA9IGcoeCwgYltOXSwgTSk7CiAgICByZXR1cm4gejsKICB9CiAgZnVuY3Rpb24gZyh4LCBtLCBNKSB7CiAgICBsZXQgeiA9IHt9LCBQID0gbVswXSAvIDQsIFQgPSB0W1BdOwogICAgaWYgKHoudHJhY2VyID0gdFtQICsgMV0sIE0gPT09IG1uIHx8IE0gPT09IFJzKSB7CiAgICAgIGxldCBiID0gdyh4LCBUICsgMSwgbVswXSwgbVswXSArIG1bMV0pOwogICAgICBpZiAoei5zdXJmYWNlVHlwZSA9IHRbUCArIDJdLCB6Lm1pZFBvaW50cyA9IG5ldyBJbnQzMkFycmF5KHgsIGJbMF1bMF0sIGJbMF1bMV0gLyA0KSwgbiA+IDEgPyB6Lnp2ZWN0b3IgPSBuZXcgSW50MTZBcnJheSh4LCBiWzFdWzBdLCBiWzFdWzFdIC8gMikgOiB6Lnp2ZWN0b3IgPSBuZXcgVWludDE2QXJyYXkoeCwgYlsxXVswXSwgYlsxXVsxXSAvIDIpLCB6LmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoeCwgYlsyXVswXSwgYlsyXVsxXSAvIDIpLCBiWzNdKSB7CiAgICAgICAgbGV0IE4gPSB3KHgsIDAsIGJbM11bMF0sIGJbM11bMF0gKyBiWzNdWzFdKTsKICAgICAgICBpZiAoTi5sZW5ndGgpIHsKICAgICAgICAgIHouYm9yZGVyID0gW107CiAgICAgICAgICBmb3IgKGxldCBJID0gMDsgSSA8IE4ubGVuZ3RoOyBJKyspCiAgICAgICAgICAgIHouYm9yZGVyW0ldID0gXyh4LCBOW0ldKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoTSA9PT0gRXMgfHwgTSA9PT0gTnMgfHwgTSA9PT0gcXMpIHsKICAgICAgbGV0IGIgPSB3KHgsIFQgKyAxLCBtWzBdLCBtWzBdICsgbVsxXSk7CiAgICAgIHoud2lkdGggPSB0W1AgKyAyXSwgei5taWRQb2ludHMgPSBuZXcgSW50MzJBcnJheSh4LCBiWzBdWzBdLCBiWzBdWzFdIC8gNCksIG4gPiAxID8gei56dmVjdG9yID0gbmV3IEludDE2QXJyYXkoeCwgYlsxXVswXSwgYlsxXVsxXSAvIDIpIDogei56dmVjdG9yID0gbmV3IFVpbnQxNkFycmF5KHgsIGJbMV1bMF0sIGJbMV1bMV0gLyAyKSwgei5wYXJzZWRQb2ludHMgPSBuZXcgSW50MTZBcnJheSh4LCBiWzJdWzBdLCBiWzJdWzFdIC8gMiksIHoudHVybmluZ0RpciA9IG5ldyBJbnQ4QXJyYXkoeCwgYlszXVswXSwgYlszXVsxXSk7CiAgICB9IGVsc2UgaWYgKE0gPT09IHZzKSB7CiAgICAgIGxldCBiID0gdyh4LCBUICsgMSwgbVswXSwgbVswXSArIG1bMV0pOwogICAgICB6Lm1pZFBvaW50cyA9IG5ldyBJbnQzMkFycmF5KHgsIGJbMF1bMF0sIGJbMF1bMV0gLyA0KSwgei5ncmFkaWVudFBvcyA9IG5ldyBJbnQzMkFycmF5KHgsIGJbMV1bMF0sIGJbMV1bMV0gLyA0KSwgei5ncmFkaWVudFN0eWxlSWQgPSBuZXcgVWludDMyQXJyYXkoeCwgYlsyXVswXSwgYlsyXVsxXSAvIDQpLCBuID4gMSA/IHouenZlY3RvciA9IG5ldyBJbnQxNkFycmF5KHgsIGJbM11bMF0sIGJbM11bMV0gLyAyKSA6IHouenZlY3RvciA9IG5ldyBVaW50MTZBcnJheSh4LCBiWzNdWzBdLCBiWzNdWzFdIC8gMiksIHouaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh4LCBiWzRdWzBdLCBiWzRdWzFdIC8gMik7CiAgICB9IGVsc2UgaWYgKE0gPT09IGtzKSB7CiAgICAgIGxldCBiID0gdyh4LCBUICsgMSwgbVswXSwgbVswXSArIG1bMV0pOwogICAgICB6LmJ1aWxkaW5nQmlkID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIG5ldyBVaW50OEFycmF5KHgsIGJbMF1bMF0sIGJbMF1bMV0pKSwgei52ZXJ0ZXggPSBuZXcgSW50MzJBcnJheSh4LCBiWzFdWzBdLCBiWzFdWzFdIC8gNCksIHoubm9ybWFsID0gbmV3IEludDMyQXJyYXkoeCwgYlsyXVswXSwgYlsyXVsxXSAvIDQpOwogICAgICBsZXQgTiA9IHcoeCwgMCwgYlszXVswXSwgYlszXVswXSArIGJbM11bMV0pOwogICAgICB6LnN1Ym1lc2ggPSBbXTsKICAgICAgZm9yIChsZXQgSSA9IDA7IEkgPCBOLmxlbmd0aDsgSSsrKQogICAgICAgIHouc3VibWVzaFtJXSA9IG5ldyBVaW50MzJBcnJheSh4LCBOW0ldWzBdLCBOW0ldWzFdIC8gNCk7CiAgICB9IGVsc2UgaWYgKE0gPT09IGpzKQogICAgICB6LnRyYWNlciA9IHRbUF0sIHoueiA9IHRbUCArIDFdLCB6LnJhZGl1cyA9IHRbUCArIDJdLCB6LnggPSB0W1AgKyAzXSwgei55ID0gdFtQICsgNF07CiAgICBlbHNlIGlmIChNID09PSBBcykgewogICAgICBsZXQgYiA9IHcoeCwgVCArIDEsIG1bMF0sIG1bMF0gKyBtWzFdKTsKICAgICAgaWYgKHouYWx0aXR1ZGUgPSB0W1AgKyAyXSwgei5taWRQb2ludHMgPSBuZXcgSW50MzJBcnJheSh4LCBiWzBdWzBdLCBiWzBdWzFdIC8gNCksIHouaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh4LCBiWzFdWzBdLCBiWzFdWzFdIC8gMiksIGJbMl0pIHsKICAgICAgICBsZXQgTiA9IHcoeCwgMCwgYlsyXVswXSwgYlsyXVswXSArIGJbMl1bMV0pOwogICAgICAgIGlmIChOLmxlbmd0aCkgewogICAgICAgICAgei5ib3JkZXIgPSBbXTsKICAgICAgICAgIGZvciAobGV0IEkgPSAwOyBJIDwgTi5sZW5ndGg7IEkrKykKICAgICAgICAgICAgei5ib3JkZXJbSV0gPSBfKHgsIE5bSV0pOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIGlmIChNID09PSBPcykgewogICAgICBsZXQgYiA9IHcoeCwgVCArIDEsIG1bMF0sIG1bMF0gKyBtWzFdKTsKICAgICAgei5wb3N4ID0gdFtQICsgMl0sIHoucG9zeSA9IHRbUCArIDNdLCB6LnJhbmsgPSB0W1AgKyA0XSwgei5kaXJlY3Rpb24gPSB0W1AgKyA1XSwgYlswXVsxXSAmJiAoei51aWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgbmV3IFVpbnQ4QXJyYXkoeCwgYlswXVswXSwgYlswXVsxXSkpKSwgYlsxXVsxXSAmJiAoei5uYW1lID0gcy5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoeCwgYlsxXVswXSwgYlsxXVsxXSkpLnJlcGxhY2UoL1xcXFwvZywgIlxcIikpOwogICAgICBsZXQgTiA9IHcoeCwgMCwgYlsyXVswXSwgYlsyXVswXSArIGJbMl1bMV0pOwogICAgICB6LnBvcyA9IFtdOwogICAgICBmb3IgKGxldCBJID0gMDsgSSA8IE4ubGVuZ3RoOyBJKyspCiAgICAgICAgei5wb3NbSV0gPSBuZXcgVWludDE2QXJyYXkoeCwgTltJXVswXSwgTltJXVsxXSAvIDIpOwogICAgfQogICAgcmV0dXJuIHo7CiAgfQogIGZ1bmN0aW9uIF8oeCwgbSkgewogICAgbGV0IE0gPSB3KHgsIDAsIG1bMF0sIG1bMF0gKyBtWzFdKTsKICAgIHJldHVybiB7CiAgICAgIHBhcnNlZFBvaW50czogbmV3IEludDE2QXJyYXkoeCwgTVswXVswXSwgTVswXVsxXSAvIDIpLAogICAgICBzcGxpdEluZGljZXM6IG5ldyBVaW50MTZBcnJheSh4LCBNWzFdWzBdLCBNWzFdWzFdIC8gMiksCiAgICAgIHR1cm5pbmdEaXI6IG5ldyBJbnQ4QXJyYXkoeCwgTVsyXVswXSwgTVsyXVsxXSAvIDIpCiAgICB9OwogIH0KICBmdW5jdGlvbiB3KHgsIG0sIE0sIHopIHsKICAgIGxldCBQID0gTSAvIDQsIFQgPSB0W1AgKyBtXSwgYiA9IChUICsgbSArIDEpICogNCArIE0sIE4gPSBbXTsKICAgIGlmIChiID4geikKICAgICAgcmV0dXJuIE47CiAgICBmb3IgKGxldCBJID0gMDsgSSA8IFQ7IEkrKykgewogICAgICBsZXQgQyA9IHRbUCArIG0gKyAxICsgSV0sIE8gPSBiICsgQzsKICAgICAgTltJXSA9IFtiLCBDXSwgTyAlIDQgIT09IDAgPyBiID0gTyArIDQgLSBPICUgNCA6IGIgPSBPOwogICAgfQogICAgcmV0dXJuIE47CiAgfQogIHJldHVybiBpOwp9KCk7CmNvbnN0IHZpID0gIkVQU0c6NDMyNiIsIFRlID0gIkVQU0c6Mzg1NyIsIG5uID0gIkVQU0c6NDk3OCIsIHNuID0gIkJEOk1FUkNBVE9SIiwgamkgPSAiU0NSRUVOX1BJWEVMIiwgRm4gPSBuZXcgRigpLCBWbiA9IG5ldyBGKCksIGJlID0gY2xhc3MgewogIHN0YXRpYyBjbG9uZSh0LCBlKSB7CiAgICByZXR1cm4gZS5jb3B5KHQpLCBlOwogIH0KICBzdGF0aWMgZnJvbUVsZW1lbnRzKHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IEYoKSksIG4uc2V0KHQsIGUpLCBuOwogIH0KICBzdGF0aWMgbGVycCh0LCBlLCBuLCBpKSB7CiAgICByZXR1cm4gaSB8fCAoaSA9IG5ldyBGKCkpLCBpLmxlcnBWZWN0b3JzKHQsIGUsIG4pLCBpOwogIH0KICBzdGF0aWMgZXF1YWxzRXBzaWxvbih0LCBlLCBuLCBpKSB7CiAgICByZXR1cm4gdCA9PT0gZSB8fCBBKHQpICYmIEEoZSkgJiYgRS5lcXVhbHNFcHNpbG9uKAogICAgICB0LngsCiAgICAgIGUueCwKICAgICAgbiwKICAgICAgaQogICAgKSAmJiBFLmVxdWFsc0Vwc2lsb24oCiAgICAgIHQueSwKICAgICAgZS55LAogICAgICBuLAogICAgICBpCiAgICApOwogIH0KICBzdGF0aWMgZXF1YWxzKHQsIGUpIHsKICAgIHJldHVybiB0LmVxdWFscyhlKTsKICB9CiAgc3RhdGljIGRvdCh0LCBlKSB7CiAgICByZXR1cm4gdC5kb3QoZSk7CiAgfQogIHN0YXRpYyBub3JtYWxpemUodCwgZSkgewogICAgcmV0dXJuIHQgPT09IGUgPyAodC5ub3JtYWxpemUoKSwgdCkgOiAoZS5jb3B5KHQpLCBlLm5vcm1hbGl6ZSgpLCBlKTsKICB9CiAgc3RhdGljIGFkZCh0LCBlLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBGKCkpLCBuLmFkZFZlY3RvcnModCwgZSk7CiAgfQogIHN0YXRpYyBtdWx0aXBseUJ5U2NhbGFyKHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IEYoKSksIG4uY29weSh0KS5tdWx0aXBseVNjYWxhcihlKSwgbjsKICB9CiAgc3RhdGljIHN1YnRyYWN0KHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IEYoKSksIG4uc3ViVmVjdG9ycyh0LCBlKSwgbjsKICB9CiAgc3RhdGljIGRpc3RhbmNlKHQsIGUpIHsKICAgIHJldHVybiB0LmRpc3RhbmNlVG8oZSk7CiAgfQogIHN0YXRpYyBhbmdsZUJldHdlZW4odCwgZSkgewogICAgcmV0dXJuIGJlLm5vcm1hbGl6ZSh0LCBGbiksIGJlLm5vcm1hbGl6ZShlLCBWbiksIEUuYWNvc0NsYW1wZWQoCiAgICAgIGJlLmRvdChGbiwgVm4pCiAgICApOwogIH0KfTsKbGV0IHV0ID0gYmU7CnYodXQsICJaRVJPIiwgbmV3IEYoKSk7CnV0LmZyb21DYXJ0ZXNpYW4zID0gdXQuY2xvbmU7CnV0LmZyb21DYXJ0ZXNpYW40ID0gdXQuY2xvbmU7CmNvbnN0IERzID0gbmV3IHAoKTsKbGV0IGd0ID0gbmV3IHAoKSwgdWUgPSBuZXcgcCgpOwpjb25zdCBVcyA9IG5ldyBwKAogIDYzNzgxMzcgKiA2Mzc4MTM3LAogIDYzNzgxMzcgKiA2Mzc4MTM3LAogIDYzNTY3NTIzMTQyNDUxNzllLTkgKiA2MzU2NzUyMzE0MjQ1MTc5ZS05CiksIEJlID0gbmV3IHAoKSwgZm4gPSBuZXcgcCgpLCBRID0gY2xhc3MgewogIGNvbnN0cnVjdG9yKCkgewogICAgdih0aGlzLCAiQ09MVU1OMFJPVzAiLCAwKTsKICAgIHYodGhpcywgIkNPTFVNTjBST1cxIiwgMSk7CiAgICB2KHRoaXMsICJDT0xVTU4wUk9XMiIsIDIpOwogICAgdih0aGlzLCAiQ09MVU1OMVJPVzAiLCAzKTsKICAgIHYodGhpcywgIkNPTFVNTjFST1cxIiwgNCk7CiAgICB2KHRoaXMsICJDT0xVTU4xUk9XMiIsIDUpOwogICAgdih0aGlzLCAiQ09MVU1OMlJPVzAiLCA2KTsKICAgIHYodGhpcywgIkNPTFVNTjJST1cxIiwgNyk7CiAgICB2KHRoaXMsICJDT0xVTU4yUk9XMiIsIDgpOwogIH0KICBzdGF0aWMgY2xvbmUodCwgZSkgewogICAgaWYgKCEhdCkKICAgICAgcmV0dXJuIGUuY29weSh0KSwgZTsKICB9CiAgc3RhdGljIGVxdWFscyh0LCBlKSB7CiAgICByZXR1cm4gQSh0KSAmJiBBKGUpID8gdC5lcXVhbHMoZSkgOiAhMTsKICB9CiAgc3RhdGljIG5vcm1hbGl6ZSh0LCBlKSB7CiAgICByZXR1cm4gdCA9PT0gZSA/ICh0Lm5vcm1hbGl6ZSgpLCB0KSA6IChlLmNvcHkodCksIGUubm9ybWFsaXplKCksIGUpOwogIH0KICBzdGF0aWMgYWRkKHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IHAoKSksIG4uYWRkVmVjdG9ycyh0LCBlKTsKICB9CiAgc3RhdGljIGRvdCh0LCBlKSB7CiAgICByZXR1cm4gdC5kb3QoZSk7CiAgfQogIHN0YXRpYyBjcm9zcyh0LCBlLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBwKCkpLCBuLmNyb3NzVmVjdG9ycyh0LCBlKSwgbjsKICB9CiAgc3RhdGljIG1hZ25pdHVkZVNxdWFyZWQodCkgewogICAgcmV0dXJuIHQubGVuZ3RoU3EoKTsKICB9CiAgc3RhdGljIG11bHRpcGx5QnlTY2FsYXIodCwgZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgcCgpKSwgbi5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKGUpLCBuOwogIH0KICBzdGF0aWMgZGl2aWRlQnlTY2FsYXIodCwgZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgcCgpKSwgbi54ID0gdC54IC8gZSwgbi55ID0gdC55IC8gZSwgbi56ID0gdC56IC8gZSwgbjsKICB9CiAgc3RhdGljIHN1YnRyYWN0KHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IHAoKSksIG4uc3ViVmVjdG9ycyh0LCBlKSwgbjsKICB9CiAgc3RhdGljIGRpc3RhbmNlKHQsIGUpIHsKICAgIHJldHVybiB0LmRpc3RhbmNlVG8oZSk7CiAgfQogIHN0YXRpYyBuZWdhdGUodCwgZSkgewogICAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgcCgpKSwgZS5jb3B5KHQpLCBlLm5lZ2F0ZSgpLCBlOwogIH0KICBzdGF0aWMgbXVsdGlwbHlDb21wb25lbnRzKHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IHAoKSksIG4ubXVsdGlwbHlWZWN0b3JzKHQsIGUpLCBuOwogIH0KICBzdGF0aWMgbWFnbml0dWRlKHQpIHsKICAgIHJldHVybiB0Lmxlbmd0aCgpOwogIH0KICBzdGF0aWMgZXF1YWxzRXBzaWxvbih0LCBlLCBuLCBpKSB7CiAgICByZXR1cm4gdCA9PT0gZSB8fCBBKHQpICYmIEEoZSkgJiYgRS5lcXVhbHNFcHNpbG9uKAogICAgICB0LngsCiAgICAgIGUueCwKICAgICAgbiwKICAgICAgaQogICAgKSAmJiBFLmVxdWFsc0Vwc2lsb24oCiAgICAgIHQueSwKICAgICAgZS55LAogICAgICBuLAogICAgICBpCiAgICApICYmIEUuZXF1YWxzRXBzaWxvbigKICAgICAgdC56LAogICAgICBlLnosCiAgICAgIG4sCiAgICAgIGkKICAgICk7CiAgfQogIHN0YXRpYyBmcm9tQ2FydGVzaWFuNCh0LCBlKSB7CiAgICByZXR1cm4gZSB8fCAoZSA9IG5ldyBwKCkpLCBlLnNldCh0LngsIHQueSwgdC56KSwgZTsKICB9CiAgc3RhdGljIGZyb21FbGVtZW50cyh0LCBlLCBuLCBpKSB7CiAgICByZXR1cm4gaSB8fCAoaSA9IG5ldyBwKCkpLCBpLnNldCh0LCBlLCBuKSwgaTsKICB9CiAgc3RhdGljIGZyb21SYWRpYW5zKHQsIGUsIG4sIGksIHIpIHsKICAgIG4gPSBHKG4sIDApOwogICAgY29uc3QgYSA9IEEoaSkgPyBpLnJhZGlpU3F1YXJlZCA6IFVzLCBvID0gTWF0aC5jb3MoZSk7CiAgICBndC54ID0gbyAqIE1hdGguY29zKHQpLCBndC55ID0gbyAqIE1hdGguc2luKHQpLCBndC56ID0gTWF0aC5zaW4oZSksIGd0ID0gUS5ub3JtYWxpemUoZ3QsIGd0KSwgUS5tdWx0aXBseUNvbXBvbmVudHMoYSwgZ3QsIHVlKTsKICAgIGNvbnN0IGggPSBNYXRoLnNxcnQoUS5kb3QoZ3QsIHVlKSk7CiAgICByZXR1cm4gdWUgPSBRLmRpdmlkZUJ5U2NhbGFyKHVlLCBoLCB1ZSksIGd0ID0gUS5tdWx0aXBseUJ5U2NhbGFyKGd0LCBuLCBndCksIEEocikgfHwgKHIgPSBuZXcgcCgpKSwgUS5hZGQodWUsIGd0LCByKTsKICB9CiAgc3RhdGljIGFuZ2xlQmV0d2Vlbih0LCBlKSB7CiAgICBRLm5vcm1hbGl6ZSh0LCBCZSksIFEubm9ybWFsaXplKGUsIGZuKTsKICAgIGNvbnN0IG4gPSBRLmRvdChCZSwgZm4pLCBpID0gUS5tYWduaXR1ZGUoCiAgICAgIFEuY3Jvc3MoCiAgICAgICAgQmUsCiAgICAgICAgZm4sCiAgICAgICAgQmUKICAgICAgKQogICAgKTsKICAgIHJldHVybiBNYXRoLmF0YW4yKGksIG4pOwogIH0KICBzdGF0aWMgZnJvbURlZ3JlZXModCwgZSwgbiwgaSwgcikgewogICAgcmV0dXJuIHQgPSBFLnRvUmFkaWFucyh0KSwgZSA9IEUudG9SYWRpYW5zKGUpLCBRLmZyb21SYWRpYW5zKHQsIGUsIG4sIGksIHIpOwogIH0KfTsKbGV0IFMgPSBROwp2KFMsICJaRVJPIiwgT2JqZWN0LmZyZWV6ZShuZXcgcCgpKSksIHYoUywgIlVOSVRfWCIsIE9iamVjdC5mcmVlemUobmV3IHAoMSwgMCwgMCkpKSwgdihTLCAiVU5JVF9ZIiwgT2JqZWN0LmZyZWV6ZShuZXcgcCgwLCAxLCAwKSkpLCB2KFMsICJVTklUX1oiLCBPYmplY3QuZnJlZXplKG5ldyBwKDAsIDAsIDEpKSksIHYoUywgImFicyIsIGZ1bmN0aW9uKHQsIGUpIHsKICByZXR1cm4gZS54ID0gTWF0aC5hYnModC54KSwgZS55ID0gTWF0aC5hYnModC55KSwgZS56ID0gTWF0aC5hYnModC56KSwgZTsKfSksIHYoUywgIm1vc3RPcnRob2dvbmFsQXhpcyIsIGZ1bmN0aW9uKHQsIGUpIHsKICBjb25zdCBuID0gUS5ub3JtYWxpemUodCwgRHMpOwogIHJldHVybiBRLmFicyhuLCBuKSwgbi54IDw9IG4ueSA/IG4ueCA8PSBuLnogPyBlID0gUS5jbG9uZShRLlVOSVRfWCwgZSkgOiBlID0gUS5jbG9uZShRLlVOSVRfWiwgZSkgOiBuLnkgPD0gbi56ID8gZSA9IFEuY2xvbmUoUS5VTklUX1ksIGUpIDogZSA9IFEuY2xvbmUoUS5VTklUX1osIGUpLCBlOwp9KTsKY2xhc3MgJCB7CiAgY29uc3RydWN0b3IodCwgZSwgbiwgaSkgewogICAgdGhpcy53ZXN0ID0gdCB8fCAwLCB0aGlzLnNvdXRoID0gZSB8fCAwLCB0aGlzLmVhc3QgPSBuIHx8IDAsIHRoaXMubm9ydGggPSBpIHx8IDA7CiAgfQogIGdldCB3aWR0aCgpIHsKICAgIHJldHVybiAkLmNvbXB1dGVXaWR0aCh0aGlzKTsKICB9CiAgZ2V0IGhlaWdodCgpIHsKICAgIHJldHVybiAkLmNvbXB1dGVIZWlnaHQodGhpcyk7CiAgfQp9CiQuZnJvbURlZ3JlZXMgPSBmdW5jdGlvbihzLCB0LCBlLCBuLCBpKSB7CiAgcmV0dXJuIHMgPSBOdC5kZWdUb1JhZChHKHMsIDApKSwgdCA9IE50LmRlZ1RvUmFkKEcodCwgMCkpLCBlID0gTnQuZGVnVG9SYWQoRyhlLCAwKSksIG4gPSBOdC5kZWdUb1JhZChHKG4sIDApKSwgQShpKSA/IChpLndlc3QgPSBzLCBpLnNvdXRoID0gdCwgaS5lYXN0ID0gZSwgaS5ub3J0aCA9IG4sIGkpIDogbmV3ICQocywgdCwgZSwgbik7Cn07CiQuY29tcHV0ZVdpZHRoID0gZnVuY3Rpb24ocykgewogIGxldCB0ID0gcy5lYXN0OwogIGNvbnN0IGUgPSBzLndlc3Q7CiAgcmV0dXJuIHQgPCBlICYmICh0ICs9IEUuVFdPX1BJKSwgdCAtIGU7Cn07CiQuY29tcHV0ZUhlaWdodCA9IGZ1bmN0aW9uKHMpIHsKICByZXR1cm4gcy5ub3J0aCAtIHMuc291dGg7Cn07CiQuY2xvbmUgPSBmdW5jdGlvbihzLCB0KSB7CiAgaWYgKCEhQShzKSkKICAgIHJldHVybiBBKHQpID8gKHQud2VzdCA9IHMud2VzdCwgdC5zb3V0aCA9IHMuc291dGgsIHQuZWFzdCA9IHMuZWFzdCwgdC5ub3J0aCA9IHMubm9ydGgsIHQpIDogbmV3ICQocy53ZXN0LCBzLnNvdXRoLCBzLmVhc3QsIHMubm9ydGgpOwp9OwokLnNvdXRod2VzdCA9IGZ1bmN0aW9uKHMsIHQpIHsKICByZXR1cm4gQSh0KSA/ICh0LnggPSBzLndlc3QsIHQueSA9IHMuc291dGgsIHQueiA9IDAsIHQpIDogbmV3IHAocy53ZXN0LCBzLnNvdXRoKTsKfTsKJC5ub3J0aGVhc3QgPSBmdW5jdGlvbihzLCB0KSB7CiAgcmV0dXJuIEEodCkgPyAodC54ID0gcy5lYXN0LCB0LnkgPSBzLm5vcnRoLCB0LnogPSAwLCB0KSA6IG5ldyBwKHMuZWFzdCwgcy5ub3J0aCk7Cn07CiQuc291dGhlYXN0ID0gZnVuY3Rpb24ocywgdCkgewogIHJldHVybiBBKHQpID8gKHQueCA9IHMuZWFzdCwgdC55ID0gcy5zb3V0aCwgdC56ID0gMCwgdCkgOiBuZXcgcChzLmVhc3QsIHMuc291dGgpOwp9OwokLm5vcnRod2VzdCA9IGZ1bmN0aW9uKHMsIHQpIHsKICByZXR1cm4gQSh0KSA/ICh0LnggPSBzLndlc3QsIHQueSA9IHMubm9ydGgsIHQueiA9IDAsIHQpIDogbmV3IHAocy53ZXN0LCBzLm5vcnRoKTsKfTsKJC5jZW50ZXIgPSBmdW5jdGlvbihzLCB0KSB7CiAgbGV0IGUgPSBzLmVhc3Q7CiAgY29uc3QgbiA9IHMud2VzdDsKICBlIDwgbiAmJiAoZSArPSBFLlRXT19QSSk7CiAgY29uc3QgaSA9IEUubmVnYXRpdmVQaVRvUGkoKG4gKyBlKSAqIDAuNSksIHIgPSAocy5zb3V0aCArIHMubm9ydGgpICogMC41OwogIHJldHVybiBBKHQpID8gKHQueCA9IGksIHQueSA9IHIsIHQueiA9IDAsIHQpIDogbmV3IHAoaSwgcik7Cn07CiQuY29udGFpbnMgPSBmdW5jdGlvbihzLCB0KSB7CiAgbGV0IGUgPSB0Lng7CiAgY29uc3QgbiA9IHQueSwgaSA9IHMud2VzdDsKICBsZXQgciA9IHMuZWFzdDsKICByZXR1cm4gciA8IGkgJiYgKHIgKz0gRS5UV09fUEksIGUgPCAwICYmIChlICs9IEUuVFdPX1BJKSksIChlID4gaSB8fCBFLmVxdWFsc0Vwc2lsb24oZSwgaSwgRS5FUFNJTE9OMTQpKSAmJiAoZSA8IHIgfHwgRS5lcXVhbHNFcHNpbG9uKGUsIHIsIEUuRVBTSUxPTjE0KSkgJiYgbiA+PSBzLnNvdXRoICYmIG4gPD0gcy5ub3J0aDsKfTsKY29uc3QgR24gPSBNYXRoLlBJICsgMWUtNSwgWm4gPSAtTWF0aC5QSSAtIDFlLTUsIFluID0gRS5QSV9PVkVSX1RXTyArIDFlLTUsIFhuID0gLUUuUElfT1ZFUl9UV08gLSAxZS01OwokLmZyb21Cb3ggPSBmdW5jdGlvbihzLCB0LCBlID0gITEpIHsKICBjb25zdCBuID0gcy5taW4sIGkgPSBzLm1heDsKICBsZXQgciA9IG4ueCAvIDE4MCAqIE1hdGguUEksIGEgPSBuLnkgLyAxODAgKiBNYXRoLlBJLCBvID0gaS54IC8gMTgwICogTWF0aC5QSSwgaCA9IGkueSAvIDE4MCAqIE1hdGguUEk7CiAgcmV0dXJuIGUgJiYgKHIgPCBabiAmJiAociA9IC1NYXRoLlBJKSwgciA+IEduICYmIChyID0gTWF0aC5QSSksIGEgPCBYbiAmJiAoYSA9IC1FLlBJX09WRVJfVFdPKSwgYSA+IFluICYmIChhID0gRS5QSV9PVkVSX1RXTyksIG8gPiBHbiAmJiAobyA9IE1hdGguUEkpLCBvIDwgWm4gJiYgKG8gPSAtTWF0aC5QSSksIGggPiBZbiAmJiAoaCA9IEUuUElfT1ZFUl9UV08pLCBoIDwgWG4gJiYgKGggPSAtRS5QSV9PVkVSX1RXTykpLCBBKHQpID8gKHQud2VzdCA9IHIsIHQuc291dGggPSBhLCB0LmVhc3QgPSBvLCB0Lm5vcnRoID0gaCwgdCkgOiBuZXcgJChyLCBhLCBvLCBoKTsKfTsKJC5NQVhfVkFMVUUgPSBPYmplY3QuZnJlZXplKAogIG5ldyAkKAogICAgLU1hdGguUEksCiAgICAtRS5QSV9PVkVSX1RXTywKICAgIE1hdGguUEksCiAgICBFLlBJX09WRVJfVFdPCiAgKQopOwpjb25zdCBXcyA9IG5ldyBwKCksIEZzID0gbmV3IHAoKTsKZnVuY3Rpb24ga2kocywgdCwgZSwgbiwgaSkgewogIGNvbnN0IHIgPSBzLngsIGEgPSBzLnksIG8gPSBzLnosIGggPSB0LngsIGMgPSB0LnksIGwgPSB0LnosIHUgPSByICogciAqIGggKiBoLCBkID0gYSAqIGEgKiBjICogYywgeSA9IG8gKiBvICogbCAqIGwsIGYgPSB1ICsgZCArIHksIGcgPSBNYXRoLnNxcnQoMSAvIGYpLCBfID0gV3MuY29weShzKS5tdWx0aXBseVNjYWxhcihnKTsKICBpZiAoZiA8IG4pCiAgICByZXR1cm4gaSB8fCAoaSA9IG5ldyBwKCkpLCBpc0Zpbml0ZShnKSA/IGkuY29weShfKSA6IHZvaWQgMDsKICBjb25zdCB3ID0gZS54LCB4ID0gZS55LCBtID0gZS56LCBNID0gRnM7CiAgTS54ID0gXy54ICogdyAqIDIsIE0ueSA9IF8ueSAqIHggKiAyLCBNLnogPSBfLnogKiBtICogMjsKICBsZXQgeiA9ICgxIC0gZykgKiBzLmxlbmd0aCgpIC8gKDAuNSAqIE0ubGVuZ3RoKCkpLCBQID0gMCwgVCwgYiwgTiwgSSwgQywgTywgUiwgRCwgVSwgTCwgcTsKICBkbyB7CiAgICB6IC09IFAsIE4gPSAxIC8gKDEgKyB6ICogdyksIEkgPSAxIC8gKDEgKyB6ICogeCksIEMgPSAxIC8gKDEgKyB6ICogbSksIE8gPSBOICogTiwgUiA9IEkgKiBJLCBEID0gQyAqIEMsIFUgPSBPICogTiwgTCA9IFIgKiBJLCBxID0gRCAqIEMsIFQgPSB1ICogTyArIGQgKiBSICsgeSAqIEQgLSAxLCBiID0gdSAqIFUgKiB3ICsgZCAqIEwgKiB4ICsgeSAqIHEgKiBtOwogICAgbGV0IGsgPSAtMiAqIGI7CiAgICBQID0gVCAvIGs7CiAgfSB3aGlsZSAoTWF0aC5hYnMoVCkgPiAxZS0xMik7CiAgcmV0dXJuIGkgPyAoaS54ID0gciAqIE4sIGkueSA9IGEgKiBJLCBpLnogPSBvICogQywgaSkgOiBuZXcgcCgKICAgIHIgKiBOLAogICAgYSAqIEksCiAgICBvICogQwogICk7Cn0KY29uc3QgVnMgPSBuZXcgcCgpLCBHcyA9IG5ldyBwKCksIFpzID0gbmV3IHAoKSwgWXMgPSBuZXcgcCgKICAxIC8gNjM3ODEzNywKICAxIC8gNjM3ODEzNywKICAxIC8gNjM1Njc1MjMxNDI0NTE3OWUtOQopLCBYcyA9IG5ldyBwKAogIDEgLyAoNjM3ODEzNyAqIDYzNzgxMzcpLAogIDEgLyAoNjM3ODEzNyAqIDYzNzgxMzcpLAogIDEgLyAoNjM1Njc1MjMxNDI0NTE3OWUtOSAqIDYzNTY3NTIzMTQyNDUxNzllLTkpCiksIFFzID0gRS5FUFNJTE9OMSwgS2UgPSBjbGFzcyB7CiAgc3RhdGljIGZyb21SYWRpYW5zKHQsIGUsIG4sIGkpIHsKICAgIHJldHVybiBuID0gRyhuLCAwKSwgQShpKSA/IChpLnggPSB0LCBpLnkgPSBlLCBpLnogPSBuLCBpKSA6IG5ldyBwKHQsIGUsIG4pOwogIH0KICBzdGF0aWMgZnJvbURlZ3JlZXModCwgZSwgbiwgaSkgewogICAgcmV0dXJuIHQgPSBFLnRvUmFkaWFucyh0KSwgZSA9IEUudG9SYWRpYW5zKGUpLCBLZS5mcm9tUmFkaWFucyh0LCBlLCBuLCBpKTsKICB9CiAgc3RhdGljIGZyb21DYXJ0ZXNpYW4odCwgZSwgbikgewogICAgY29uc3QgaSA9IEEoZSkgPyBlLm9uZU92ZXJSYWRpaSA6IFlzLCByID0gQShlKSA/IGUub25lT3ZlclJhZGlpU3F1YXJlZCA6IFhzLCBhID0gQShlKSA/IGUuX2NlbnRlclRvbGVyYW5jZVNxdWFyZWQgOiBRcywgbyA9IGtpKAogICAgICB0LAogICAgICBpLAogICAgICByLAogICAgICBhLAogICAgICBHcwogICAgKTsKICAgIGlmICghQShvKSkKICAgICAgcmV0dXJuOwogICAgbGV0IGggPSBTLm11bHRpcGx5Q29tcG9uZW50cygKICAgICAgbywKICAgICAgciwKICAgICAgVnMKICAgICk7CiAgICBoID0gUy5ub3JtYWxpemUoaCwgaCk7CiAgICBjb25zdCBjID0gUy5zdWJ0cmFjdCh0LCBvLCBacyksIGwgPSBNYXRoLmF0YW4yKGgueSwgaC54KSwgdSA9IE1hdGguYXNpbihoLnopLCBkID0gRS5zaWduKFMuZG90KGMsIHQpKSAqIFMubWFnbml0dWRlKGMpOwogICAgcmV0dXJuIEEobikgPyAobi54ID0gbCwgbi55ID0gdSwgbi56ID0gZCwgbikgOiBuZXcgcChsLCB1LCBkKTsKICB9CiAgc3RhdGljIHRvQ2FydGVzaWFuKHQsIGUsIG4pIHsKICAgIHJldHVybiBTLmZyb21SYWRpYW5zKAogICAgICB0LngsCiAgICAgIHQueSwKICAgICAgdC56LAogICAgICBlLAogICAgICBuCiAgICApOwogIH0KICBzdGF0aWMgY2xvbmUodCwgZSkgewogICAgaWYgKCEhQSh0KSkKICAgICAgcmV0dXJuIEEoZSkgPyAoZS54ID0gdC54LCBlLnkgPSB0LnksIGUueiA9IHQueiwgZSkgOiBuZXcgcCgKICAgICAgICB0LngsCiAgICAgICAgdC55LAogICAgICAgIHQuegogICAgICApOwogIH0KICBzdGF0aWMgZXF1YWxzKHQsIGUpIHsKICAgIHJldHVybiB0ID09PSBlIHx8IEEodCkgJiYgQShlKSAmJiB0LnggPT09IGUueCAmJiB0LnkgPT09IGUueSAmJiB0LnogPT09IGUuejsKICB9CiAgc3RhdGljIGVxdWFsc0Vwc2lsb24odCwgZSwgbikgewogICAgcmV0dXJuIG4gPSBHKG4sIDApLCB0ID09PSBlIHx8IEEodCkgJiYgQShlKSAmJiBFLmVxdWFsc0Vwc2lsb24odC54LCBlLngsIG4pICYmIEUuZXF1YWxzRXBzaWxvbih0LnksIGUueSwgbikgJiYgRS5lcXVhbHNFcHNpbG9uKHQueiwgZS56LCBuKTsKICB9Cn07CmxldCBSdCA9IEtlOwp2KFJ0LCAiZnJvbVJhZGlhbnMiLCBmdW5jdGlvbih0LCBlLCBuLCBpKSB7CiAgcmV0dXJuIG4gPSBHKG4sIDApLCBBKGkpID8gKGkueCA9IHQsIGkueSA9IGUsIGkueiA9IG4sIGkpIDogbmV3IHAodCwgZSwgbik7Cn0pLCB2KFJ0LCAiZnJvbURlZ3JlZXMiLCBmdW5jdGlvbih0LCBlLCBuLCBpKSB7CiAgcmV0dXJuIHQgPSBFLnRvUmFkaWFucyh0KSwgZSA9IEUudG9SYWRpYW5zKGUpLCBLZS5mcm9tUmFkaWFucyh0LCBlLCBuLCBpKTsKfSksIHYoUnQsICJaRVJPIiwgT2JqZWN0LmZyZWV6ZShuZXcgcCgwLCAwLCAwKSkpOwpjb25zdCBRbiA9IG5ldyBwKCksICRzID0gbmV3IHAoKTsKY2xhc3MgZHQgewogIGNvbnN0cnVjdG9yKHQsIGUsIG4pIHsKICAgIHRoaXMuX3JhZGlpID0gbmV3IHAodCwgZSwgbiksIHRoaXMuX3JhZGlpU3F1YXJlZCA9IG5ldyBwKHQgKiB0LCBlICogZSwgbiAqIG4pLCB0aGlzLl9yYWRpaVRvVGhlRm91cnRoID0gbmV3IHAoCiAgICAgIHQgKiB0ICogdCAqIHQsCiAgICAgIGUgKiBlICogZSAqIGUsCiAgICAgIG4gKiBuICogbiAqIG4KICAgICksIHRoaXMuX29uZU92ZXJSYWRpaSA9IG5ldyBwKAogICAgICB0ID09PSAwID8gMCA6IDEgLyB0LAogICAgICBlID09PSAwID8gMCA6IDEgLyBlLAogICAgICBuID09PSAwID8gMCA6IDEgLyBuCiAgICApLCB0aGlzLl9vbmVPdmVyUmFkaWlTcXVhcmVkID0gbmV3IHAoCiAgICAgIHQgPT09IDAgPyAwIDogMSAvICh0ICogdCksCiAgICAgIGUgPT09IDAgPyAwIDogMSAvIChlICogZSksCiAgICAgIG4gPT09IDAgPyAwIDogMSAvIChuICogbikKICAgICksIHRoaXMuX21pbmltdW1SYWRpdXMgPSBNYXRoLm1pbih0LCBlLCBuKSwgdGhpcy5fbWF4aW11bVJhZGl1cyA9IE1hdGgubWF4KHQsIGUsIG4pLCB0aGlzLl9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkID0gMC4xLCB0aGlzLl9yYWRpaVNxdWFyZWQueiAhPT0gMCAmJiAodGhpcy5fc3F1YXJlZFhPdmVyU3F1YXJlZFogPSB0aGlzLl9yYWRpaVNxdWFyZWQueCAvIHRoaXMuX3JhZGlpU3F1YXJlZC56KTsKICB9CiAgc3RhdGljIGZyb21DYXJ0ZXNpYW4zKHQpIHsKICAgIHJldHVybiBuZXcgZHQodC54LCB0LnksIHQueik7CiAgfQogIGdlb2RldGljU3VyZmFjZU5vcm1hbENhcnRvZ3JhcGhpYyh0LCBlKSB7CiAgICBlIHx8IChlID0gbmV3IHAoKSk7CiAgICBjb25zdCBuID0gdC54LCBpID0gdC55LCByID0gTWF0aC5jb3MoaSksIGEgPSByICogTWF0aC5jb3MobiksIG8gPSByICogTWF0aC5zaW4obiksIGggPSBNYXRoLnNpbihpKTsKICAgIHJldHVybiBlLnNldChhLCBvLCBoKSwgZS5ub3JtYWxpemUoKSwgZTsKICB9CiAgY2FydG9ncmFwaGljRGVncmVlVG9DYXJ0ZXNpYW4odCwgZSkgewogICAgcmV0dXJuIFFuLnNldCgKICAgICAgTnQuZGVnVG9SYWQodC54KSwKICAgICAgTnQuZGVnVG9SYWQodC55KSwKICAgICAgdC56CiAgICApLCB0aGlzLmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKFFuLCBlKTsKICB9CiAgY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4odCwgZSkgewogICAgY29uc3QgbiA9IHRoaXMuZ2VvZGV0aWNTdXJmYWNlTm9ybWFsQ2FydG9ncmFwaGljKHQpOwogICAgZSB8fCAoZSA9IG5ldyBwKCkpLCBlLm11bHRpcGx5VmVjdG9ycyh0aGlzLl9yYWRpaVNxdWFyZWQsIG4pOwogICAgY29uc3QgaSA9IE1hdGguc3FydChuLmNsb25lKCkuZG90KGUpKTsKICAgIHJldHVybiBlLmRpdmlkZVNjYWxhcihpKSwgbi5tdWx0aXBseVNjYWxhcih0LnopLCBlLmFkZChuKSwgZTsKICB9CiAgY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWNEZWdyZWUodCwgZSkgewogICAgY29uc3QgbiA9IHRoaXMuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWModCwgZSk7CiAgICBpZiAoISFuKQogICAgICByZXR1cm4gZSA9IG4sIGUueCA9IE50LnJhZFRvRGVnKGUueCksIGUueSA9IE50LnJhZFRvRGVnKGUueSksIGU7CiAgfQogIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2UodCwgZSkgewogICAgcmV0dXJuIGtpKAogICAgICB0LAogICAgICB0aGlzLl9vbmVPdmVyUmFkaWksCiAgICAgIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQsCiAgICAgIHRoaXMuX2NlbnRlclRvbGVyYW5jZVNxdWFyZWQsCiAgICAgIGUKICAgICk7CiAgfQogIHNjYWxlVG9HZW9jZW50cmljU3VyZmFjZSh0LCBlKSB7CiAgICBlIHx8IChlID0gbmV3IHAoKSk7CiAgICBjb25zdCBuID0gdC54LCBpID0gdC55LCByID0gdC56LCBhID0gdGhpcy5fb25lT3ZlclJhZGlpU3F1YXJlZCwgbyA9IDEgLyBNYXRoLnNxcnQoCiAgICAgIG4gKiBuICogYS54ICsgaSAqIGkgKiBhLnkgKyByICogciAqIGEuegogICAgKTsKICAgIHJldHVybiBlLmNvcHkodCkubXVsdGlwbHlTY2FsYXIobyk7CiAgfQogIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljKHQsIGUpIHsKICAgIGNvbnN0IG4gPSB0aGlzLnNjYWxlVG9HZW9kZXRpY1N1cmZhY2UoCiAgICAgIHQsCiAgICAgICRzCiAgICApOwogICAgaWYgKCFuKQogICAgICByZXR1cm47CiAgICBjb25zdCBpID0gdGhpcy5nZW9kZXRpY1N1cmZhY2VOb3JtYWwobiksIHIgPSB0LmNsb25lKCk7CiAgICByLnN1YihuKTsKICAgIGNvbnN0IGEgPSBNYXRoLmF0YW4yKGkueSwgaS54KSwgbyA9IE1hdGguYXNpbihpLnopLCBoID0gTWF0aC5zaWduKHIuZG90KHQpKSAqIHIubGVuZ3RoKCk7CiAgICByZXR1cm4gZSB8fCAoZSA9IG5ldyBwKCkpLCBlLnNldChhLCBvLCBoKSwgZTsKICB9CiAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKHQsIGUpIHsKICAgIHJldHVybiBBKGUpIHx8IChlID0gbmV3IHAoKSksIGUubXVsdGlwbHlWZWN0b3JzKHQsIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQpLCBlLm5vcm1hbGl6ZSgpLCBlOwogIH0KICBnZXRTdXJmYWNlTm9ybWFsSW50ZXJzZWN0aW9uV2l0aFpBeGlzKHQsIGUsIG4pIHsKICAgIGUgPSBHKGUsIDApOwogICAgY29uc3QgaSA9IHRoaXMuX3NxdWFyZWRYT3ZlclNxdWFyZWRaOwogICAgaWYgKEEobikgfHwgKG4gPSBuZXcgcCgpKSwgbi54ID0gMCwgbi55ID0gMCwgbi56ID0gdC56ICogKDEgLSBpKSwgIShNYXRoLmFicyhuLnopID49IHRoaXMuX3JhZGlpLnogLSBlKSkKICAgICAgcmV0dXJuIG47CiAgfQogIHRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZSh0LCBlKSB7CiAgICByZXR1cm4gUy5tdWx0aXBseUNvbXBvbmVudHModCwgdGhpcy5fb25lT3ZlclJhZGlpLCBlKTsKICB9CiAgc3RhdGljIGNsb25lKHQsIGUpIHsKICAgIGlmICghdCkKICAgICAgcmV0dXJuOwogICAgY29uc3QgbiA9IHQuX3JhZGlpOwogICAgcmV0dXJuIGUgPyAoUy5jbG9uZShuLCBlLl9yYWRpaSksIFMuY2xvbmUodC5fcmFkaWlTcXVhcmVkLCBlLl9yYWRpaVNxdWFyZWQpLCBTLmNsb25lKHQuX3JhZGlpVG9UaGVGb3VydGgsIGUuX3JhZGlpVG9UaGVGb3VydGgpLCBTLmNsb25lKHQuX29uZU92ZXJSYWRpaSwgZS5fb25lT3ZlclJhZGlpKSwgUy5jbG9uZSh0Ll9vbmVPdmVyUmFkaWlTcXVhcmVkLCBlLl9vbmVPdmVyUmFkaWlTcXVhcmVkKSwgZS5fbWluaW11bVJhZGl1cyA9IHQuX21pbmltdW1SYWRpdXMsIGUuX21heGltdW1SYWRpdXMgPSB0Ll9tYXhpbXVtUmFkaXVzLCBlLl9jZW50ZXJUb2xlcmFuY2VTcXVhcmVkID0gdC5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZCwgZSkgOiBuZXcgZHQobi54LCBuLnksIG4ueik7CiAgfQogIGdldCByYWRpaSgpIHsKICAgIHJldHVybiB0aGlzLl9yYWRpaTsKICB9CiAgZ2V0IHJhZGlpU3F1YXJlZCgpIHsKICAgIHJldHVybiB0aGlzLl9yYWRpaVNxdWFyZWQ7CiAgfQogIGdldCByYWRpaVRvVGhlRm91cnRoKCkgewogICAgcmV0dXJuIHRoaXMucmFkaWlUb1RoZUZvdXJ0aDsKICB9CiAgZ2V0IG9uZU92ZXJSYWRpaSgpIHsKICAgIHJldHVybiB0aGlzLl9vbmVPdmVyUmFkaWk7CiAgfQogIGdldCBvbmVPdmVyUmFkaWlTcXVhcmVkKCkgewogICAgcmV0dXJuIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQ7CiAgfQogIGdldCBtYXhpbXVtUmFkaXVzKCkgewogICAgcmV0dXJuIHRoaXMuX21heGltdW1SYWRpdXM7CiAgfQogIGdldCBtaW5pbXVtUmFkaXVzKCkgewogICAgcmV0dXJuIHRoaXMuX21pbmltdW1SYWRpdXM7CiAgfQp9CmR0LldHUzg0ID0gT2JqZWN0LmZyZWV6ZSgKICBuZXcgZHQoNjM3ODEzNywgNjM3ODEzNywgNjM1Njc1MjMxNDI0NTE3OWUtOSkKKTsKbGV0ICRuID0gbmV3IFh0KCksIEhuID0gbmV3IFh0KCksIHhuID0gbmV3IFh0KCksIEpuID0gbmV3IFh0KCksIHduID0gbmV3IHAoKTsKY2xhc3Mgc2UgewogIHN0YXRpYyBmcm9tQXhpc0FuZ2xlKHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IFh0KCkpLCB3bi5jb3B5KHQpLCB3bi5ub3JtYWxpemUoKSwgbi5zZXRGcm9tQXhpc0FuZ2xlKHduLCBlKSwgbjsKICB9CiAgc3RhdGljIG11bHRpcGx5KHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IFh0KCkpLCBuLm11bHRpcGx5UXVhdGVybmlvbnModCwgZSksIG47CiAgfQogIHN0YXRpYyBmcm9tSGVhZGluZ1BpdGNoUm9sbCh0LCBlKSB7CiAgICByZXR1cm4gSm4gPSBzZS5mcm9tQXhpc0FuZ2xlKAogICAgICBTLlVOSVRfWCwKICAgICAgdC5yb2xsLAogICAgICAkbgogICAgKSwgeG4gPSBzZS5mcm9tQXhpc0FuZ2xlKAogICAgICBTLlVOSVRfWSwKICAgICAgLXQucGl0Y2gsCiAgICAgIGUKICAgICksIGUgPSBzZS5tdWx0aXBseSgKICAgICAgeG4sCiAgICAgIEpuLAogICAgICB4bgogICAgKSwgSG4gPSBzZS5mcm9tQXhpc0FuZ2xlKAogICAgICBTLlVOSVRfWiwKICAgICAgLXQuaGVhZGluZywKICAgICAgJG4KICAgICksIHNlLm11bHRpcGx5KEhuLCBlLCBlKTsKICB9Cn0KY2xhc3MgeGUgewogIHN0YXRpYyBjbG9uZSh0LCBlKSB7CiAgICByZXR1cm4gZS5jb3B5KHQpLCBlOwogIH0KICBzdGF0aWMgaW52ZXJzZVRyYW5zZm9ybWF0aW9uKHQsIGUpIHsKICAgIHJldHVybiBlLmNvcHkodCkuaW52ZXJ0KCksIGU7CiAgfQogIHN0YXRpYyBtdWx0aXBseUJ5UG9pbnQodCwgZSwgbikgewogICAgY29uc3QgaSA9IHQuZWxlbWVudHMsIHIgPSBlLngsIGEgPSBlLnksIG8gPSBlLnosIGggPSBpWzBdICogciArIGlbNF0gKiBhICsgaVs4XSAqIG8gKyBpWzEyXSwgYyA9IGlbMV0gKiByICsgaVs1XSAqIGEgKyBpWzldICogbyArIGlbMTNdLCBsID0gaVsyXSAqIHIgKyBpWzZdICogYSArIGlbMTBdICogbyArIGlbMTRdOwogICAgcmV0dXJuIG4ueCA9IGgsIG4ueSA9IGMsIG4ueiA9IGwsIG47CiAgfQogIHN0YXRpYyBtdWx0aXBseUJ5UG9pbnRBc1ZlY3Rvcih0LCBlLCBuKSB7CiAgICBjb25zdCBpID0gdC5lbGVtZW50cywgciA9IGUueCwgYSA9IGUueSwgbyA9IGUueiwgaCA9IGlbMF0gKiByICsgaVs0XSAqIGEgKyBpWzhdICogbywgYyA9IGlbMV0gKiByICsgaVs1XSAqIGEgKyBpWzldICogbywgbCA9IGlbMl0gKiByICsgaVs2XSAqIGEgKyBpWzEwXSAqIG87CiAgICByZXR1cm4gbi54ID0gaCwgbi55ID0gYywgbi56ID0gbCwgbjsKICB9CiAgc3RhdGljIGNvbXB1dGVWaWV3cG9ydFRyYW5zZm9ybWF0aW9uKHQsIGUsIG4sIGkpIHsKICAgIEEoaSkgfHwgKGkgPSBuZXcgYXQoKSksIHQgPSBHKHQsIEcuRU1QVFlfT0JKRUNUKTsKICAgIGNvbnN0IHIgPSBHKHQueCwgMCksIGEgPSBHKHQueSwgMCksIG8gPSBHKHQud2lkdGgsIDApLCBoID0gRyh0LmhlaWdodCwgMCk7CiAgICBlID0gRyhlLCAwKSwgbiA9IEcobiwgMSk7CiAgICBjb25zdCBjID0gbyAqIDAuNSwgbCA9IGggKiAwLjUsIHUgPSAobiAtIGUpICogMC41LCBkID0gYywgeSA9IGwsIGYgPSB1LCBnID0gciArIGMsIF8gPSBhICsgbCwgdyA9IGUgKyB1LCB4ID0gMSwgbSA9IGkuZWxlbWVudHM7CiAgICByZXR1cm4gbVswXSA9IGQsIG1bMV0gPSAwLCBtWzJdID0gMCwgbVszXSA9IDAsIG1bNF0gPSAwLCBtWzVdID0geSwgbVs2XSA9IDAsIG1bN10gPSAwLCBtWzhdID0gMCwgbVs5XSA9IDAsIG1bMTBdID0gZiwgbVsxMV0gPSAwLCBtWzEyXSA9IGcsIG1bMTNdID0gXywgbVsxNF0gPSB3LCBtWzE1XSA9IHgsIGk7CiAgfQogIHN0YXRpYyBlcXVhbHModCwgZSkgewogICAgcmV0dXJuIHQuZXF1YWxzKGUpOwogIH0KICBzdGF0aWMgbXVsdGlwbHlCeVZlY3Rvcih0LCBlLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBtdCgpKSwgbi5jb3B5KGUpLCBuLmFwcGx5TWF0cml4NCh0KSwgbjsKICB9CiAgc3RhdGljIGdldENvbHVtbih0LCBlLCBuKSB7CiAgICBjb25zdCBpID0gdC5lbGVtZW50cywgciA9IGUgKiA0LCBhID0gaVtyXSwgbyA9IGlbciArIDFdLCBoID0gaVtyICsgMl0sIGMgPSBpW3IgKyAzXTsKICAgIHJldHVybiBuLnggPSBhLCBuLnkgPSBvLCBuLnogPSBoLCBuLncgPSBjLCBuOwogIH0KICBzdGF0aWMgZnJvbVRyYW5zbGF0aW9uUXVhdGVybmlvblJvdGF0aW9uU2NhbGUodCwgZSwgbiwgaSkgewogICAgaSB8fCAoaSA9IG5ldyBhdCgpKTsKICAgIGNvbnN0IHIgPSBuLngsIGEgPSBuLnksIG8gPSBuLnosIGggPSBlLnggKiBlLngsIGMgPSBlLnggKiBlLnksIGwgPSBlLnggKiBlLnosIHUgPSBlLnggKiBlLncsIGQgPSBlLnkgKiBlLnksIHkgPSBlLnkgKiBlLnosIGYgPSBlLnkgKiBlLncsIGcgPSBlLnogKiBlLnosIF8gPSBlLnogKiBlLncsIHcgPSBlLncgKiBlLncsIHggPSBoIC0gZCAtIGcgKyB3LCBtID0gMiAqIChjIC0gXyksIE0gPSAyICogKGwgKyBmKSwgeiA9IDIgKiAoYyArIF8pLCBQID0gLWggKyBkIC0gZyArIHcsIFQgPSAyICogKHkgLSB1KSwgYiA9IDIgKiAobCAtIGYpLCBOID0gMiAqICh5ICsgdSksIEkgPSAtaCAtIGQgKyBnICsgdywgQyA9IGkuZWxlbWVudHM7CiAgICByZXR1cm4gQ1swXSA9IHggKiByLCBDWzFdID0geiAqIHIsIENbMl0gPSBiICogciwgQ1szXSA9IDAsIENbNF0gPSBtICogYSwgQ1s1XSA9IFAgKiBhLCBDWzZdID0gTiAqIGEsIENbN10gPSAwLCBDWzhdID0gTSAqIG8sIENbOV0gPSBUICogbywgQ1sxMF0gPSBJICogbywgQ1sxMV0gPSAwLCBDWzEyXSA9IHQueCwgQ1sxM10gPSB0LnksIENbMTRdID0gdC56LCBDWzE1XSA9IDEsIGk7CiAgfQp9CnYoeGUsICJJREVOVElUWSIsIE9iamVjdC5mcmVlemUobmV3IGF0KCkpKTsKeGUuWkVSTyA9IE9iamVjdC5mcmVlemUoCiAgbmV3IGF0KAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDAsCiAgICAwLAogICAgMAogICkKKTsKY29uc3Qgb3QgPSB7fSwgSHMgPSBuZXcgWHQoKSwgSnMgPSBuZXcgcCgxLCAxLCAxKSwgS3MgPSBuZXcgYXQoKSwgem4gPSB7CiAgdXA6IHsKICAgIHNvdXRoOiAiZWFzdCIsCiAgICBub3J0aDogIndlc3QiLAogICAgd2VzdDogInNvdXRoIiwKICAgIGVhc3Q6ICJub3J0aCIKICB9LAogIGRvd246IHsKICAgIHNvdXRoOiAid2VzdCIsCiAgICBub3J0aDogImVhc3QiLAogICAgd2VzdDogIm5vcnRoIiwKICAgIGVhc3Q6ICJzb3V0aCIKICB9LAogIHNvdXRoOiB7CiAgICB1cDogIndlc3QiLAogICAgZG93bjogImVhc3QiLAogICAgd2VzdDogImRvd24iLAogICAgZWFzdDogInVwIgogIH0sCiAgbm9ydGg6IHsKICAgIHVwOiAiZWFzdCIsCiAgICBkb3duOiAid2VzdCIsCiAgICB3ZXN0OiAidXAiLAogICAgZWFzdDogImRvd24iCiAgfSwKICB3ZXN0OiB7CiAgICB1cDogIm5vcnRoIiwKICAgIGRvd246ICJzb3V0aCIsCiAgICBub3J0aDogImRvd24iLAogICAgc291dGg6ICJ1cCIKICB9LAogIGVhc3Q6IHsKICAgIHVwOiAic291dGgiLAogICAgZG93bjogIm5vcnRoIiwKICAgIG5vcnRoOiAidXAiLAogICAgc291dGg6ICJkb3duIgogIH0KfTsKbGV0IGRlID0gewogIG5vcnRoOiBbLTEsIDAsIDBdLAogIGVhc3Q6IFswLCAxLCAwXSwKICB1cDogWzAsIDAsIDFdLAogIHNvdXRoOiBbMSwgMCwgMF0sCiAgd2VzdDogWzAsIC0xLCAwXSwKICBkb3duOiBbMCwgMCwgLTFdCn0sIGduID0ge30sIGN0ID0gewogIGVhc3Q6IG5ldyBwKCksCiAgbm9ydGg6IG5ldyBwKCksCiAgdXA6IG5ldyBwKCksCiAgd2VzdDogbmV3IHAoKSwKICBzb3V0aDogbmV3IHAoKSwKICBkb3duOiBuZXcgcCgpCn0sIEt0ID0gbmV3IHAoKSwgdGUgPSBuZXcgcCgpLCBlZSA9IG5ldyBwKCk7CmNvbnN0IFllID0gKHMpID0+IHMgIT09IHZvaWQgMCwgdHIgPSBuZXcgcCgpLCBlciA9IChzKSA9PiAocyA9ICtzLCBzID09PSAwID8gcyA6IHMgPiAwID8gMSA6IC0xKSwgVnQgPSBuZXcgcCgpLCBEZSA9IG5ldyBwKCksIEJpID0gZnVuY3Rpb24ocywgdCwgZSA9IDAsIG4pIHsKICBjb25zdCBpID0gbmV3IHAoCiAgICA0MDY4MDYzMTU5MDc2OSwKICAgIDQwNjgwNjMxNTkwNzY5LAogICAgNDA0MDgyOTk5ODQ2NjE0NDVlLTMKICApLCByID0gTWF0aC5jb3ModCk7CiAgVnQueCA9IHIgKiBNYXRoLmNvcyhzKSwgVnQueSA9IHIgKiBNYXRoLnNpbihzKSwgVnQueiA9IE1hdGguc2luKHQpLCBWdC5ub3JtYWxpemUoKSwgRGUubXVsdGlwbHlWZWN0b3JzKGksIFZ0KTsKICBjb25zdCBhID0gTWF0aC5zcXJ0KFZ0LmRvdChEZSkpOwogIHJldHVybiBEZS5kaXZpZGVTY2FsYXIoYSksIFZ0Lm11bHRpcGx5U2NhbGFyKGUpLCBZZShuKSB8fCAobiA9IG5ldyBwKCkpLCBuLmFkZFZlY3RvcnMoRGUsIFZ0KTsKfSwgbnIgPSAocywgdCwgZSA9IDAsIG4pID0+IEJpKHMgKiBNYXRoLlBJIC8gMTgwLCB0ICogTWF0aC5QSSAvIDE4MCwgZSwgbik7Cm90LmxuZ2xhdFRvRWNlZiA9IG5yOwpvdC5yYWRpYW5Ub0VjZWYgPSBCaTsKb3QubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvciA9IGZ1bmN0aW9uKHMsIHQpIHsKICBpZiAoIXpuLmhhc093blByb3BlcnR5KHMpIHx8ICF6bltzXS5oYXNPd25Qcm9wZXJ0eSh0KSkKICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgImZpcnN0QXhpcyBhbmQgc2Vjb25kQXhpcyBtdXN0IGJlIGVhc3QsIG5vcnRoLCB1cCwgd2VzdCwgc291dGggb3IgZG93bi4iCiAgICApOwogIGxldCBlID0gem5bc11bdF0sIG4sIGkgPSBzICsgdDsKICByZXR1cm4gWWUoZ25baV0pID8gbiA9IGduW2ldIDogKG4gPSBmdW5jdGlvbihyLCBhLCBvKSB7CiAgICBpZiAoIVllKHIpKQogICAgICB0aHJvdyBuZXcgRXJyb3IoIm9yaWdpbiBpcyByZXF1aXJlZC4iKTsKICAgIGlmIChZZShvKSB8fCAobyA9IG5ldyBhdCgpKSwgci5lcXVhbHModHIpKQogICAgICBLdC5mcm9tQXJyYXkoZGVbc10pLCB0ZS5mcm9tQXJyYXkoZGVbdF0pLCBlZS5mcm9tQXJyYXkoZGVbZV0pOwogICAgZWxzZSBpZiAoTWF0aC5hYnMoci54KSA8IDFlLTE0ICYmIE1hdGguYWJzKHIueSkgPCAxZS0xNCkgewogICAgICBsZXQgYyA9IGVyKHIueik7CiAgICAgIEt0LmZyb21BcnJheShkZVtzXSksIHMgIT09ICJlYXN0IiAmJiBzICE9PSAid2VzdCIgJiYgS3QubXVsdGlwbHlTY2FsYXIoYyksIHRlLmZyb21BcnJheShkZVt0XSksIHQgIT09ICJlYXN0IiAmJiB0ICE9PSAid2VzdCIgJiYgdGUubXVsdGlwbHlTY2FsYXIoYyksIGVlLmZyb21BcnJheShkZVtlXSksIGUgIT09ICJlYXN0IiAmJiBlICE9PSAid2VzdCIgJiYgZWUubXVsdGlwbHlTY2FsYXIoYyk7CiAgICB9IGVsc2UgewogICAgICBhID0gYSB8fCBkdC5XR1M4NCwgYS5nZW9kZXRpY1N1cmZhY2VOb3JtYWwociwgY3QudXApOwogICAgICBsZXQgYyA9IGN0LnVwLCBsID0gY3QuZWFzdDsKICAgICAgbC54ID0gLXIueSwgbC55ID0gci54LCBsLnogPSAwLCBjdC5lYXN0LmNvcHkobCkubm9ybWFsaXplKCksIGN0Lm5vcnRoLmNyb3NzVmVjdG9ycyhjLCBsKSwgY3QuZG93bi5jb3B5KGN0LnVwKS5tdWx0aXBseVNjYWxhcigtMSksIGN0Lndlc3QuY29weShjdC5lYXN0KS5tdWx0aXBseVNjYWxhcigtMSksIGN0LnNvdXRoLmNvcHkoY3Qubm9ydGgpLm11bHRpcGx5U2NhbGFyKC0xKSwgS3QgPSBjdFtzXSwgdGUgPSBjdFt0XSwgZWUgPSBjdFtlXTsKICAgIH0KICAgIGNvbnN0IGggPSBvLmVsZW1lbnRzOwogICAgcmV0dXJuIGhbMF0gPSBLdC54LCBoWzFdID0gS3QueSwgaFsyXSA9IEt0LnosIGhbM10gPSAwLCBoWzRdID0gdGUueCwgaFs1XSA9IHRlLnksIGhbNl0gPSB0ZS56LCBoWzddID0gMCwgaFs4XSA9IGVlLngsIGhbOV0gPSBlZS55LCBoWzEwXSA9IGVlLnosIGhbMTFdID0gMCwgaFsxMl0gPSByLngsIGhbMTNdID0gci55LCBoWzE0XSA9IHIueiwgaFsxNV0gPSAxLCBvOwogIH0sIGduW2ldID0gbiksIG47Cn07Cm90LmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lID0gb3QubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvcigKICAiZWFzdCIsCiAgIm5vcnRoIgopOwpvdC5oZWFkaW5nUGl0Y2hSb2xsVG9GaXhlZEZyYW1lID0gZnVuY3Rpb24ocywgdCwgZSwgbiwgaSkgewogIG4gPSBuIHx8IG90LmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lOwogIGNvbnN0IHIgPSBzZS5mcm9tSGVhZGluZ1BpdGNoUm9sbCgKICAgIHQsCiAgICBIcwogICksIGEgPSB4ZS5mcm9tVHJhbnNsYXRpb25RdWF0ZXJuaW9uUm90YXRpb25TY2FsZSgKICAgIFMuWkVSTywKICAgIHIsCiAgICBKcywKICAgIEtzCiAgKTsKICByZXR1cm4gaSA9IG4ocywgZSwgaSksIGkubXVsdGlwbHkoYSk7Cn07Cm90Lm5vcnRoRWFzdERvd25Ub0ZpeGVkRnJhbWUgPSBvdC5sb2NhbEZyYW1lVG9GaXhlZEZyYW1lR2VuZXJhdG9yKAogICJub3J0aCIsCiAgImVhc3QiCik7Cm90Lm5vcnRoVXBFYXN0VG9GaXhlZEZyYW1lID0gb3QubG9jYWxGcmFtZVRvRml4ZWRGcmFtZUdlbmVyYXRvcigKICAibm9ydGgiLAogICJ1cCIKKTsKb3Qubm9ydGhXZXN0VXBUb0ZpeGVkRnJhbWUgPSBvdC5sb2NhbEZyYW1lVG9GaXhlZEZyYW1lR2VuZXJhdG9yKAogICJub3J0aCIsCiAgIndlc3QiCik7CmZ1bmN0aW9uIF9lKHMsIHQpIHsKICB0aGlzLnN0YXJ0ID0gRyhzLCAwKSwgdGhpcy5zdG9wID0gRyh0LCAwKTsKfQpjbGFzcyBCIHsKICBzdGF0aWMgZnJvbVF1YXRlcm5pb24odCwgZSkgewogICAgY29uc3QgbiA9IHQueCAqIHQueCwgaSA9IHQueCAqIHQueSwgciA9IHQueCAqIHQueiwgYSA9IHQueCAqIHQudywgbyA9IHQueSAqIHQueSwgaCA9IHQueSAqIHQueiwgYyA9IHQueSAqIHQudywgbCA9IHQueiAqIHQueiwgdSA9IHQueiAqIHQudywgZCA9IHQudyAqIHQudywgeSA9IG4gLSBvIC0gbCArIGQsIGYgPSAyICogKGkgLSB1KSwgZyA9IDIgKiAociArIGMpLCBfID0gMiAqIChpICsgdSksIHcgPSAtbiArIG8gLSBsICsgZCwgeCA9IDIgKiAoaCAtIGEpLCBtID0gMiAqIChyIC0gYyksIE0gPSAyICogKGggKyBhKSwgeiA9IC1uIC0gbyArIGwgKyBkOwogICAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgSigpKSwgZS5zZXQoeSwgZiwgZywgXywgdywgeCwgbSwgTSwgeiksIGU7CiAgfQogIHN0YXRpYyBnZXRDb2x1bW4odCwgZSwgbikgewogICAgY29uc3QgaSA9IHQuZWxlbWVudHMsIHIgPSBlICogMywgYSA9IGlbcl0sIG8gPSBpW3IgKyAxXSwgaCA9IGlbciArIDJdOwogICAgcmV0dXJuIG4ueCA9IGEsIG4ueSA9IG8sIG4ueiA9IGgsIG47CiAgfQogIHN0YXRpYyBtdWx0aXBseUJ5VmVjdG9yKHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IHAoKSksIG4uY29weShlKSwgbi5hcHBseU1hdHJpeDModCksIG47CiAgfQogIHN0YXRpYyBtdWx0aXBseUJ5U2NhbGUodCwgZSwgbikgewogICAgbiB8fCAobiA9IG5ldyBKKCkpOwogICAgY29uc3QgaSA9IG4uZWxlbWVudHMsIHIgPSB0LmVsZW1lbnRzOwogICAgcmV0dXJuIGlbMF0gPSByWzBdICogZS54LCBpWzFdID0gclsxXSAqIGUueCwgaVsyXSA9IHJbMl0gKiBlLngsIGlbM10gPSByWzNdICogZS55LCBpWzRdID0gcls0XSAqIGUueSwgaVs1XSA9IHJbNV0gKiBlLnksIGlbNl0gPSByWzZdICogZS56LCBpWzddID0gcls3XSAqIGUueiwgaVs4XSA9IHJbOF0gKiBlLnosIG47CiAgfQogIHN0YXRpYyB0cmFuc3Bvc2UodCwgZSkgewogICAgcmV0dXJuIGUgfHwgKGUgPSBuZXcgSigpKSwgZS5jb3B5KHQpLnRyYW5zcG9zZSgpLCBlOwogIH0KICBzdGF0aWMgZnJvbVNjYWxlKHQsIGUpIHsKICAgIGUgfHwgKGUgPSBuZXcgSigpKTsKICAgIGNvbnN0IG4gPSBlLmVsZW1lbnRzOwogICAgcmV0dXJuIG5bMF0gPSB0LngsIG5bMV0gPSAwLCBuWzJdID0gMCwgblszXSA9IDAsIG5bNF0gPSB0LnksIG5bNV0gPSAwLCBuWzZdID0gMCwgbls3XSA9IDAsIG5bOF0gPSB0LnosIGU7CiAgfQogIHN0YXRpYyBtdWx0aXBseSh0LCBlLCBuKSB7CiAgICBuIHx8IChuID0gbmV3IEooKSk7CiAgICBjb25zdCBpID0gdC5lbGVtZW50cywgciA9IGUuZWxlbWVudHMsIGEgPSBuLmVsZW1lbnRzLCBvID0gaVswXSwgaCA9IGlbM10sIGMgPSBpWzZdLCBsID0gaVsxXSwgdSA9IGlbNF0sIGQgPSBpWzddLCB5ID0gaVsyXSwgZiA9IGlbNV0sIGcgPSBpWzhdLCBfID0gclswXSwgdyA9IHJbM10sIHggPSByWzZdLCBtID0gclsxXSwgTSA9IHJbNF0sIHogPSByWzddLCBQID0gclsyXSwgVCA9IHJbNV0sIGIgPSByWzhdOwogICAgcmV0dXJuIGFbMF0gPSBvICogXyArIGggKiBtICsgYyAqIFAsIGFbM10gPSBvICogdyArIGggKiBNICsgYyAqIFQsIGFbNl0gPSBvICogeCArIGggKiB6ICsgYyAqIGIsIGFbMV0gPSBsICogXyArIHUgKiBtICsgZCAqIFAsIGFbNF0gPSBsICogdyArIHUgKiBNICsgZCAqIFQsIGFbN10gPSBsICogeCArIHUgKiB6ICsgZCAqIGIsIGFbMl0gPSB5ICogXyArIGYgKiBtICsgZyAqIFAsIGFbNV0gPSB5ICogdyArIGYgKiBNICsgZyAqIFQsIGFbOF0gPSB5ICogeCArIGYgKiB6ICsgZyAqIGIsIG47CiAgfQogIHN0YXRpYyBjbG9uZSh0LCBlKSB7CiAgICBpZiAoISFBKHQpKQogICAgICByZXR1cm4gQShlKSA/IChlLmNsb25lKHQpLCBlKSA6IG5ldyBKKAogICAgICAgIHRbMF0sCiAgICAgICAgdFszXSwKICAgICAgICB0WzZdLAogICAgICAgIHRbMV0sCiAgICAgICAgdFs0XSwKICAgICAgICB0WzddLAogICAgICAgIHRbMl0sCiAgICAgICAgdFs1XSwKICAgICAgICB0WzhdCiAgICAgICk7CiAgfQogIHN0YXRpYyBzZXRDb2x1bW4odCwgZSwgbiwgaSkgewogICAgaSA9IEIuY2xvbmUodCwgaSk7CiAgICBjb25zdCByID0gaS5lbGVtZW50cywgYSA9IGUgKiAzOwogICAgcmV0dXJuIHJbYV0gPSBuLngsIHJbYSArIDFdID0gbi55LCByW2EgKyAyXSA9IG4ueiwgaTsKICB9Cn0KQi5aRVJPID0gSi5aRVJPID0gT2JqZWN0LmZyZWV6ZSgKICBuZXcgSigwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKQopOwpCLkNPTFVNTjBST1cwID0gMDsKQi5DT0xVTU4wUk9XMSA9IDE7CkIuQ09MVU1OMFJPVzIgPSAyOwpCLkNPTFVNTjFST1cwID0gMzsKQi5DT0xVTU4xUk9XMSA9IDQ7CkIuQ09MVU1OMVJPVzIgPSA1OwpCLkNPTFVNTjJST1cwID0gNjsKQi5DT0xVTU4yUk9XMSA9IDc7CkIuQ09MVU1OMlJPVzIgPSA4Owp2YXIgQ3QgPSB7fTsKQ3QuY29tcHV0ZURpc2NyaW1pbmFudCA9IGZ1bmN0aW9uKHMsIHQsIGUpIHsKICBpZiAodHlwZW9mIHMgIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiYSBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICBpZiAodHlwZW9mIHQgIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiYiBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICBpZiAodHlwZW9mIGUgIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiYyBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICB2YXIgbiA9IHQgKiB0IC0gNCAqIHMgKiBlOwogIHJldHVybiBuOwp9OwpmdW5jdGlvbiBLbihzLCB0LCBlKSB7CiAgdmFyIG4gPSBzICsgdDsKICByZXR1cm4gRS5zaWduKHMpICE9PSBFLnNpZ24odCkgJiYgTWF0aC5hYnMobiAvIE1hdGgubWF4KE1hdGguYWJzKHMpLCBNYXRoLmFicyh0KSkpIDwgZSA/IDAgOiBuOwp9CkN0LmNvbXB1dGVSZWFsUm9vdHMgPSBmdW5jdGlvbihzLCB0LCBlKSB7CiAgaWYgKHR5cGVvZiBzICE9ICJudW1iZXIiKQogICAgdGhyb3cgbmV3IGooImEgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgaWYgKHR5cGVvZiB0ICE9ICJudW1iZXIiKQogICAgdGhyb3cgbmV3IGooImIgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgaWYgKHR5cGVvZiBlICE9ICJudW1iZXIiKQogICAgdGhyb3cgbmV3IGooImMgaXMgYSByZXF1aXJlZCBudW1iZXIuIik7CiAgdmFyIG47CiAgaWYgKHMgPT09IDApCiAgICByZXR1cm4gdCA9PT0gMCA/IFtdIDogWy1lIC8gdF07CiAgaWYgKHQgPT09IDApIHsKICAgIGlmIChlID09PSAwKQogICAgICByZXR1cm4gWzAsIDBdOwogICAgdmFyIGkgPSBNYXRoLmFicyhlKSwgciA9IE1hdGguYWJzKHMpOwogICAgaWYgKGkgPCByICYmIGkgLyByIDwgRS5FUFNJTE9OMTQpCiAgICAgIHJldHVybiBbMCwgMF07CiAgICBpZiAoaSA+IHIgJiYgciAvIGkgPCBFLkVQU0lMT04xNCkKICAgICAgcmV0dXJuIFtdOwogICAgaWYgKG4gPSAtZSAvIHMsIG4gPCAwKQogICAgICByZXR1cm4gW107CiAgICB2YXIgYSA9IE1hdGguc3FydChuKTsKICAgIHJldHVybiBbLWEsIGFdOwogIH0gZWxzZSBpZiAoZSA9PT0gMCkKICAgIHJldHVybiBuID0gLXQgLyBzLCBuIDwgMCA/IFtuLCAwXSA6IFswLCBuXTsKICB2YXIgbyA9IHQgKiB0LCBoID0gNCAqIHMgKiBlLCBjID0gS24obywgLWgsIEUuRVBTSUxPTjE0KTsKICBpZiAoYyA8IDApCiAgICByZXR1cm4gW107CiAgdmFyIGwgPSAtMC41ICogS24oCiAgICB0LAogICAgRS5zaWduKHQpICogTWF0aC5zcXJ0KGMpLAogICAgRS5FUFNJTE9OMTQKICApOwogIHJldHVybiB0ID4gMCA/IFtsIC8gcywgZSAvIGxdIDogW2UgLyBsLCBsIC8gc107Cn07CnZhciBDZSA9IHt9OwpDZS5jb21wdXRlRGlzY3JpbWluYW50ID0gZnVuY3Rpb24ocywgdCwgZSwgbikgewogIGlmICh0eXBlb2YgcyAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJhIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgdCAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJiIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgZSAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJjIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgbiAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJkIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIHZhciBpID0gcyAqIHMsIHIgPSB0ICogdCwgYSA9IGUgKiBlLCBvID0gbiAqIG4sIGggPSAxOCAqIHMgKiB0ICogZSAqIG4gKyByICogYSAtIDI3ICogaSAqIG8gLSA0ICogKHMgKiBhICogZSArIHIgKiB0ICogbik7CiAgcmV0dXJuIGg7Cn07CmZ1bmN0aW9uIE1uKHMsIHQsIGUsIG4pIHsKICB2YXIgaSA9IHMsIHIgPSB0IC8gMywgYSA9IGUgLyAzLCBvID0gbiwgaCA9IGkgKiBhLCBjID0gciAqIG8sIGwgPSByICogciwgdSA9IGEgKiBhLCBkID0gaSAqIGEgLSBsLCB5ID0gaSAqIG8gLSByICogYSwgZiA9IHIgKiBvIC0gdSwgZyA9IDQgKiBkICogZiAtIHkgKiB5LCBfLCB3OwogIGlmIChnIDwgMCkgewogICAgdmFyIHgsIG0sIE07CiAgICBsICogYyA+PSBoICogdSA/ICh4ID0gaSwgbSA9IGQsIE0gPSAtMiAqIHIgKiBkICsgaSAqIHkpIDogKHggPSBvLCBtID0gZiwgTSA9IC1vICogeSArIDIgKiBhICogZik7CiAgICB2YXIgeiA9IE0gPCAwID8gLTEgOiAxLCBQID0gLXogKiBNYXRoLmFicyh4KSAqIE1hdGguc3FydCgtZyk7CiAgICB3ID0gLU0gKyBQOwogICAgdmFyIFQgPSB3IC8gMiwgYiA9IFQgPCAwID8gLU1hdGgucG93KC1ULCAxIC8gMykgOiBNYXRoLnBvdyhULCAxIC8gMyksIE4gPSB3ID09PSBQID8gLWIgOiAtbSAvIGI7CiAgICByZXR1cm4gXyA9IG0gPD0gMCA/IGIgKyBOIDogLU0gLyAoYiAqIGIgKyBOICogTiArIG0pLCBsICogYyA+PSBoICogdSA/IFsoXyAtIHIpIC8gaV0gOiBbLW8gLyAoXyArIGEpXTsKICB9CiAgdmFyIEkgPSBkLCBDID0gLTIgKiByICogZCArIGkgKiB5LCBPID0gZiwgUiA9IC1vICogeSArIDIgKiBhICogZiwgRCA9IE1hdGguc3FydChnKSwgVSA9IE1hdGguc3FydCgzKSAvIDIsIEwgPSBNYXRoLmFicyhNYXRoLmF0YW4yKGkgKiBELCAtQykgLyAzKTsKICBfID0gMiAqIE1hdGguc3FydCgtSSk7CiAgdmFyIHEgPSBNYXRoLmNvcyhMKTsKICB3ID0gXyAqIHE7CiAgdmFyIGsgPSBfICogKC1xIC8gMiAtIFUgKiBNYXRoLnNpbihMKSksIFcgPSB3ICsgayA+IDIgKiByID8gdyAtIHIgOiBrIC0gciwgWCA9IGksIFogPSBXIC8gWDsKICBMID0gTWF0aC5hYnMoTWF0aC5hdGFuMihvICogRCwgLVIpIC8gMyksIF8gPSAyICogTWF0aC5zcXJ0KC1PKSwgcSA9IE1hdGguY29zKEwpLCB3ID0gXyAqIHEsIGsgPSBfICogKC1xIC8gMiAtIFUgKiBNYXRoLnNpbihMKSk7CiAgdmFyIGh0ID0gLW8sIHR0ID0gdyArIGsgPCAyICogYSA/IHcgKyBhIDogayArIGEsIGV0ID0gaHQgLyB0dCwgRWUgPSBYICogdHQsIEFlID0gLVcgKiB0dCAtIFggKiBodCwgJGkgPSBXICogaHQsIEx0ID0gKGEgKiBBZSAtIHIgKiAkaSkgLyAoLXIgKiBBZSArIGEgKiBFZSk7CiAgcmV0dXJuIFogPD0gTHQgPyBaIDw9IGV0ID8gTHQgPD0gZXQgPyBbWiwgTHQsIGV0XSA6IFtaLCBldCwgTHRdIDogW2V0LCBaLCBMdF0gOiBaIDw9IGV0ID8gW0x0LCBaLCBldF0gOiBMdCA8PSBldCA/IFtMdCwgZXQsIFpdIDogW2V0LCBMdCwgWl07Cn0KQ2UuY29tcHV0ZVJlYWxSb290cyA9IGZ1bmN0aW9uKHMsIHQsIGUsIG4pIHsKICBpZiAodHlwZW9mIHMgIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiYSBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICBpZiAodHlwZW9mIHQgIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiYiBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICBpZiAodHlwZW9mIGUgIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiYyBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICBpZiAodHlwZW9mIG4gIT0gIm51bWJlciIpCiAgICB0aHJvdyBuZXcgaigiZCBpcyBhIHJlcXVpcmVkIG51bWJlci4iKTsKICB2YXIgaSwgcjsKICBpZiAocyA9PT0gMCkKICAgIHJldHVybiBDdC5jb21wdXRlUmVhbFJvb3RzKHQsIGUsIG4pOwogIGlmICh0ID09PSAwKSB7CiAgICBpZiAoZSA9PT0gMCkgewogICAgICBpZiAobiA9PT0gMCkKICAgICAgICByZXR1cm4gWzAsIDAsIDBdOwogICAgICByID0gLW4gLyBzOwogICAgICB2YXIgYSA9IHIgPCAwID8gLU1hdGgucG93KC1yLCAxIC8gMykgOiBNYXRoLnBvdyhyLCAxIC8gMyk7CiAgICAgIHJldHVybiBbYSwgYSwgYV07CiAgICB9IGVsc2UgaWYgKG4gPT09IDApCiAgICAgIHJldHVybiBpID0gQ3QuY29tcHV0ZVJlYWxSb290cyhzLCAwLCBlKSwgaS5MZW5ndGggPT09IDAgPyBbMF0gOiBbaVswXSwgMCwgaVsxXV07CiAgICByZXR1cm4gTW4ocywgMCwgZSwgbik7CiAgfSBlbHNlIHsKICAgIGlmIChlID09PSAwKQogICAgICByZXR1cm4gbiA9PT0gMCA/IChyID0gLXQgLyBzLCByIDwgMCA/IFtyLCAwLCAwXSA6IFswLCAwLCByXSkgOiBNbihzLCB0LCAwLCBuKTsKICAgIGlmIChuID09PSAwKQogICAgICByZXR1cm4gaSA9IEN0LmNvbXB1dGVSZWFsUm9vdHMocywgdCwgZSksIGkubGVuZ3RoID09PSAwID8gWzBdIDogaVsxXSA8PSAwID8gW2lbMF0sIGlbMV0sIDBdIDogaVswXSA+PSAwID8gWzAsIGlbMF0sIGlbMV1dIDogW2lbMF0sIDAsIGlbMV1dOwogIH0KICByZXR1cm4gTW4ocywgdCwgZSwgbik7Cn07CnZhciBFbiA9IHt9OwpFbi5jb21wdXRlRGlzY3JpbWluYW50ID0gZnVuY3Rpb24ocywgdCwgZSwgbiwgaSkgewogIGlmICh0eXBlb2YgcyAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJhIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgdCAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJiIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgZSAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJjIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgbiAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJkIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgaSAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJlIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIHZhciByID0gcyAqIHMsIGEgPSByICogcywgbyA9IHQgKiB0LCBoID0gbyAqIHQsIGMgPSBlICogZSwgbCA9IGMgKiBlLCB1ID0gbiAqIG4sIGQgPSB1ICogbiwgeSA9IGkgKiBpLCBmID0geSAqIGksIGcgPSBvICogYyAqIHUgLSA0ICogaCAqIGQgLSA0ICogcyAqIGwgKiB1ICsgMTggKiBzICogdCAqIGUgKiBkIC0gMjcgKiByICogdSAqIHUgKyAyNTYgKiBhICogZiArIGkgKiAoMTggKiBoICogZSAqIG4gLSA0ICogbyAqIGwgKyAxNiAqIHMgKiBjICogYyAtIDgwICogcyAqIHQgKiBjICogbiAtIDYgKiBzICogbyAqIHUgKyAxNDQgKiByICogZSAqIHUpICsgeSAqICgxNDQgKiBzICogbyAqIGUgLSAyNyAqIG8gKiBvIC0gMTI4ICogciAqIGMgLSAxOTIgKiByICogdCAqIG4pOwogIHJldHVybiBnOwp9OwpmdW5jdGlvbiBUdChzLCB0LCBlLCBuKSB7CiAgdmFyIGkgPSBzICogcywgciA9IHQgLSAzICogaSAvIDgsIGEgPSBlIC0gdCAqIHMgLyAyICsgaSAqIHMgLyA4LCBvID0gbiAtIGUgKiBzIC8gNCArIHQgKiBpIC8gMTYgLSAzICogaSAqIGkgLyAyNTYsIGggPSBDZS5jb21wdXRlUmVhbFJvb3RzKAogICAgMSwKICAgIDIgKiByLAogICAgciAqIHIgLSA0ICogbywKICAgIC1hICogYQogICk7CiAgaWYgKGgubGVuZ3RoID4gMCkgewogICAgdmFyIGMgPSAtcyAvIDQsIGwgPSBoW2gubGVuZ3RoIC0gMV07CiAgICBpZiAoTWF0aC5hYnMobCkgPCBFLkVQU0lMT04xNCkgewogICAgICB2YXIgdSA9IEN0LmNvbXB1dGVSZWFsUm9vdHMoMSwgciwgbyk7CiAgICAgIGlmICh1Lmxlbmd0aCA9PT0gMikgewogICAgICAgIHZhciBkID0gdVswXSwgeSA9IHVbMV0sIGY7CiAgICAgICAgaWYgKGQgPj0gMCAmJiB5ID49IDApIHsKICAgICAgICAgIHZhciBnID0gTWF0aC5zcXJ0KGQpLCBfID0gTWF0aC5zcXJ0KHkpOwogICAgICAgICAgcmV0dXJuIFtjIC0gXywgYyAtIGcsIGMgKyBnLCBjICsgX107CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChkID49IDAgJiYgeSA8IDApCiAgICAgICAgICAgIHJldHVybiBmID0gTWF0aC5zcXJ0KGQpLCBbYyAtIGYsIGMgKyBmXTsKICAgICAgICAgIGlmIChkIDwgMCAmJiB5ID49IDApCiAgICAgICAgICAgIHJldHVybiBmID0gTWF0aC5zcXJ0KHkpLCBbYyAtIGYsIGMgKyBmXTsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIFtdOwogICAgfSBlbHNlIGlmIChsID4gMCkgewogICAgICB2YXIgdyA9IE1hdGguc3FydChsKSwgeCA9IChyICsgbCAtIGEgLyB3KSAvIDIsIG0gPSAociArIGwgKyBhIC8gdykgLyAyLCBNID0gQ3QuY29tcHV0ZVJlYWxSb290cygxLCB3LCB4KSwgeiA9IEN0LmNvbXB1dGVSZWFsUm9vdHMoMSwgLXcsIG0pOwogICAgICByZXR1cm4gTS5sZW5ndGggIT09IDAgPyAoTVswXSArPSBjLCBNWzFdICs9IGMsIHoubGVuZ3RoICE9PSAwID8gKHpbMF0gKz0gYywgelsxXSArPSBjLCBNWzFdIDw9IHpbMF0gPyBbTVswXSwgTVsxXSwgelswXSwgelsxXV0gOiB6WzFdIDw9IE1bMF0gPyBbelswXSwgelsxXSwgTVswXSwgTVsxXV0gOiBNWzBdID49IHpbMF0gJiYgTVsxXSA8PSB6WzFdID8gW3pbMF0sIE1bMF0sIE1bMV0sIHpbMV1dIDogelswXSA+PSBNWzBdICYmIHpbMV0gPD0gTVsxXSA/IFtNWzBdLCB6WzBdLCB6WzFdLCBNWzFdXSA6IE1bMF0gPiB6WzBdICYmIE1bMF0gPCB6WzFdID8gW3pbMF0sIE1bMF0sIHpbMV0sIE1bMV1dIDogW01bMF0sIHpbMF0sIE1bMV0sIHpbMV1dKSA6IE0pIDogei5sZW5ndGggIT09IDAgPyAoelswXSArPSBjLCB6WzFdICs9IGMsIHopIDogW107CiAgICB9CiAgfQogIHJldHVybiBbXTsKfQpmdW5jdGlvbiBNZShzLCB0LCBlLCBuKSB7CiAgdmFyIGkgPSBlICogZSwgciA9IHQgKiB0LCBhID0gcyAqIHMsIG8gPSAtMiAqIHQsIGggPSBlICogcyArIHIgLSA0ICogbiwgYyA9IGEgKiBuIC0gZSAqIHQgKiBzICsgaSwgbCA9IENlLmNvbXB1dGVSZWFsUm9vdHMoMSwgbywgaCwgYyk7CiAgaWYgKGwubGVuZ3RoID4gMCkgewogICAgdmFyIHUgPSBsWzBdLCBkID0gdCAtIHUsIHkgPSBkICogZCwgZiA9IHMgLyAyLCBnID0gZCAvIDIsIF8gPSB5IC0gNCAqIG4sIHcgPSB5ICsgNCAqIE1hdGguYWJzKG4pLCB4ID0gYSAtIDQgKiB1LCBtID0gYSArIDQgKiBNYXRoLmFicyh1KSwgTSwgejsKICAgIGlmICh1IDwgMCB8fCBfICogbSA8IHggKiB3KSB7CiAgICAgIHZhciBQID0gTWF0aC5zcXJ0KHgpOwogICAgICBNID0gUCAvIDIsIHogPSBQID09PSAwID8gMCA6IChzICogZyAtIGUpIC8gUDsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBUID0gTWF0aC5zcXJ0KF8pOwogICAgICBNID0gVCA9PT0gMCA/IDAgOiAocyAqIGcgLSBlKSAvIFQsIHogPSBUIC8gMjsKICAgIH0KICAgIHZhciBiLCBOOwogICAgZiA9PT0gMCAmJiBNID09PSAwID8gKGIgPSAwLCBOID0gMCkgOiBFLnNpZ24oZikgPT09IEUuc2lnbihNKSA/IChiID0gZiArIE0sIE4gPSB1IC8gYikgOiAoTiA9IGYgLSBNLCBiID0gdSAvIE4pOwogICAgdmFyIEksIEM7CiAgICBnID09PSAwICYmIHogPT09IDAgPyAoSSA9IDAsIEMgPSAwKSA6IEUuc2lnbihnKSA9PT0gRS5zaWduKHopID8gKEkgPSBnICsgeiwgQyA9IG4gLyBJKSA6IChDID0gZyAtIHosIEkgPSBuIC8gQyk7CiAgICB2YXIgTyA9IEN0LmNvbXB1dGVSZWFsUm9vdHMoMSwgYiwgSSksIFIgPSBDdC5jb21wdXRlUmVhbFJvb3RzKDEsIE4sIEMpOwogICAgaWYgKE8ubGVuZ3RoICE9PSAwKQogICAgICByZXR1cm4gUi5sZW5ndGggIT09IDAgPyBPWzFdIDw9IFJbMF0gPyBbT1swXSwgT1sxXSwgUlswXSwgUlsxXV0gOiBSWzFdIDw9IE9bMF0gPyBbUlswXSwgUlsxXSwgT1swXSwgT1sxXV0gOiBPWzBdID49IFJbMF0gJiYgT1sxXSA8PSBSWzFdID8gW1JbMF0sIE9bMF0sIE9bMV0sIFJbMV1dIDogUlswXSA+PSBPWzBdICYmIFJbMV0gPD0gT1sxXSA/IFtPWzBdLCBSWzBdLCBSWzFdLCBPWzFdXSA6IE9bMF0gPiBSWzBdICYmIE9bMF0gPCBSWzFdID8gW1JbMF0sIE9bMF0sIFJbMV0sIE9bMV1dIDogW09bMF0sIFJbMF0sIE9bMV0sIFJbMV1dIDogTzsKICAgIGlmIChSLmxlbmd0aCAhPT0gMCkKICAgICAgcmV0dXJuIFI7CiAgfQogIHJldHVybiBbXTsKfQpFbi5jb21wdXRlUmVhbFJvb3RzID0gZnVuY3Rpb24ocywgdCwgZSwgbiwgaSkgewogIGlmICh0eXBlb2YgcyAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJhIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgdCAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJiIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgZSAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJjIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgbiAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJkIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmICh0eXBlb2YgaSAhPSAibnVtYmVyIikKICAgIHRocm93IG5ldyBqKCJlIGlzIGEgcmVxdWlyZWQgbnVtYmVyLiIpOwogIGlmIChNYXRoLmFicyhzKSA8IEUuRVBTSUxPTjE1KQogICAgcmV0dXJuIENlLmNvbXB1dGVSZWFsUm9vdHModCwgZSwgbiwgaSk7CiAgdmFyIHIgPSB0IC8gcywgYSA9IGUgLyBzLCBvID0gbiAvIHMsIGggPSBpIC8gcywgYyA9IHIgPCAwID8gMSA6IDA7CiAgc3dpdGNoIChjICs9IGEgPCAwID8gYyArIDEgOiBjLCBjICs9IG8gPCAwID8gYyArIDEgOiBjLCBjICs9IGggPCAwID8gYyArIDEgOiBjLCBjKSB7CiAgICBjYXNlIDA6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgMToKICAgICAgcmV0dXJuIE1lKHIsIGEsIG8sIGgpOwogICAgY2FzZSAyOgogICAgICByZXR1cm4gTWUociwgYSwgbywgaCk7CiAgICBjYXNlIDM6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgNDoKICAgICAgcmV0dXJuIFR0KHIsIGEsIG8sIGgpOwogICAgY2FzZSA1OgogICAgICByZXR1cm4gTWUociwgYSwgbywgaCk7CiAgICBjYXNlIDY6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgNzoKICAgICAgcmV0dXJuIFR0KHIsIGEsIG8sIGgpOwogICAgY2FzZSA4OgogICAgICByZXR1cm4gTWUociwgYSwgbywgaCk7CiAgICBjYXNlIDk6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgMTA6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgMTE6CiAgICAgIHJldHVybiBNZShyLCBhLCBvLCBoKTsKICAgIGNhc2UgMTI6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgMTM6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgMTQ6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGNhc2UgMTU6CiAgICAgIHJldHVybiBUdChyLCBhLCBvLCBoKTsKICAgIGRlZmF1bHQ6CiAgICAgIHJldHVybjsKICB9Cn07CnZhciBWID0ge307ClYucmF5UGxhbmUgPSBmdW5jdGlvbihzLCB0LCBlKSB7CiAgaWYgKCFBKHMpKQogICAgdGhyb3cgbmV3IGooInJheSBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEodCkpCiAgICB0aHJvdyBuZXcgaigicGxhbmUgaXMgcmVxdWlyZWQuIik7CiAgQShlKSB8fCAoZSA9IG5ldyBwKCkpOwogIHZhciBuID0gcy5vcmlnaW4sIGkgPSBzLmRpcmVjdGlvbiwgciA9IHQubm9ybWFsLCBhID0gUy5kb3QociwgaSk7CiAgaWYgKCEoTWF0aC5hYnMoYSkgPCBFLkVQU0lMT04xNSkpIHsKICAgIHZhciBvID0gKC10LmNvbnN0YW50IC0gUy5kb3QociwgbikpIC8gYTsKICAgIGlmICghKG8gPCAwKSkKICAgICAgcmV0dXJuIGUgPSBTLm11bHRpcGx5QnlTY2FsYXIoaSwgbywgZSksIFMuYWRkKG4sIGUsIGUpOwogIH0KfTsKdmFyIGlyID0gbmV3IHAoKSwgc3IgPSBuZXcgcCgpLCBEaSA9IG5ldyBwKCksIHRpID0gbmV3IHAoKSwgZWkgPSBuZXcgcCgpOwpWLnJheVRyaWFuZ2xlUGFyYW1ldHJpYyA9IGZ1bmN0aW9uKHMsIHQsIGUsIG4sIGkpIHsKICBpZiAoIUEocykpCiAgICB0aHJvdyBuZXcgaigicmF5IGlzIHJlcXVpcmVkLiIpOwogIGlmICghQSh0KSkKICAgIHRocm93IG5ldyBqKCJwMCBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEoZSkpCiAgICB0aHJvdyBuZXcgaigicDEgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFBKG4pKQogICAgdGhyb3cgbmV3IGooInAyIGlzIHJlcXVpcmVkLiIpOwogIGkgPSBHKGksICExKTsKICB2YXIgciA9IHMub3JpZ2luLCBhID0gcy5kaXJlY3Rpb24sIG8gPSBTLnN1YnRyYWN0KGUsIHQsIGlyKSwgaCA9IFMuc3VidHJhY3QobiwgdCwgc3IpLCBjID0gUy5jcm9zcyhhLCBoLCBEaSksIGwgPSBTLmRvdChvLCBjKSwgdSwgZCwgeSwgZiwgZzsKICBpZiAoaSkgewogICAgaWYgKGwgPCBFLkVQU0lMT042IHx8ICh1ID0gUy5zdWJ0cmFjdChyLCB0LCB0aSksIHkgPSBTLmRvdCh1LCBjKSwgeSA8IDAgfHwgeSA+IGwpIHx8IChkID0gUy5jcm9zcyh1LCBvLCBlaSksIGYgPSBTLmRvdChhLCBkKSwgZiA8IDAgfHwgeSArIGYgPiBsKSkKICAgICAgcmV0dXJuOwogICAgZyA9IFMuZG90KGgsIGQpIC8gbDsKICB9IGVsc2UgewogICAgaWYgKE1hdGguYWJzKGwpIDwgRS5FUFNJTE9ONikKICAgICAgcmV0dXJuOwogICAgdmFyIF8gPSAxIC8gbDsKICAgIGlmICh1ID0gUy5zdWJ0cmFjdChyLCB0LCB0aSksIHkgPSBTLmRvdCh1LCBjKSAqIF8sIHkgPCAwIHx8IHkgPiAxIHx8IChkID0gUy5jcm9zcyh1LCBvLCBlaSksIGYgPSBTLmRvdChhLCBkKSAqIF8sIGYgPCAwIHx8IHkgKyBmID4gMSkpCiAgICAgIHJldHVybjsKICAgIGcgPSBTLmRvdChoLCBkKSAqIF87CiAgfQogIHJldHVybiBnOwp9OwpWLnJheVRyaWFuZ2xlID0gZnVuY3Rpb24ocywgdCwgZSwgbiwgaSwgcikgewogIHZhciBhID0gVi5yYXlUcmlhbmdsZVBhcmFtZXRyaWMoCiAgICBzLAogICAgdCwKICAgIGUsCiAgICBuLAogICAgaQogICk7CiAgaWYgKCEoIUEoYSkgfHwgYSA8IDApKQogICAgcmV0dXJuIEEocikgfHwgKHIgPSBuZXcgcCgpKSwgUy5tdWx0aXBseUJ5U2NhbGFyKHMuZGlyZWN0aW9uLCBhLCByKSwgUy5hZGQocy5vcmlnaW4sIHIsIHIpOwp9Owp2YXIgcnIgPSBuZXcgZW4oKTsKVi5saW5lU2VnbWVudFRyaWFuZ2xlID0gZnVuY3Rpb24ocywgdCwgZSwgbiwgaSwgciwgYSkgewogIGlmICghQShzKSkKICAgIHRocm93IG5ldyBqKCJ2MCBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEodCkpCiAgICB0aHJvdyBuZXcgaigidjEgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFBKGUpKQogICAgdGhyb3cgbmV3IGooInAwIGlzIHJlcXVpcmVkLiIpOwogIGlmICghQShuKSkKICAgIHRocm93IG5ldyBqKCJwMSBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEoaSkpCiAgICB0aHJvdyBuZXcgaigicDIgaXMgcmVxdWlyZWQuIik7CiAgdmFyIG8gPSBycjsKICBTLmNsb25lKHMsIG8ub3JpZ2luKSwgUy5zdWJ0cmFjdCh0LCBzLCBvLmRpcmVjdGlvbiksIFMubm9ybWFsaXplKG8uZGlyZWN0aW9uLCBvLmRpcmVjdGlvbik7CiAgdmFyIGggPSBWLnJheVRyaWFuZ2xlUGFyYW1ldHJpYygKICAgIG8sCiAgICBlLAogICAgbiwKICAgIGksCiAgICByCiAgKTsKICBpZiAoISghQShoKSB8fCBoIDwgMCB8fCBoID4gUy5kaXN0YW5jZShzLCB0KSkpCiAgICByZXR1cm4gQShhKSB8fCAoYSA9IG5ldyBwKCkpLCBTLm11bHRpcGx5QnlTY2FsYXIoby5kaXJlY3Rpb24sIGgsIGEpLCBTLmFkZChvLm9yaWdpbiwgYSwgYSk7Cn07CmZ1bmN0aW9uIGFyKHMsIHQsIGUsIG4pIHsKICB2YXIgaSA9IHQgKiB0IC0gNCAqIHMgKiBlOwogIGlmICghKGkgPCAwKSkgewogICAgaWYgKGkgPiAwKSB7CiAgICAgIHZhciByID0gMSAvICgyICogcyksIGEgPSBNYXRoLnNxcnQoaSksIG8gPSAoLXQgKyBhKSAqIHIsIGggPSAoLXQgLSBhKSAqIHI7CiAgICAgIHJldHVybiBvIDwgaCA/IChuLnJvb3QwID0gbywgbi5yb290MSA9IGgpIDogKG4ucm9vdDAgPSBoLCBuLnJvb3QxID0gbyksIG47CiAgICB9CiAgICB2YXIgYyA9IC10IC8gKDIgKiBzKTsKICAgIGlmIChjICE9PSAwKQogICAgICByZXR1cm4gbi5yb290MCA9IG4ucm9vdDEgPSBjLCBuOwogIH0KfQp2YXIgb3IgPSB7CiAgcm9vdDA6IDAsCiAgcm9vdDE6IDAKfTsKZnVuY3Rpb24gVWkocywgdCwgZSkgewogIEEoZSkgfHwgKGUgPSBuZXcgX2UoKSk7CiAgdmFyIG4gPSBzLm9yaWdpbiwgaSA9IHMuZGlyZWN0aW9uLCByID0gdC5jZW50ZXIsIGEgPSB0LnJhZGl1cyAqIHQucmFkaXVzLCBvID0gUy5zdWJ0cmFjdChuLCByLCBEaSksIGggPSBTLmRvdChpLCBpKSwgYyA9IDIgKiBTLmRvdChpLCBvKSwgbCA9IFMubWFnbml0dWRlU3F1YXJlZChvKSAtIGEsIHUgPSBhcihoLCBjLCBsLCBvcik7CiAgaWYgKCEhQSh1KSkKICAgIHJldHVybiBlLnN0YXJ0ID0gdS5yb290MCwgZS5zdG9wID0gdS5yb290MSwgZTsKfQpWLnJheVNwaGVyZSA9IGZ1bmN0aW9uKHMsIHQsIGUpIHsKICBpZiAoIUEocykpCiAgICB0aHJvdyBuZXcgaigicmF5IGlzIHJlcXVpcmVkLiIpOwogIGlmICghQSh0KSkKICAgIHRocm93IG5ldyBqKCJzcGhlcmUgaXMgcmVxdWlyZWQuIik7CiAgaWYgKGUgPSBVaShzLCB0LCBlKSwgISghQShlKSB8fCBlLnN0b3AgPCAwKSkKICAgIHJldHVybiBlLnN0YXJ0ID0gTWF0aC5tYXgoZS5zdGFydCwgMCksIGU7Cn07CnZhciBociA9IG5ldyBlbigpOwpWLmxpbmVTZWdtZW50U3BoZXJlID0gZnVuY3Rpb24ocywgdCwgZSwgbikgewogIGlmICghQShzKSkKICAgIHRocm93IG5ldyBqKCJwMCBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEodCkpCiAgICB0aHJvdyBuZXcgaigicDEgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFBKGUpKQogICAgdGhyb3cgbmV3IGooInNwaGVyZSBpcyByZXF1aXJlZC4iKTsKICB2YXIgaSA9IGhyOwogIFMuY2xvbmUocywgaS5vcmlnaW4pOwogIHZhciByID0gUy5zdWJ0cmFjdCh0LCBzLCBpLmRpcmVjdGlvbiksIGEgPSBTLm1hZ25pdHVkZShyKTsKICBpZiAoUy5ub3JtYWxpemUociwgciksIG4gPSBVaShpLCBlLCBuKSwgISghQShuKSB8fCBuLnN0b3AgPCAwIHx8IG4uc3RhcnQgPiBhKSkKICAgIHJldHVybiBuLnN0YXJ0ID0gTWF0aC5tYXgobi5zdGFydCwgMCksIG4uc3RvcCA9IE1hdGgubWluKG4uc3RvcCwgYSksIG47Cn07CnZhciBjciA9IG5ldyBwKCksIGxyID0gbmV3IHAoKTsKVi5yYXlFbGxpcHNvaWQgPSBmdW5jdGlvbihzLCB0KSB7CiAgaWYgKCFBKHMpKQogICAgdGhyb3cgbmV3IGooInJheSBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEodCkpCiAgICB0aHJvdyBuZXcgaigiZWxsaXBzb2lkIGlzIHJlcXVpcmVkLiIpOwogIHZhciBlID0gdC5vbmVPdmVyUmFkaWksIG4gPSBTLm11bHRpcGx5Q29tcG9uZW50cyhlLCBzLm9yaWdpbiwgY3IpLCBpID0gUy5tdWx0aXBseUNvbXBvbmVudHMoZSwgcy5kaXJlY3Rpb24sIGxyKSwgciA9IFMubWFnbml0dWRlU3F1YXJlZChuKSwgYSA9IFMuZG90KG4sIGkpLCBvLCBoLCBjLCBsLCB1OwogIGlmIChyID4gMSkgewogICAgaWYgKGEgPj0gMCkKICAgICAgcmV0dXJuOwogICAgdmFyIGQgPSBhICogYTsKICAgIGlmIChvID0gciAtIDEsIGggPSBTLm1hZ25pdHVkZVNxdWFyZWQoaSksIGMgPSBoICogbywgZCA8IGMpCiAgICAgIHJldHVybjsKICAgIGlmIChkID4gYykgewogICAgICBsID0gYSAqIGEgLSBjLCB1ID0gLWEgKyBNYXRoLnNxcnQobCk7CiAgICAgIHZhciB5ID0gdSAvIGgsIGYgPSBvIC8gdTsKICAgICAgcmV0dXJuIHkgPCBmID8gbmV3IF9lKHksIGYpIDogewogICAgICAgIHN0YXJ0OiBmLAogICAgICAgIHN0b3A6IHkKICAgICAgfTsKICAgIH0KICAgIHZhciBnID0gTWF0aC5zcXJ0KG8gLyBoKTsKICAgIHJldHVybiBuZXcgX2UoZywgZyk7CiAgfSBlbHNlIGlmIChyIDwgMSkKICAgIHJldHVybiBvID0gciAtIDEsIGggPSBTLm1hZ25pdHVkZVNxdWFyZWQoaSksIGMgPSBoICogbywgbCA9IGEgKiBhIC0gYywgdSA9IC1hICsgTWF0aC5zcXJ0KGwpLCBuZXcgX2UoMCwgdSAvIGgpOwogIGlmIChhIDwgMCkKICAgIHJldHVybiBoID0gUy5tYWduaXR1ZGVTcXVhcmVkKGkpLCBuZXcgX2UoMCwgLWEgLyBoKTsKfTsKZnVuY3Rpb24gbmUocywgdCwgZSkgewogIHZhciBuID0gcyArIHQ7CiAgcmV0dXJuIEUuc2lnbihzKSAhPT0gRS5zaWduKHQpICYmIE1hdGguYWJzKG4gLyBNYXRoLm1heChNYXRoLmFicyhzKSwgTWF0aC5hYnModCkpKSA8IGUgPyAwIDogbjsKfQpmdW5jdGlvbiB1cihzLCB0LCBlLCBuLCBpKSB7CiAgdmFyIHIgPSBuICogbiwgYSA9IGkgKiBpLCBvID0gKHNbQi5DT0xVTU4xUk9XMV0gLSBzW0IuQ09MVU1OMlJPVzJdKSAqIGEsIGggPSBpICogKG4gKiBuZSgKICAgIHNbQi5DT0xVTU4xUk9XMF0sCiAgICBzW0IuQ09MVU1OMFJPVzFdLAogICAgRS5FUFNJTE9OMTUKICApICsgdC55KSwgYyA9IHNbQi5DT0xVTU4wUk9XMF0gKiByICsgc1tCLkNPTFVNTjJST1cyXSAqIGEgKyBuICogdC54ICsgZSwgbCA9IGEgKiBuZSgKICAgIHNbQi5DT0xVTU4yUk9XMV0sCiAgICBzW0IuQ09MVU1OMVJPVzJdLAogICAgRS5FUFNJTE9OMTUKICApLCB1ID0gaSAqIChuICogbmUoc1tCLkNPTFVNTjJST1cwXSwgc1tCLkNPTFVNTjBST1cyXSkgKyB0LnopLCBkLCB5ID0gW107CiAgaWYgKHUgPT09IDAgJiYgbCA9PT0gMCkgewogICAgaWYgKGQgPSBDdC5jb21wdXRlUmVhbFJvb3RzKG8sIGgsIGMpLCBkLmxlbmd0aCA9PT0gMCkKICAgICAgcmV0dXJuIHk7CiAgICB2YXIgZiA9IGRbMF0sIGcgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMSAtIGYgKiBmLCAwKSk7CiAgICBpZiAoeS5wdXNoKG5ldyBwKG4sIGkgKiBmLCBpICogLWcpKSwgeS5wdXNoKG5ldyBwKG4sIGkgKiBmLCBpICogZykpLCBkLmxlbmd0aCA9PT0gMikgewogICAgICB2YXIgXyA9IGRbMV0sIHcgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMSAtIF8gKiBfLCAwKSk7CiAgICAgIHkucHVzaChuZXcgcChuLCBpICogXywgaSAqIC13KSksIHkucHVzaChuZXcgcChuLCBpICogXywgaSAqIHcpKTsKICAgIH0KICAgIHJldHVybiB5OwogIH0KICB2YXIgeCA9IHUgKiB1LCBtID0gbCAqIGwsIE0gPSBvICogbywgeiA9IHUgKiBsLCBQID0gTSArIG0sIFQgPSAyICogKGggKiBvICsgeiksIGIgPSAyICogYyAqIG8gKyBoICogaCAtIG0gKyB4LCBOID0gMiAqIChjICogaCAtIHopLCBJID0gYyAqIGMgLSB4OwogIGlmIChQID09PSAwICYmIFQgPT09IDAgJiYgYiA9PT0gMCAmJiBOID09PSAwKQogICAgcmV0dXJuIHk7CiAgZCA9IEVuLmNvbXB1dGVSZWFsUm9vdHMoUCwgVCwgYiwgTiwgSSk7CiAgdmFyIEMgPSBkLmxlbmd0aDsKICBpZiAoQyA9PT0gMCkKICAgIHJldHVybiB5OwogIGZvciAodmFyIE8gPSAwOyBPIDwgQzsgKytPKSB7CiAgICB2YXIgUiA9IGRbT10sIEQgPSBSICogUiwgVSA9IE1hdGgubWF4KDEgLSBELCAwKSwgTCA9IE1hdGguc3FydChVKSwgcTsKICAgIEUuc2lnbihvKSA9PT0gRS5zaWduKGMpID8gcSA9IG5lKAogICAgICBvICogRCArIGMsCiAgICAgIGggKiBSLAogICAgICBFLkVQU0lMT04xMgogICAgKSA6IEUuc2lnbihjKSA9PT0gRS5zaWduKGggKiBSKSA/IHEgPSBuZSgKICAgICAgbyAqIEQsCiAgICAgIGggKiBSICsgYywKICAgICAgRS5FUFNJTE9OMTIKICAgICkgOiBxID0gbmUoCiAgICAgIG8gKiBEICsgaCAqIFIsCiAgICAgIGMsCiAgICAgIEUuRVBTSUxPTjEyCiAgICApOwogICAgdmFyIGsgPSBuZShsICogUiwgdSwgRS5FUFNJTE9OMTUpLCBXID0gcSAqIGs7CiAgICBXIDwgMCA/IHkucHVzaChuZXcgcChuLCBpICogUiwgaSAqIEwpKSA6IFcgPiAwID8geS5wdXNoKG5ldyBwKG4sIGkgKiBSLCBpICogLUwpKSA6IEwgIT09IDAgPyAoeS5wdXNoKG5ldyBwKG4sIGkgKiBSLCBpICogLUwpKSwgeS5wdXNoKG5ldyBwKG4sIGkgKiBSLCBpICogTCkpLCArK08pIDogeS5wdXNoKG5ldyBwKG4sIGkgKiBSLCBpICogTCkpOwogIH0KICByZXR1cm4geTsKfQp2YXIgcG4gPSBuZXcgcCgpLCBuaSA9IG5ldyBwKCksIGlpID0gbmV3IHAoKSwgVWUgPSBuZXcgcCgpLCBkciA9IG5ldyBwKCksIHlyID0gbmV3IEooKSwgbXIgPSBuZXcgSigpLCBmciA9IG5ldyBKKCksIHhyID0gbmV3IEooKSwgd3IgPSBuZXcgSigpLCBzaSA9IG5ldyBKKCksIHJpID0gbmV3IEooKSwgYWkgPSBuZXcgcCgpLCB6ciA9IG5ldyBwKCksIGdyID0gbmV3IHAoKTsKVi5ncmF6aW5nQWx0aXR1ZGVMb2NhdGlvbiA9IGZ1bmN0aW9uKHMsIHQpIHsKICBpZiAoIUEocykpCiAgICB0aHJvdyBuZXcgaigicmF5IGlzIHJlcXVpcmVkLiIpOwogIGlmICghQSh0KSkKICAgIHRocm93IG5ldyBqKCJlbGxpcHNvaWQgaXMgcmVxdWlyZWQuIik7CiAgdmFyIGUgPSBzLm9yaWdpbiwgbiA9IHMuZGlyZWN0aW9uOwogIGlmICghUy5lcXVhbHMoZSwgUy5aRVJPKSkgewogICAgdmFyIGkgPSB0Lmdlb2RldGljU3VyZmFjZU5vcm1hbChlLCBwbik7CiAgICBpZiAoUy5kb3QobiwgaSkgPj0gMCkKICAgICAgcmV0dXJuIGU7CiAgfQogIHZhciByID0gQSh0aGlzLnJheUVsbGlwc29pZChzLCB0KSksIGEgPSB0LnRyYW5zZm9ybVBvc2l0aW9uVG9TY2FsZWRTcGFjZShuLCBwbiksIG8gPSBTLm5vcm1hbGl6ZShhLCBhKSwgaCA9IFMubW9zdE9ydGhvZ29uYWxBeGlzKGEsIFVlKSwgYyA9IFMubm9ybWFsaXplKAogICAgUy5jcm9zcyhoLCBvLCBuaSksCiAgICBuaQogICksIGwgPSBTLm5vcm1hbGl6ZSgKICAgIFMuY3Jvc3MobywgYywgaWkpLAogICAgaWkKICApLCB1ID0geXI7CiAgdVswXSA9IG8ueCwgdVsxXSA9IG8ueSwgdVsyXSA9IG8ueiwgdVszXSA9IGMueCwgdVs0XSA9IGMueSwgdVs1XSA9IGMueiwgdVs2XSA9IGwueCwgdVs3XSA9IGwueSwgdVs4XSA9IGwuejsKICB2YXIgZCA9IEIudHJhbnNwb3NlKHUsIG1yKSwgeSA9IEIuZnJvbVNjYWxlKHQucmFkaWksIGZyKSwgZiA9IEIuZnJvbVNjYWxlKHQub25lT3ZlclJhZGlpLCB4ciksIGcgPSB3cjsKICBnWzBdID0gMCwgZ1sxXSA9IC1uLnosIGdbMl0gPSBuLnksIGdbM10gPSBuLnosIGdbNF0gPSAwLCBnWzVdID0gLW4ueCwgZ1s2XSA9IC1uLnksIGdbN10gPSBuLngsIGdbOF0gPSAwOwogIHZhciBfID0gQi5tdWx0aXBseSgKICAgIEIubXVsdGlwbHkoZCwgZiwgc2kpLAogICAgZywKICAgIHNpCiAgKSwgdyA9IEIubXVsdGlwbHkoQi5tdWx0aXBseShfLCB5LCByaSksIHUsIHJpKSwgeCA9IEIubXVsdGlwbHlCeVZlY3RvcihfLCBlLCBkciksIG0gPSB1cigKICAgIHcsCiAgICBTLm5lZ2F0ZSh4LCBwbiksCiAgICAwLAogICAgMCwKICAgIDEKICApLCBNLCB6LCBQID0gbS5sZW5ndGg7CiAgaWYgKFAgPiAwKSB7CiAgICBmb3IgKHZhciBUID0gUy5jbG9uZShTLlpFUk8sIHpyKSwgYiA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTiA9IDA7IE4gPCBQOyArK04pIHsKICAgICAgTSA9IEIubXVsdGlwbHlCeVZlY3RvcigKICAgICAgICB5LAogICAgICAgIEIubXVsdGlwbHlCeVZlY3Rvcih1LCBtW05dLCBhaSksCiAgICAgICAgYWkKICAgICAgKTsKICAgICAgdmFyIEkgPSBTLm5vcm1hbGl6ZSgKICAgICAgICBTLnN1YnRyYWN0KE0sIGUsIFVlKSwKICAgICAgICBVZQogICAgICApLCBDID0gUy5kb3QoSSwgbik7CiAgICAgIEMgPiBiICYmIChiID0gQywgVCA9IFMuY2xvbmUoTSwgVCkpOwogICAgfQogICAgdmFyIE8gPSB0LmNhcnRlc2lhblRvQ2FydG9ncmFwaGljKAogICAgICBULAogICAgICBncgogICAgKTsKICAgIHJldHVybiBiID0gRS5jbGFtcChiLCAwLCAxKSwgeiA9IFMubWFnbml0dWRlKAogICAgICBTLnN1YnRyYWN0KFQsIGUsIFVlKQogICAgKSAqIE1hdGguc3FydCgxIC0gYiAqIGIpLCB6ID0gciA/IC16IDogeiwgTy56ID0geiwgdC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbihPLCBuZXcgcCgpKTsKICB9Cn07CnZhciBNciA9IG5ldyBwKCk7ClYubGluZVNlZ21lbnRQbGFuZSA9IGZ1bmN0aW9uKHMsIHQsIGUsIG4pIHsKICBpZiAoIUEocykpCiAgICB0aHJvdyBuZXcgaigiZW5kUG9pbnQwIGlzIHJlcXVpcmVkLiIpOwogIGlmICghQSh0KSkKICAgIHRocm93IG5ldyBqKCJlbmRQb2ludDEgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFBKGUpKQogICAgdGhyb3cgbmV3IGooInBsYW5lIGlzIHJlcXVpcmVkLiIpOwogIEEobikgfHwgKG4gPSBuZXcgcCgpKTsKICB2YXIgaSA9IFMuc3VidHJhY3QoCiAgICB0LAogICAgcywKICAgIE1yCiAgKSwgciA9IGUubm9ybWFsLCBhID0gUy5kb3QociwgaSk7CiAgaWYgKCEoTWF0aC5hYnMoYSkgPCBFLkVQU0lMT042KSkgewogICAgdmFyIG8gPSBTLmRvdChyLCBzKSwgaCA9IC0oZS5jb25zdGFudCArIG8pIC8gYTsKICAgIGlmICghKGggPCAwIHx8IGggPiAxKSkKICAgICAgcmV0dXJuIFMubXVsdGlwbHlCeVNjYWxhcihpLCBoLCBuKSwgUy5hZGQocywgbiwgbiksIG47CiAgfQp9OwpWLnRyaWFuZ2xlUGxhbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihzLCB0LCBlLCBuKSB7CiAgaWYgKCFBKHMpIHx8ICFBKHQpIHx8ICFBKGUpIHx8ICFBKG4pKQogICAgdGhyb3cgbmV3IGooInAwLCBwMSwgcDIsIGFuZCBwbGFuZSBhcmUgcmVxdWlyZWQuIik7CiAgdmFyIGkgPSBuLm5vcm1hbCwgciA9IG4uY29uc3RhbnQsIGEgPSBTLmRvdChpLCBzKSArIHIgPCAwLCBvID0gUy5kb3QoaSwgdCkgKyByIDwgMCwgaCA9IFMuZG90KGksIGUpICsgciA8IDAsIGMgPSAwOwogIGMgKz0gYSA/IDEgOiAwLCBjICs9IG8gPyAxIDogMCwgYyArPSBoID8gMSA6IDA7CiAgdmFyIGwsIHU7CiAgaWYgKChjID09PSAxIHx8IGMgPT09IDIpICYmIChsID0gbmV3IHAoKSwgdSA9IG5ldyBwKCkpLCBjID09PSAxKSB7CiAgICBpZiAoYSkKICAgICAgcmV0dXJuIFYubGluZVNlZ21lbnRQbGFuZShzLCB0LCBuLCBsKSwgVi5saW5lU2VnbWVudFBsYW5lKHMsIGUsIG4sIHUpLCB7CiAgICAgICAgcG9zaXRpb25zOiBbcywgdCwgZSwgbCwgdV0sCiAgICAgICAgaW5kaWNlczogWwogICAgICAgICAgMCwKICAgICAgICAgIDMsCiAgICAgICAgICA0LAogICAgICAgICAgMSwKICAgICAgICAgIDIsCiAgICAgICAgICA0LAogICAgICAgICAgMSwKICAgICAgICAgIDQsCiAgICAgICAgICAzCiAgICAgICAgXQogICAgICB9OwogICAgaWYgKG8pCiAgICAgIHJldHVybiBWLmxpbmVTZWdtZW50UGxhbmUodCwgZSwgbiwgbCksIFYubGluZVNlZ21lbnRQbGFuZSh0LCBzLCBuLCB1KSwgewogICAgICAgIHBvc2l0aW9uczogW3MsIHQsIGUsIGwsIHVdLAogICAgICAgIGluZGljZXM6IFsKICAgICAgICAgIDEsCiAgICAgICAgICAzLAogICAgICAgICAgNCwKICAgICAgICAgIDIsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDIsCiAgICAgICAgICA0LAogICAgICAgICAgMwogICAgICAgIF0KICAgICAgfTsKICAgIGlmIChoKQogICAgICByZXR1cm4gVi5saW5lU2VnbWVudFBsYW5lKGUsIHMsIG4sIGwpLCBWLmxpbmVTZWdtZW50UGxhbmUoZSwgdCwgbiwgdSksIHsKICAgICAgICBwb3NpdGlvbnM6IFtzLCB0LCBlLCBsLCB1XSwKICAgICAgICBpbmRpY2VzOiBbCiAgICAgICAgICAyLAogICAgICAgICAgMywKICAgICAgICAgIDQsCiAgICAgICAgICAwLAogICAgICAgICAgMSwKICAgICAgICAgIDQsCiAgICAgICAgICAwLAogICAgICAgICAgNCwKICAgICAgICAgIDMKICAgICAgICBdCiAgICAgIH07CiAgfSBlbHNlIGlmIChjID09PSAyKQogICAgaWYgKGEpCiAgICAgIGlmIChvKSB7CiAgICAgICAgaWYgKCFoKQogICAgICAgICAgcmV0dXJuIFYubGluZVNlZ21lbnRQbGFuZShzLCBlLCBuLCBsKSwgVi5saW5lU2VnbWVudFBsYW5lKHQsIGUsIG4sIHUpLCB7CiAgICAgICAgICAgIHBvc2l0aW9uczogW3MsIHQsIGUsIGwsIHVdLAogICAgICAgICAgICBpbmRpY2VzOiBbCiAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICAxLAogICAgICAgICAgICAgIDQsCiAgICAgICAgICAgICAgMCwKICAgICAgICAgICAgICA0LAogICAgICAgICAgICAgIDMsCiAgICAgICAgICAgICAgMiwKICAgICAgICAgICAgICAzLAogICAgICAgICAgICAgIDQKICAgICAgICAgICAgXQogICAgICAgICAgfTsKICAgICAgfSBlbHNlCiAgICAgICAgcmV0dXJuIFYubGluZVNlZ21lbnRQbGFuZShlLCB0LCBuLCBsKSwgVi5saW5lU2VnbWVudFBsYW5lKHMsIHQsIG4sIHUpLCB7CiAgICAgICAgICBwb3NpdGlvbnM6IFtzLCB0LCBlLCBsLCB1XSwKICAgICAgICAgIGluZGljZXM6IFsKICAgICAgICAgICAgMiwKICAgICAgICAgICAgMCwKICAgICAgICAgICAgNCwKICAgICAgICAgICAgMiwKICAgICAgICAgICAgNCwKICAgICAgICAgICAgMywKICAgICAgICAgICAgMSwKICAgICAgICAgICAgMywKICAgICAgICAgICAgNAogICAgICAgICAgXQogICAgICAgIH07CiAgICBlbHNlCiAgICAgIHJldHVybiBWLmxpbmVTZWdtZW50UGxhbmUodCwgcywgbiwgbCksIFYubGluZVNlZ21lbnRQbGFuZShlLCBzLCBuLCB1KSwgewogICAgICAgIHBvc2l0aW9uczogW3MsIHQsIGUsIGwsIHVdLAogICAgICAgIGluZGljZXM6IFsKICAgICAgICAgIDEsCiAgICAgICAgICAyLAogICAgICAgICAgNCwKICAgICAgICAgIDEsCiAgICAgICAgICA0LAogICAgICAgICAgMywKICAgICAgICAgIDAsCiAgICAgICAgICAzLAogICAgICAgICAgNAogICAgICAgIF0KICAgICAgfTsKfTsKY2xhc3MgUWUgewogIHN0YXRpYyBjbG9uZSh0LCBlKSB7CiAgICByZXR1cm4gZSB8fCAoZSA9IG5ldyBtdCgpKSwgZS5jb3B5KHQpLCBlOwogIH0KICBzdGF0aWMgZnJvbUVsZW1lbnRzKHQsIGUsIG4sIGksIHIpIHsKICAgIHJldHVybiByIHx8IChyID0gbmV3IG10KCkpLCByLnNldCh0LCBlLCBuLCBpKSwgcjsKICB9CiAgc3RhdGljIGxlcnAodCwgZSwgbiwgaSkgewogICAgcmV0dXJuIGkgfHwgKGkgPSBuZXcgbXQoKSksIGkubGVycFZlY3RvcnModCwgZSwgbiksIGk7CiAgfQogIHN0YXRpYyBlcXVhbHModCwgZSkgewogICAgcmV0dXJuIHQuZXF1YWxzKGUpOwogIH0KICBzdGF0aWMgbm9ybWFsaXplKHQsIGUpIHsKICAgIHJldHVybiB0ID09PSBlID8gKHQubm9ybWFsaXplKCksIHQpIDogKGUuY29weSh0KSwgZS5ub3JtYWxpemUoKSwgZSk7CiAgfQogIHN0YXRpYyBhZGQodCwgZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgbXQoKSksIG4uYWRkVmVjdG9ycyh0LCBlKTsKICB9CiAgc3RhdGljIG11bHRpcGx5QnlTY2FsYXIodCwgZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgbXQoKSksIG4uY29weSh0KS5tdWx0aXBseVNjYWxhcihlKSwgbjsKICB9CiAgc3RhdGljIHN1YnRyYWN0KHQsIGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IG10KCkpLCBuLnN1YlZlY3RvcnModCwgZSksIG47CiAgfQogIHN0YXRpYyBkaXN0YW5jZSh0LCBlKSB7CiAgICByZXR1cm4gdC5kaXN0YW5jZVRvKGUpOwogIH0KfQp2KFFlLCAiWkVSTyIsIG5ldyBtdCgwLCAwLCAwLCAwKSksIHYoUWUsICJVTklUX1ciLCBPYmplY3QuZnJlZXplKG5ldyBtdCgwLCAwLCAwLCAxKSkpOwpjb25zdCBwciA9IG5ldyBwKCksIF9yID0gbmV3IHAoKSwgU3IgPSBuZXcgYXQoKSwgUHIgPSBuZXcgbXQoMCwgMCwgMCwgMCksIGJyID0gbmV3IHAoKTsKY2xhc3MgeHQgewogIHN0YXRpYyBmcm9tUG9pbnROb3JtYWwodCwgZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgemUoKSksIG4uc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoZSwgdCksIG47CiAgfQogIHN0YXRpYyBmcm9tQ2FydGVzaWFuNCh0LCBlKSB7CiAgICBjb25zdCBuID0gUy5mcm9tQ2FydGVzaWFuNCh0LCBwciksIGkgPSB0Lnc7CiAgICBpZiAoIUUuZXF1YWxzRXBzaWxvbigKICAgICAgUy5tYWduaXR1ZGUobiksCiAgICAgIDEsCiAgICAgIEUuRVBTSUxPTjYKICAgICkpCiAgICAgIHRocm93IG5ldyBFcnJvcigibm9ybWFsIG11c3QgYmUgbm9ybWFsaXplZC4iKTsKICAgIHJldHVybiBBKGUpID8gKFMuY2xvbmUobiwgZS5ub3JtYWwpLCBlLmNvbnN0YW50ID0gaSwgZSkgOiBuZXcgeHQobiwgaSk7CiAgfQogIHN0YXRpYyBnZXRQb2ludERpc3RhbmNlKHQsIGUpIHsKICAgIHJldHVybiBTLmRvdCh0Lm5vcm1hbCwgZSkgKyB0LmNvbnN0YW50OwogIH0KICBzdGF0aWMgcHJvamVjdFBvaW50T250b1BsYW5lKHQsIGUsIG4pIHsKICAgIEEobikgfHwgKG4gPSBuZXcgcCgpKTsKICAgIGNvbnN0IGkgPSB4dC5nZXRQb2ludERpc3RhbmNlKHQsIGUpLCByID0gUy5tdWx0aXBseUJ5U2NhbGFyKAogICAgICB0Lm5vcm1hbCwKICAgICAgaSwKICAgICAgX3IKICAgICk7CiAgICByZXR1cm4gUy5zdWJ0cmFjdChlLCByLCBuKTsKICB9CiAgc3RhdGljIHRyYW5zZm9ybSh0LCBlLCBuKSB7CiAgICBjb25zdCBpID0gdC5ub3JtYWwsIHIgPSB0LmNvbnN0YW50LCBhID0gYXQuaW52ZXJzZVRyYW5zcG9zZSgKICAgICAgZSwKICAgICAgU3IKICAgICk7CiAgICBsZXQgbyA9IFFlLmZyb21FbGVtZW50cygKICAgICAgaS54LAogICAgICBpLnksCiAgICAgIGkueiwKICAgICAgciwKICAgICAgUHIKICAgICk7CiAgICBvID0gYXQubXVsdGlwbHlCeVZlY3RvcigKICAgICAgYSwKICAgICAgbywKICAgICAgbwogICAgKTsKICAgIGNvbnN0IGggPSBTLmZyb21DYXJ0ZXNpYW40KAogICAgICBvLAogICAgICBicgogICAgKTsKICAgIHJldHVybiBvID0gUWUuZGl2aWRlQnlTY2FsYXIoCiAgICAgIG8sCiAgICAgIFMubWFnbml0dWRlKGgpLAogICAgICBvCiAgICApLCB6ZS5mcm9tQ2FydGVzaWFuNChvLCBuKTsKICB9CiAgc3RhdGljIGNsb25lKHQsIGUpIHsKICAgIHJldHVybiBBKGUpID8gKFMuY2xvbmUodC5ub3JtYWwsIGUubm9ybWFsKSwgZS5jb25zdGFudCA9IHQuY29uc3RhbnQsIGUpIDogbmV3IHh0KHQubm9ybWFsLCB0LmNvbnN0YW50KTsKICB9CiAgc3RhdGljIGVxdWFscyh0LCBlKSB7CiAgICByZXR1cm4gdC5jb25zdGFudCA9PT0gZS5jb25zdGFudCAmJiBTLmVxdWFscyh0Lm5vcm1hbCwgZS5ub3JtYWwpOwogIH0KfQp6ZS5PUklHSU5fWFlfUExBTkUgPSBPYmplY3QuZnJlZXplKG5ldyB4dChTLlVOSVRfWiwgMCkpOwp6ZS5PUklHSU5fWVpfUExBTkUgPSBPYmplY3QuZnJlZXplKG5ldyB4dChTLlVOSVRfWCwgMCkpOwp6ZS5PUklHSU5fWlhfUExBTkUgPSBPYmplY3QuZnJlZXplKG5ldyB4dChTLlVOSVRfWSwgMCkpOwpjb25zdCBfbiA9IG5ldyBtdCgwLCAwLCAwLCAwKSwgb2kgPSBuZXcgZW4oKSwgV2UgPSBuZXcgcCgpOwpjbGFzcyBJZSB7CiAgY29uc3RydWN0b3IodCwgZSkgewogICAgaWYgKGUgPSBHKGUsIGR0LldHUzg0KSwgdCA9IGUuc2NhbGVUb0dlb2RldGljU3VyZmFjZSh0KSwgIUEodCkpCiAgICAgIHRocm93IG5ldyBqKAogICAgICAgICJvcmlnaW4gbXVzdCBub3QgYmUgYXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzb2lkLiIKICAgICAgKTsKICAgIGNvbnN0IG4gPSBvdC5lYXN0Tm9ydGhVcFRvRml4ZWRGcmFtZSh0LCBlKTsKICAgIHRoaXMuX2VsbGlwc29pZCA9IGUsIHRoaXMuX29yaWdpbiA9IHQsIHRoaXMuX3hBeGlzID0gUy5mcm9tQ2FydGVzaWFuNCgKICAgICAgeGUuZ2V0Q29sdW1uKG4sIDAsIF9uKQogICAgKSwgdGhpcy5feUF4aXMgPSBTLmZyb21DYXJ0ZXNpYW40KAogICAgICB4ZS5nZXRDb2x1bW4obiwgMSwgX24pCiAgICApOwogICAgY29uc3QgaSA9IFMuZnJvbUNhcnRlc2lhbjQoCiAgICAgIHhlLmdldENvbHVtbihuLCAyLCBfbikKICAgICk7CiAgICB0aGlzLl9wbGFuZSA9IHh0LmZyb21Qb2ludE5vcm1hbCh0LCBpKTsKICB9CiAgc3RhdGljIGZyb21Qb2ludHModCwgZSkgewogICAgbGV0IG4gPSB0WzBdLngsIGkgPSB0WzBdLnksIHIgPSB0WzBdLnosIGEgPSB0WzBdLngsIG8gPSB0WzBdLnksIGggPSB0WzBdLno7CiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHQubGVuZ3RoOyB5KyspIHsKICAgICAgY29uc3QgZiA9IHRbeV0sIGcgPSBmLngsIF8gPSBmLnksIHcgPSBmLno7CiAgICAgIG4gPSBNYXRoLm1pbihnLCBuKSwgYSA9IE1hdGgubWF4KGcsIGEpLCBpID0gTWF0aC5taW4oXywgaSksIG8gPSBNYXRoLm1heChfLCBvKSwgciA9IE1hdGgubWluKHcsIHIpLCBoID0gTWF0aC5tYXgodywgaCk7CiAgICB9CiAgICBjb25zdCBjID0gbmV3IHAobiwgaSwgciksIGwgPSBuZXcgcChhLCBvLCBoKSwgdSA9IG5ldyBTZShjLCBsKTsKICAgIGxldCBkID0gbmV3IHAoKTsKICAgIHJldHVybiBkID0gdS5nZXRDZW50ZXIoZCksIG5ldyBJZShkLCBlKTsKICB9CiAgcHJvamVjdFBvaW50VG9OZWFyZXN0T25QbGFuZSh0LCBlKSB7CiAgICBBKGUpIHx8IChlID0gbmV3IHV0KCkpOwogICAgY29uc3QgbiA9IG9pOwogICAgbi5vcmlnaW4gPSB0LCBTLmNsb25lKHRoaXMuX3BsYW5lLm5vcm1hbCwgbi5kaXJlY3Rpb24pOwogICAgbGV0IGkgPSBWLnJheVBsYW5lKAogICAgICBuLAogICAgICB0aGlzLl9wbGFuZSwKICAgICAgV2UKICAgICk7CiAgICBpZiAoQShpKSB8fCAoUy5uZWdhdGUobi5kaXJlY3Rpb24sIG4uZGlyZWN0aW9uKSwgaSA9IFYucmF5UGxhbmUoCiAgICAgIG4sCiAgICAgIHRoaXMuX3BsYW5lLAogICAgICBXZQogICAgKSksIEEoaSkpIHsKICAgICAgY29uc3QgciA9IFMuc3VidHJhY3QoCiAgICAgICAgaSwKICAgICAgICB0aGlzLl9vcmlnaW4sCiAgICAgICAgaQogICAgICApLCBhID0gUy5kb3QodGhpcy5feEF4aXMsIHIpLCBvID0gUy5kb3QodGhpcy5feUF4aXMsIHIpOwogICAgICByZXR1cm4gQShlKSA/IChlLnggPSBhLCBlLnkgPSBvLCBlKSA6IG5ldyBGKGEsIG8pOwogICAgfQogIH0KICBwcm9qZWN0UG9pbnRzT250b1BsYW5lKHQsIGUpIHsKICAgIEEoZSkgfHwgKGUgPSBbXSk7CiAgICBsZXQgbiA9IDA7CiAgICBjb25zdCBpID0gdC5sZW5ndGg7CiAgICBmb3IgKGxldCByID0gMDsgciA8IGk7IHIrKykgewogICAgICBjb25zdCBhID0gdGhpcy5wcm9qZWN0UG9pbnRPbnRvUGxhbmUodFtyXSwgZVtuXSk7CiAgICAgIGEgJiYgKGVbbl0gPSBhLCBuKyspOwogICAgfQogICAgcmV0dXJuIGUubGVuZ3RoID0gbiwgZTsKICB9CiAgcHJvamVjdFBvaW50T250b1BsYW5lKHQsIGUpIHsKICAgIGNvbnN0IG4gPSBvaTsKICAgIG4ub3JpZ2luID0gdCwgUy5ub3JtYWxpemUodCwgbi5kaXJlY3Rpb24pOwogICAgbGV0IGkgPSBWLnJheVBsYW5lKAogICAgICBuLAogICAgICB0aGlzLl9wbGFuZSwKICAgICAgV2UKICAgICk7CiAgICBpZiAoQShpKSB8fCAoUy5uZWdhdGUobi5kaXJlY3Rpb24sIG4uZGlyZWN0aW9uKSwgaSA9IFYucmF5UGxhbmUoCiAgICAgIG4sCiAgICAgIHRoaXMuX3BsYW5lLAogICAgICBXZQogICAgKSksIEEoaSkpIHsKICAgICAgY29uc3QgciA9IFMuc3VidHJhY3QoCiAgICAgICAgaSwKICAgICAgICB0aGlzLl9vcmlnaW4sCiAgICAgICAgaQogICAgICApLCBhID0gUy5kb3QodGhpcy5feEF4aXMsIHIpLCBvID0gUy5kb3QodGhpcy5feUF4aXMsIHIpOwogICAgICByZXR1cm4gQShlKSA/IChlLnggPSBhLCBlLnkgPSBvLCBlKSA6IG5ldyBGKGEsIG8pOwogICAgfQogIH0KICBnZXQgZWxsaXBzb2lkKCkgewogICAgcmV0dXJuIHRoaXMuX2VsbGlwc29pZDsKICB9CiAgZ2V0IG9yaWdpbigpIHsKICAgIHJldHVybiB0aGlzLl9vcmlnaW47CiAgfQogIGdldCBwbGFuZSgpIHsKICAgIHJldHVybiB0aGlzLl9wbGFuZTsKICB9CiAgZ2V0IHhBeGlzKCkgewogICAgcmV0dXJuIHRoaXMuX3hBeGlzOwogIH0KICBnZXQgeUF4aXMoKSB7CiAgICByZXR1cm4gdGhpcy5feUF4aXM7CiAgfQogIGdldCB6QXhpcygpIHsKICAgIHJldHVybiB0aGlzLl9wbGFuZS5ub3JtYWw7CiAgfQp9CmNvbnN0IHllID0gbmV3IHAoKSwgVHIgPSBuZXcgcCgpLCBJciA9IG5ldyBlbigpLCBDciA9IG5ldyBwKCksIE9yID0gbmV3IHAoKSwgbHQgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IodCwgZSkgewogICAgdGhpcy5wb3NpdGlvbiA9IHQsIHRoaXMucG9zaXRpb24gfHwgKHQgPSBuZXcgRigpKSwgdGhpcy50YW5nZW50UGxhbmUgPSBlLCB0aGlzLnRhbmdlbnRQbGFuZSB8fCAodGhpcy50YW5nZW50UGxhbmUgPSBsdC5OT1JUSF9QT0xFX1RBTkdFTlRfUExBTkUpOwogIH0KICBnZXRMYXRpdHVkZSh0KSB7CiAgICB0IHx8ICh0ID0gZHQuV0dTODQpLCB5ZS54ID0gdGhpcy5sb25naXR1ZGUsIHllLnkgPSB0aGlzLmNvbmZvcm1hbExhdGl0dWRlLCB5ZS56ID0gMDsKICAgIGNvbnN0IGUgPSB0aGlzLmVsbGlwc29pZC5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgeWUsCiAgICAgIFRyCiAgICApOwogICAgcmV0dXJuIHQuY2FydGVzaWFuVG9DYXJ0b2dyYXBoaWMoZSwgeWUpLCB5ZS55OwogIH0KICBzdGF0aWMgZnJvbUNhcnRlc2lhbih0LCBlKSB7CiAgICBjb25zdCBuID0gdC56IDwgMCA/IC0xIDogMTsKICAgIGxldCBpID0gbHQuTk9SVEhfUE9MRV9UQU5HRU5UX1BMQU5FLCByID0gbHQuU09VVEhfUE9MRTsKICAgIG4gPCAwICYmIChpID0gbHQuU09VVEhfUE9MRV9UQU5HRU5UX1BMQU5FLCByID0gbHQuTk9SVEhfUE9MRSk7CiAgICBjb25zdCBhID0gSXI7CiAgICBhLm9yaWdpbiA9IGkuZWxsaXBzb2lkLnNjYWxlVG9HZW9jZW50cmljU3VyZmFjZSgKICAgICAgdCwKICAgICAgYS5vcmlnaW4KICAgICksIGEuZGlyZWN0aW9uID0gUy5zdWJ0cmFjdCgKICAgICAgYS5vcmlnaW4sCiAgICAgIHIsCiAgICAgIENyCiAgICApLCBTLm5vcm1hbGl6ZShhLmRpcmVjdGlvbiwgYS5kaXJlY3Rpb24pOwogICAgY29uc3QgbyA9IFYucmF5UGxhbmUoCiAgICAgIGEsCiAgICAgIGkucGxhbmUsCiAgICAgIE9yCiAgICApLCBoID0gUy5zdWJ0cmFjdChvLCByLCBvKSwgYyA9IFMuZG90KGkueEF4aXMsIGgpLCBsID0gbiAqIFMuZG90KGkueUF4aXMsIGgpOwogICAgcmV0dXJuIGUgPyAoZS5wb3NpdGlvbiA9IG5ldyBGKGMsIGwpLCBlLnRhbmdlbnRQbGFuZSA9IGksIGUpIDogbmV3IGx0KG5ldyBGKGMsIGwpLCBpKTsKICB9CiAgY2xvbmUodCkgewogICAgcmV0dXJuIGx0LmNsb25lKHRoaXMsIHQpOwogIH0KICBzdGF0aWMgY2xvbmUodCwgZSkgewogICAgaWYgKCEhdCkKICAgICAgcmV0dXJuIGUgPyAoZS5wb3NpdGlvbiA9IHQucG9zaXRpb24sIGUudGFuZ2VudFBsYW5lID0gdC50YW5nZW50UGxhbmUsIGUpIDogbmV3IGx0KAogICAgICAgIHQucG9zaXRpb24sCiAgICAgICAgdC50YW5nZW50UGxhbmUKICAgICAgKTsKICB9CiAgZ2V0IGVsbGlwc29pZCgpIHsKICAgIHJldHVybiB0aGlzLnRhbmdlbnRQbGFuZS5lbGxpcHNvaWQ7CiAgfQogIGdldCB4KCkgewogICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDsKICB9CiAgZ2V0IHkoKSB7CiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55OwogIH0KICBnZXQgY29uZm9ybWFsTGF0aXR1ZGUoKSB7CiAgICBjb25zdCB0ID0gdGhpcy5wb3NpdGlvbi5sZW5ndGgoKSwgZSA9IDIgKiB0aGlzLmVsbGlwc29pZC5tYXhpbXVtUmFkaXVzOwogICAgcmV0dXJuIHRoaXMudGFuZ2VudFBsYW5lLnBsYW5lLm5vcm1hbC56ICogKEUuUElfT1ZFUl9UV08gLSAyICogTWF0aC5hdGFuMih0LCBlKSk7CiAgfQogIGdldCBsb25naXR1ZGUoKSB7CiAgICBsZXQgdCA9IEUuUElfT1ZFUl9UV08gKyBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTsKICAgIHJldHVybiB0ID4gTWF0aC5QSSAmJiAodCAtPSBFLlRXT19QSSksIHQ7CiAgfQp9OwpsZXQgQXQgPSBsdDsKdihBdCwgIkhBTEZfVU5JVF9TUEhFUkUiLCBPYmplY3QuZnJlZXplKG5ldyBkdCgwLjUsIDAuNSwgMC41KSkpLCB2KEF0LCAiTk9SVEhfUE9MRSIsIE9iamVjdC5mcmVlemUobmV3IHAoMCwgMCwgMC41KSkpLCB2KEF0LCAiU09VVEhfUE9MRSIsIE9iamVjdC5mcmVlemUobmV3IHAoMCwgMCwgLTAuNSkpKSwgdihBdCwgIk5PUlRIX1BPTEVfVEFOR0VOVF9QTEFORSIsIE9iamVjdC5mcmVlemUobmV3IEllKGx0Lk5PUlRIX1BPTEUsIGx0LkhBTEZfVU5JVF9TUEhFUkUpKSksIHYoQXQsICJTT1VUSF9QT0xFX1RBTkdFTlRfUExBTkUiLCBPYmplY3QuZnJlZXplKG5ldyBJZShsdC5TT1VUSF9QT0xFLCBsdC5IQUxGX1VOSVRfU1BIRVJFKSkpOwpuZXcgQXQoKTsKbmV3IEF0KCk7Cm5ldyBGKCk7Cm5ldyBGKCk7Cm5ldyBBdCgpOwpuZXcgRigpOwpmdW5jdGlvbiBFcihzKSB7CiAgaWYgKHMubGVuZ3RoIDwgMykKICAgIHRocm93IG5ldyBFcnJvcigiXHU3MEI5XHU3Njg0XHU2NTcwXHU5MUNGXHU1RkM1XHU5ODdCXHU1OTI3XHU0RThFXHU3QjQ5XHU0RThFM1x1NEUyQVx1NjI0RFx1ODBGRFx1NUY2Mlx1NjIxMFx1NTkxQVx1OEZCOVx1NUY2MiIpOwogIGNvbnN0IHQgPSBBcihzKSwgZSA9IHMubWFwKChuLCBpKSA9PiB7CiAgICBjb25zdCByID0gTWF0aC5hdGFuMihuLnkgLSB0LnksIG4ueCAtIHQueCk7CiAgICByZXR1cm4geyBpbmRleDogaSwgYW5nbGU6IHIgfTsKICB9KTsKICByZXR1cm4gZS5zb3J0KChuLCBpKSA9PiBuLmFuZ2xlIC0gaS5hbmdsZSksIGUubWFwKChuKSA9PiBuLmluZGV4KTsKfQpmdW5jdGlvbiBBcihzLCB0KSB7CiAgdCB8fCAodCA9IG5ldyBGKCkpOwogIGNvbnN0IGUgPSBzLmxlbmd0aDsKICBsZXQgbiA9IDAsIGkgPSAwOwogIHJldHVybiBzLmZvckVhY2goKHIpID0+IHsKICAgIG4gKz0gci54LCBpICs9IHIueTsKICB9KSwgdC5zZXQobiAvIGUsIGkgLyBlKTsKfQpmdW5jdGlvbiBScihzLCB0LCBlLCBuLCBpLCByKSB7CiAgY29uc3QgYSA9IHMueCwgbyA9IHMueSwgaCA9IHQueCwgYyA9IHQueSwgbCA9IGUueCwgdSA9IGUueSwgZCA9IG4ueCwgeSA9IG4ueSwgZiA9IChhIC0gaCkgKiAodSAtIHkpIC0gKG8gLSBjKSAqIChsIC0gZCk7CiAgaWYgKE1hdGguYWJzKGYpIDwgMWUtNCkKICAgIHJldHVybiBudWxsOwogIGNvbnN0IGcgPSAoKGEgLSBsKSAqICh1IC0geSkgLSAobyAtIHUpICogKGwgLSBkKSkgLyBmLCBfID0gLSgoYSAtIGgpICogKG8gLSB1KSAtIChvIC0gYykgKiAoYSAtIGwpKSAvIGY7CiAgcmV0dXJuIGcgPj0gMCAmJiBnIDw9IDEgJiYgXyA+PSAwICYmIF8gPD0gMSA/IHsKICAgIHBvaW50OiBzLmNsb25lKCkubGVycCh0LCBnKSwKICAgIHV2OiBpLmNsb25lKCkubGVycChyLCBnKQogIH0gOiBudWxsOwp9CmZ1bmN0aW9uIE5yKHMsIHQsIGUsIG4pIHsKICBjb25zdCBpID0gZS54IC0gdC54LCByID0gZS55IC0gdC55LCBhID0gbi54IC0gdC54LCBvID0gbi55IC0gdC55LCBoID0gcy54IC0gdC54LCBjID0gcy55IC0gdC55LCBsID0gaSAqIG8gLSByICogYSwgdSA9IChoICogbyAtIGMgKiBhKSAvIGwsIGQgPSAoaSAqIGMgLSByICogaCkgLyBsOwogIHJldHVybiB1ID49IDAgJiYgZCA+PSAwICYmIHUgKyBkIDw9IDE7Cn0KZnVuY3Rpb24gV2kocywgdCwgZSwgbiwgaSkgewogIHJldHVybiBzLnggPj0gdCAmJiBzLnggPD0gZSAmJiBzLnkgPj0gbiAmJiBzLnkgPD0gaTsKfQpmdW5jdGlvbiBMcihzLCB0LCBlLCBuKSB7CiAgcmV0dXJuIFsKICAgIG5ldyBGKHMsIGUpLAogICAgbmV3IEYodCwgZSksCiAgICBuZXcgRih0LCBuKSwKICAgIG5ldyBGKHMsIG4pCiAgXTsKfQpmdW5jdGlvbiBxcihzKSB7CiAgcmV0dXJuIFsKICAgIFtzWzBdLCBzWzFdXSwKICAgIFtzWzFdLCBzWzJdXSwKICAgIFtzWzJdLCBzWzNdXSwKICAgIFtzWzNdLCBzWzBdXQogIF07Cn0KZnVuY3Rpb24gdnIocywgdCwgZSkgewogIGNvbnN0IG4gPSBbXTsKICBzLmZvckVhY2goKHgsIG0pID0+IHsKICAgIGlmIChXaSgKICAgICAgeCwKICAgICAgZVswXS54LAogICAgICBlWzJdLngsCiAgICAgIGVbMF0ueSwKICAgICAgZVsyXS55CiAgICApKSB7CiAgICAgIGNvbnN0IHogPSB4LnggKyAiLCIgKyB4LnkgKyAiLCIgKyB4Lno7CiAgICAgIG5bel0gfHwgKG5bel0gPSB7CiAgICAgICAgcG9pbnQ6IHgsCiAgICAgICAgdXY6IHRbbV0KICAgICAgfSk7CiAgICB9CiAgfSk7CiAgY29uc3QgaSA9IE1hdGgubWluKHNbMF0ueCwgTWF0aC5taW4oc1sxXS54LCBzWzJdLngpKSwgciA9IE1hdGgubWF4KHNbMF0ueCwgTWF0aC5tYXgoc1sxXS54LCBzWzJdLngpKSwgYSA9IE1hdGgubWluKHNbMF0ueSwgTWF0aC5taW4oc1sxXS55LCBzWzJdLnkpKSwgbyA9IE1hdGgubWF4KHNbMF0ueSwgTWF0aC5tYXgoc1sxXS55LCBzWzJdLnkpKSwgaCA9IE1hdGgubWluKHRbMF0ueCwgTWF0aC5taW4odFsxXS54LCB0WzJdLngpKSwgYyA9IE1hdGgubWF4KHRbMF0ueCwgTWF0aC5tYXgodFsxXS54LCB0WzJdLngpKSwgbCA9IE1hdGgubWluKHRbMF0ueSwgTWF0aC5taW4odFsxXS55LCB0WzJdLnkpKSwgdSA9IE1hdGgubWF4KHRbMF0ueSwgTWF0aC5tYXgodFsxXS55LCB0WzJdLnkpKSwgZCA9IHIgLSBpLCB5ID0gbyAtIGEsIGYgPSBjIC0gaCwgZyA9IHUgLSBsOwogIGUuZm9yRWFjaCgoeCkgPT4gewogICAgaWYgKE5yKHgsIC4uLnMpKSB7CiAgICAgIGNvbnN0IE0gPSB4LnggKyAiLCIgKyB4LnkgKyAiLCIgKyB4Lno7CiAgICAgIGlmICghbltNXSkgewogICAgICAgIGNvbnN0IHogPSBoICsgZiAqICh4LnggLSBpKSAvIGQsIFAgPSBsICsgZyAqICh4LnkgLSBhKSAvIHk7CiAgICAgICAgbltNXSA9IHsKICAgICAgICAgIHBvaW50OiB4LAogICAgICAgICAgdXY6IG5ldyBGKHosIFApCiAgICAgICAgfTsKICAgICAgfQogICAgfQogIH0pOwogIGNvbnN0IF8gPSBbCiAgICBbMCwgMV0sCiAgICBbMSwgMl0sCiAgICBbMiwgMF0KICBdLCB3ID0gcXIoZSk7CiAgcmV0dXJuIF8uZm9yRWFjaCgoW3gsIG1dKSA9PiB7CiAgICB3LmZvckVhY2goKFtNLCB6XSkgPT4gewogICAgICBjb25zdCBQID0gc1t4XSwgVCA9IHNbbV0sIGIgPSB0W3hdLCBOID0gdFttXSwgSSA9IFJyKFAsIFQsIE0sIHosIGIsIE4pOwogICAgICBpZiAoSSkgewogICAgICAgIGNvbnN0IHsgcG9pbnQ6IEMgfSA9IEksIE8gPSBDLnggKyAiLCIgKyBDLnkgKyAiLCIgKyBDLno7CiAgICAgICAgbltPXSB8fCAobltPXSA9IEkpOwogICAgICB9CiAgICB9KTsKICB9KSwgT2JqZWN0LnZhbHVlcyhuKTsKfQpjb25zdCBqciA9IG5ldyBwKCksIGtyID0gbmV3IHAoKSwgQnIgPSBuZXcgcCgpOwpuZXcgcCgpOwpuZXcgcCgpOwpuZXcgcCgpOwpjb25zdCBrdCA9IG5ldyBwKCksIERyID0gbmV3IEYoKSwgVXIgPSBuZXcgRigpLCBXciA9IG5ldyBGKCksIEZyID0gKHMsIHQsIGUsIG4sIGksIHIsIGEsIG8sIGgpID0+IHsKICBjb25zdCBjID0gW107CiAgZm9yIChsZXQgdyA9IDA7IHcgPCBzLmxlbmd0aDsgdysrKSB7CiAgICBjb25zdCB4ID0gc1t3XTsKICAgIGxldCBtID0gYCR7eC54fSwke3gueX0sJHt4Lnp9YDsKICAgIGhbbV0gPSBlW3ddLCBXaSh4LCBvWzBdLCBvWzFdLCBvWzBdLCBvWzFdKSAmJiBjLnB1c2godyk7CiAgfQogIGlmIChjLmxlbmd0aCA9PT0gMykKICAgIHJldHVybiAhMTsKICBjb25zdCB1ID0gTHIob1swXSwgb1sxXSwgb1swXSwgb1sxXSksIGQgPSBbc1swXSwgc1sxXSwgc1syXV0sIHkgPSB2cihkLCB0LCB1KSwgZiA9IHkubWFwKCh3KSA9PiB3LnBvaW50KSwgZyA9IHkubWFwKCh3KSA9PiB3LnV2KTsKICBpZiAoZi5sZW5ndGggPiAyKSB7CiAgICBjb25zdCB3ID0gRXIoZiksIHggPSBbXTsKICAgIGZvciAobGV0IG0gPSAwLCBNID0gdy5sZW5ndGg7IG0gPCBNOyBtKyspIHsKICAgICAgY29uc3QgeiA9IHdbbV0sIFAgPSBmW3pdLCBUID0gZ1t6XSwgYiA9IGAke1AueH0sJHtQLnl9LCR7UC56fWA7CiAgICAgIFNzKGhbYl0pIHx8IChpLnB1c2goUC54LCBQLnksIFAueiksIG4gJiYgci5wdXNoKFQueCwgVC55KSwgaFtiXSA9IGkubGVuZ3RoIC8gMyAtIDEpOwogICAgICBjb25zdCBOID0gaFtiXTsKICAgICAgeC5wdXNoKE4pOwogICAgfQogICAgZi5sZW5ndGggPT09IDMgPyBhLnB1c2goCiAgICAgIHhbMV0sCiAgICAgIHhbMl0sCiAgICAgIHhbMF0KICAgICkgOiBmLmxlbmd0aCA9PT0gNCA/IGEucHVzaCgKICAgICAgeFsyXSwKICAgICAgeFszXSwKICAgICAgeFswXSwKICAgICAgeFswXSwKICAgICAgeFsxXSwKICAgICAgeFsyXQogICAgKSA6IGYubGVuZ3RoID09PSA1ICYmIGEucHVzaCgKICAgICAgeFszXSwKICAgICAgeFs0XSwKICAgICAgeFswXSwKICAgICAgeFswXSwKICAgICAgeFsxXSwKICAgICAgeFsyXSwKICAgICAgeFsyXSwKICAgICAgeFszXSwKICAgICAgeFswXQogICAgKTsKICB9CiAgcmV0dXJuICEwOwp9LCBGaSA9IChzLCB0LCBlLCBuLCBpID0gMCwgciA9IFstMC41MDEsIDAuNTAxXSkgPT4gewogIGNvbnN0IGEgPSAhIWUsIG8gPSBBcnJheS5mcm9tKHQpOwogIGxldCBoID0gMDsKICBjb25zdCBjID0gcy5sZW5ndGg7CiAgbGV0IGwgPSBudWxsLCB1ID0gbnVsbDsKICBpZiAoQXJyYXkuaXNBcnJheShzWzBdKSkgewogICAgbCA9IFtdOwogICAgbGV0IHcgPSAwOwogICAgZm9yIChoID0gMDsgaCA8IGM7IGgrKykgewogICAgICBjb25zdCB4ID0gc1toXTsKICAgICAgbFt3KytdID0geFswXSwgbFt3KytdID0geFsxXSwgbFt3KytdID0geFsyXTsKICAgIH0KICB9IGVsc2UKICAgIGwgPSBzLnNsaWNlKDApOwogIGlmIChhKQogICAgaWYgKEFycmF5LmlzQXJyYXkoZVswXSkpIHsKICAgICAgdSA9IFtdOwogICAgICBsZXQgeCA9IDA7CiAgICAgIGZvciAoaCA9IDA7IGggPCBlLmxlbmd0aDsgaCsrKSB7CiAgICAgICAgY29uc3QgbSA9IGVbaF07CiAgICAgICAgdVt4KytdID0gbVswXSwgdVt4KytdID0gbVsxXTsKICAgICAgfQogICAgfSBlbHNlCiAgICAgIHUgPSBlLnNsaWNlKDApOwogIGNvbnN0IHkgPSBbXSwgZiA9IHt9LCBnID0ge30sIF8gPSBuICogbjsKICBmb3IgKDsgby5sZW5ndGggPiAwOyApIHsKICAgIGNvbnN0IHcgPSBvLnBvcCgpLCB4ID0gby5wb3AoKSwgbSA9IG8ucG9wKCksIE0gPSBqci5mcm9tQXJyYXkobCwgbSAqIDMpLCB6ID0ga3IuZnJvbUFycmF5KGwsIHggKiAzKSwgUCA9IEJyLmZyb21BcnJheShsLCB3ICogMyk7CiAgICBsZXQgVCwgYiwgTjsKICAgIGEgJiYgKFQgPSBEci5mcm9tQXJyYXkodSwgbSAqIDIpLCBiID0gVXIuZnJvbUFycmF5KHUsIHggKiAyKSwgTiA9IFdyLmZyb21BcnJheSh1LCB3ICogMikpOwogICAgY29uc3QgSSA9IFMubWFnbml0dWRlU3F1YXJlZChTLnN1YnRyYWN0KE0sIHosIGt0KSksIEMgPSBTLm1hZ25pdHVkZVNxdWFyZWQoUy5zdWJ0cmFjdCh6LCBQLCBrdCkpLCBPID0gUy5tYWduaXR1ZGVTcXVhcmVkKFMuc3VidHJhY3QoUCwgTSwga3QpKSwgUiA9IE1hdGgubWF4KEksIEMsIE8pOwogICAgbGV0IEQsIFUsIEw7CiAgICBpZiAoUiA+IF8pCiAgICAgIEkgPT09IFIgPyAoRCA9IGAke01hdGgubWluKG0sIHgpfSAke01hdGgubWF4KG0sIHgpfWAsIGggPSBmW0RdLCBoID09IG51bGwgJiYgKFUgPSBTLmFkZChNLCB6LCBrdCksIFMubXVsdGlwbHlCeVNjYWxhcihVLCAwLjUsIFUpLCBsLnB1c2goVS54LCBVLnksIFUueiksIGggPSBsLmxlbmd0aCAvIDMgLSAxLCBmW0RdID0gaCwgYSAmJiAoTCA9IHV0LmFkZChULCBiLCBrdCksIHV0Lm11bHRpcGx5QnlTY2FsYXIoTCwgMC41LCBMKSwgdS5wdXNoKEwueCwgTC55KSkpLCBvLnB1c2gobSwgaCwgdyksIG8ucHVzaChoLCB4LCB3KSkgOiBDID09PSBSID8gKEQgPSBgJHtNYXRoLm1pbih4LCB3KX0gJHtNYXRoLm1heCh4LCB3KX1gLCBoID0gZltEXSwgaCB8fCAoVSA9IFMuYWRkKHosIFAsIGt0KSwgUy5tdWx0aXBseUJ5U2NhbGFyKFUsIDAuNSwgVSksIGwucHVzaChVLngsIFUueSwgVS56KSwgaCA9IGwubGVuZ3RoIC8gMyAtIDEsIGZbRF0gPSBoLCBhICYmIChMID0gdXQuYWRkKGIsIE4sIGt0KSwgdXQubXVsdGlwbHlCeVNjYWxhcihMLCAwLjUsIEwpLCB1LnB1c2goTC54LCBMLnkpKSksIG8ucHVzaCh4LCBoLCBtKSwgby5wdXNoKGgsIHcsIG0pKSA6IE8gPT09IFIgJiYgKEQgPSBgJHtNYXRoLm1pbih3LCBtKX0gJHtNYXRoLm1heCh3LCBtKX1gLCBoID0gZltEXSwgaCB8fCAoVSA9IFMuYWRkKFAsIE0sIGt0KSwgUy5tdWx0aXBseUJ5U2NhbGFyKFUsIDAuNSwgVSksIGwucHVzaChVLngsIFUueSwgVS56KSwgaCA9IGwubGVuZ3RoIC8gMyAtIDEsIGZbRF0gPSBoLCBhICYmIChMID0gdXQuYWRkKE4sIFQsIGt0KSwgdXQubXVsdGlwbHlCeVNjYWxhcihMLCAwLjUsIEwpLCB1LnB1c2goTC54LCBMLnkpKSksIG8ucHVzaCh3LCBoLCB4KSwgby5wdXNoKGgsIG0sIHgpKTsKICAgIGVsc2UgewogICAgICBpZiAoRnIoCiAgICAgICAgW00sIHosIFBdLAogICAgICAgIFtULCBiLCBOXSwKICAgICAgICBbbSwgeCwgd10sCiAgICAgICAgYSwKICAgICAgICBsLAogICAgICAgIHUsCiAgICAgICAgbywKICAgICAgICByLAogICAgICAgIGcKICAgICAgKSkKICAgICAgICBjb250aW51ZTsKICAgICAgeS5wdXNoKG0gKyBpKSwgeS5wdXNoKHggKyBpKSwgeS5wdXNoKHcgKyBpKTsKICAgIH0KICB9CiAgcmV0dXJuIHsKICAgIHZlcnRpY2VzOiBsLAogICAgdXZzOiB1LAogICAgaW5kaWNlczogeQogIH07Cn0sIFp0ID0gbmV3IHAoKSwgX3QgPSBuZXcgcCgpLCBoaSA9IChzLCB0LCBlLCBuKSA9PiBzID09PSB0IHx8ICFzIHx8ICF0ID8gKG4uY29weShlKSwgbikgOiAocy51bnByb2plY3RDb29yZGluYXRlKGUsIF90KSwgWnQuY29weShfdCksIHQucHJvamVjdENvb3JkaW5hdGUoWnQsIG4pLCBuKSwgUXQgPSAocywgdCwgZSA9ICEwLCBuID0gITApID0+IHsKICBpZiAoIXQuZm9yY2VQcm9qZWN0Q29vcmRpbmF0ZXMgJiYgdC50YXJnZXRQcm9qZWN0aW9uTmFtZSA9PT0gdC5zb3VyY2VQcm9qZWN0aW9uTmFtZSkKICAgIHJldHVybjsKICBjb25zdCBpID0gdC5zb3VyY2VQcm9qZWN0aW9uLCByID0gdC50YXJnZXRQcm9qZWN0aW9uLCBbYSwgbywgaF0gPSB0LnRhcmdldENlbnRlciwgYyA9IHQuZm9yY2VVc2VHZW9Cb3VuZGluZ0JveCB8fCBpLmlzR2VvLCBsID0gYyA/IHQuZ2VvQm91bmRpbmdCb3ggOiB0LnByb2plY3RlZEJvdW5kaW5nQm94OwogIGxldCB1LCBkLCB5LCBmOwogIGlmIChsLmlzQm94MykgewogICAgY29uc3QgdyA9IGwubWluLCB4ID0gbC5tYXg7CiAgICB1ID0gdy54LCBkID0gdy55LCB5ID0geC54LCBmID0geC55OwogIH0gZWxzZQogICAgW3UsIGQsICwgeSwgZl0gPSBsOwogIGNvbnN0IGcgPSB5IC0gdSwgXyA9IGYgLSBkOwogIGlmIChlKQogICAgZm9yIChsZXQgdyA9IDAsIHggPSBzLmxlbmd0aCAtIDI7IHcgPCB4OyB3ICs9IDMpIHsKICAgICAgY29uc3QgbSA9IHNbd10sIE0gPSBzW3cgKyAxXSwgeiA9IHNbdyArIDJdOwogICAgICBadC5zZXQodSArIChtICsgMC41KSAqIGcsIGQgKyAoTSArIDAuNSkgKiBfLCB6KSwgYyA/IHIucHJvamVjdENvb3JkaW5hdGUoWnQsIF90KSA6IGhpKGksIHIsIFp0LCBfdCksIHNbd10gPSBfdC54LCBzW3cgKyAxXSA9IF90LnksIHNbdyArIDJdID0gX3QueiwgbiAmJiAoc1t3XSAtPSBhLCBzW3cgKyAxXSAtPSBvLCBzW3cgKyAyXSAtPSBoKTsKICAgIH0KICBlbHNlCiAgICBmb3IgKGxldCB3ID0gMCwgeCA9IHMubGVuZ3RoOyB3IDwgeDsgdyArPSAxKSB7CiAgICAgIGNvbnN0IG0gPSBzW3ddLCBNID0gbVswXSwgeiA9IG1bMV0sIFAgPSBtWzJdOwogICAgICBadC5zZXQodSArIChNICsgMC41KSAqIGcsIGQgKyAoeiArIDAuNSkgKiBfLCBQKSwgYyA/IHIucHJvamVjdENvb3JkaW5hdGUoWnQsIF90KSA6IGhpKGksIHIsIFp0LCBfdCksIG1bMF0gPSBfdC54LCBtWzFdID0gX3QueSwgbVsyXSA9IF90LnosIG4gJiYgKG1bMF0gLT0gYSwgbVsxXSAtPSBvLCBtWzJdIC09IGgpOwogICAgfQp9LCBWciA9IChzLCB0LCBlLCBuKSA9PiB7CiAgaWYgKG4uc291cmNlUHJvamVjdGlvbk5hbWUgPT09IG4udGFyZ2V0UHJvamVjdGlvbk5hbWUpCiAgICByZXR1cm4gewogICAgICB2ZXJ0aWNlczogcywKICAgICAgaW5kaWNlczogdCwKICAgICAgdXZzOiBlCiAgICB9OwogIGxldCByID0gMSAvIE1hdGgubWF4KDIsIDE2IC0gbi56KTsKICByZXR1cm4gRmkocywgdCwgZSwgcik7Cn07Cm5ldyBwKCk7CmNsYXNzIE9lIHsKICBjb25zdHJ1Y3RvcigpIHsKICAgIHYodGhpcywgImlzUHJvamVjdGlvbiIsICEwKTsKICAgIHYodGhpcywgImlzR2VvIiwgITEpOwogICAgdih0aGlzLCAiaXNBeGlzQWxpZ25lZCIsICExKTsKICB9CiAgcHJvamVjdENvb3JkaW5hdGUodCwgZSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJwcm9qZWN0Q29vcmRpbmF0ZSgpIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gZGVyaXZlZCBjbGFzc2VzIik7CiAgfQogIHVucHJvamVjdENvb3JkaW5hdGUodCwgZSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJ1bnByb2plY3RDb29yZGluYXRlKCkgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBkZXJpdmVkIGNsYXNzZXMiKTsKICB9CiAgZ2VvQm94VG9Qcm9qZWN0ZWRCb3godCwgZSkgewogICAgZSB8fCAoZSA9IG5ldyBTZSgpKTsKICAgIGNvbnN0IG4gPSB0aGlzLnByb2plY3RDb29yZGluYXRlKHQubWluKSwgaSA9IHRoaXMucHJvamVjdENvb3JkaW5hdGUodC5tYXgpOwogICAgcmV0dXJuIGUubWluLmNvcHkobiksIGUubWF4LmNvcHkoaSksIGU7CiAgfQogIGdldEdlb2RldGljU3VyZmFjZU5vcm1hbCh0LCBlKSB7CiAgICByZXR1cm4gZSB8fCAoZSA9IG5ldyBwKCkpLCBlLnNldCgwLCAwLCAxKSwgZTsKICB9CiAgZ2V0UHJvamVjdGVkU3VyZmFjZU5vcm1hbCh0LCBlKSB7CiAgICByZXR1cm4gZSB8fCAoZSA9IG5ldyBwKCkpLCBlLnNldCgwLCAwLCAxKSwgZTsKICB9CiAgcHJvamVjdGVkQm94VG9HZW9Cb3godCwgZSkgewogICAgZSB8fCAoZSA9IG5ldyBTZSgpKTsKICAgIGNvbnN0IG4gPSB0aGlzLnVucHJvamVjdENvb3JkaW5hdGUodC5taW4pLCBpID0gdGhpcy51bnByb2plY3RDb29yZGluYXRlKHQubWF4KTsKICAgIHJldHVybiBlLm1pbi5jb3B5KG4pLCBlLm1heC5jb3B5KGkpLCBlOwogIH0KICBlcXVhbHModCkgewogICAgcmV0dXJuIHQgPyB0aGlzLm5hbWUgPT09IHQubmFtZSA6ICExOwogIH0KICBnZXRXb3JsZEJvdW5kaW5nQm94KCkgewogICAgY29uc3QgdCA9IG5ldyBTZShuZXcgcCgtMTgwLCAtOTAsIC0xMDApLCBuZXcgcCgxODAsIDkwLCAxMDApKTsKICAgIHJldHVybiB0aGlzLmdlb0JveFRvUHJvamVjdGVkQm94KHQpOwogIH0KICBsb2NhbEZyYW1lVG9GaXhlZEZyYW1lKHQsIGUpIHsKICAgIHJldHVybiBlIHx8IChlID0gbmV3IGF0KCkpLCBlLmlkZW50aXR5KCksIGUuc2V0UG9zaXRpb24odCksIGU7CiAgfQp9CmNvbnN0ICRlID0gKHMsIHQsIGUsIG4pID0+IHsKICBpZiAoTWF0aC5hYnMocykgPCBuKQogICAgcmV0dXJuIHQ7CiAgY29uc3QgaSA9IHMgPiAwID8gMSA6IC0xLCBhID0gKE1hdGguYWJzKHMpIC0gbikgLyBuOwogIHJldHVybiBpICogKGUgKiAoMSArIGEpKTsKfSwgSGUgPSAocywgdCwgZSwgbikgPT4gewogIGlmIChNYXRoLmFicyhzKSA8IGUpCiAgICByZXR1cm4gdDsKICBjb25zdCBpID0gcyA+IDAgPyAxIDogLTEsIGEgPSAoTWF0aC5hYnMocykgLSBlKSAvIGU7CiAgcmV0dXJuIGkgKiAobiAqICgxICsgYSkpOwp9LCBjaSA9IE1hdGguUEkgLyAxODAsIEplID0gNjM3ODEzNywgU3QgPSAyMDAzNzUwOCwgbGkgPSAxODAgLyBNYXRoLlBJLCBWaSA9IDg1LjA1MTEyODc3OTg7CmZ1bmN0aW9uIEdyKHMsIHQgPSBudWxsLCBlID0gITEpIHsKICB2YXIgbiA9IE1hdGguYWJzKHNbMF0pIDw9IDE4MCA/IHNbMF0gOiBzWzBdIC0gWXIoc1swXSkgKiAzNjA7CiAgY29uc3QgaSA9IHQgfHwgWzAsIDBdOwogIHJldHVybiBpWzBdID0gSmUgKiBuICogY2ksIGlbMV0gPSBKZSAqIE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgKiAwLjI1ICsgMC41ICogc1sxXSAqIGNpKSksIGUgPyAoaVswXSA9IEhlKHNbMF0sIGlbMF0sIDE4MCwgU3QpLCBpWzFdID0gSGUoc1sxXSwgaVsxXSwgVmksIFN0KSkgOiAoaVswXSA+IFN0ICYmIChpWzBdID0gU3QpLCBpWzBdIDwgLVN0ICYmIChpWzBdID0gLVN0KSwgaVsxXSA+IFN0ICYmIChpWzFdID0gU3QpLCBpWzFdIDwgLVN0ICYmIChpWzFdID0gLVN0KSksIGk7Cn0KZnVuY3Rpb24gWnIocywgdCwgZSA9ICExKSB7CiAgY29uc3QgbiA9IHQgfHwgWzAsIDBdOwogIHJldHVybiBuWzBdID0gc1swXSAqIGxpIC8gSmUsIG5bMV0gPSAoTWF0aC5QSSAqIDAuNSAtIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoLXNbMV0gLyBKZSkpKSAqIGxpLCBlICYmIChuWzBdID0gJGUoc1swXSwgblswXSwgMTgwLCBTdCksIG5bMV0gPSAkZShzWzFdLCBuWzFdLCBWaSwgU3QpKSwgbjsKfQpmdW5jdGlvbiBZcihzKSB7CiAgcmV0dXJuIHMgPCAwID8gLTEgOiBzID4gMCA/IDEgOiAwOwp9CmNvbnN0IHVpID0gWzAsIDBdOwpjbGFzcyBYciBleHRlbmRzIE9lIHsKICBjb25zdHJ1Y3RvcigpIHsKICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7CiAgICB2KHRoaXMsICJuYW1lIiwgVGUpOwogICAgdih0aGlzLCAiaXNBeGlzQWxpZ25lZCIsICEwKTsKICB9CiAgcHJvamVjdENvb3JkaW5hdGUoZSwgbikgewogICAgY29uc3QgaSA9IEdyKFtlLngsIGUueV0sIHVpLCAhMCk7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBwKCkpLCBuLnggPSBpWzBdLCBuLnkgPSBpWzFdLCBuLnogPSBlLnosIG47CiAgfQogIHVucHJvamVjdENvb3JkaW5hdGUoZSwgbikgewogICAgY29uc3QgaSA9IFpyKFtlLngsIGUueV0sIHVpLCAhMCk7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBwKCkpLCBuLnggPSBpWzBdLCBuLnkgPSBpWzFdLCBuLnogPSBlLnosIG47CiAgfQp9CmNvbnN0IFFyID0gewogIE9VVFNJREU6IC0xLAogIElOVEVSU0VDVElORzogMCwKICBJTlNJREU6IDEKfTsKdmFyIFNuID0gT2JqZWN0LmZyZWV6ZShRcik7CmNsYXNzIHd0IHsKICBjb25zdHJ1Y3Rvcih0LCBlKSB7CiAgICB0aGlzLmlzT3JpZW50ZWRCb3VuZGluZ0JveCA9ICEwLCB0aGlzLmNlbnRlciA9IFMuY2xvbmUoRyh0LCBTLlpFUk8pLCBuZXcgcCgpKSwgdGhpcy5oYWxmQXhlcyA9IEIuY2xvbmUoRyhlLCBCLlpFUk8pKTsKICB9CiAgaW50ZXJzZWN0UGxhbmUodCkgewogICAgcmV0dXJuIHd0LmludGVyc2VjdFBsYW5lKHRoaXMsIHQpOwogIH0KICBkaXN0YW5jZVNxdWFyZWRUbyh0KSB7CiAgICByZXR1cm4gd3QuZGlzdGFuY2VTcXVhcmVkVG8odGhpcywgdCk7CiAgfQogIGNvbXB1dGVDb3JuZXJzKHQpIHsKICAgIHJldHVybiB3dC5jb21wdXRlQ29ybmVycyh0aGlzLCB0KTsKICB9CiAgZ2V0Q2VudGVyKHQpIHsKICAgIHJldHVybiBBKHQpID8gKHQuY29weSh0aGlzLmNlbnRlciksIHQpIDogdGhpcy5jZW50ZXIuY2xvbmUoKTsKICB9CiAgaW50ZXJzZWN0c09iYih0KSB7CiAgICBjb25zdCBlID0gdGhpcy5jZW50ZXIsIG4gPSB0LmNlbnRlciwgaSA9IHRoaXMuaGFsZkF4ZXMsIHIgPSB0LmhhbGZBeGVzLCBhID0gbmV3IHAoKS5zdWJWZWN0b3JzKG4sIGUpLCBvID0gbmV3IHAoaS5lbGVtZW50c1swXSwgaS5lbGVtZW50c1sxXSwgaS5lbGVtZW50c1syXSksIGggPSBuZXcgcChpLmVsZW1lbnRzWzNdLCBpLmVsZW1lbnRzWzRdLCBpLmVsZW1lbnRzWzVdKSwgYyA9IG5ldyBwKGkuZWxlbWVudHNbNl0sIGkuZWxlbWVudHNbN10sIGkuZWxlbWVudHNbOF0pLCBsID0gbmV3IHAoci5lbGVtZW50c1swXSwgci5lbGVtZW50c1sxXSwgci5lbGVtZW50c1syXSksIHUgPSBuZXcgcChyLmVsZW1lbnRzWzNdLCByLmVsZW1lbnRzWzRdLCByLmVsZW1lbnRzWzVdKSwgZCA9IG5ldyBwKHIuZWxlbWVudHNbNl0sIHIuZWxlbWVudHNbN10sIHIuZWxlbWVudHNbOF0pLCB5ID0gby5sZW5ndGgoKSwgZiA9IGgubGVuZ3RoKCksIGcgPSBjLmxlbmd0aCgpOwogICAgby5ub3JtYWxpemUoKSwgaC5ub3JtYWxpemUoKSwgYy5ub3JtYWxpemUoKTsKICAgIGNvbnN0IF8gPSBsLmxlbmd0aCgpLCB3ID0gdS5sZW5ndGgoKSwgeCA9IGQubGVuZ3RoKCk7CiAgICBsLm5vcm1hbGl6ZSgpLCB1Lm5vcm1hbGl6ZSgpLCBkLm5vcm1hbGl6ZSgpOwogICAgbGV0IG0sIE0sIHo7CiAgICByZXR1cm4gbSA9IHksIE0gPSBfICogTWF0aC5hYnMoby5kb3QobCkpICsgdyAqIE1hdGguYWJzKG8uZG90KHUpKSArIHggKiBNYXRoLmFicyhvLmRvdChkKSksIHogPSBNYXRoLmFicyhhLmRvdChvKSksICEoeiA+IG0gKyBNIHx8IChtID0gZiwgTSA9IF8gKiBNYXRoLmFicyhoLmRvdChsKSkgKyB3ICogTWF0aC5hYnMoaC5kb3QodSkpICsgeCAqIE1hdGguYWJzKGguZG90KGQpKSwgeiA9IE1hdGguYWJzKGEuZG90KGgpKSwgeiA+IG0gKyBNKSB8fCAobSA9IGcsIE0gPSBfICogTWF0aC5hYnMoYy5kb3QobCkpICsgdyAqIE1hdGguYWJzKGMuZG90KHUpKSArIHggKiBNYXRoLmFicyhjLmRvdChkKSksIHogPSBNYXRoLmFicyhhLmRvdChjKSksIHogPiBtICsgTSkgfHwgKG0gPSB5ICogTWF0aC5hYnMobC5kb3QobykpICsgZiAqIE1hdGguYWJzKGwuZG90KGgpKSArIGcgKiBNYXRoLmFicyhsLmRvdChjKSksIE0gPSBfLCB6ID0gTWF0aC5hYnMoYS5kb3QobCkpLCB6ID4gbSArIE0pIHx8IChtID0geSAqIE1hdGguYWJzKHUuZG90KG8pKSArIGYgKiBNYXRoLmFicyh1LmRvdChoKSkgKyBnICogTWF0aC5hYnModS5kb3QoYykpLCBNID0gdywgeiA9IE1hdGguYWJzKGEuZG90KHUpKSwgeiA+IG0gKyBNKSB8fCAobSA9IHkgKiBNYXRoLmFicyhkLmRvdChvKSkgKyBmICogTWF0aC5hYnMoZC5kb3QoaCkpICsgZyAqIE1hdGguYWJzKGQuZG90KGMpKSwgTSA9IHgsIHogPSBNYXRoLmFicyhhLmRvdChkKSksIHogPiBtICsgTSkpOwogIH0KfQpjb25zdCBHaSA9IG5ldyBwKCksICRyID0gbmV3IHAoKTsKZnVuY3Rpb24gZGkocywgdCwgZSwgbiwgaSwgciwgYSwgbywgaCwgYywgbCkgewogIGlmICghQShpKSB8fCAhQShyKSB8fCAhQShhKSB8fCAhQShvKSB8fCAhQShoKSB8fCAhQShjKSkKICAgIHRocm93IG5ldyBqKAogICAgICAiYWxsIGV4dGVudHMgKG1pbmltdW0vbWF4aW11bSBYL1kvWikgYXJlIHJlcXVpcmVkLiIKICAgICk7CiAgQShsKSB8fCAobCA9IG5ldyB3dCgpKTsKICBjb25zdCB1ID0gbC5oYWxmQXhlczsKICBCLnNldENvbHVtbih1LCAwLCB0LCB1KSwgQi5zZXRDb2x1bW4odSwgMSwgZSwgdSksIEIuc2V0Q29sdW1uKHUsIDIsIG4sIHUpOwogIGxldCBkID0gR2k7CiAgZC54ID0gKGkgKyByKSAvIDIsIGQueSA9IChhICsgbykgLyAyLCBkLnogPSAoaCArIGMpIC8gMjsKICBjb25zdCB5ID0gJHI7CiAgeS54ID0gKHIgLSBpKSAvIDIsIHkueSA9IChvIC0gYSkgLyAyLCB5LnogPSAoYyAtIGgpIC8gMjsKICBjb25zdCBmID0gbC5jZW50ZXI7CiAgcmV0dXJuIGQgPSBCLm11bHRpcGx5QnlWZWN0b3IodSwgZCwgZCksIFMuYWRkKHMsIGQsIGYpLCBCLm11bHRpcGx5QnlTY2FsZSh1LCB5LCB1KSwgbDsKfQpjb25zdCB5aSA9IG5ldyBwKCksIEhyID0gbmV3IHAoKSwgSnIgPSBuZXcgcCgpLCBLciA9IG5ldyBwKCksIHRhID0gbmV3IHAoKSwgZWEgPSBuZXcgcCgpLCBuYSA9IG5ldyBwKCksIGlhID0gbmV3IHAoKSwgbWkgPSBuZXcgcCgpLCBzYSA9IG5ldyBwKCksIGZpID0gbmV3IHAoKSwgcmEgPSBuZXcgcCgpLCBhYSA9IG5ldyBGKCksIG9hID0gbmV3IEYoKSwgaGEgPSBuZXcgRigpLCBjYSA9IG5ldyBGKCksIGxhID0gbmV3IEYoKSwgdWEgPSBuZXcgcCgpLCBkYSA9IG5ldyBwKCksIHlhID0gbmV3IHAoKSwgbWEgPSBuZXcgcCgpLCBmYSA9IG5ldyBGKCksIHhhID0gbmV3IHAoKSwgd2EgPSBuZXcgcCgpLCB6YSA9IG5ldyBwKCksIGdhID0gbmV3IHplKG5ldyBwKDEsIDAsIDApLCAwKTsKd3QuZnJvbVJlY3RhbmdsZSA9IGZ1bmN0aW9uKHMsIHQsIGUsIG4sIGkpIHsKICBpZiAoIUEocykpCiAgICB0aHJvdyBuZXcgaigicmVjdGFuZ2xlIGlzIHJlcXVpcmVkIik7CiAgaWYgKHMud2lkdGggPCAwIHx8IHMud2lkdGggPiBFLlRXT19QSSkKICAgIHRocm93IG5ldyBqKCJSZWN0YW5nbGUgd2lkdGggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDIgKiBwaSIpOwogIGlmIChzLmhlaWdodCA8IDAgfHwgcy5oZWlnaHQgPiBFLlBJKQogICAgdGhyb3cgbmV3IGooIlJlY3RhbmdsZSBoZWlnaHQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIHBpIik7CiAgaWYgKEEobikgJiYgIUUuZXF1YWxzRXBzaWxvbigKICAgIG4ucmFkaWkueCwKICAgIG4ucmFkaWkueSwKICAgIEUuRVBTSUxPTjE1CiAgKSkKICAgIHRocm93IG5ldyBqKAogICAgICAiRWxsaXBzb2lkIG11c3QgYmUgYW4gZWxsaXBzb2lkIG9mIHJldm9sdXRpb24gKHJhZGlpLnggPT0gcmFkaWkueSkiCiAgICApOwogIHQgPSBHKHQsIDApLCBlID0gRyhlLCAwKSwgbiA9IEcobiwgZHQuV0dTODQpOwogIGxldCByLCBhLCBvLCBoLCBjLCBsLCB1OwogIGlmIChzLndpZHRoIDw9IEUuUEkpIHsKICAgIGNvbnN0IFQgPSAkLmNlbnRlcigKICAgICAgcywKICAgICAgeWkKICAgICksIGIgPSBuLmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKAogICAgICBULAogICAgICBIcgogICAgKSwgTiA9IG5ldyBJZShiLCBuKTsKICAgIHUgPSBOLnBsYW5lOwogICAgY29uc3QgSSA9IFQueCwgQyA9IHMuc291dGggPCAwICYmIHMubm9ydGggPiAwID8gMCA6IFQueSwgTyA9IFJ0LmZyb21SYWRpYW5zKAogICAgICBJLAogICAgICBzLm5vcnRoLAogICAgICBlLAogICAgICBKcgogICAgKSwgUiA9IFJ0LmZyb21SYWRpYW5zKAogICAgICBzLndlc3QsCiAgICAgIHMubm9ydGgsCiAgICAgIGUsCiAgICAgIEtyCiAgICApLCBEID0gUnQuZnJvbVJhZGlhbnMoCiAgICAgIHMud2VzdCwKICAgICAgQywKICAgICAgZSwKICAgICAgdGEKICAgICksIFUgPSBSdC5mcm9tUmFkaWFucygKICAgICAgcy53ZXN0LAogICAgICBzLnNvdXRoLAogICAgICBlLAogICAgICBlYQogICAgKSwgTCA9IFJ0LmZyb21SYWRpYW5zKAogICAgICBJLAogICAgICBzLnNvdXRoLAogICAgICBlLAogICAgICBuYQogICAgKSwgcSA9IG4uY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgIE8sCiAgICAgIGlhCiAgICApOwogICAgbGV0IGsgPSBuLmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKAogICAgICBSLAogICAgICBtaQogICAgKTsKICAgIGNvbnN0IFcgPSBuLmNhcnRvZ3JhcGhpY1RvQ2FydGVzaWFuKAogICAgICBELAogICAgICBzYQogICAgKTsKICAgIGxldCBYID0gbi5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgVSwKICAgICAgZmkKICAgICk7CiAgICBjb25zdCBaID0gbi5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgTCwKICAgICAgcmEKICAgICksIGh0ID0gTi5wcm9qZWN0UG9pbnRUb05lYXJlc3RPblBsYW5lKAogICAgICBxLAogICAgICBhYQogICAgKSwgdHQgPSBOLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgIGssCiAgICAgIG9hCiAgICApLCBldCA9IE4ucHJvamVjdFBvaW50VG9OZWFyZXN0T25QbGFuZSgKICAgICAgVywKICAgICAgaGEKICAgICksIEVlID0gTi5wcm9qZWN0UG9pbnRUb05lYXJlc3RPblBsYW5lKAogICAgICBYLAogICAgICBjYQogICAgKSwgQWUgPSBOLnByb2plY3RQb2ludFRvTmVhcmVzdE9uUGxhbmUoCiAgICAgIFosCiAgICAgIGxhCiAgICApOwogICAgcmV0dXJuIHIgPSBNYXRoLm1pbigKICAgICAgdHQueCwKICAgICAgZXQueCwKICAgICAgRWUueAogICAgKSwgYSA9IC1yLCBoID0gTWF0aC5tYXgodHQueSwgaHQueSksIG8gPSBNYXRoLm1pbihFZS55LCBBZS55KSwgUi56ID0gVS56ID0gdCwgayA9IG4uY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgIFIsCiAgICAgIG1pCiAgICApLCBYID0gbi5jYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbigKICAgICAgVSwKICAgICAgZmkKICAgICksIGMgPSBNYXRoLm1pbigKICAgICAgeHQuZ2V0UG9pbnREaXN0YW5jZSh1LCBrKSwKICAgICAgeHQuZ2V0UG9pbnREaXN0YW5jZSh1LCBYKQogICAgKSwgbCA9IGUsIGRpKAogICAgICBOLm9yaWdpbiwKICAgICAgTi54QXhpcywKICAgICAgTi55QXhpcywKICAgICAgTi56QXhpcywKICAgICAgciwKICAgICAgYSwKICAgICAgbywKICAgICAgaCwKICAgICAgYywKICAgICAgbCwKICAgICAgaQogICAgKTsKICB9CiAgY29uc3QgZCA9IHMuc291dGggPiAwLCB5ID0gcy5ub3J0aCA8IDAsIGYgPSBkID8gcy5zb3V0aCA6IHkgPyBzLm5vcnRoIDogMCwgZyA9ICQuY2VudGVyKAogICAgcywKICAgIHlpCiAgKS54LCBfID0gUy5mcm9tUmFkaWFucygKICAgIGcsCiAgICBmLAogICAgZSwKICAgIG4sCiAgICB1YQogICk7CiAgXy56ID0gMDsKICBjb25zdCB4ID0gTWF0aC5hYnMoXy54KSA8IEUuRVBTSUxPTjEwICYmIE1hdGguYWJzKF8ueSkgPCBFLkVQU0lMT04xMCA/IFMuVU5JVF9YIDogUy5ub3JtYWxpemUoXywgZGEpLCBtID0gUy5VTklUX1osIE0gPSBTLmNyb3NzKAogICAgeCwKICAgIG0sCiAgICB5YQogICk7CiAgdSA9IHh0LmZyb21Qb2ludE5vcm1hbChfLCB4LCBnYSk7CiAgY29uc3QgeiA9IFMuZnJvbVJhZGlhbnMoCiAgICBnICsgRS5QSV9PVkVSX1RXTywKICAgIGYsCiAgICBlLAogICAgbiwKICAgIG1hCiAgKTsKICBhID0gUy5kb3QoCiAgICB4dC5wcm9qZWN0UG9pbnRPbnRvUGxhbmUoCiAgICAgIHUsCiAgICAgIHosCiAgICAgIGZhCiAgICApLAogICAgTQogICksIHIgPSAtYSwgaCA9IFMuZnJvbVJhZGlhbnMoCiAgICAwLAogICAgcy5ub3J0aCwKICAgIHkgPyB0IDogZSwKICAgIG4sCiAgICB4YQogICkueiwgbyA9IFMuZnJvbVJhZGlhbnMoCiAgICAwLAogICAgcy5zb3V0aCwKICAgIGQgPyB0IDogZSwKICAgIG4sCiAgICB3YQogICkuejsKICBjb25zdCBQID0gUy5mcm9tUmFkaWFucygKICAgIHMuZWFzdCwKICAgIGYsCiAgICBlLAogICAgbiwKICAgIHphCiAgKTsKICByZXR1cm4gYyA9IHh0LmdldFBvaW50RGlzdGFuY2UodSwgUCksIGwgPSAwLCBkaSgKICAgIF8sCiAgICBNLAogICAgbSwKICAgIHgsCiAgICByLAogICAgYSwKICAgIG8sCiAgICBoLAogICAgYywKICAgIGwsCiAgICBpCiAgKTsKfTsKY29uc3QgTWEgPSBuZXcgcCgpLCBwYSA9IG5ldyBwKCksIF9hID0gbmV3IHAoKSwgU2EgPSBuZXcgcCgpLCB4aSA9IG5ldyBwKCksIFBhID0gbmV3IHAoKTsKd3QuZGlzdGFuY2VTcXVhcmVkVG8gPSBmdW5jdGlvbihzLCB0KSB7CiAgaWYgKCFBKHMpKQogICAgdGhyb3cgbmV3IGooImJveCBpcyByZXF1aXJlZC4iKTsKICBpZiAoIUEodCkpCiAgICB0aHJvdyBuZXcgaigiY2FydGVzaWFuIGlzIHJlcXVpcmVkLiIpOwogIGNvbnN0IGUgPSBTLnN1YnRyYWN0KHQsIHMuY2VudGVyLCBHaSksIG4gPSBzLmhhbGZBeGVzOwogIGxldCBpID0gQi5nZXRDb2x1bW4obiwgMCwgTWEpLCByID0gQi5nZXRDb2x1bW4obiwgMSwgcGEpLCBhID0gQi5nZXRDb2x1bW4obiwgMiwgX2EpOwogIGNvbnN0IG8gPSBTLm1hZ25pdHVkZShpKSwgaCA9IFMubWFnbml0dWRlKHIpLCBjID0gUy5tYWduaXR1ZGUoYSk7CiAgbGV0IGwgPSAhMCwgdSA9ICEwLCBkID0gITA7CiAgbyA+IDAgPyBTLmRpdmlkZUJ5U2NhbGFyKGksIG8sIGkpIDogbCA9ICExLCBoID4gMCA/IFMuZGl2aWRlQnlTY2FsYXIociwgaCwgcikgOiB1ID0gITEsIGMgPiAwID8gUy5kaXZpZGVCeVNjYWxhcihhLCBjLCBhKSA6IGQgPSAhMTsKICBjb25zdCB5ID0gIWwgKyAhdSArICFkOwogIGxldCBmLCBnLCBfOwogIGlmICh5ID09PSAxKSB7CiAgICBsZXQgTSA9IGk7CiAgICBmID0gciwgZyA9IGEsIHUgPyBkIHx8IChNID0gYSwgZyA9IGkpIDogKE0gPSByLCBmID0gaSksIF8gPSBTLmNyb3NzKGYsIGcsIHhpKSwgTSA9PT0gaSA/IGkgPSBfIDogTSA9PT0gciA/IHIgPSBfIDogTSA9PT0gYSAmJiAoYSA9IF8pOwogIH0gZWxzZSBpZiAoeSA9PT0gMikgewogICAgZiA9IGksIHUgPyBmID0gciA6IGQgJiYgKGYgPSBhKTsKICAgIGxldCBNID0gUy5VTklUX1k7CiAgICBTLmVxdWFsc0Vwc2lsb24oTSwgZiwgRS5FUFNJTE9OMykgJiYgKE0gPSBTLlVOSVRfWCksIGcgPSBTLmNyb3NzKGYsIE0sIFNhKSwgUy5ub3JtYWxpemUoZywgZyksIF8gPSBTLmNyb3NzKGYsIGcsIHhpKSwgUy5ub3JtYWxpemUoXywgXyksIGYgPT09IGkgPyAociA9IGcsIGEgPSBfKSA6IGYgPT09IHIgPyAoYSA9IGcsIGkgPSBfKSA6IGYgPT09IGEgJiYgKGkgPSBnLCByID0gXyk7CiAgfSBlbHNlCiAgICB5ID09PSAzICYmIChpID0gUy5VTklUX1gsIHIgPSBTLlVOSVRfWSwgYSA9IFMuVU5JVF9aKTsKICBjb25zdCB3ID0gUGE7CiAgdy54ID0gUy5kb3QoZSwgaSksIHcueSA9IFMuZG90KGUsIHIpLCB3LnogPSBTLmRvdChlLCBhKTsKICBsZXQgeCA9IDAsIG07CiAgcmV0dXJuIHcueCA8IC1vID8gKG0gPSB3LnggKyBvLCB4ICs9IG0gKiBtKSA6IHcueCA+IG8gJiYgKG0gPSB3LnggLSBvLCB4ICs9IG0gKiBtKSwgdy55IDwgLWggPyAobSA9IHcueSArIGgsIHggKz0gbSAqIG0pIDogdy55ID4gaCAmJiAobSA9IHcueSAtIGgsIHggKz0gbSAqIG0pLCB3LnogPCAtYyA/IChtID0gdy56ICsgYywgeCArPSBtICogbSkgOiB3LnogPiBjICYmIChtID0gdy56IC0gYywgeCArPSBtICogbSksIHg7Cn07Cnd0LmludGVyc2VjdFBsYW5lID0gZnVuY3Rpb24ocywgdCkgewogIGlmICghQShzKSkKICAgIHRocm93IG5ldyBqKCJib3ggaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFBKHQpKQogICAgdGhyb3cgbmV3IGooInBsYW5lIGlzIHJlcXVpcmVkLiIpOwogIGNvbnN0IGUgPSBzLmNlbnRlciwgbiA9IHQubm9ybWFsLCBpID0gcy5oYWxmQXhlcywgciA9IG4ueCwgYSA9IG4ueSwgbyA9IG4ueiwgaCA9IGkuZWxlbWVudHMsIGMgPSBNYXRoLmFicygKICAgIHIgKiBoW0IuQ09MVU1OMFJPVzBdICsgYSAqIGhbQi5DT0xVTU4wUk9XMV0gKyBvICogaFtCLkNPTFVNTjBST1cyXQogICkgKyBNYXRoLmFicygKICAgIHIgKiBoW0IuQ09MVU1OMVJPVzBdICsgYSAqIGhbQi5DT0xVTU4xUk9XMV0gKyBvICogaFtCLkNPTFVNTjFST1cyXQogICkgKyBNYXRoLmFicygKICAgIHIgKiBoW0IuQ09MVU1OMlJPVzBdICsgYSAqIGhbQi5DT0xVTU4yUk9XMV0gKyBvICogaFtCLkNPTFVNTjJST1cyXQogICksIGwgPSBTLmRvdChuLmNsb25lKCksIGUpICsgdC5jb25zdGFudDsKICByZXR1cm4gbCA8PSAtYyA/IFNuLk9VVFNJREUgOiBsID49IGMgPyBTbi5JTlNJREUgOiBTbi5JTlRFUlNFQ1RJTkc7Cn07CmNvbnN0IGJhID0gbmV3IHAoKSwgVGEgPSBuZXcgcCgpLCBJYSA9IG5ldyBwKCk7Cnd0LmNvbXB1dGVDb3JuZXJzID0gZnVuY3Rpb24ocywgdCkgewogIEEodCkgfHwgKHQgPSBbCiAgICBuZXcgcCgpLAogICAgbmV3IHAoKSwKICAgIG5ldyBwKCksCiAgICBuZXcgcCgpLAogICAgbmV3IHAoKSwKICAgIG5ldyBwKCksCiAgICBuZXcgcCgpLAogICAgbmV3IHAoKQogIF0pOwogIGNvbnN0IGUgPSBzLmNlbnRlciwgbiA9IHMuaGFsZkF4ZXMsIGkgPSBCLmdldENvbHVtbihuLCAwLCBiYSksIHIgPSBCLmdldENvbHVtbihuLCAxLCBUYSksIGEgPSBCLmdldENvbHVtbihuLCAyLCBJYSk7CiAgcmV0dXJuIFMuY2xvbmUoZSwgdFswXSksIFMuc3VidHJhY3QodFswXSwgaSwgdFswXSksIFMuc3VidHJhY3QodFswXSwgciwgdFswXSksIFMuc3VidHJhY3QodFswXSwgYSwgdFswXSksIFMuY2xvbmUoZSwgdFsxXSksIFMuc3VidHJhY3QodFsxXSwgaSwgdFsxXSksIFMuc3VidHJhY3QodFsxXSwgciwgdFsxXSksIFMuYWRkKHRbMV0sIGEsIHRbMV0pLCBTLmNsb25lKGUsIHRbMl0pLCBTLnN1YnRyYWN0KHRbMl0sIGksIHRbMl0pLCBTLmFkZCh0WzJdLCByLCB0WzJdKSwgUy5zdWJ0cmFjdCh0WzJdLCBhLCB0WzJdKSwgUy5jbG9uZShlLCB0WzNdKSwgUy5zdWJ0cmFjdCh0WzNdLCBpLCB0WzNdKSwgUy5hZGQodFszXSwgciwgdFszXSksIFMuYWRkKHRbM10sIGEsIHRbM10pLCBTLmNsb25lKGUsIHRbNF0pLCBTLmFkZCh0WzRdLCBpLCB0WzRdKSwgUy5zdWJ0cmFjdCh0WzRdLCByLCB0WzRdKSwgUy5zdWJ0cmFjdCh0WzRdLCBhLCB0WzRdKSwgUy5jbG9uZShlLCB0WzVdKSwgUy5hZGQodFs1XSwgaSwgdFs1XSksIFMuc3VidHJhY3QodFs1XSwgciwgdFs1XSksIFMuYWRkKHRbNV0sIGEsIHRbNV0pLCBTLmNsb25lKGUsIHRbNl0pLCBTLmFkZCh0WzZdLCBpLCB0WzZdKSwgUy5hZGQodFs2XSwgciwgdFs2XSksIFMuc3VidHJhY3QodFs2XSwgYSwgdFs2XSksIFMuY2xvbmUoZSwgdFs3XSksIFMuYWRkKHRbN10sIGksIHRbN10pLCBTLmFkZCh0WzddLCByLCB0WzddKSwgUy5hZGQodFs3XSwgYSwgdFs3XSksIHQ7Cn07Cnd0LmZyb21HZW9Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKHMsIHQpIHsKICBpZiAoIUEocykpCiAgICB0aHJvdyBuZXcgaigiZ2VvQm91bmRpbmdCb3ggaXMgcmVxdWlyZWQuIik7CiAgY29uc3QgZSA9IHMubWluLCBuID0gcy5tYXgsIGkgPSAkLmZyb21Cb3gocywgbnVsbCwgITApOwogIHJldHVybiB3dC5mcm9tUmVjdGFuZ2xlKAogICAgaSwKICAgIGUueiwKICAgIG4ueiwKICAgIG51bGwsCiAgICB0CiAgKTsKfTsKY2xhc3MgQ2EgZXh0ZW5kcyBPZSB7CiAgY29uc3RydWN0b3IoKSB7CiAgICBzdXBlciguLi5hcmd1bWVudHMpOwogICAgdih0aGlzLCAibmFtZSIsIG5uKTsKICB9CiAgcHJvamVjdENvb3JkaW5hdGUoZSwgbikgewogICAgcmV0dXJuIGR0LldHUzg0LmNhcnRvZ3JhcGhpY0RlZ3JlZVRvQ2FydGVzaWFuKGUsIG4pOwogIH0KICB1bnByb2plY3RDb29yZGluYXRlKGUsIG4pIHsKICAgIHJldHVybiBkdC5XR1M4NC5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY0RlZ3JlZShlLCBuKTsKICB9CiAgZ2V0R2VvZGV0aWNTdXJmYWNlTm9ybWFsKGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IHAoKSksIGR0LldHUzg0Lmdlb2RldGljU3VyZmFjZU5vcm1hbENhcnRvZ3JhcGhpYyhlLCBuKTsKICB9CiAgZ2V0UHJvamVjdGVkU3VyZmFjZU5vcm1hbChlLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBwKCkpLCBkdC5XR1M4NC5nZW9kZXRpY1N1cmZhY2VOb3JtYWwoZSwgbik7CiAgfQogIGdlb0JveFRvUHJvamVjdGVkQm94KGUsIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IHd0KCkpLCBuID0gd3QuZnJvbUdlb0JvdW5kaW5nQm94KGUsIG4pLCBuOwogIH0KICBnZXRMT0RTYWNsZU9mR2VvQm91bmRpbmdCb3goZSkgewogICAgaWYgKGUubWluLnkgPiA4NSB8fCBlLm1heC55IDwgLTg1KQogICAgICByZXR1cm4gMDsKICAgIGNvbnN0IG4gPSAoZS5taW4ueSArIGUubWF4LnkpIC8gMjsKICAgIHJldHVybiBNYXRoLmNvcyhOdC5kZWdUb1JhZChuKSk7CiAgfQogIGxvY2FsRnJhbWVUb0ZpeGVkRnJhbWUoZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgYXQoKSksIG90LmVhc3ROb3J0aFVwVG9GaXhlZEZyYW1lKGUsIG51bGwsIG4pLCBuOwogIH0KfQpmdW5jdGlvbiBZdCgpIHsKfQpmdW5jdGlvbiBBbihzLCB0KSB7CiAgZm9yIChsZXQgZSBpbiB0KQogICAgc1tlXSA9IHRbZV07Cn0KZnVuY3Rpb24gZnQocywgdCkgewogIHRoaXMubG5nID0gcywgdGhpcy5sYXQgPSB0Owp9CkFuKGZ0LnByb3RvdHlwZSwgewogIGVxdWFsczogZnVuY3Rpb24ocykgewogICAgcmV0dXJuIHRoaXMubGF0ID09PSBzLmxhdCAmJiB0aGlzLmxuZyA9PT0gcy5sbmc7CiAgfSwKICBjbG9uZTogZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gbmV3IGZ0KHRoaXMubGF0LCB0aGlzLmxuZyk7CiAgfSwKICBnZXRMbmdTcGFuOiBmdW5jdGlvbihzKSB7CiAgICBsZXQgdCA9IHRoaXMubG5nLCBlID0gTWF0aC5hYnMocyAtIHQpOwogICAgcmV0dXJuIGUgPiAxODAgJiYgKGUgPSAzNjAgLSBlKSwgZTsKICB9LAogIHN1YjogZnVuY3Rpb24ocykgewogICAgcmV0dXJuIG5ldyBmdCh0aGlzLmxhdCAtIHMubGF0LCB0aGlzLmxuZyAtIHMubG5nKTsKICB9LAogIHRvU3RyaW5nOiBmdW5jdGlvbigpIHsKICAgIHJldHVybiAiUG9pbnQiOwogIH0KfSk7CmZ1bmN0aW9uIHdpKHMsIHQpIHsKICB0aGlzLnggPSBzLCB0aGlzLnkgPSB0Owp9CkFuKFl0LCB7CiAgRUFSVEhSQURJVVM6IDYzNzA5OTY4MWUtMiwKICBNQ0JBTkQ6IFsxMjg5MDU5NDg2ZS0yLCA4MzYyMzc3ODdlLTIsIDU1OTEwMjEsIDM0ODE5ODk4M2UtMiwgMTY3ODA0MzEyZS0yLCAwXSwKICBMTEJBTkQ6IFs3NSwgNjAsIDQ1LCAzMCwgMTUsIDBdLAogIE1DMkxMOiBbCiAgICBbMTQxMDUyNjE3MjExNjI1NWUtMjMsIDg5ODMwNTUwOTY0ODg3MmUtMjAsIC0xLjk5Mzk4MzM4MTYzMzEsIDIwMC45ODI0MzgzMTA2Nzk2LCAtMTg3LjI0MDM3MDM4MTU1NDcsIDkxLjYwODc1MTY2Njk4NDMsIC0yMy4zODc2NTY0OTYwMzMzOSwgMi41NzEyMTMxNzI5NjE5OCwgLTAuMDM4MDEwMDMzMDg2NTMsIDE3MzM3OTgxMmUtMV0sCiAgICBbLTc0MzU4NTYzODk1NjU1MzdlLTI0LCA4OTgzMDU1MDk3NzI2MjM5ZS0yMSwgLTAuNzg2MjUyMDE4ODYyODksIDk2LjMyNjg3NTk5NzU5ODQ2LCAtMS44NTIwNDc1NzUyOTgyNiwgLTU5LjM2OTM1OTA1NDg1ODc3LCA0Ny40MDAzMzU0OTI5NjczNywgLTE2LjUwNzQxOTMxMDYzODg3LCAyLjI4Nzg2Njc0Njk5Mzc1LCAxMDI2MDE0NDg2ZS0yXSwKICAgIFstMzAzMDg4MzQ2MDg5ODgyNmUtMjMsIDg5ODMwNTUwOTk4MzU3OGUtMjAsIDAuMzAwNzEzMTYyODc2MTYsIDU5Ljc0MjkzNjE4NDQyMjc3LCA3LjM1Nzk4NDA3NDg3MSwgLTI1LjM4MzcxMDAyNjY0NzQ1LCAxMy40NTM4MDUyMTExMDkwOCwgLTMuMjk4ODM3NjcyMzU1ODQsIDAuMzI3MTA5MDUzNjM0NzUsIDY4NTY4MTczN2UtMl0sCiAgICBbLTE5ODE5ODEzMDQ5MzA1NTJlLTIzLCA4OTgzMDU1MDk5Nzc5NTM1ZS0yMSwgMC4wMzI3ODE4Mjg1MjU5MSwgNDAuMzE2Nzg1Mjc3MDU3NDQsIDAuNjU2NTkyOTg2NzcyNzcsIC00LjQ0MjU1NTM0NDc3NDkyLCAwLjg1MzQxOTExODA1MjYzLCAwLjEyOTIzMzQ3OTk4MjA0LCAtMC4wNDYyNTczNjAwNzU2MSwgNDQ4Mjc3NzA2ZS0yXSwKICAgIFszMDkxOTEzNzEwNjg0MzdlLTIzLCA4OTgzMDU1MDk2ODEyMTU1ZS0yMSwgNjk5NTcyNDA2MmUtMTQsIDIzLjEwOTM0MzA0MTQ0OTAxLCAtMjM2NjM0OTA1MTFlLTE0LCAtMC42MzIxODE3ODEwMjQyLCAtMC4wMDY2MzQ5NDQ2NzI3MywgMC4wMzQzMDA4MjM5Nzk1MywgLTAuMDA0NjYwNDM4NzYzMzIsIDI1NTUxNjQ0ZS0xXSwKICAgIFsyODkwODcxMTQ0Nzc2ODc4ZS0yNCwgODk4MzA1NTA5NTgwNTQwN2UtMjEsIC0zMDY4Mjk4ZS0xNCwgNy40NzEzNzAyNTQ2ODAzMiwgLTM1MzkzNzk5NGUtMTQsIC0wLjAyMTQ1MTQ0ODYxMDM3LCAtMTIzNDQyNjU5NmUtMTQsIDEwMzIyOTUyNzczZS0xNCwgLTMyMzg5MDM2NGUtMTQsIDgyNjA4OC41XQogIF0sCiAgTEwyTUM6IFsKICAgIFstMC4wMDE1NzAyMTAyNDQ0LCAxMTEzMjAuNzAyMDYxNjkzOSwgMTcwNDQ4MDUyNDUzNTIwMywgLTEwMzM4OTg3Mzc2MDQyMzQwLCAyNjExMjY2Nzg1NjYwMzg4MCwgLTM1MTQ5NjY5MTc2NjUzNzAwLCAyNjU5NTcwMDcxODQwMzkyMCwgLTEwNzI1MDEyNDU0MTg4MjQwLCAxODAwODE5OTEyOTUwNDc0LCA4Mi41XSwKICAgIFs4Mjc3ODI0NTE2MTcyNTI2ZS0xOSwgMTExMzIwLjcwMjA0NjM1NzgsIDY0Nzc5NTU3NDY2NzE2MDdlLTcsIC00MDgyMDAzMTczNjQxMzE2ZS02LCAxMDc3NDkwNTY2MzUxMTQyZS01LCAtMTUxNzE4NzU1MzE1MTU1OWUtNSwgMTIwNTMwNjUzMzg2MjE2N2UtNSwgLTUxMjQ5Mzk2NjM1Nzc0NzJlLTYsIDkxMzMxMTkzNTk1MTIwMzJlLTcsIDY3LjVdLAogICAgWzAuMDAzMzczOTg3NjY3NjUsIDExMTMyMC43MDIwMjAyMTYyLCA0NDgxMzUxMDQ1ODkwMzY1ZS05LCAtMjMzOTM3NTExOTkzMTY2MmUtOCwgNzk2ODIyMTU0NzE4NjQ1NWUtOCwgLTExNTk2NDk5MzI3OTcyNTNlLTcsIDk3MjM2NzExMTU2MDIxNDVlLTgsIC00MzY2MTk0NjMzNzUyODIxZS04LCA4NDc3MjMwNTAxMTM1MjM0ZS05LCA1Mi41XSwKICAgIFswLjAwMjIwNjM2NDk2MjA4LCAxMTEzMjAuNzAyMDIwOTEyOCwgNTE3NTEuODYxMTI4NDExMzEsIDM3OTY4Mzc3NDk0NzAyNDVlLTksIDk5MjAxMy43Mzk3NzkxMDEzLCAtMTIyMTk1MjIxNzExMjg3ZS04LCAxMzQwNjUyNjk3MDA5MDc1ZS05LCAtNjIwOTQzLjY5OTA5ODQzMTIsIDE0NDQxNi45MjkzODA2MjQxLCAzNy41XSwKICAgIFstMzQ0MTk2MzUwNDM2ODM5MmUtMTksIDExMTMyMC43MDIwNTc2ODU2LCAyNzguMjM1Mzk4MDc3Mjc1MiwgMjQ4NTc1ODY5MDAzNTM5NGUtOSwgNjA3MC43NTA5NjMyNDMzNzgsIDU0ODIxLjE4MzQ1MzUyMTE4LCA5NTQwLjYwNjYzMzMwNDIzNiwgLTI3MTAuNTUzMjY3NDY2NDUsIDE0MDUuNDgzODQ0MTIxNzI2LCAyMi41XSwKICAgIFstMzIxODEzNTg3ODYxMzEzMmUtMTksIDExMTMyMC43MDIwNzAxNjE1LCAwLjAwMzY5MzgzNDMxMjg5LCA4MjM3MjUuNjQwMjc5NTcxOCwgMC40NjEwNDk4NjkwOTA5MywgMjM1MS4zNDMxNDEzMzEyOTIsIDEuNTgwNjA3ODQyOTgxOTksIDguNzc3Mzg1ODkwNzgyODQsIDAuMzcyMzg4ODQyNTI0MjQsIDcuNDVdCiAgXSwKICBnZXREaXN0YW5jZUJ5TUM6IGZ1bmN0aW9uKHMsIHQpIHsKICAgIGlmICghcyB8fCAhdCkKICAgICAgcmV0dXJuIDA7CiAgICBsZXQgZSwgbiwgaSwgcjsKICAgIHJldHVybiBzID0gdGhpcy5jb252ZXJ0TUMyTEwocyksICFzIHx8IChlID0gdGhpcy50b1JhZGlhbnMocy5sbmcpLCBuID0gdGhpcy50b1JhZGlhbnMocy5sYXQpLCB0ID0gdGhpcy5jb252ZXJ0TUMyTEwodCksICF0KSA/IDAgOiAoaSA9IHRoaXMudG9SYWRpYW5zKHQubG5nKSwgciA9IHRoaXMudG9SYWRpYW5zKHQubGF0KSwgdGhpcy5nZXREaXN0YW5jZShlLCBpLCBuLCByKSk7CiAgfSwKICBnZXREaXN0YW5jZUJ5TEw6IGZ1bmN0aW9uKHMsIHQpIHsKICAgIGlmICghcyB8fCAhdCkKICAgICAgcmV0dXJuIDA7CiAgICBzLmxuZyA9IHRoaXMuZ2V0TG9vcChzLmxuZywgLTE4MCwgMTgwKSwgcy5sYXQgPSB0aGlzLmdldFJhbmdlKHMubGF0LCAtNzQsIDc0KSwgdC5sbmcgPSB0aGlzLmdldExvb3AodC5sbmcsIC0xODAsIDE4MCksIHQubGF0ID0gdGhpcy5nZXRSYW5nZSh0LmxhdCwgLTc0LCA3NCk7CiAgICBsZXQgZSwgbiwgaSwgcjsKICAgIHJldHVybiBlID0gdGhpcy50b1JhZGlhbnMocy5sbmcpLCBpID0gdGhpcy50b1JhZGlhbnMocy5sYXQpLCBuID0gdGhpcy50b1JhZGlhbnModC5sbmcpLCByID0gdGhpcy50b1JhZGlhbnModC5sYXQpLCB0aGlzLmdldERpc3RhbmNlKGUsIG4sIGksIHIpOwogIH0sCiAgY29udmVydE1DMkxMOiBmdW5jdGlvbihpKSB7CiAgICBpZiAoaSA9PSBudWxsKQogICAgICByZXR1cm4gbmV3IGZ0KDAsIDApOwogICAgaWYgKGkubG5nIDwgMTgwICYmIGkubG5nID4gLTE4MCAmJiBpLmxhdCA8IDkwICYmIGkubGF0ID4gLTkwKQogICAgICByZXR1cm4gaTsKICAgIGxldCB0LCBlOwogICAgdCA9IG5ldyBmdChNYXRoLmFicyhpLmxuZyksIE1hdGguYWJzKGkubGF0KSk7CiAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuTUNCQU5ELmxlbmd0aDsgcisrKQogICAgICBpZiAodC5sYXQgPj0gdGhpcy5NQ0JBTkRbcl0pIHsKICAgICAgICBlID0gdGhpcy5NQzJMTFtyXTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgbGV0IG4gPSB0aGlzLmNvbnZlcnRvcihpLCBlKTsKICAgIHZhciBpID0gbmV3IGZ0KG4ubG5nLnRvRml4ZWQoNiksIG4ubGF0LnRvRml4ZWQoNikpOwogICAgcmV0dXJuIGk7CiAgfSwKICBjb252ZXJ0TEwyTUM6IGZ1bmN0aW9uKGMpIHsKICAgIGlmIChjID09IG51bGwpCiAgICAgIHJldHVybiBuZXcgZnQoMCwgMCk7CiAgICBpZiAoYy5sbmcgPiAxODAgfHwgYy5sbmcgPCAtMTgwIHx8IGMubGF0ID4gOTAgfHwgYy5sYXQgPCAtOTApCiAgICAgIHJldHVybiBjOwogICAgbGV0IHQsIGU7CiAgICBpZiAoYy5sbmcgPSB0aGlzLmdldExvb3AoYy5sbmcsIC0xODAsIDE4MCksIGMubGF0ID0gdGhpcy5nZXRSYW5nZShjLmxhdCwgLTc0LCA3NCksIHQgPSBuZXcgZnQoYy5sbmcsIGMubGF0KSwgd2luZG93LkJNQVBHTF84NCkgewogICAgICB2YXIgbiA9IHt9LCBpID0gNjM3ODEzNzsKICAgICAgbi5sbmcgPSB0LmxuZyAqIE1hdGguUEkgLyAxODAgKiBpOwogICAgICB2YXIgciA9IHQubGF0ICogTWF0aC5QSSAvIDE4MDsKICAgICAgbi5sYXQgPSBpIC8gMiAqIE1hdGgubG9nKCgxICsgTWF0aC5zaW4ocikpIC8gKDEgLSBNYXRoLnNpbihyKSkpOwogICAgICB2YXIgYSA9IG5ldyBmdChOdW1iZXIobi5sbmcpLCBOdW1iZXIobi5sYXQpKTsKICAgICAgcmV0dXJuIGE7CiAgICB9CiAgICBmb3IgKHZhciBvID0gMDsgbyA8IHRoaXMuTExCQU5ELmxlbmd0aDsgbysrKQogICAgICBpZiAodC5sYXQgPj0gdGhpcy5MTEJBTkRbb10pIHsKICAgICAgICBlID0gdGhpcy5MTDJNQ1tvXTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgaWYgKCFlKSB7CiAgICAgIGZvciAodmFyIG8gPSAwOyBvIDwgdGhpcy5MTEJBTkQubGVuZ3RoOyBvKyspCiAgICAgICAgaWYgKHQubGF0IDw9IC10aGlzLkxMQkFORFtvXSkgewogICAgICAgICAgZSA9IHRoaXMuTEwyTUNbb107CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICB9CiAgICBsZXQgaCA9IHRoaXMuY29udmVydG9yKGMsIGUpOwogICAgdmFyIGMgPSBuZXcgZnQoTnVtYmVyKGgubG5nKSwgTnVtYmVyKGgubGF0KSk7CiAgICByZXR1cm4gYzsKICB9LAogIGNvbnZlcnRvcjogZnVuY3Rpb24ocywgdCkgewogICAgaWYgKCFzIHx8ICF0KQogICAgICByZXR1cm47CiAgICBsZXQgZSA9IHRbMF0gKyB0WzFdICogTWF0aC5hYnMocy5sbmcpLCBuID0gTWF0aC5hYnMocy5sYXQpIC8gdFs5XSwgaSA9IHRbMl0gKyB0WzNdICogbiArIHRbNF0gKiBuICogbiArIHRbNV0gKiBuICogbiAqIG4gKyB0WzZdICogbiAqIG4gKiBuICogbiArIHRbN10gKiBuICogbiAqIG4gKiBuICogbiArIHRbOF0gKiBuICogbiAqIG4gKiBuICogbiAqIG47CiAgICByZXR1cm4gZSAqPSBzLmxuZyA8IDAgPyAtMSA6IDEsIGkgKj0gcy5sYXQgPCAwID8gLTEgOiAxLCBuZXcgZnQoZSwgaSk7CiAgfSwKICBnZXREaXN0YW5jZTogZnVuY3Rpb24ocywgdCwgZSwgbikgewogICAgcmV0dXJuIHRoaXMuRUFSVEhSQURJVVMgKiBNYXRoLmFjb3MoTWF0aC5zaW4oZSkgKiBNYXRoLnNpbihuKSArIE1hdGguY29zKGUpICogTWF0aC5jb3MobikgKiBNYXRoLmNvcyh0IC0gcykpOwogIH0sCiAgdG9SYWRpYW5zOiBmdW5jdGlvbihzKSB7CiAgICByZXR1cm4gTWF0aC5QSSAqIHMgLyAxODA7CiAgfSwKICB0b0RlZ3JlZXM6IGZ1bmN0aW9uKHMpIHsKICAgIHJldHVybiAxODAgKiBzIC8gTWF0aC5QSTsKICB9LAogIGdldFJhbmdlOiBmdW5jdGlvbihzLCB0LCBlKSB7CiAgICByZXR1cm4gdCAhPSBudWxsICYmIChzID0gTWF0aC5tYXgocywgdCkpLCBlICE9IG51bGwgJiYgKHMgPSBNYXRoLm1pbihzLCBlKSksIHM7CiAgfSwKICBnZXRMb29wOiBmdW5jdGlvbihzLCB0LCBlKSB7CiAgICBmb3IgKDsgcyA+IGU7ICkKICAgICAgcyAtPSBlIC0gdDsKICAgIGZvciAoOyBzIDwgdDsgKQogICAgICBzICs9IGUgLSB0OwogICAgcmV0dXJuIHM7CiAgfQp9KTsKQW4oWXQucHJvdG90eXBlLCB7CiAgbG5nTGF0VG9NZXJjYXRvcjogZnVuY3Rpb24ocykgewogICAgcmV0dXJuIFl0LmNvbnZlcnRMTDJNQyhzKTsKICB9LAogIGxuZ0xhdFRvUG9pbnQ6IGZ1bmN0aW9uKHMpIHsKICAgIGxldCB0ID0gWXQuY29udmVydExMMk1DKHMpOwogICAgcmV0dXJuIG5ldyB3aSh0LmxuZywgdC5sYXQpOwogIH0sCiAgbWVyY2F0b3JUb0xuZ0xhdDogZnVuY3Rpb24ocykgewogICAgcmV0dXJuIFl0LmNvbnZlcnRNQzJMTChzKTsKICB9LAogIHBvaW50VG9MbmdMYXQ6IGZ1bmN0aW9uKHMpIHsKICAgIGxldCB0ID0gbmV3IGZ0KHMueCwgcy55KTsKICAgIHJldHVybiBZdC5jb252ZXJ0TUMyTEwodCk7CiAgfSwKICBwb2ludFRvUGl4ZWw6IGZ1bmN0aW9uKHMsIHQsIGUsIG4sIGkpIHsKICAgIGlmICghcykKICAgICAgcmV0dXJuOwogICAgcyA9IHRoaXMubG5nTGF0VG9NZXJjYXRvcihzLCBpKTsKICAgIGxldCByID0gdGhpcy5nZXRab29tVW5pdHModCksIGEgPSBNYXRoLnJvdW5kKChzLmxuZyAtIGUubG5nKSAvIHIgKyBuLndpZHRoIC8gMiksIG8gPSBNYXRoLnJvdW5kKChlLmxhdCAtIHMubGF0KSAvIHIgKyBuLmhlaWdodCAvIDIpOwogICAgcmV0dXJuIG5ldyB3aShhLCBvKTsKICB9LAogIHBpeGVsVG9Qb2ludDogZnVuY3Rpb24ocywgdCwgZSwgbiwgaSkgewogICAgaWYgKCFzKQogICAgICByZXR1cm47CiAgICBsZXQgciA9IHRoaXMuZ2V0Wm9vbVVuaXRzKHQpLCBhID0gZS5sbmcgKyByICogKHMueCAtIG4ud2lkdGggLyAyKSwgbyA9IGUubGF0IC0gciAqIChzLnkgLSBuLmhlaWdodCAvIDIpLCBoID0gbmV3IGZ0KGEsIG8pOwogICAgcmV0dXJuIHRoaXMubWVyY2F0b3JUb0xuZ0xhdChoLCBpKTsKICB9LAogIGdldFpvb21Vbml0czogZnVuY3Rpb24ocykgewogICAgcmV0dXJuIE1hdGgucG93KDIsIDE4IC0gcyk7CiAgfQp9KTsKY29uc3QgRmUgPSAyMDAzNzcyNDE2ZS0yLCB6aSA9IDg1LjA1MTEyODc3OTgwNjU5OwpjbGFzcyBPYSBleHRlbmRzIE9lIHsKICBjb25zdHJ1Y3RvcigpIHsKICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7CiAgICB2KHRoaXMsICJuYW1lIiwgc24pOwogICAgdih0aGlzLCAiaXNBeGlzQWxpZ25lZCIsICEwKTsKICAgIHYodGhpcywgInVucHJvamVjdENvb3JkaW5hdGUiLCAoZSwgbikgPT4gewogICAgICBuIHx8IChuID0gbmV3IHAoKSk7CiAgICAgIGNvbnN0IGkgPSBZdC5jb252ZXJ0TUMyTEwoeyBsbmc6IGUueCwgbGF0OiBlLnkgfSk7CiAgICAgIHJldHVybiBuLnNldChOdW1iZXIoaS5sbmcpLCBOdW1iZXIoaS5sYXQpLCBlLnopLCBuLnggPSAkZShlLngsIG4ueCwgMTgwLCBGZSksIG4ueSA9ICRlKGUueSwgbi55LCB6aSwgRmUpLCBuOwogICAgfSk7CiAgfQogIHByb2plY3RDb29yZGluYXRlKGUsIG4pIHsKICAgIG4gfHwgKG4gPSBuZXcgcCgpKTsKICAgIGNvbnN0IGkgPSBZdC5jb252ZXJ0TEwyTUMoeyBsbmc6IGUueCwgbGF0OiBlLnkgfSk7CiAgICByZXR1cm4gbi5zZXQoTnVtYmVyKGkubG5nKSwgTnVtYmVyKGkubGF0KSwgZS56KSwgbi54ID0gSGUoZS54LCBuLngsIDE4MCwgRmUpLCBuLnkgPSBIZShlLnksIG4ueSwgemksIEZlKSwgbjsKICB9Cn0KY29uc3QgVmUgPSA2Mzc4MTM3ICogTWF0aC5QSSAvIDE4MDsKY2xhc3MgRWEgZXh0ZW5kcyBPZSB7CiAgY29uc3RydWN0b3IoKSB7CiAgICBzdXBlciguLi5hcmd1bWVudHMpOwogICAgdih0aGlzLCAibmFtZSIsIHZpKTsKICAgIHYodGhpcywgImlzR2VvIiwgITApOwogICAgdih0aGlzLCAiaXNBeGlzQWxpZ25lZCIsICEwKTsKICB9CiAgcHJvamVjdENvb3JkaW5hdGUoZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgcCgpKSwgbi54ID0gZS54ICogVmUsIG4ueSA9IGUueSAqIFZlLCBuLnogPSBlLnosIG47CiAgfQogIHVucHJvamVjdENvb3JkaW5hdGUoZSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgcCgpKSwgbi54ID0gZS54IC8gVmUsIG4ueSA9IGUueSAvIFZlLCBuLnogPSBlLnosIG47CiAgfQp9CmNsYXNzIEFhIGV4dGVuZHMgT2UgewogIGNvbnN0cnVjdG9yKCkgewogICAgc3VwZXIoLi4uYXJndW1lbnRzKTsKICAgIHYodGhpcywgIm5hbWUiLCBqaSk7CiAgICB2KHRoaXMsICJpc0F4aXNBbGlnbmVkIiwgITApOwogIH0KICBwcm9qZWN0Q29vcmRpbmF0ZShlLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBwKCkpLCBuLnggPSBlLngsIG4ueSA9IC1lLnksIG4ueiA9IGUueiwgbjsKICB9CiAgdW5wcm9qZWN0Q29vcmRpbmF0ZShlLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBwKCkpLCBuLnggPSBlLngsIG4ueSA9IC1lLnksIG4ueiA9IGUueiwgbjsKICB9Cn0KY29uc3QgaWUgPSB7fSwgUmEgPSAocykgPT4gKHMgPSBzLnRvVXBwZXJDYXNlKCkudHJpbSgpLCBzID09PSAiRVBTRzo5MDA5MTMiID8gVGUgOiBzID09PSAiR0xPQkUiIHx8IHMgPT09ICJFQ0VGIiA/IG5uIDogcyksIGdpID0gKHMpID0+IHsKICBpZiAocyA9IFJhKHMpLCAhaWVbc10pCiAgICBzd2l0Y2ggKHMpIHsKICAgICAgY2FzZSBUZToKICAgICAgICBpZVtzXSA9IG5ldyBYcigpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIG5uOgogICAgICAgIGllW3NdID0gbmV3IENhKCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2Ugc246CiAgICAgICAgaWVbc10gPSBuZXcgT2EoKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSB2aToKICAgICAgICBpZVtzXSA9IG5ldyBFYSgpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIGppOgogICAgICAgIGllW3NdID0gbmV3IEFhKCk7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9qZWN0aW9uOiAke3N9YCk7CiAgICB9CiAgcmV0dXJuIGllW3NdOwp9LCBOYSA9IChzLCB0KSA9PiB7CiAgY29uc3QgZSA9IFsKICAgIC0wLjUsCiAgICAtMC41LAogICAgMCwKICAgIC0wLjUsCiAgICAwLjUsCiAgICAwLAogICAgMC41LAogICAgMC41LAogICAgMCwKICAgIDAuNSwKICAgIC0wLjUsCiAgICAwCiAgXSwgbiA9IFsKICAgIDAsCiAgICAwLAogICAgMCwKICAgIDEsCiAgICAxLAogICAgMSwKICAgIDEsCiAgICAwCiAgXSwgaSA9IFswLCAyLCAxLCAwLCAzLCAyXSwgewogICAgdmVydGljZXM6IHIsCiAgICB1dnM6IGEsCiAgICBpbmRpY2VzOiBvCiAgfSA9IFZyKGUsIGksIG4sIHMpOwogIFF0KHIsIHMpOwogIGNvbnN0IGggPSB7CiAgICB2ZXJ0aWNlczogciwKICAgIHV2czogYSwKICAgIGluZGljZXM6IG8KICB9OwogIGlmICh0KSB7CiAgICBjb25zdCBjID0gci5sZW5ndGggLyAzOwogICAgZm9yIChjb25zdCBsIG9mIE9iamVjdC5rZXlzKHQpKSB7CiAgICAgIGNvbnN0IHUgPSB0W2xdLCBkID0gQXJyYXkuaXNBcnJheSh1KSwgeSA9IGQgPyB1Lmxlbmd0aCA6IDEsIGYgPSBbXTsKICAgICAgaWYgKGQpCiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBjOyBnKyspCiAgICAgICAgICBmb3IgKGxldCBfID0gMDsgXyA8IHk7IF8rKykKICAgICAgICAgICAgZi5wdXNoKHVbX10pOwogICAgICBlbHNlCiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBjOyBnKyspCiAgICAgICAgICBmLnB1c2godSk7CiAgICAgIGhbbF0gPSBmOwogICAgfQogIH0KICByZXR1cm4gaDsKfSwgbWUgPSBuZXcgcCgpLCBmZSA9IG5ldyBwKCksIGl0ID0gbmV3IHAoKSwgc3QgPSBuZXcgcCgpLCBNdCA9IFswLCAwLCAwXSwgSXQgPSBbMCwgMCwgMF0sIEggPSBbMCwgMCwgMF07CmZ1bmN0aW9uIHdlKHMpIHsKICByZXR1cm4gcyA8IDAuMDQwNDUgPyBzICogMC4wNzczOTkzODA4IDogTWF0aC5wb3cocyAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgMi40KTsKfQpmdW5jdGlvbiBHdChzKSB7CiAgcmV0dXJuIFsKICAgIHdlKChzICYgMjU1KSAvIDI1NSksCiAgICB3ZSgocyA+PiA4ICYgMjU1KSAvIDI1NSksCiAgICB3ZSgocyA+PiAxNiAmIDI1NSkgLyAyNTUpLAogICAgKHMgPj4gMjQgJiAyNTUpIC8gMjU1CiAgXTsKfQpmdW5jdGlvbiBQbihzKSB7CiAgcmV0dXJuIFsKICAgIHdlKChzICYgMjU1KSAvIDI1NSkgKiAyNTUsCiAgICB3ZSgocyA+PiA4ICYgMjU1KSAvIDI1NSkgKiAyNTUsCiAgICB3ZSgocyA+PiAxNiAmIDI1NSkgLyAyNTUpICogMjU1LAogICAgKHMgPj4gMjQgJiAyNTUpIC8gMjU1CiAgXTsKfQpsZXQgJHQgPSAxLjY3NDU4MTA2MTk3NDk1NzsKY29uc3QgTGEgPSAyMDAzNzUwODM0Mjc4OTJlLTcsIEdlID0gMywgTWkgPSA0LCBwaSA9IDcsIF9pID0gOCwgU2kgPSAxNSwgUGkgPSAxNiwgcWEgPSAxOCwgYmkgPSAxOSwgVGkgPSAyMCwgWmkgPSAwLCBQZSA9IDEsIFhlID0gMywgcmUgPSA0LCBJbiA9IDU7CmxldCB2YSA9IDQ7CmNvbnN0IGFlID0gLTFlLTMsIHJ0ID0gMWUtNCwgWmUgPSAxZS01LCBqYSA9IExhICogMiwgWWkgPSB7fTsKbGV0IElpID0gamE7CmZvciAobGV0IHMgPSAwOyBzIDw9IDIxOyBzKyspCiAgWWlbc10gPSBJaSwgSWkgLz0gMjsKY29uc3Qga2EgPSB7CiAgMzogODM4ODYwOCwKICA1OiA0MTk0MzA0LAogIDc6IDEwNDg1NzYsCiAgOTogMjYyMTQ0LAogIDEwOiA2NTUzNiwKICAxMjogMzI3NjgsCiAgMTU6IDQwOTYsCiAgMTc6IDIwNDgsCiAgMTk6IDUxMgp9LCBCYSA9IHsKICAzOiAyNTYsCiAgNTogNTEyLAogIDc6IDUxMiwKICA5OiA1MTIsCiAgMTA6IDI1NiwKICAxMjogNTEyLAogIDE1OiA1MTIsCiAgMTc6IDEwMjQsCiAgMTk6IDEwMjQKfSwgYm4gPSB7CiAgMDogIjAwMDAwMDAwIiwKICAxNjogIjAwMDEwMDAwIiwKICAzMjogIjAwMTAwMDAwIiwKICA0ODogIjAwMTEwMDAwIiwKICA2NDogIjAxMDAwMDAwIiwKICA5NjogIjAxMTAwMDAwIgp9OwpmdW5jdGlvbiBSbihzLCB0KSB7CiAgbGV0IGU7CiAgYm5bc10gfHwgKGUgPSBzLnRvU3RyaW5nKDIpLCBlLmxlbmd0aCA8IDggJiYgKGUgPSBuZXcgQXJyYXkoOCAtIGUubGVuZ3RoICsgMSkuam9pbigiMCIpICsgZSksIGJuW3NdID0gZSksIGUgPSBibltzXTsKICBjb25zdCBuID0gdC5mZXRjaE9wdGlvbnMuc3RhcnRaOwogIGxldCBpID0gdC56LCByID0gMjA7CiAgcmV0dXJuIGkgPiByICYmIChpID0gciksIGVbaSAtIG5dID09PSAiMSI7Cn0Kc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgKHMpID0+IHsKICBjb25zdCB0ID0gcy5kYXRhLCB7CiAgICB0aWxlS2V5OiBlLAogICAgdHlwZTogbgogIH0gPSB0OwogIG4gPT09ICJyZXF1ZXN0VGlsZSIgPyBzZWxmLmhhbmRsZVJlcXVlc3RUaWxlKHQpIDogbiA9PT0gImNoYW5nZVN0eWxlIiA/IHNlbGYuaGFuZGxlQ2hhbmdlU3R5bGUodCkgOiBuID09PSAiY2hhbmdlSWNvblNldEluZm8iID8gc2VsZi5oYW5kbGVDaGFuZ2VJY29uU2V0SW5mbyh0KSA6IGNvbnNvbGUubG9nKHQpOwp9KTsKc2VsZi5oYW5kbGVSZXF1ZXN0VGlsZSA9IGFzeW5jIChzKSA9PiB7CiAgY29uc3QgewogICAgdGlsZUtleTogdCwKICAgIGZldGNoT3B0aW9uczogZSA9IHt9LAogICAgd29ya2VyT3B0aW9uczogbiwKICAgIHVybDogaSwKICAgIHo6IHIsCiAgICBzb3VyY2VQcm9qZWN0aW9uTmFtZTogYSwKICAgIHRhcmdldFByb2plY3Rpb25OYW1lOiBvCiAgfSA9IHM7CiAgcy5zb3VyY2VQcm9qZWN0aW9uID0gZ2koYSksIHMudGFyZ2V0UHJvamVjdGlvbiA9IGdpKG8pOwogIGNvbnN0IGggPSBvID09PSBUZSAmJiBhID09PSBUZTsKICBzLmlzTm9ybWFsaXplZCA9IGg7CiAgbGV0IGMgPSBudWxsLCBsID0gMDsKICBuICYmIChzZWxmLmRpc3BsYXlPcHRpb25zID0gbi5kaXNwbGF5T3B0aW9ucywgc2VsZi56SW5kZXggPSBuLmhlaWdodCwgbi5pc0F0dGFjaCAmJiAoc2VsZi5pc0F0dGFjaCA9ICEhbi5pc0F0dGFjaCwgJHQgPSAxKSk7CiAgdHJ5IHsKICAgIGxldCBkID0gYXdhaXQgQ3MoaSwgewogICAgICByZXNwb25zZVR5cGU6ICJhcnJheWJ1ZmZlciIsCiAgICAgIC4uLmUKICAgIH0pLnRoZW4oKF8pID0+IF8uYXJyYXlCdWZmZXIoKSk7CiAgICBjb25zdCB5ID0gQnMoZCksIGYgPSB7CiAgICAgIGFycm93czogW10sCiAgICAgIHBvbHlnb25zOiBbXSwKICAgICAgcG9seWdvbk9wYWNpdHlzOiBbXSwKICAgICAgbGluZXM6IFtdLAogICAgICBwb2x5Z29uM2RzOiBbXSwKICAgICAgYnVpbGRpbmczZHM6IFtdLAogICAgICBwb2lzOiBbXSwKICAgICAgYmdzOiBbXQogICAgfTsKICAgIGxldCBnID0gNjExLjQ5NjIyNjI4MTQwODcgKiAxMDA7CiAgICBsID0gV2EoeSwgZiwgcyksIGMgPSBVYShmKTsKICB9IGNhdGNoIChkKSB7CiAgICBjb25zb2xlLndhcm4oZCksIGMgPSB7fTsKICB9CiAgbGV0IHUgPSBbXTsKICBpZiAoYy5wb2x5Z29uICYmIHUucHVzaChjLnBvbHlnb24uYXR0cmlidXRlcy5idWZmZXIsIGMucG9seWdvbi5pbmRpY2VzLmJ1ZmZlciksIGMubGluZSAmJiB1LnB1c2goYy5saW5lLmF0dHJpYnV0ZXMuYnVmZmVyLCBjLmxpbmUuaW5kaWNlcy5idWZmZXIpLCBjLnBvbHlnb24zZCAmJiB1LnB1c2goYy5wb2x5Z29uM2QuYXR0cmlidXRlcy5idWZmZXIsIGMucG9seWdvbjNkLmluZGljZXMuYnVmZmVyKSwgYy5idWlsZGluZzNkICYmIHUucHVzaChjLmJ1aWxkaW5nM2QuYXR0cmlidXRlcy5idWZmZXIsIGMuYnVpbGRpbmczZC5pbmRpY2VzLmJ1ZmZlciksIGMuYXJyb3cgJiYgdS5wdXNoKGMuYXJyb3cuYXR0cmlidXRlcy5idWZmZXIsIGMuYXJyb3cuaW5kaWNlcy5idWZmZXIpLCBjLmRhc2hMaW5lKSB7CiAgICBjb25zdCBkID0gT2JqZWN0LmtleXMoYy5kYXNoTGluZSk7CiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGQubGVuZ3RoOyB5KyspIHsKICAgICAgY29uc3QgZiA9IGMuZGFzaExpbmVbZFt5XV07CiAgICAgIHUucHVzaChmLmF0dHJpYnV0ZXMuYnVmZmVyLCBmLmluZGljZXMuYnVmZmVyKTsKICAgIH0KICB9CiAgaWYgKGMudGV4dHVyZUxpbmUpIHsKICAgIGNvbnN0IGQgPSBPYmplY3Qua2V5cyhjLnRleHR1cmVMaW5lKTsKICAgIGZvciAobGV0IHkgPSAwOyB5IDwgZC5sZW5ndGg7IHkrKykgewogICAgICBjb25zdCBmID0gYy50ZXh0dXJlTGluZVtkW3ldXTsKICAgICAgdS5wdXNoKGYuYXR0cmlidXRlcy5idWZmZXIsIGYuaW5kaWNlcy5idWZmZXIpOwogICAgfQogIH0KICBpZiAoYy5nYW9xaW5nTGluZSkgewogICAgY29uc3QgZCA9IE9iamVjdC5rZXlzKGMuZ2FvcWluZ0xpbmUpOwogICAgZm9yIChsZXQgeSA9IDA7IHkgPCBkLmxlbmd0aDsgeSsrKSB7CiAgICAgIGNvbnN0IGYgPSBjLmdhb3FpbmdMaW5lW2RbeV1dOwogICAgICB1LnB1c2goZi5hdHRyaWJ1dGVzLmJ1ZmZlciwgZi5pbmRpY2VzLmJ1ZmZlcik7CiAgICB9CiAgfQogIGMubWF4TGF5ZXJJbmRleCA9IGwsIHNlbGYucG9zdE1lc3NhZ2UoewogICAgdHlwZTogInJlc3BvbnNlVGlsZSIsCiAgICB0aWxlS2V5OiB0LAogICAgY29udGVudDogYywKICAgIGlzTm9ybWFsaXplZDogaAogIH0sIHUpOwp9OwpmdW5jdGlvbiBObihzLCB0KSB7CiAgbGV0IGUgPSAxOwogIHJldHVybiB0LnNvdXJjZVByb2plY3Rpb25OYW1lID09PSBzbiA/IGUgPSBCYVt0LmZldGNoT3B0aW9ucy5iYXNlWl0gKiAxMDAgOiAoZSA9IDEwMjQgKiAxMDAsIHNlbGYuaXNBdHRhY2ggJiYgKGUgPSA2MTEuNDk2MjI2MjgxNDA4NyAqIDEwMCkpLCBlOwp9CmZ1bmN0aW9uIERhKHMsIHQpIHsKICBjb25zdCBlID0gdC5mZXRjaE9wdGlvbnMuYmFzZVo7CiAgcmV0dXJuIHQuc291cmNlUHJvamVjdGlvbk5hbWUgPT09IHNuID8ga2FbZV0gOiBZaVtlXTsKfQpmdW5jdGlvbiBDbihzLCB0LCBlLCBuLCBpID0gMCwgcikgewogIHJldHVybiByIHx8IChyID0gcyksIHJbaV0gPSBzW2ldIC8gKHQgLyAxMDApIC0gMC41LCByW2kgKyAxXSA9IHNbaSArIDFdIC8gKHQgLyAxMDApIC0gMC41LCByW2kgKyAyXSA9IHNbaSArIDJdLCBzZWxmLmlzQXR0YWNoICYmIChyW2ldIDwgZSAmJiAocltpXSA9IC0wLjUpLCByW2ldID4gbiAmJiAocltpXSA9IDAuNSksIHJbaSArIDFdIDwgZSAmJiAocltpICsgMV0gPSAtMC41KSwgcltpICsgMV0gPiBuICYmIChyW2kgKyAxXSA9IDAuNSkpLCByOwp9CmZ1bmN0aW9uIFVhKHMpIHsKICBjb25zdCB0ID0ge307CiAgaWYgKHMucG9seWdvbnMgJiYgcy5wb2x5Z29ucy5sZW5ndGggPiAwICYmICh0LnBvbHlnb24gPSBFdChzLnBvbHlnb25zKSksIHMucG9seWdvbk9wYWNpdHlzICYmIHMucG9seWdvbk9wYWNpdHlzLmxlbmd0aCA+IDAgJiYgKHQucG9seWdvbk9wYWNpdHkgPSBFdChzLnBvbHlnb25PcGFjaXR5cywgeyBpc0NvbG9yNDogITAgfSkpLCBzLmJncyAmJiBzLmJncy5sZW5ndGggPiAwICYmICh0LmJnID0gRXQocy5iZ3MpKSwgcy5saW5lcyAmJiBzLmxpbmVzLmxlbmd0aCA+IDApIHsKICAgIGxldCBlID0ge30sIG4gPSB7fSwgaSA9IHt9LCByID0gW10sIGEgPSAhMSwgbyA9ICExLCBoID0gITE7CiAgICBmb3IgKGxldCBjID0gMDsgYyA8IHMubGluZXMubGVuZ3RoOyBjKyspIHsKICAgICAgY29uc3QgbCA9IHMubGluZXNbY10sIHUgPSBsLmZpbGxUZXh0dXJlU3R5bGU7CiAgICAgIGlmICh1KSB7CiAgICAgICAgY29uc3QgZCA9IHUuZmlsbFRleHR1cmUsIHkgPSB1LmlzU2luZ2xlOwogICAgICAgIGwuaXNHYW9RaW5nID8gKGggPSAhMCwgaVtkXSB8fCAoaVtkXSA9IFtdKSwgaVtkXS5wdXNoKGwpKSA6IHkgPyAobyA9ICEwLCBuW2RdIHx8IChuW2RdID0gW10pLCBuW2RdLnB1c2gobCkpIDogKGEgPSAhMCwgZVtkXSB8fCAoZVtkXSA9IFtdKSwgZVtkXS5wdXNoKGwpKTsKICAgICAgfSBlbHNlCiAgICAgICAgci5wdXNoKGwpOwogICAgfQogICAgdC5saW5lID0gRXQociwgeyBpc0xpbmU6ICEwLCBpc0NvbG9yNDogITAgfSksIGEgJiYgKHQuZGFzaExpbmUgPSB7fSk7CiAgICBmb3IgKGxldCBjIGluIGUpCiAgICAgIGUuaGFzT3duUHJvcGVydHkoYykgJiYgKHQuZGFzaExpbmVbY10gPSBFdChlW2NdLCB7CiAgICAgICAgaXNMaW5lOiAhMCwKICAgICAgICBpc0NvbG9yNDogITAsCiAgICAgICAgaXNEYXNoTGluZTogITAKICAgICAgfSkpOwogICAgbyAmJiAodC50ZXh0dXJlTGluZSA9IHt9KTsKICAgIGZvciAobGV0IGMgaW4gbikKICAgICAgbi5oYXNPd25Qcm9wZXJ0eShjKSAmJiAodC50ZXh0dXJlTGluZVtjXSA9IEV0KG5bY10sIHsKICAgICAgICBpc0xpbmU6ICEwLAogICAgICAgIGlzQ29sb3I0OiAhMCwKICAgICAgICBpc0Rhc2hMaW5lOiAhMCwKICAgICAgICBpc1RleHR1cmVMaW5lOiAhMAogICAgICB9KSk7CiAgICBoICYmICh0Lmdhb3FpbmdMaW5lID0ge30pOwogICAgZm9yIChsZXQgYyBpbiBpKQogICAgICBpLmhhc093blByb3BlcnR5KGMpICYmICh0Lmdhb3FpbmdMaW5lW2NdID0gRXQoaVtjXSwgewogICAgICAgIGlzTGluZTogITAsCiAgICAgICAgaXNDb2xvcjQ6ICEwLAogICAgICAgIGlzRGFzaExpbmU6ICEwCiAgICAgIH0pKTsKICB9CiAgcmV0dXJuIHMucG9seWdvbjNkcyAmJiBzLnBvbHlnb24zZHMubGVuZ3RoID4gMCAmJiAodC5wb2x5Z29uM2QgPSBFdChzLnBvbHlnb24zZHMpKSwgcy5idWlsZGluZzNkcyAmJiBzLmJ1aWxkaW5nM2RzLmxlbmd0aCA+IDAgJiYgKHQuYnVpbGRpbmczZCA9IEV0KHMuYnVpbGRpbmczZHMsIHsgaXNCdWlsZGluZzogITAgfSkpLCBzLmFycm93cyAmJiBzLmFycm93cy5sZW5ndGggPiAwICYmICh0LmFycm93ID0gRXQocy5hcnJvd3MsIHsgaXNBcnJvdzogITAgfSkpLCBzLnBvaXMgJiYgcy5wb2lzLmxlbmd0aCA+IDAgJiYgKHQucG9pID0gcy5wb2lzKSwgdDsKfQpmdW5jdGlvbiBFdChzLCB0ID0ge30pIHsKICBzLnNvcnQoKHgsIG0pID0+IHgucmFuayAtIG0ucmFuayk7CiAgY29uc3QgZSA9IFtdLCBuID0gW107CiAgbGV0IGkgPSBudWxsLCByID0gbnVsbCwgYSA9IG51bGwsIG8gPSBudWxsLCBoID0gbnVsbCwgYyA9IG51bGwsIGwgPSBudWxsLCB1ID0gbnVsbCwgZCA9IG51bGwsIHkgPSBudWxsLCBmID0gbnVsbCwgZyA9IG51bGwsIF8gPSAwLCB3ID0gMDsKICBmb3IgKGxldCB4ID0gMDsgeCA8IHMubGVuZ3RoOyB4KyspCiAgICBpZiAoaSA9IHNbeF0sIHIgPSBpLnZlcnRpY2VzLCBhID0gaS5ub3JtYWxzLCBvID0gaS5mbGF0Tm9ybWFscywgaCA9IGkudXZzLCBjID0gaS5kaWZmcywgbCA9IGkuaW5kaWNlcywgdSA9IGkuY29sb3JzLCBkID0gaS5sYXllckluZGljZXMsIHkgPSBpLndpZHRocywgZyA9IGkudG90YWxMZW5ndGhzLCBmID0gaS5oZWlnaHRBbmRDb25jYXZlcywgISghbCB8fCAhbC5sZW5ndGgpKSB7CiAgICAgIGZvciAobGV0IG0gPSAwLCBNID0gci5sZW5ndGggLSAyOyBtIDwgTTsgbSArPSAzKQogICAgICAgIGUucHVzaChyW21dLCByW20gKyAxXSwgclttICsgMl0pLCB0LmlzQXJyb3cgPyAoXyA9IG0gLyAzICogMiwgZS5wdXNoKG9bbV0sIG9bbSArIDFdLCBvW20gKyAyXSksIGUucHVzaChoW19dLCBoW18gKyAxXSksIGUucHVzaChjW21dLCBjW20gKyAxXSwgY1ttICsgMl0pKSA6IChlLnB1c2goYVttXSwgYVttICsgMV0sIGFbbSArIDJdKSwgdC5pc0NvbG9yNCA/IChfID0gbSAvIDMgKiA0LCBlLnB1c2goCiAgICAgICAgICB1W19dLAogICAgICAgICAgdVtfICsgMV0sCiAgICAgICAgICB1W18gKyAyXSwKICAgICAgICAgIHVbXyArIDNdCiAgICAgICAgKSkgOiBlLnB1c2godVttXSwgdVttICsgMV0sIHVbbSArIDJdKSksIHQuaXNCdWlsZGluZyA/IChfID0gbSAvIDMgKiAyLCBlLnB1c2goZltfXSwgZltfICsgMV0pKSA6IGUucHVzaChkW20gLyAzXSksIHQuaXNMaW5lICYmIChfID0gbSAvIDMgKiAyLCBlLnB1c2goeVttIC8gM10pLCB0LmlzRGFzaExpbmUgJiYgZS5wdXNoKGhbX10sIGhbXyArIDFdKSwgdC5pc1RleHR1cmVMaW5lICYmIGUucHVzaChnW20gLyAzXSkpOwogICAgICBmb3IgKGxldCBtID0gMCwgTSA9IGwubGVuZ3RoOyBtIDwgTTsgbSsrKQogICAgICAgIG4ucHVzaChsW21dICsgdyk7CiAgICAgIHcgKz0gci5sZW5ndGggLyAzOwogICAgfQogIHJldHVybiB7CiAgICBhdHRyaWJ1dGVzOiBuZXcgRmxvYXQzMkFycmF5KGUpLAogICAgaW5kaWNlczogbmV3IFVpbnQzMkFycmF5KG4pCiAgfTsKfQpsZXQgWSA9IDA7CmZ1bmN0aW9uIFdhKHMsIHQsIGUpIHsKICBjb25zdCBuID0gc2VsZi5kaXNwbGF5T3B0aW9ucywgaSA9IG4gJiYgbi5iYXNlID09PSAhMSwgciA9IG4gJiYgbi5saW5rID09PSAhMSwgYSA9IG4gJiYgbi5idWlsZGluZyA9PT0gITEsIG8gPSBuICYmIG4ucG9pID09PSAhMSwgaCA9IG4gJiYgbi5mbGF0ID09PSAhMCwgYyA9IHMuZ2VvbGF5ZXIsIGwgPSB0LnBvbHlnb25zLCB1ID0gdC5wb2x5Z29uT3BhY2l0eXMsIGQgPSB0LnBvbHlnb24zZHMsIHkgPSB0LmxpbmVzLCBmID0gdC5idWlsZGluZzNkcywgZyA9IHQucG9pcywgXyA9IHQuYXJyb3dzLCB3ID0gTWF0aC5mbG9vcihlLnVzZVpvb20pIHx8IGUuejsKICBsZXQgeCA9IDAsIG0gPSAwLCBNID0gbnVsbCwgeiA9IG51bGwsIFAgPSBudWxsLCBUID0gbnVsbCwgYiA9IG51bGw7CiAgWSA9IHJ0ICogMjA7CiAgY29uc3QgTiA9IGUueiA8IDkgPyBwdChtLCAxNTIyLCB3LCByZSwgZSkgOiBwdChtLCA3MiwgdywgcmUsIGUpOwogICFpICYmIE4gJiYgbC5wdXNoKEdhKE4sIGUpKSwgWSArPSBydCAqIDE7CiAgZm9yIChjb25zdCBJIG9mIGMpIHsKICAgIG0gPSBJLmNhdGFsb2dUeXBlLCB4ID0gSS5yYW5rOwogICAgY29uc3QgQyA9IEkuYXJyb3dwOwogICAgaWYgKG0gPT09IHFhICYmIEMpIHsKICAgICAgY29uc3QgTCA9IEZhKEksIHcsIGUpOwogICAgICBMICYmIChMLnJhbmsgPSB4LCBfLnB1c2goTCksIFkgKz0gcnQpOwogICAgICBjb250aW51ZTsKICAgIH0KICAgIGNvbnN0IE8gPSBJLmdlb29iamVjdHNldFNldDsKICAgIGlmICghQXJyYXkuaXNBcnJheShPKSkKICAgICAgY29udGludWU7CiAgICBsZXQgUiA9IFtdOwogICAgZm9yIChjb25zdCBMIG9mIE8pIHsKICAgICAgaWYgKCFBcnJheS5pc0FycmF5KEwuZ2VvT2JqZWN0U2V0KSB8fCBMLnN0eWxlSWQgPT09IDE1MjIgJiYgZS56IDwgOSkKICAgICAgICBjb250aW51ZTsKICAgICAgbGV0IHEgPSBudWxsOwogICAgICBpZiAoIWkgJiYgKG0gPT09IHBpIHx8IG0gPT09IFNpKSkKICAgICAgICBxID0gcHQobSwgTC5zdHlsZUlkLCB3LCByZSwgZSk7CiAgICAgIGVsc2UgaWYgKCFyICYmIG0gPT09IFRpKSB7CiAgICAgICAgY29uc3QgayA9IEwuZ2VvT2JqZWN0U2V0LCBYID0gKGsgJiYga1swXSkuZ3JhZGllbnRTdHlsZUlkLCBaID0gcHQoCiAgICAgICAgICBtLAogICAgICAgICAgWFswXSwKICAgICAgICAgIHcsCiAgICAgICAgICByZSwKICAgICAgICAgIGUKICAgICAgICApLCBodCA9IHB0KG0sIFhbMV0sIHcsIHJlLCBlKTsKICAgICAgICBaICYmIGh0ICYmIChxID0gewogICAgICAgICAgc3RhcnRQdFN0eWxlOiBaLAogICAgICAgICAgZW5kUHRTdHlsZTogaHQKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmICghciAmJiBtID09PSBiaSkKICAgICAgICBxID0gcHQobSwgTC5zdHlsZUlkLCB3LCBYZSwgZSk7CiAgICAgIGVsc2UgaWYgKCFyICYmIG0gPT09IE1pKQogICAgICAgIHEgPSBwdChtLCBMLnN0eWxlSWQsIHcsIFhlLCBlKTsKICAgICAgZWxzZSBpZiAobSA9PT0gUGkpCiAgICAgICAgcSA9IHB0KG0sIEwuc3R5bGVJZCwgdywgWGUsIGUpOwogICAgICBlbHNlIGlmICghYSAmJiBtID09PSBfaSkKICAgICAgICBxID0gcHQobSwgTC5zdHlsZUlkLCB3LCBJbiwgZSk7CiAgICAgIGVsc2UgaWYgKCFvICYmIG0gPT09IEdlKSB7CiAgICAgICAgY29uc3QgayA9IHB0KG0sIEwuc3R5bGVJZCwgdywgWmksIGUpLCBXID0gcHQoCiAgICAgICAgICBtLAogICAgICAgICAgTC5zdHlsZUlkLAogICAgICAgICAgdywKICAgICAgICAgIFBlLAogICAgICAgICAgZQogICAgICAgICk7CiAgICAgICAgKCFXIHx8IFcubGVuZ3RoID09PSAwKSAmJiAoIWsgfHwgay5sZW5ndGggPiAwKSB8fCAocSA9IHsKICAgICAgICAgIHN0eWxlUHQ6IGssCiAgICAgICAgICBzdHlsZVRleHQ6IFcKICAgICAgICB9KTsKICAgICAgfQogICAgICBpZiAoISFxKSB7CiAgICAgICAgZm9yIChjb25zdCBrIG9mIEwuZ2VvT2JqZWN0U2V0KQogICAgICAgICAgaWYgKCEobSAhPT0gR2UgJiYgIShrLm1pZFBvaW50cyAmJiBrLm1pZFBvaW50cy5sZW5ndGggJiYgay5taWRQb2ludHMubGVuZ3RoIDwgOGUzKSkgJiYgISFSbihrLnRyYWNlciwgZSkpIHsKICAgICAgICAgICAgaWYgKCFpICYmIG0gPT09IHBpKSB7CiAgICAgICAgICAgICAgY29uc3QgVyA9IHEuY29sb3JbM10gPCAxOwogICAgICAgICAgICAgIE0gPSBUbihrLCBxLmNvbG9yLCB7CiAgICAgICAgICAgICAgICBpc1RyYW5zcGFyZW50OiBXCiAgICAgICAgICAgICAgfSwgZSksIE0gJiYgKE0ucmFuayA9IHgsIFcgPyB1LnB1c2goTSkgOiBsLnB1c2goTSksIFkgKz0gcnQpOwogICAgICAgICAgICB9IGVsc2UgaWYgKG0gPT09IGJpKQogICAgICAgICAgICAgIFAgPSBwZShrLCBxLmZpbGxDb2xvciwgcS5maWxsV2lkdGgsIHsKICAgICAgICAgICAgICAgIGZpbGxUZXh0dXJlOiBxLmZpbGxUZXh0dXJlLAogICAgICAgICAgICAgICAgaXNTaW5nbGU6ICEwCiAgICAgICAgICAgICAgfSwgZSksIFAgJiYgKFAucmFuayA9IHgsIHkucHVzaChQKSwgWSArPSBydCk7CiAgICAgICAgICAgIGVsc2UgaWYgKCFyICYmIG0gPT09IE1pKQogICAgICAgICAgICAgIHEuaGF2ZUJvcmRlckxpbmUgJiYgcS5ib3JkZXJDb2xvclszXSA+IDAgJiYgIXEuZmlsbFRleHR1cmUgJiYgKFAgPSBwZSgKICAgICAgICAgICAgICAgIGssCiAgICAgICAgICAgICAgICBxLmJvcmRlckNvbG9yLAogICAgICAgICAgICAgICAgcS5ib3JkZXJXaWR0aCAvIDIsCiAgICAgICAgICAgICAgICB2b2lkIDAsCiAgICAgICAgICAgICAgICBlCiAgICAgICAgICAgICAgKSwgUCAmJiAoUC5yYW5rID0geCwgeS5wdXNoKFApLCBZICs9IHJ0KSksIFAgPSBwZShrLCBxLmZpbGxDb2xvciwgcS5maWxsV2lkdGggLyAyLCB7CiAgICAgICAgICAgICAgICBmaWxsVGV4dHVyZTogcS5maWxsVGV4dHVyZQogICAgICAgICAgICAgIH0sIGUpLCBQICYmIChQLnJhbmsgPSB4LCB5LnB1c2goUCksIFkgKz0gcnQpOwogICAgICAgICAgICBlbHNlIGlmICghaSAmJiBtID09PSBTaSkgewogICAgICAgICAgICAgIGlmIChrLmJvcmRlciAmJiBrLmJvcmRlci5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgICAgICBSLnB1c2goewogICAgICAgICAgICAgICAgICBnZW9PYmplY3Q6IGssCiAgICAgICAgICAgICAgICAgIHN0eWxlQ29uZmlnOiBxCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB6ID0gVG4oaywgcS5jb2xvciwgewogICAgICAgICAgICAgICAgaXNHYW9RaW5nOiAhaAogICAgICAgICAgICAgIH0sIGUpLCB6ICYmICh6LnJhbmsgPSB4LCBkLnB1c2goeiksIFkgKz0gcnQpOwogICAgICAgICAgICB9IGVsc2UgaWYgKG0gPT09IFBpKQogICAgICAgICAgICAgIFAgPSBwZShrLCBxLmZpbGxDb2xvciwgcS5maWxsV2lkdGggLyA4LCB7CiAgICAgICAgICAgICAgICBpc0dhb1Fpbmc6ICFoLAogICAgICAgICAgICAgICAgZmlsbFRleHR1cmU6IHEuZmlsbFRleHR1cmUsCiAgICAgICAgICAgICAgICBzY2FsZTogMS41CiAgICAgICAgICAgICAgfSwgZSksIFAgJiYgKFAuaXNHYW9RaW5nID0gIWgsIFAucmFuayA9IHgsIHkucHVzaChQKSwgWSArPSBydCk7CiAgICAgICAgICAgIGVsc2UgaWYgKCFhICYmIG0gPT09IF9pKQogICAgICAgICAgICAgIFQgPSBYYShrLCBxLmZpbGxUb3AsIHEuZmlsbFNpZGUsIGUpLCBUICYmIChULnJhbmsgPSB4LCBmLnB1c2goVCkpOwogICAgICAgICAgICBlbHNlIGlmICghciAmJiBtID09PSBUaSkKICAgICAgICAgICAgICBNID0gWWEoCiAgICAgICAgICAgICAgICBrLAogICAgICAgICAgICAgICAgcS5zdGFydFB0U3R5bGUsCiAgICAgICAgICAgICAgICBxLmVuZFB0U3R5bGUsCiAgICAgICAgICAgICAgICBlCiAgICAgICAgICAgICAgKSwgTSAmJiAoTS5yYW5rID0geCwgbC5wdXNoKE0pLCBZICs9IHJ0KTsKICAgICAgICAgICAgZWxzZSBpZiAoIW8gJiYgbSA9PT0gR2UpIHsKICAgICAgICAgICAgICBpZiAoIWsubmFtZSkKICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgIGIgPSAkYShrLCBMLnN0eWxlSWQsIGUsIHEpLCBiICYmIGcucHVzaChiKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBmb3IgKGxldCBMID0gMDsgTCA8IFIubGVuZ3RoOyBMKyspIHsKICAgICAgY29uc3QgeyBnZW9PYmplY3Q6IHEsIHN0eWxlQ29uZmlnOiBrIH0gPSBSW0xdOwogICAgICBmb3IgKGxldCBXID0gMCwgWCA9IHEuYm9yZGVyLmxlbmd0aDsgVyA8IFg7IFcrKykgewogICAgICAgIGNvbnN0IFogPSBxLmJvcmRlcltXXTsKICAgICAgICBaLm1pZFBvaW50cyA9IHEubWlkUG9pbnRzLCBaLnp2ZWN0b3IgPSBxLnp2ZWN0b3I7CiAgICAgICAgY29uc3QgaHQgPSBwZShaLCBrLmJvcmRlclJnYmEsIGsuYm9yZGVyV2lkdGggLyAyLCB7CiAgICAgICAgICBpc0dhb1Fpbmc6ICFoCiAgICAgICAgfSwgZSk7CiAgICAgICAgaHQgJiYgKGh0LnJhbmsgPSB4LCB5LnB1c2goaHQpLCBZICs9IHJ0KTsKICAgICAgfQogICAgfQogICAgbGV0IEQgPSBbXSwgVSA9IFtdOwogICAgZm9yIChsZXQgTCA9IDA7IEwgPCBSLmxlbmd0aDsgTCsrKSB7CiAgICAgIGNvbnN0IHsgZ2VvT2JqZWN0OiBxLCBzdHlsZUNvbmZpZzogayB9ID0gUltMXTsKICAgICAgaWYgKHogPSBUbihxLCBrLmNvbG9yLCB7CiAgICAgICAgaXNHYW9RaW5nOiAhaCwKICAgICAgICBib3JkZXJSZ2JhOiBrLmJvcmRlclJnYmEsCiAgICAgICAgaXNEZWxheTogITAKICAgICAgfSwgZSksIHogJiYgei5kZWxheU9iamVjdCkgewogICAgICAgIGNvbnN0IFcgPSB6LmRlbGF5T2JqZWN0LCBYID0gei5vYmplY3Q7CiAgICAgICAgRC5wdXNoKFcpLCBVLnB1c2goWCk7CiAgICAgIH0gZWxzZQogICAgICAgIHogJiYgKHoucmFuayA9IHgsIGQucHVzaCh6KSwgWSArPSBydCk7CiAgICB9CiAgICBmb3IgKGxldCBMID0gMDsgTCA8IEQubGVuZ3RoOyBMKyspIHsKICAgICAgY29uc3QgcSA9IERbTF0sIGsgPSBxLmxheWVySW5kaWNlczsKICAgICAgZm9yIChsZXQgVyA9IDA7IFcgPCBrLmxlbmd0aDsgVysrKQogICAgICAgIGtbV10gPSBZOwogICAgICBxLnJhbmsgPSB4LCBkLnB1c2gocSksIFkgKz0gcnQ7CiAgICB9CiAgICBmb3IgKGxldCBMID0gMDsgTCA8IFUubGVuZ3RoOyBMKyspIHsKICAgICAgY29uc3QgcSA9IFVbTF0sIGsgPSBxLmxheWVySW5kaWNlczsKICAgICAgZm9yIChsZXQgVyA9IDA7IFcgPCBrLmxlbmd0aDsgVysrKQogICAgICAgIGtbV10gPSBZOwogICAgICBxLnJhbmsgPSB4LCBkLnB1c2gocSksIFkgKz0gcnQ7CiAgICB9CiAgfQogIGlmIChzLmxhYmVscCkgewogICAgbGV0IEkgPSBzLmxhYmVscDsKICAgIGZvciAobGV0IEMgPSAwOyBDIDwgSS5sZW5ndGg7IEMrKykgewogICAgICBjb25zdCBPID0gSVtDXTsKICAgICAgbGV0IFIgPSBudWxsOwogICAgICBvIHx8IChSID0gcHQoR2UsIE8uc3R5bGVJZCwgdywgUGUsIGUpKSwgUiAmJiBIYShnLCBPLCB3LCBlLCBSKTsKICAgIH0KICB9CiAgcmV0dXJuIFk7Cn0KZnVuY3Rpb24gRmEocywgdCwgZSkgewogIGNvbnN0IG4gPSBzLmFycm93cCwgaSA9IE9uKG4ueCksIHIgPSBlLnRhcmdldFByb2plY3Rpb24sIFthLCBvLCBoXSA9IGUudGFyZ2V0Q2VudGVyLCBjID0gbi50cmFjZXIsIGwgPSBuLnp2ZWN0b3IsIHUgPSAxIC8gMjU2LCBkID0gLTAuNSArIHUsIHkgPSAwLjUgLSB1OwogIGxldCBmID0gTm4oZS56LCBlKTsKICBjb25zdCBnID0gW10sIF8gPSBbXSwgdyA9IFtdLCB4ID0gW10sIG0gPSBbXSwgTSA9IFtdLCB6ID0gW10sIFAgPSBPbihsLCAxKTsKICBsZXQgVCA9IFtdOwogIFAubGVuZ3RoID09PSAxICYmIFBbMF0gPyAoVCA9IG5ldyBBcnJheShpLmxlbmd0aCksIFQuZmlsbChQWzBdKSkgOiBUID0gUDsKICBmb3IgKGxldCBiID0gMDsgYiA8IGkubGVuZ3RoOyBiKyspCiAgICBpW2JdWzJdID0gVFtiXSAvICR0OwogIGZvciAobGV0IGIgPSAwLCBOID0gYy5sZW5ndGg7IGIgPCBOOyBiKyspIHsKICAgIGxldCBJID0gY1tiXTsKICAgIGlmICghUm4oSSwgZSkpCiAgICAgIGNvbnRpbnVlOwogICAgY29uc3QgQyA9IGlbYiAqIDJdLCBPID0gaVtiICogMiArIDFdOwogICAgSFswXSA9IChDWzBdICsgT1swXSkgLyAyLCBIWzFdID0gKENbMV0gKyBPWzFdKSAvIDIsIEhbMl0gPSAoQ1syXSArIE9bMl0pIC8gMjsKICAgIGNvbnN0IFIgPSBIWzBdIC0gQ1swXSwgRCA9IEhbMV0gLSBDWzFdOwogICAgaXQuc2V0KFIsIEQsIDApLCBzdC5zZXQoLUQsIFIsIDApOwogICAgY29uc3QgVSA9IE0ubGVuZ3RoOwogICAgaWYgKCFlLmlzTm9ybWFsaXplZCkgewogICAgICBjb25zdCBMID0gTWF0aC5oeXBvdChSLCBEKTsKICAgICAgTXRbMF0gPSBDWzBdLCBNdFsxXSA9IENbMV0sIE10WzJdID0gQ1syXSwgSXRbMF0gPSBPWzBdLCBJdFsxXSA9IE9bMV0sIEl0WzJdID0gT1syXSwgQ24oTXQsIGYsIGQsIHkpLCBRdChNdCwgZSwgITAsICExKSwgQ24oSXQsIGYsIGQsIHkpLCBRdChJdCwgZSwgITAsICExKSwgSFswXSA9IChJdFswXSArIE10WzBdKSAvIDIgLSBhLCBIWzFdID0gKEl0WzFdICsgTXRbMV0pIC8gMiAtIG8sIEhbMl0gPSAoSXRbMl0gKyBNdFsyXSkgLyAyIC0gaCwgci5nZXRQcm9qZWN0ZWRTdXJmYWNlTm9ybWFsKGl0LmZyb21BcnJheShNdCksIHN0KSwgaXQuc2V0KAogICAgICAgIEl0WzBdIC0gTXRbMF0sCiAgICAgICAgSXRbMV0gLSBNdFsxXSwKICAgICAgICBJdFsyXSAtIE10WzJdCiAgICAgICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoTCksIHN0LmNyb3NzVmVjdG9ycyhzdCwgaXQpLm5vcm1hbGl6ZSgpOwogICAgfQogICAgZ1tnLmxlbmd0aF0gPSBIWzBdLCBnW2cubGVuZ3RoXSA9IEhbMV0sIGdbZy5sZW5ndGhdID0gSFsyXSwgd1t3Lmxlbmd0aF0gPSAtaXQueCwgd1t3Lmxlbmd0aF0gPSAtaXQueSwgd1t3Lmxlbmd0aF0gPSAtaXQueiwgbVttLmxlbmd0aF0gPSBzdC54LCBtW20ubGVuZ3RoXSA9IHN0LnksIG1bbS5sZW5ndGhdID0gc3QueiwgeFt4Lmxlbmd0aF0gPSAwLjEyNSwgeFt4Lmxlbmd0aF0gPSAwLjMxMjUsIE1bTS5sZW5ndGhdID0gWSwgZ1tnLmxlbmd0aF0gPSBIWzBdLCBnW2cubGVuZ3RoXSA9IEhbMV0sIGdbZy5sZW5ndGhdID0gSFsyXSwgd1t3Lmxlbmd0aF0gPSAtaXQueCwgd1t3Lmxlbmd0aF0gPSAtaXQueSwgd1t3Lmxlbmd0aF0gPSAtaXQueiwgbVttLmxlbmd0aF0gPSAtc3QueCwgbVttLmxlbmd0aF0gPSAtc3QueSwgbVttLmxlbmd0aF0gPSAtc3QueiwgeFt4Lmxlbmd0aF0gPSAwLjEyNSwgeFt4Lmxlbmd0aF0gPSAwLjY4NzUsIE1bTS5sZW5ndGhdID0gWSwgZ1tnLmxlbmd0aF0gPSBIWzBdLCBnW2cubGVuZ3RoXSA9IEhbMV0sIGdbZy5sZW5ndGhdID0gSFsyXSwgd1t3Lmxlbmd0aF0gPSBpdC54LCB3W3cubGVuZ3RoXSA9IGl0LnksIHdbdy5sZW5ndGhdID0gaXQueiwgbVttLmxlbmd0aF0gPSBzdC54LCBtW20ubGVuZ3RoXSA9IHN0LnksIG1bbS5sZW5ndGhdID0gc3QueiwgeFt4Lmxlbmd0aF0gPSAxLCB4W3gubGVuZ3RoXSA9IDAuMzEyNSwgTVtNLmxlbmd0aF0gPSBZLCBnW2cubGVuZ3RoXSA9IEhbMF0sIGdbZy5sZW5ndGhdID0gSFsxXSwgZ1tnLmxlbmd0aF0gPSBIWzJdLCB3W3cubGVuZ3RoXSA9IGl0LngsIHdbdy5sZW5ndGhdID0gaXQueSwgd1t3Lmxlbmd0aF0gPSBpdC56LCBtW20ubGVuZ3RoXSA9IC1zdC54LCBtW20ubGVuZ3RoXSA9IC1zdC55LCBtW20ubGVuZ3RoXSA9IC1zdC56LCB4W3gubGVuZ3RoXSA9IDEsIHhbeC5sZW5ndGhdID0gMC42ODc1LCBNW00ubGVuZ3RoXSA9IFksIF9bXy5sZW5ndGhdID0gVSwgX1tfLmxlbmd0aF0gPSBVICsgMSwgX1tfLmxlbmd0aF0gPSBVICsgMiwgX1tfLmxlbmd0aF0gPSBVICsgMiwgX1tfLmxlbmd0aF0gPSBVICsgMSwgX1tfLmxlbmd0aF0gPSBVICsgMzsKICB9CiAgcmV0dXJuIHsKICAgIHZlcnRpY2VzOiBnLAogICAgaW5kaWNlczogXywKICAgIGZsYXROb3JtYWxzOiBtLAogICAgaW5zdGFuY2VSb3RhdGlvbk1hdHJpY2VzOiB6LAogICAgZGlmZnM6IHcsCiAgICB1dnM6IHgsCiAgICBsYXllckluZGljZXM6IE0KICB9Owp9CmZ1bmN0aW9uIHBlKHMsIHQsIGUsIG4gPSB7fSwgaSkgewogIGNvbnN0IHIgPSBzLm1pZFBvaW50cywgYSA9IHMuenZlY3RvciwgbyA9IG4uaXNHYW9RaW5nIHx8ICExLCBoID0gbi5pbmRleE9mZnNldCB8fCAwLCBjID0gbi5maWxsVGV4dHVyZSwgbCA9IG4uaXNTaW5nbGU7CiAgbGV0IHUgPSBuLnNjYWxlIHx8IDE7CiAgaWYgKCFyKQogICAgcmV0dXJuOwogIGNvbnN0IGQgPSBxbihyLCBhZSwgaSk7CiAgbGV0IHkgPSBudWxsOwogIGlmIChvKSB7CiAgICBpZiAoYS5sZW5ndGggPT09IDEgJiYgYVswXSkKICAgICAgeSA9IG5ldyBBcnJheShyLmxlbmd0aCA+PiAxKSwgeS5maWxsKGFbMF0pOwogICAgZWxzZSBpZiAoYS5sZW5ndGggPiAxKSB7CiAgICAgIHkgPSBbXTsKICAgICAgZm9yIChsZXQgdyA9IGg7IHcgPCBhLmxlbmd0aDsgdysrKQogICAgICAgIHlbd10gPSBhW3ddIHx8IDE7CiAgICB9CiAgfQogIGxldCBmOwogIGMgJiYgdSA+IDEgJiYgKGYgPSBMbihjKSwgdSA9IE1hdGgubWF4KGZbMV0gLyA3LCAxKSk7CiAgbGV0IGcgPSAwOwogIC9ndW9qaWV0aWFucWlhb2ppZXRpLy50ZXN0KGMpICYmIChnID0gMC4wNCksIC93ZWlkaW5nZ3VvamllX2d1b25laS8udGVzdChjKSAmJiAoZSAqPSAxLjEpOwogIGZvciAobGV0IHcgPSAwOyB3IDwgZC5sZW5ndGg7IHcrKykKICAgIHkgJiYgeVt3XSAmJiAoZFt3XVsyXSArPSBnICsgeVt3XSAvIDEwMCAvICR0KTsKICBRdChkLCBpLCAhMSwgITEpOwogIGNvbnN0IF8gPSBJcyhkLCBlLCBpLCBsLCB1KTsKICByZXR1cm4gXy5jb2xvcnMgPSBXbihfLnZlcnRpY2VzLmxlbmd0aCAvIDMsIFt0WzBdLCB0WzFdLCB0WzJdLCB0WzNdIHx8IDFdKSwgXy5sYXllckluZGljZXMgPSBXbihfLnZlcnRpY2VzLmxlbmd0aCAvIDMsIFtZXSksIGMgJiYgKF8uZmlsbFRleHR1cmVTdHlsZSA9IHsKICAgIGZpbGxUZXh0dXJlOiBjLAogICAgdGV4dHVyZUluZm86IGYsCiAgICBpc1NpbmdsZTogbCA/IDEgOiAwCiAgfSksIF87Cn0KZnVuY3Rpb24gVmEocywgdCwgZSkgewogIGNvbnN0IFtuLCBpLCByLCBhLCBvLCBoXSA9IHQucHJvamVjdGVkQm91bmRpbmdCb3gsIGMgPSBhIC0gbiwgbCA9IG8gLSBpOwogIHJldHVybiBlLnggPSBuICsgKHMueCArIDAuNSkgKiBjLCBlLnkgPSBpICsgKHMueSArIDAuNSkgKiBsLCBlLnogPSBzLnogfHwgMCwgZTsKfQpmdW5jdGlvbiBHYShzLCB0KSB7CiAgY29uc3QgZSA9IHMuY29sb3I7CiAgcmV0dXJuIE5hKHQsIHsKICAgIGNvbG9yczogW2VbMF0sIGVbMV0sIGVbMl1dLAogICAgbGF5ZXJJbmRpY2VzOiBbMF0sCiAgICBub3JtYWxzOiBbMCwgMCwgMV0KICB9KTsKfQpmdW5jdGlvbiBaYShzKSB7CiAgcmV0dXJuIHMudGFyZ2V0UHJvamVjdGlvbk5hbWUgPT09IHMuc291cmNlUHJvamVjdGlvbk5hbWUgPyAwIDogcy50YXJnZXRQcm9qZWN0aW9uTmFtZSA9PT0gbm4gPyAwLjA1IDogMSAvIE1hdGgubWF4KDIsIDE2IC0gcy56KTsKfQpmdW5jdGlvbiBUbihzLCB0LCBlID0ge30sIG4pIHsKICBjb25zdCBpID0gcy5taWRQb2ludHM7CiAgbGV0IHIgPSBzLmluZGljZXM7CiAgY29uc3QgYSA9IHMuenZlY3RvciwgbyA9IGUuaXNHYW9RaW5nIHx8ICExLCBoID0gZS5pc0RlbGF5IHx8ICExLCBjID0gZS5pc1RyYW5zcGFyZW50IHx8ICExOwogIGlmICghciB8fCAhaSkKICAgIHJldHVybjsKICBjb25zdCBsID0gW10sIHUgPSBbXSwgZCA9IFtdLCB5ID0gW10sIGYgPSBbXTsKICBsZXQgZyA9IFtdLCBfID0gW10sIHcgPSBbXSwgeCA9IFtdLCBtID0gW107CiAgY29uc3QgTSA9IGwubGVuZ3RoIC8gMzsKICBsZXQgeiA9IHFuKGksIGFlICogMTAwLCBuKSwgUCA9ICExLCBUID0gITE7CiAgaWYgKG8pIHsKICAgIGlmIChZICs9IHJ0ICogMSwgYS5sZW5ndGggPT09IDEgJiYgYVswXSkgewogICAgICBQID0gITAsIGFbMF0gPCAwICYmIChUID0gITApOwogICAgICBmb3IgKGxldCBJID0gMCwgQyA9IHoubGVuZ3RoOyBJIDwgQzsgSSArPSAxKQogICAgICAgIHpbSV1bMl0gPSBhWzBdOwogICAgfSBlbHNlIGlmIChhLmxlbmd0aCA+IDEpIHsKICAgICAgUCA9ICEwOwogICAgICBmb3IgKGxldCBJID0gMDsgSSA8IGEubGVuZ3RoOyBJKyspCiAgICAgICAgYVtJXSA8IDAgJiYgKFQgPSAhMCksIHpbSV1bMl0gPSBNYXRoLm1heChhW0ldLCAwKTsKICAgIH0KICB9IGVsc2UgewogICAgY29uc3QgSSA9IFphKG4pOwogICAgaWYgKEkgPiAwKSB7CiAgICAgIGNvbnN0IEMgPSBGaSh6LCByLCBudWxsLCBJKSwgTyA9IEMudmVydGljZXM7CiAgICAgIHogPSBbXTsKICAgICAgZm9yIChsZXQgUiA9IDAsIEQgPSBPLmxlbmd0aCAtIDI7IFIgPCBEOyBSICs9IDMpCiAgICAgICAgei5wdXNoKFtPW1JdLCBPW1IgKyAxXSwgT1tSICsgMl1dKTsKICAgICAgciA9IEMuaW5kaWNlczsKICAgIH0KICB9CiAgbGV0IGIgPSBudWxsOwogIGZvciAobGV0IEkgPSAwLCBDID0gei5sZW5ndGg7IEkgPCBDOyBJICs9IDEpCiAgICBiID0geltJXSwgbC5wdXNoKGJbMF0sIGJbMV0sIGJbMl0pLCBkLnB1c2goMCwgMCwgMSksIGMgPyB5LnB1c2godFswXSwgdFsxXSwgdFsyXSwgdFszXSB8fCAxKSA6IHkucHVzaCh0WzBdLCB0WzFdLCB0WzJdKSwgZi5wdXNoKFkpOwogIGZvciAobGV0IEkgPSAwLCBDID0gci5sZW5ndGg7IEkgPCBDOyBJKyspCiAgICB1LnB1c2goTSArIHJbSV0pOwogIGggfHwgKGcgPSBsLCBfID0gdSwgeCA9IHksIHcgPSBkLCBtID0gZik7CiAgbGV0IE4gPSBQICYmICFUOwogIGlmIChQICYmICFUKSB7CiAgICBjb25zdCBJID0gZS5ib3JkZXJSZ2JhIHx8IHQ7CiAgICBsZXQgQyA9IGggPyAwIDogbC5sZW5ndGggLyAzOwogICAgZm9yIChsZXQgTyA9IDAsIFIgPSB6Lmxlbmd0aDsgTyA8IFI7IE8gKz0gMSkgewogICAgICBiID0geltPXTsKICAgICAgbGV0IEQgPSBiWzJdLCBVID0gRCAtIDI4MDsKICAgICAgVSA8IDAgJiYgKFUgPSAwKSwgZy5wdXNoKAogICAgICAgIGJbMF0sCiAgICAgICAgYlsxXSwKICAgICAgICBELAogICAgICAgIGJbMF0sCiAgICAgICAgYlsxXSwKICAgICAgICBVCiAgICAgICksIHgucHVzaCgKICAgICAgICBJWzBdLAogICAgICAgIElbMV0sCiAgICAgICAgSVsyXSwKICAgICAgICBJWzBdLAogICAgICAgIElbMV0sCiAgICAgICAgSVsyXQogICAgICApLCBtLnB1c2goWSwgWSk7CiAgICAgIGxldCBMID0gTyA9PT0gUiAtIDEgPyAwIDogTyArIDEsIHEgPSBiWzBdLCBrID0gYlsxXSwgVyA9IHpbTF1bMF0sIFggPSB6W0xdWzFdLCBaID0gWwogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICBVIC0gRAogICAgICBdLCBodCA9IFsKICAgICAgICBXIC0gcSwKICAgICAgICBYIC0gaywKICAgICAgICAwCiAgICAgIF0sIHR0ID0gUWkoWiwgaHQpOwogICAgICAhdHRbMF0gJiYgIXR0WzFdICYmICF0dFsyXSAmJiAodHQgPSBbZFtkLmxlbmd0aCAtIDNdLCBkW2QubGVuZ3RoIC0gMl0sIGRbZC5sZW5ndGggLSAxXV0pLCB3LnB1c2goCiAgICAgICAgdHRbMF0sCiAgICAgICAgdHRbMV0sCiAgICAgICAgdHRbMl0sCiAgICAgICAgdHRbMF0sCiAgICAgICAgdHRbMV0sCiAgICAgICAgdHRbMl0KICAgICAgKTsKICAgICAgbGV0IGV0ID0gITE7CiAgICAgIHEgPT09IFcgPyAoTWF0aC5hYnMocSArIDAuNSkgPCBaZSB8fCBNYXRoLmFicyhxIC0gMC41KSA8IFplKSAmJiAoZXQgPSAhMCkgOiBrID09PSBYICYmIChNYXRoLmFicyhrICsgMC41KSA8IFplIHx8IE1hdGguYWJzKGsgLSAwLjUpIDwgWmUpICYmIChldCA9ICEwKSwgZXQgfHwgKE8gPT09IFIgLSAxID8gXy5wdXNoKAogICAgICAgIEMgKyBPICogMiwKICAgICAgICBDICsgTyAqIDIgKyAxLAogICAgICAgIEMsCiAgICAgICAgQywKICAgICAgICBDICsgTyAqIDIgKyAxLAogICAgICAgIEMgKyAxCiAgICAgICkgOiBfLnB1c2goCiAgICAgICAgQyArIE8gKiAyLAogICAgICAgIEMgKyBPICogMiArIDEsCiAgICAgICAgQyArIE8gKiAyICsgMiwKICAgICAgICBDICsgTyAqIDIgKyAyLAogICAgICAgIEMgKyBPICogMiArIDEsCiAgICAgICAgQyArIE8gKiAyICsgMwogICAgICApKTsKICAgIH0KICB9CiAgZm9yIChsZXQgSSA9IDA7IEkgPCBsLmxlbmd0aDsgSSArPSAzKQogICAgbFtJICsgMl0gPSBsW0kgKyAyXSAvIDEwMCAvICR0OwogIGlmIChRdChsLCBuKSwgaCAmJiBOKSB7CiAgICBmb3IgKGxldCBPID0gMDsgTyA8IGcubGVuZ3RoOyBPICs9IDMpCiAgICAgIGdbTyArIDJdID0gZ1tPICsgMl0gLyAxMDAgLyAkdDsKICAgIHJldHVybiBRdChnLCBuKSwgewogICAgICBkZWxheU9iamVjdDogewogICAgICAgIHZlcnRpY2VzOiBnLAogICAgICAgIGluZGljZXM6IF8sCiAgICAgICAgbm9ybWFsczogdywKICAgICAgICBjb2xvcnM6IHgsCiAgICAgICAgbGF5ZXJJbmRpY2VzOiBtCiAgICAgIH0sCiAgICAgIG9iamVjdDogewogICAgICAgIHZlcnRpY2VzOiBsLAogICAgICAgIGluZGljZXM6IHUsCiAgICAgICAgbm9ybWFsczogZCwKICAgICAgICBjb2xvcnM6IHksCiAgICAgICAgbGF5ZXJJbmRpY2VzOiBmCiAgICAgIH0KICAgIH07CiAgfQogIHJldHVybiB7CiAgICB2ZXJ0aWNlczogbCwKICAgIGluZGljZXM6IHUsCiAgICBub3JtYWxzOiBkLAogICAgY29sb3JzOiB5LAogICAgbGF5ZXJJbmRpY2VzOiBmCiAgfTsKfQpmdW5jdGlvbiBZYShzLCB0LCBlLCBuKSB7CiAgY29uc3QgaSA9IHMubWlkUG9pbnRzOwogIGxldCByID0gcy5pbmRpY2VzOwogIGNvbnN0IGEgPSBzLnp2ZWN0b3IsIG8gPSBzLmdyYWRpZW50UG9zOwogIGlmICghciB8fCAhaSkKICAgIHJldHVybjsKICBsZXQgaDsKICBpZiAoYS5sZW5ndGggPT09IDEgJiYgYVswXSkKICAgIGggPSBuZXcgQXJyYXkoaS5sZW5ndGggLyAyKSwgaC5maWxsKGFbMF0pOwogIGVsc2UgaWYgKGEubGVuZ3RoID4gMSkgewogICAgaCA9IFtdOwogICAgZm9yIChsZXQgSSA9IDA7IEkgPCBhLmxlbmd0aDsgSSsrKQogICAgICBoW0ldID0gYVtJXSB8fCAxOwogIH0KICBjb25zdCBjID0gW10sIGwgPSBbXSwgdSA9IFtdLCBkID0gW10sIHkgPSBbXSwgZiA9IGMubGVuZ3RoIC8gMzsKICBsZXQgZyA9IE9uKGkpOwogIGNvbnN0IF8gPSAxIC8gMjU2LCB3ID0gLTAuNSArIF8sIHggPSAwLjUgLSBfOwogIGxldCBtID0gTm4obi56LCBuKTsKICBjb25zdCBNID0gW29bMF0gLyAxMDAsIG9bMV0gLyAxMDBdLCB6ID0gW29bMl0gLyAxMDAsIG9bM10gLyAxMDBdLCBQID0gdC5jb2xvciwgVCA9IGUuY29sb3IsIGIgPSBbelswXSAtIE1bMF0sIHpbMV0gLSBNWzFdXSwgTiA9IE1hdGguc3FydChNYXRoLnBvdyhiWzBdLCAyKSArIE1hdGgucG93KGJbMV0sIDIpKTsKICBmb3IgKGxldCBJID0gMCwgQyA9IGcubGVuZ3RoOyBJIDwgQzsgSSsrKSB7CiAgICBjb25zdCBPID0gZ1tJXTsKICAgIGxldCBSLCBEOwogICAgaWYgKGJbMF0gPT09IDApCiAgICAgIFIgPSBNLCBEID0gT1sxXTsKICAgIGVsc2UgewogICAgICBjb25zdCBaID0gLSgoTVswXSAtIE9bMF0pICogYlswXSArIChNWzFdIC0gT1sxXSkgKiBiWzFdKSAvIChiWzBdICogYlswXSArIGJbMV0gKiBiWzFdKTsKICAgICAgUiA9IFogKiBiWzBdICsgTVswXSwgRCA9IFogKiBiWzFdICsgTVsxXTsKICAgIH0KICAgIGxldCBMID0gTWF0aC5zcXJ0KE1hdGgucG93KFIgLSB6WzBdLCAyKSArIE1hdGgucG93KEQgLSB6WzFdLCAyKSkgLyBOOwogICAgTVswXSA8IHpbMF0gJiYgUiA8IE1bMF0gfHwgTVswXSA+IHpbMF0gJiYgUiA+IE1bMF0gPyBMID0gMSA6IChNWzBdIDwgelswXSAmJiBSID4gelswXSB8fCBNWzBdID4gelswXSAmJiBSIDwgelswXSkgJiYgKEwgPSAwKTsKICAgIGNvbnN0IHEgPSBMICogUFswXSArICgxIC0gTCkgKiBUWzBdLCBrID0gTCAqIFBbMV0gKyAoMSAtIEwpICogVFsxXSwgVyA9IEwgKiBQWzJdICsgKDEgLSBMKSAqIFRbMl07CiAgICBDbihPLCBtLCB3LCB4KTsKICAgIGNvbnN0IFggPSBoID8gaFtJXSAvIDEwMCAvICR0IDogYWU7CiAgICBjLnB1c2goT1swXSwgT1sxXSwgWCksIGQucHVzaChxLCBrLCBXKSwgdS5wdXNoKDAsIDAsIDEpLCB5LnB1c2goWSk7CiAgfQogIGZvciAobGV0IEkgPSAwLCBDID0gci5sZW5ndGg7IEkgPCBDOyBJKyspCiAgICBsLnB1c2goZiArIHJbSV0pOwogIHJldHVybiBRdChjLCBuKSwgewogICAgdmVydGljZXM6IGMsCiAgICBpbmRpY2VzOiBsLAogICAgbm9ybWFsczogdSwKICAgIGNvbG9yczogZCwKICAgIGxheWVySW5kaWNlczogeQogIH07Cn0KZnVuY3Rpb24gQnQocywgdCwgZSkgewogIGxldCBuID0gMDsKICByZXR1cm4gcyAmJiAobiB8PSAxKSwgdCAmJiAobiB8PSAyKSwgZSAmJiAobiB8PSA0KSwgbjsKfQpmdW5jdGlvbiBYYShzLCB0LCBlLCBuKSB7CiAgY29uc3QgaSA9IHMubWlkUG9pbnRzLCByID0gcy5pbmRpY2VzLCBhID0gcy5hbHRpdHVkZSAvICR0OwogIGlmICghciB8fCAhaSkKICAgIHJldHVybjsKICBjb25zdCBvID0gW10sIGggPSBbXSwgYyA9IFtdLCBsID0gW10sIHUgPSBbXSwgZCA9IHFuKGksIGEgKyBhZSwgbik7CiAgbGV0IHkgPSBudWxsOwogIGZvciAobGV0IHcgPSAwLCB4ID0gZC5sZW5ndGg7IHcgPCB4OyB3ICs9IDEpCiAgICB5ID0gZFt3XSwgby5wdXNoKHlbMF0sIHlbMV0sIHlbMl0pLCBjLnB1c2goMCwgMCwgMSksIGwucHVzaCh0WzBdLCB0WzFdLCB0WzJdKSwgdS5wdXNoKHlbMl0sIEJ0KCExLCAhMSwgITEpKTsKICBmb3IgKGxldCB3ID0gMCwgeCA9IHIubGVuZ3RoOyB3IDwgeDsgdysrKQogICAgaC5wdXNoKHJbd10pOwogIGNvbnN0IGYgPSBvLmxlbmd0aCAvIDMsIF8gPSBQcyhkKSA/IGQubGVuZ3RoIC0gMSA6IGQubGVuZ3RoOwogIGZvciAobGV0IHcgPSAwLCB4ID0gXzsgdyA8IHg7IHcgKz0gMSkgewogICAgbGV0IG0gPSBbZFt3XVswXSwgZFt3XVsxXSwgYWVdLCBNID0gW2Rbd11bMF0sIGRbd11bMV0sIGRbd11bMl1dLCB6ID0gdyArIDE7CiAgICB3ID09PSB4IC0gMSAmJiAoeiA9IDApOwogICAgbGV0IFAgPSBbZFt6XVswXSwgZFt6XVsxXSwgYWVdLCBUID0gW2Rbel1bMF0sIGRbel1bMV0sIGRbel1bMl1dLCBiID0gdyA9PT0gMCA/IHggLSAxIDogdyAtIDEsIE4gPSBbZFtiXVswXSwgZFtiXVsxXSwgYWVdLCBJID0gWwogICAgICBQWzBdIC0gbVswXSwKICAgICAgUFsxXSAtIG1bMV0sCiAgICAgIFBbMl0gLSBtWzJdCiAgICBdLCBDID0gWwogICAgICBNWzBdIC0gbVswXSwKICAgICAgTVsxXSAtIG1bMV0sCiAgICAgIE1bMl0gLSBtWzJdCiAgICBdLCBPID0gUWkoSSwgQyk7CiAgICBvLnB1c2goCiAgICAgIG1bMF0sCiAgICAgIG1bMV0sCiAgICAgIG1bMl0sCiAgICAgIE1bMF0sCiAgICAgIE1bMV0sCiAgICAgIE1bMl0sCiAgICAgIFBbMF0sCiAgICAgIFBbMV0sCiAgICAgIFBbMl0sCiAgICAgIFRbMF0sCiAgICAgIFRbMV0sCiAgICAgIFRbMl0KICAgICksIGMucHVzaCgKICAgICAgT1swXSwKICAgICAgT1sxXSwKICAgICAgT1syXSwKICAgICAgT1swXSwKICAgICAgT1sxXSwKICAgICAgT1syXSwKICAgICAgT1swXSwKICAgICAgT1sxXSwKICAgICAgT1syXSwKICAgICAgT1swXSwKICAgICAgT1sxXSwKICAgICAgT1syXQogICAgKSwgbC5wdXNoKAogICAgICBlWzBdLAogICAgICBlWzFdLAogICAgICBlWzJdLAogICAgICBlWzBdLAogICAgICBlWzFdLAogICAgICBlWzJdLAogICAgICBlWzBdLAogICAgICBlWzFdLAogICAgICBlWzJdLAogICAgICBlWzBdLAogICAgICBlWzFdLAogICAgICBlWzJdCiAgICApOwogICAgbGV0IFIgPSBEbihOLCBtLCBQKTsKICAgIHcgPT09IDAgPyB1LnB1c2goCiAgICAgIDAsCiAgICAgIEJ0KCEwLCBSLCAhMSksCiAgICAgIE1bMl0sCiAgICAgIEJ0KCExLCBSLCAhMSkKICAgICkgOiB1LnB1c2goCiAgICAgIDAsCiAgICAgIEJ0KCEwLCBSLCAhMCksCiAgICAgIE1bMl0sCiAgICAgIEJ0KCExLCBSLCAhMCksCiAgICAgIDAsCiAgICAgIEJ0KCEwLCBSLCAhMSksCiAgICAgIE1bMl0sCiAgICAgIEJ0KCExLCBSLCAhMSkKICAgICksIHcgPT09IHggLSAxICYmIChSID0gRG4obSwgUCwgZFt6ICsgMV0pLCB1LnB1c2goCiAgICAgIDAsCiAgICAgIEJ0KCEwLCBSLCAhMCksCiAgICAgIE1bMl0sCiAgICAgIEJ0KCExLCBSLCAhMCkKICAgICkpOwogICAgY29uc3QgRCA9IGYgKyB3ICogNDsKICAgIGgucHVzaCgKICAgICAgRCwKICAgICAgRCArIDIsCiAgICAgIEQgKyAzLAogICAgICBELAogICAgICBEICsgMywKICAgICAgRCArIDEKICAgICk7CiAgfQogIHJldHVybiBRdChvLCBuKSwgewogICAgdmVydGljZXM6IG8sCiAgICBpbmRpY2VzOiBoLAogICAgbm9ybWFsczogYywKICAgIGNvbG9yczogbCwKICAgIGhlaWdodEFuZENvbmNhdmVzOiB1CiAgfTsKfQpmdW5jdGlvbiBRYShzLCB0KSB7CiAgY29uc3QgZSA9IExuKHMpOwogIGlmICghZSkKICAgIHJldHVybiBudWxsOwogIGNvbnN0IG4gPSAyLCBpID0gZVswXSAvIG4gKiB0LCByID0gZVsxXSAvIG4gKiB0LCBhID0gTWF0aC5yb3VuZCgtaSAvIDIpLCBvID0gTWF0aC5yb3VuZCgtciAvIDIpLCBoID0gYSArIGksIGMgPSBvLCBsID0gaCwgdSA9IGMgKyByOwogIHJldHVybiB7CiAgICB2ZXJ0ZXg6IFthLCBvLCBoLCBjLCBsLCB1LCBhLCBvLCBsLCB1LCBhLCB1XSwKICAgIHRleGNvb3JkOiBudWxsLAogICAgd2lkdGg6IGksCiAgICBoZWlnaHQ6IHIsCiAgICBpY29uVHlwZTogcwogIH07Cn0KZnVuY3Rpb24gTG4ocykgewogIGlmICghcyB8fCBzID09PSAiZGlzZWtvbmciKQogICAgcmV0dXJuIG51bGw7CiAgbGV0IHQgPSBzZWxmLmljb25TZXRJbmZvW3NdIHx8IHNlbGYuaWNvblNldEluZm9bIk1hcFJlcy8iICsgc107CiAgcmV0dXJuICF0ICYmIHMgJiYgcy5jaGFyQ29kZUF0KDApID49IDQ4ICYmIHMuY2hhckNvZGVBdCgwKSA8PSA1NyAmJiAodCA9IHNlbGYuaWNvblNldEluZm9bIl8iICsgc10pLCB0Owp9CmZ1bmN0aW9uIFhpKHMsIHQsIGUsIG4sIGkpIHsKICBsZXQgYSA9IE1hdGgucm91bmQocyAvIDEwMCksIG8gPSBNYXRoLnJvdW5kKHQgLyAxMDApOwogIGNvbnN0IGggPSBEYShuLnosIG4pOwogIHJldHVybiBtZS54ID0gYSAvIGggLSAwLjUsIG1lLnkgPSBvIC8gaCAtIDAuNSwgbWUueiA9IGUgfHwgMCwgVmEobWUsIG4sIGZlKSwgbi5pc05vcm1hbGl6ZWQgfHwgKG4uc291cmNlUHJvamVjdGlvbi51bnByb2plY3RDb29yZGluYXRlKGZlLCBtZSksIG4udGFyZ2V0UHJvamVjdGlvbi5wcm9qZWN0Q29vcmRpbmF0ZShtZSwgZmUpKSwgaVswXSA9IGZlLngsIGlbMV0gPSBmZS55LCBpWzJdID0gZmUueiwgaTsKfQpmdW5jdGlvbiAkYShzLCB0LCBlLCBuKSB7CiAgY29uc3QgaSA9IG4uc3R5bGVUZXh0LCByID0gcy5uYW1lLCBhID0gcy5kaXJlY3Rpb247CiAgbGV0IG8sIGgsIGMgPSAwLCBsID0gMCwgdSA9ICExOwogIGNvbnN0IGQgPSByICE9PSAiIiAmJiAhIWk7CiAgaWYgKG4uc3R5bGVQdCkgewogICAgbGV0IGYgPSAobi5zdHlsZVB0Lnpvb20gfHwgMTAwKSAvIDEwMDsKICAgIG8gPSBuLnN0eWxlUHQuaWNvbjsKICAgIGNvbnN0IF8gPSBMbihvKTsKICAgIHUgPSAhIShhID09PSB2YSAmJiBkICYmIF8pLCBvICE9PSBudWxsICYmICF1ID8gKGggPSBRYShvLCBmKSwgaCAmJiAoYyA9IGgud2lkdGgsIGwgPSBoLmhlaWdodCkpIDogXyAmJiAoYyA9IF9bMF0sIGwgPSBfWzFdKTsKICB9CiAgbiA9IG4uc3R5bGVUZXh0OwogIGxldCB5ID0gWzAsIDAsIDBdOwogIHJldHVybiB5ID0gWGkocy5wb3N4LCBzLnBvc3ksIHNlbGYuekluZGV4LCBlLCB5KSwgewogICAgcG9zaXRpb246IHksCiAgICB0ZXh0OiBzLm5hbWUsCiAgICBzdHlsZUlkOiB0LAogICAgc3R5bGVDb25maWc6IG4sCiAgICBpY29uQ29uZmlnOiB7CiAgICAgIGljb246IG8sCiAgICAgIHBvczogaCwKICAgICAgc2l6ZTogW2MsIGxdLAogICAgICB0ZXh0RHJhd09uSWNvbjogdQogICAgfSwKICAgIGhhc1RleHQ6IGQsCiAgICAuLi5zCiAgfTsKfQpmdW5jdGlvbiBIYShzLCB0LCBlLCBuLCBpKSB7CiAgY29uc3QgciA9IDEwMCAqICR0LCBhID0gMjsKICBsZXQgbyA9IHQubmFtZUxlbiB8fCB0Lm5hbWUuc3BsaXQoIiIpLmxlbmd0aDsKICBpZiAobyA9PT0gMCkKICAgIHJldHVybjsKICBsZXQgaCA9IHQuenZlY3RvciwgYyA9IHQueCwgbCA9IHQucmV2ZXJzZSwgdSA9IHQudHJhY2VyLCBkID0gdS5sZW5ndGgsIHkgPSBbaFswXV0sIGYgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjLnNsaWNlKDAsIGEpKTsKICBmb3IgKGxldCBnID0gYSwgXyA9IDE7IGcgPCBjLmxlbmd0aDsgZyArPSBhLCBfKyspCiAgICBmW2ddID0gZltnIC0gYV0gKyBjW2ddLCBmW2cgKyAxXSA9IGZbZyAtIChhIC0gMSldICsgY1tnICsgMV0sIGgubGVuZ3RoID09PSAxID8geVtfXSA9IGhbMF0gOiBoLmxlbmd0aCA+IDEgJiYgKHlbX10gPSB5W18gLSAxXSArIGhbX10pOwogIGZvciAobGV0IGcgPSAwOyBnIDwgZDsgZysrKSB7CiAgICBsZXQgXyA9IHVbZ10sIHcgPSBsW2ddOwogICAgaWYgKCFSbihfLCBuKSkKICAgICAgY29udGludWU7CiAgICBsZXQgeCA9IGcgKiBvICogYTsKICAgIGMgPSBmLnNsaWNlKHgsIHggKyBvICogYSk7CiAgICBsZXQgbSA9IDA7CiAgICBoLmxlbmd0aCA+IDAgJiYgKG0gPSB5W2cgKiBvXSAvIHIpOwogICAgbGV0IE0gPSBbMCwgMCwgMF07CiAgICBNID0gWGkoY1swXSwgY1sxXSwgbSArIChzZWxmLnpJbmRleCB8fCAwKSwgbiwgTSk7CiAgICBsZXQgeiA9IGNbKG8gLSAxKSAqIGFdIC0gY1swXSwgUCA9IGNbKG8gLSAxKSAqIGEgKyAxXSAtIGNbMV0sIFQgPSBNYXRoLmF0YW4yKC1QLCAteikgKyBNYXRoLlBJOwogICAgdyA9PT0gMSAmJiAoVCArPSBNYXRoLlBJKSwgcy5wdXNoKHsKICAgICAgdHlwZTogImxhYmVscCIsCiAgICAgIHBvc2l0aW9uOiBNLAogICAgICB0ZXh0OiB0Lm5hbWUsCiAgICAgIHJvdGF0ZVo6IFQsCiAgICAgIHN0eWxlQ29uZmlnOiBpLAogICAgICBoYXNUZXh0OiAhMCwKICAgICAgLi4udAogICAgfSk7CiAgfQp9CmZ1bmN0aW9uIE9uKHMsIHQpIHsKICB0ID0gdCB8fCAyOwogIGxldCBlID0gbmV3IEFycmF5KHQpLmZpbGwoMCk7CiAgY29uc3QgbiA9IFtdOwogIGZvciAobGV0IGkgPSAwLCByID0gcy5sZW5ndGggLSAodCAtIDEpOyBpIDwgcjsgaSArPSB0KSB7CiAgICBjb25zdCBhID0gW107CiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHQ7IG8rKykKICAgICAgZVtvXSArPSBzW2kgKyBvXSwgYS5wdXNoKGVbb10gLyAxMDApOwogICAgdCA+IDEgPyBuLnB1c2goYSkgOiBuLnB1c2goYVswXSk7CiAgfQogIHJldHVybiBuOwp9CmZ1bmN0aW9uIHFuKHMsIHQgPSAwLCBlKSB7CiAgY29uc3QgbiA9IDM5MDYyNWUtOCwgaSA9IC0wLjUgKyBuLCByID0gMC41IC0gbjsKICBsZXQgYSA9IE5uKGUueiwgZSksIG8gPSAwLCBoID0gMCwgYyA9IDAsIGwgPSAwOwogIGNvbnN0IHUgPSBbXTsKICBmb3IgKGxldCBkID0gMCwgeSA9IHMubGVuZ3RoIC0gMTsgZCA8IHk7IGQgKz0gMikKICAgIG8gKz0gc1tkXSwgaCArPSBzW2QgKyAxXSwgYyA9IG8gLyBhIC0gMC41LCBsID0gaCAvIGEgLSAwLjUsIHNlbGYuaXNBdHRhY2ggJiYgKGMgPCBpICYmIChjID0gLTAuNSksIGMgPiByICYmIChjID0gMC41KSwgbCA8IGkgJiYgKGwgPSAtMC41KSwgbCA+IHIgJiYgKGwgPSAwLjUpKSwgdS5wdXNoKFtjLCBsLCB0XSk7CiAgcmV0dXJuIHU7Cn0Kc2VsZi5oYW5kbGVDaGFuZ2VTdHlsZSA9IChzKSA9PiB7CiAgc2VsZi5mZWF0dXJlU3R5bGVzID0gcy5mZWF0dXJlU3R5bGVzLCBzZWxmLmNhY2hlZFN0eWxlcyA9IHt9Owp9OwpzZWxmLmhhbmRsZUNoYW5nZUljb25TZXRJbmZvID0gKHMpID0+IHsKICBzZWxmLmljb25TZXRJbmZvID0gcy5pY29uU2V0SW5mbzsKfTsKZnVuY3Rpb24gcHQocywgdCwgZSwgbiA9IHJlLCBpKSB7CiAgY29uc3QgciA9IHNlbGYuZmVhdHVyZVN0eWxlc1sxXSwgYSA9IHNlbGYuZmVhdHVyZVN0eWxlc1syXTsKICBlICs9IGkud29ya2VyT3B0aW9ucy5zdHlsZVpvb21PZmZzZXQgfHwgMCwgbiA9PT0gUGUgJiYgZSA9PT0gOSAmJiAoZSA9IDgpOwogIGxldCBvID0gcltlXVswXTsKICBpZiAoIW8pCiAgICByZXR1cm47CiAgbGV0IGggPSBvW3RdOwogIGlmICghaCAmJiAobiA9PT0gUGUgfHwgbiA9PT0gSW4pICYmIChvID0gcltlICsgMV0gJiYgcltlICsgMV1bMF0sIGggPSBvICYmIG9bdF0pLCAhaCkKICAgIHJldHVybjsKICBsZXQgYywgbDsKICBmb3IgKGxldCBkID0gMDsgZCA8IGgubGVuZ3RoOyBkKyspIHsKICAgIGlmIChjID0gaFtkXSwgc2VsZi5jYWNoZWRTdHlsZXNbYCR7c31fJHtufV8ke2N9YF0pCiAgICAgIHJldHVybiBzZWxmLmNhY2hlZFN0eWxlc1tgJHtzfV8ke259XyR7Y31gXTsKICAgIGlmIChsID0gYVtuXVtjXSwgbCkKICAgICAgYnJlYWs7CiAgfQogIGlmICghbCkKICAgIHJldHVybjsKICBsZXQgdSA9IG51bGw7CiAgcmV0dXJuIG4gPT09IHJlID8gdSA9IHsKICAgIGNvbG9yOiBHdChsWzBdKSwKICAgIGJvcmRlclJnYmE6IEd0KGxbMV0pLAogICAgYm9yZGVyV2lkdGg6IGxbMl0sCiAgICBib3JkZXJUZXh0dXJlOiBsWzNdLAogICAgd2F0ZXJTdHlsZTogbFs1XSwKICAgIGhhbG9TdHlsZTogbFs2XSwKICAgIHRleHR1cmVTdHlsZTogbFs3XSwKICAgIHRoaWNrUmdiYTogR3QobFs4XSkKICB9IDogbiA9PT0gWGUgPyB1ID0gewogICAgYm9yZGVyQ29sb3I6IEd0KGxbMF0pLAogICAgZmlsbENvbG9yOiBHdChsWzFdKSwKICAgIGJvcmRlcldpZHRoOiBsWzJdLAogICAgZmlsbFdpZHRoOiBsWzNdLAogICAgYm9yZGVyQ2FwOiBsWzRdLAogICAgZmlsbENhcDogbFs1XSwKICAgIGhhdmVCb3JkZXJMaW5lOiBsWzZdLAogICAgaGF2ZUZpbGxUZXh0dXJlOiBsWzhdLAogICAgZmlsbFRleHR1cmU6IGxbMTJdCiAgfSA6IG4gPT09IEluID8gdSA9IHsKICAgIGZpbHRlcjogbFswXSwKICAgIHJhdGlvOiBsWzFdLAogICAgaGF2ZUJvcmRlcjogbFsyXSwKICAgIGJvcmRlcldpZHRoOiBsWzNdLAogICAgYm9yZGVyUmdiYTogR3QobFs0XSksCiAgICBmaWxsVG9wOiBHdChsWzVdKSwKICAgIGZpbGxTaWRlOiBHdChsWzZdKQogIH0gOiBuID09PSBQZSA/IHUgPSB7CiAgICBmb250UmdiYTogUG4obFswXSksCiAgICBoYWxvUmdiYTogUG4obFsxXSksCiAgICBiYWNrUmdiYTogUG4obFsyXSksCiAgICBmb250U2l6ZTogbFszXSwKICAgIGhhbG9TaXplOiBsWzRdLAogICAgZm9udFdlaWdodDogbFs1XSwKICAgIGZvbnRTdHlsZTogbFs2XSwKICAgIGRlbnNpdHk6IGxbN10KICB9IDogbiA9PT0gWmkgJiYgKHUgPSB7CiAgICByYW5rOiBsWzBdLAogICAgdWNmbGFnOiBsWzFdLAogICAgaWNvbjogbFsyXSwKICAgIGljb25UeXBlOiBsWzNdLAogICAgbmluZUdHOiBsWzRdLAogICAgZGVuc2l0eTogbFs1XSwKICAgIHpvb206IGxbNl0KICB9KSwgYyAmJiAoc2VsZi5jYWNoZWRTdHlsZXNbYCR7c31fJHtufV8ke2N9YF0gPSB1KSwgdTsKfQpmdW5jdGlvbiBRaShzLCB0KSB7CiAgY29uc3QgZSA9IFtdOwogIHJldHVybiBlWzBdID0gc1sxXSAqIHRbMl0gLSBzWzJdICogdFsxXSwgZVsxXSA9IHNbMl0gKiB0WzBdIC0gc1swXSAqIHRbMl0sIGVbMl0gPSBzWzBdICogdFsxXSAtIHNbMV0gKiB0WzBdLCBlOwp9Cg==", S0 = typeof window < "u" && window.Blob && new Blob([atob(z_)], { type: "text/javascript;charset=utf-8" });
function iV() {
  const s = S0 && (window.URL || window.webkitURL).createObjectURL(S0);
  try {
    return s ? new Worker(s) : new Worker("data:application/javascript;base64," + z_, { type: "module" });
  } finally {
    s && (window.URL || window.webkitURL).revokeObjectURL(s);
  }
}
function Ta(s = "", t, e = 3) {
  function i(n, o) {
    return e--, fetch(n, o).then((r) => {
      if (r.status === 200)
        return r;
    }).catch((r) => {
      if (e > 0)
        return i(n, o);
    });
  }
  return i(s, t);
}
function X_(s, t, e) {
  let i, n, o, r = "";
  const a = [], c = "jsonp" + Math.ceil(Math.random() * 1e5), l = s.indexOf("?") > 0 ? "&" : "?";
  e = Object.assign({}, {
    jsonpCallback: "jsonp",
    timeout: 5e4,
    jsonp: "callback"
  }, e);
  for (let C in t)
    ({}).hasOwnProperty.call(t, C) && (typeof t[C] == "object" ? r = C + "=" + JSON.stringify(t[C]) : r = C + "=" + t[C], a.push(r));
  s += l + a.join("&"), o = document.getElementsByTagName("script")[0] || document.head, s = s + "&" + e.jsonp + "=" + c, n = document.createElement("script"), n.src = s, n.type = "text/javascript", o.parentNode.appendChild(n, o);
  function d() {
    n.parentNode && n.parentNode.removeChild(n), i && clearTimeout(i), window[c] = null;
  }
  return new Promise((C, p) => {
    window[c] = (m) => {
      if (m && typeof m == "string")
        try {
          m = JSON.parse(m);
        } catch {
          m = {}, console.error("[ERROR] Parse Error.");
        }
      C(m), d();
    }, n.onerror = (m) => {
      d(), p({
        errno: -2,
        errmsg: `[ERROR] Load Error: ${m}`,
        data: {}
      });
    }, e.timeout && (i = setTimeout(() => {
      d(), p({
        errno: -3,
        errmsg: "[ERROR] Time out.",
        data: {}
      });
    }, e.timeout));
  });
}
const QC = (s, t) => fetch(s, Object.assign(t, { credentials: "include" })).then((e) => {
  if (e.ok)
    return e.json();
  throw Error("");
}).then((e) => e).catch(() => {
}), nV = (s) => QC(s, { method: "GET" }), sV = (s, t) => QC(s, {
  method: "POST",
  body: t
});
function YC() {
  let s, t;
  const e = new Promise(function(i, n) {
    s = i, t = n;
  });
  return {
    resolve: s,
    reject: t,
    promise: e
  };
}
const xY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  reFetch: Ta,
  jsonp: X_,
  request: QC,
  get: nV,
  post: sV,
  defer: YC
}, Symbol.toStringTag, { value: "Module" })), oV = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

#include <normal_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>

#ifdef MVT_USE_VERTEX_ZINDEX
attribute float layerIndex;
uniform float maxLayerIndex;
varying float vLayerIndex;

#define WORLD_DISTANCE_NEAR 100000.0
#define WORLD_DISTANCE_MID 1500000.0
#define WORLD_DISTANCE_FAR 6000000.0
#define LAYER_INDEX (maxLayerIndex - layerIndex)
// \u5728mid\u548Cfar\u4EA4\u63A5\u90A3\u5757\uFF0C\u56E0\u4E3A\u7EBF\u6570\u636E\u7279\u522B\u788E\uFF0C\u5BFC\u81F4layerIndex\u5F88\u591A\uFF0C\u5730\u9762\u4F1A\u9677\u5F88\u6DF1\uFF0C\u8FD8\u6CA1\u627E\u5230\u6BD4\u8F83\u597D\u7684\u51FD\u6570\u6765\u89E3\u51B3\u8FD9\u4E2Acase

float y1(float x) {
    return pow(LAYER_INDEX * log2(x * 5.), 1.5);
}

float y2(float x) {
    float xx = x - WORLD_DISTANCE_NEAR;
    return LAYER_INDEX * log2(xx) + y1(WORLD_DISTANCE_NEAR);
}

float y3(float x) {
    float xx = x - WORLD_DISTANCE_MID;
    return log2(LAYER_INDEX * xx) + y2(WORLD_DISTANCE_MID);
}

float y4(float x) {
    return 110. * LAYER_INDEX + y3(WORLD_DISTANCE_FAR);
}

/**
y1 = pow(x, 2)                  x: (0, near]
y2 = (x - near) + y1(near)      x: (near, mid]
y3 = sqrt(x - mid) + y2(mid)    x: (mid, far]
y4 = n + y3(far)                x: (far, +\u221E)
*/
float y(float x) {
    if (x <= WORLD_DISTANCE_NEAR) {
        return y1(x);
    }
    if (x > WORLD_DISTANCE_NEAR && x <= WORLD_DISTANCE_MID) {
        return y2(x);
    }
    else if (x > WORLD_DISTANCE_MID && x <= WORLD_DISTANCE_FAR) {
        return y3(x);
    }
    else if (x > WORLD_DISTANCE_FAR) {
        return y4(x);
    }
}
#endif

#ifdef USE_AO
attribute vec2 heightAndConcave;

varying float v_concave;
varying float v_h;
varying float v_ground;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    #ifdef MVT_USE_COLOR4
        attribute vec4 aColor;
    #endif
#endif

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        #ifdef MVT_USE_COLOR4
            vColor = aColor;
        #else 
            vColor = vec4(color, 1.0);
        #endif
    #endif

    #include <begin_vertex>
    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);

    #ifdef MVT_USE_VERTEX_ZINDEX
        // vec3 worldToEye = cameraPosition - worldPosition.xyz;
        // float dis = length(worldToEye);
        // float layerGap = maxLayerIndex - layerIndex;
        // // float zOffset = log2(layerGap * dis + 1.0);
        // // float zOffset = exp(layerGap * log2(dis * 10.));
        // float zOffset = y(dis);
        // // if (dis > WORLD_DISTANCE_NEAR && dis <= WORLD_DISTANCE_MID) {
        // //     zOffset = layerGap * dis * 0.0001;
        // // }
        // // else if (dis > WORLD_DISTANCE_MID && dis <= WORLD_DISTANCE_FAR) {
        // //     zOffset = layerGap * dis * 0.001;
        // // }
        // // else if (dis > WORLD_DISTANCE_FAR) {
        // //     zOffset = layerGap * dis * 0.01;
        // // }
        // worldPosition.z -= zOffset;

        vLayerIndex = layerIndex;
    #endif

    #ifdef USE_AO
        v_h = heightAndConcave.x;
        float encodeConcave = heightAndConcave.y;
        v_ground = mod(encodeConcave, 2.0);
        float concave = mod(floor(encodeConcave * 0.5), 2.0);
        float start = mod(floor(encodeConcave * 0.25), 2.0);
        concave = pow(concave, 2.2);
        v_concave = mix(concave, -concave, start);
    #endif

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    // #ifdef MVT_USE_VERTEX_ZINDEX
    //     float depth = layerGap * 1000.0;
    //     gl_Position.z = gl_Position.z + depth;
    // #endif

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    #include <fog_vertex>
    #include <logdepthbuf_vertex>

}

`, rV = `#define GLSLIFY 1
#include <common>
#include <packing>
#include <fog_pars_fragment>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform float opacity;

#ifdef USE_AO
    uniform float concaveIntensity;
    uniform float heightIntensity;

    varying float v_concave;
    varying float v_ground;
    varying float v_h;
#endif

#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>

#include <mvt_depth_range_pars_fragment>

void main() {

    vec4 diffuseColor = vec4(0.0);
    #ifdef MVT_USE_VERTEX_COLOR
        diffuseColor = vColor;
    #else
        diffuseColor = vec4(color, 1.0);
    #endif

    diffuseColor.a *= opacity;
    if (diffuseColor.a <= 0.) {
        discard;
    }

    #if ( NUM_DIR_LIGHTS > 0 )
        // \u6839\u636E\u65B9\u5411\u5149\u7684\u65B9\u5411\u4E0E\u6CD5\u5411\uFF0C\u6765\u8BA1\u7B97\u989C\u8272\u8870\u51CF\u7A0B\u5EA6\uFF0C\u503C\u8303\u56F4\u4E3A-1~1\uFF0C\u7ED9\u91CD\u6620\u5C04\u52300.8~1\u7684\u8303\u56F4
        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);
        gl_FragColor = vec4(diffuseColor.rgb * (normalLightIntensity / 10.0 + 0.9), diffuseColor.a);
    #else 
        gl_FragColor = diffuseColor;
    #endif

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #ifdef USE_AO
        float ao_shade = 1.0;
        float concave = v_concave * v_concave;
        float intensity = concaveIntensity;
        float x_shade = mix(1.0, mix(0.6, 0.75, min(0.01, 1.0)), intensity) + 0.1 * intensity;
        ao_shade *= mix(1.0, x_shade * x_shade * x_shade, concave);

        intensity = heightIntensity;
        float h_floors = v_h / 3.0;
        float y_shade = 1.0 - 0.9 * intensity * min(v_ground, 1.0);
        ao_shade *= (1.0 - 0.08 * intensity) * (y_shade + (1.0 - y_shade) * (1.0 - pow(1.0 - min(h_floors / 16.0, 1.0), 16.0))) + 0.08 * intensity * min(h_floors / 160.0, 1.0);

        gl_FragColor.rgb *= ao_shade;
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <mvt_depth_range_fragment>
}

`, aV = we.merge([
  Xt.fog,
  Xt.lights,
  {
    opacity: { value: 1 },
    uColor: { value: [0, 1, 1] },
    vertexColors: { value: !1 },
    vertexZIndex: { value: !1 },
    maxLayerIndex: { value: 0 },
    isEmissive: { value: !1 },
    depthRange: { value: new Z(0, 1) },
    concaveIntensity: { value: 0.2 },
    heightIntensity: { value: 0.4 }
  }
]);
class Xc extends di {
  constructor(t) {
    super(), this.name = "BaiduVectorMaterial", this.type = "BaiduVectorMaterial", this.isBaiduVectorMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = rV, this.vertexShader = oV, Object.assign(this.uniforms, we.clone(aV)), oi(this, [
      "opacity",
      "maxLayerIndex",
      "isEmissive",
      "concaveIntensity",
      "heightIntensity"
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"],
      ["isColor4", "MVT_USE_COLOR4"],
      ["useAO", "USE_AO"]
    ]), this.setValues(t);
  }
}
const gV = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

attribute float totalLength;
attribute float lengths;
attribute float randomFactor;

#ifdef USE_PREV_NEXT
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 viewportTransform;
uniform float fovX;
uniform float fovY;
attribute vec3 prev;
attribute vec3 next;
attribute vec2 expandAndPrev;
#else
attribute float aWidth;
#endif

#ifdef MVT_USE_EXTENT_CLIP
attribute vec2 extentVertex;
varying vec2 vExtentVertex;
#endif

uniform float elapsedTime;
uniform bool vertexColors;
uniform bool antialias;
uniform float lineWidth;
uniform float height;
uniform float uZoomUnits;
uniform bool useZoomUnits;

varying vec2 vUV;
varying vec3 vNormal;
varying vec4 vColor;
varying float vAliasPart;
varying float vCounter;
varying float vLength;
varying float vTotalLength;
varying float vZoomUnits;
varying float vClippedLength;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

#ifdef MVT_USE_VERTEX_DASHARRAY
attribute float aDashArray;
varying float vDashArray;
#endif

#ifdef MVT_USE_VERTEX_DASHRATIO
attribute float aDashRatio;
varying float vDashRatio;
#endif

attribute vec2 prevAndNextLength;

#ifdef USE_DASH
varying vec2 vPrevAndNextLength;
#endif

float branchFreeTernary(bool comparison, float a, float b) {
    float useA = float(comparison);
    return a * useA + b * (1.0 - useA);
}

#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

#ifdef MVT_USE_VERTEX_ZINDEX
attribute float layerIndex;
uniform float maxLayerIndex;

#define WORLD_DISTANCE_NEAR 100000.0
#define WORLD_DISTANCE_MID 1500000.0
#define WORLD_DISTANCE_FAR 6000000.0
#define LAYER_INDEX (maxLayerIndex - layerIndex)
// \u5728mid\u548Cfar\u4EA4\u63A5\u90A3\u5757\uFF0C\u56E0\u4E3A\u7EBF\u6570\u636E\u7279\u522B\u788E\uFF0C\u5BFC\u81F4layerIndex\u5F88\u591A\uFF0C\u5730\u9762\u4F1A\u9677\u5F88\u6DF1\uFF0C\u8FD8\u6CA1\u627E\u5230\u6BD4\u8F83\u597D\u7684\u51FD\u6570\u6765\u89E3\u51B3\u8FD9\u4E2Acase

float y1(float x) {
    return pow(LAYER_INDEX * log2(x * 5.), 1.5);
}

float y2(float x) {
    float xx = x - WORLD_DISTANCE_NEAR;
    return LAYER_INDEX * log2(xx) + y1(WORLD_DISTANCE_NEAR);
}

float y3(float x) {
    float xx = x - WORLD_DISTANCE_MID;
    return log2(LAYER_INDEX * xx) + y2(WORLD_DISTANCE_MID);
}

float y4(float x) {
    return 110. * LAYER_INDEX + y3(WORLD_DISTANCE_FAR);
}

/**
y1 = pow(x, 2)                  x: (0, near]
y2 = (x - near) + y1(near)      x: (near, mid]
y3 = sqrt(x - mid) + y2(mid)    x: (mid, far]
y4 = n + y3(far)                x: (far, +\u221E)
*/
float y(float x) {
    if (x <= WORLD_DISTANCE_NEAR) {
        return y1(x);
    }
    if (x > WORLD_DISTANCE_NEAR && x <= WORLD_DISTANCE_MID) {
        return y2(x);
    }
    else if (x > WORLD_DISTANCE_MID && x <= WORLD_DISTANCE_FAR) {
        return y3(x);
    }
    else if (x > WORLD_DISTANCE_FAR) {
        return y4(x);
    }
}
varying float vLayerIndex;
#endif

#ifdef USE_PREV_NEXT

vec4 eyeToWindowCoordinates(vec4 positionEC) {
    vec4 q = projectionMatrix * positionEC;
    q.xyz /= q.w;
    q.xyz = (viewportTransform * vec4(q.xyz, 1.0)).xyz;

    return q;
}

void clipLineSegmentWithLengthToNearPlane(
    vec3 p0,
    vec3 p1,
    float l0,
    float l1,
    out vec4 positionWC,
    out bool clipped,
    out bool culledByNearPlane,
    out vec4 clippedPositionEC,
    out float clippedLength
)
{
    culledByNearPlane = false;
    clippedLength = l0;
    clipped = false;

    vec3 p0ToP1 = p1 - p0;
    float magnitude = length(p0ToP1);
    vec3 direction = normalize(p0ToP1);
    float lengthDistance = l1 - l0;

    float endPoint0Distance = cameraNear + p0.z;

    float denominator = -direction.z;

    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)
    {
        culledByNearPlane = true;
    }
    else if (endPoint0Distance > 0.0)
    {
        float t = endPoint0Distance / denominator;
        if (t < 0.0 || t > magnitude)
        {
            culledByNearPlane = true;
        }
        else
        {
            // Segment crosses the near plane, update p0 to lie exactly on it.
            p0 = p0 + t * direction;
            p0.z = min(p0.z, -cameraNear);

            l0 = mix(l0, l1, t / magnitude);

            // clippedLength = l0 + (t / ma)

            clipped = true;
        }
    }

    // \u89C6\u9525\u4F53\u53C2\u6570
    float tanHalfFovX = tan(fovX / 2.0 * 1.5);
    float tanHalfFovY = tan(fovY / 2.0 * 1.5);

    vec4 planes[4];
    planes[0] = vec4( 1,  0,  tanHalfFovX, 0); // Left
    planes[1] = vec4(-1,  0,  tanHalfFovX, 0); // Right
    planes[2] = vec4( 0,  1,  tanHalfFovY, 0); // Bottom
    planes[3] = vec4( 0, -1,  tanHalfFovY, 0); // Top

    vec3 p0Clone = p0;
    float lengthClone = l0;
    float mint = 10.0;
    for (int i = 0; i < 2; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            lengthClone = mix(l0, l1, mint);
            // clippedLength = l0 - (mint / lengthDistance);
            clipped = true;
        }
    }

    p0 = p0Clone;
    l0 = lengthClone;
    mint = 10.0;
    for (int i = 2; i < 4; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            lengthClone = mix(l0, l1, mint);
            // clippedLength = l0 + (mint * lengthDistance);
            // clippedLength = l0 - (mint / lengthDistance);
            clipped = true;
        }
    }

    p0 = p0Clone;
    clippedLength = lengthClone;

    clippedPositionEC = vec4(p0, 1.0);
    positionWC = eyeToWindowCoordinates(clippedPositionEC);

}

void clipLineSegmentToNearPlane(
    vec3 p0,
    vec3 p1,
    out vec4 positionWC,
    out bool clipped,
    out bool culledByNearPlane,
    out vec4 clippedPositionEC)
{
    culledByNearPlane = false;
    clipped = false;

    vec3 p0ToP1 = p1 - p0;
    float magnitude = length(p0ToP1);
    vec3 direction = normalize(p0ToP1);

    float endPoint0Distance = cameraNear + p0.z;

    float denominator = -direction.z;

    if (endPoint0Distance > 0.0 && abs(denominator) < 0.0000001)
    {
        culledByNearPlane = true;
    }
    else if (endPoint0Distance > 0.0)
    {
        float t = endPoint0Distance / denominator;
        if (t < 0.0 || t > magnitude)
        {
            culledByNearPlane = true;
        }
        else
        {
            // Segment crosses the near plane, update p0 to lie exactly on it.
            p0 = p0 + t * direction;
            p0.z = min(p0.z, -cameraNear);

            clipped = true;
        }
    }

    // \u89C6\u9525\u4F53\u53C2\u6570
    float tanHalfFovX = tan(fovX / 2.0 * 1.5);
    float tanHalfFovY = tan(fovY / 2.0 * 1.5);

    vec4 planes[4];
    planes[0] = vec4( 1,  0,  tanHalfFovX, 0); // Left
    planes[1] = vec4(-1,  0,  tanHalfFovX, 0); // Right
    planes[2] = vec4( 0,  1,  tanHalfFovY, 0); // Bottom
    planes[3] = vec4( 0, -1,  tanHalfFovY, 0); // Top

    vec3 p0Clone = p0;
    float mint = 10.0;
    for (int i = 0; i < 2; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            clipped = true;
        }
    }

    p0 = p0Clone;
    mint = 10.0;
    for (int i = 2; i < 4; i++) {
        vec4 plane = planes[i];
        float d0 = dot(vec4(p0, 1.0), plane);
        float d1 = dot(vec4(p1, 1.0), plane);

        if (d0 > 0.0 && d1 > 0.0) {
            // \u7EBF\u6BB5\u5B8C\u5168\u5728\u8BE5\u88C1\u526A\u5E73\u9762\u5916\uFF0C\u5254\u9664
            culledByNearPlane = true;
        }
        else if (d0 > 0.0) {
            // p0 \u5728\u5916\uFF0Cp1 \u5728\u5185\uFF0C\u8BA1\u7B97\u4EA4\u70B9
            mint = min(mint, d0 / (d0 - d1));
            p0Clone = mix(p0, p1, mint);
            clipped = true;
        }
    }

    p0 = p0Clone;

    clippedPositionEC = vec4(p0, 1.0);
    positionWC = eyeToWindowCoordinates(clippedPositionEC);

}

#endif

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    vUV = uv;
    // vCounter = counter;
    // vLength = uv.x;
    vTotalLength = totalLength;

    #ifdef MVT_USE_EXTENT_CLIP
    vExtentVertex = extentVertex;
    #endif

    #include <begin_vertex>

    #ifdef USE_PREV_NEXT
        float width = expandAndPrev.x;
        float pixelSize;
        vec4 worldPosition;
        if (keepSize) {
            vec4 prevEC = modelViewMatrix * vec4(prev, 1.0);
            vec4 nextEC = modelViewMatrix * vec4(next, 1.0);
            vec4 positionEC = modelViewMatrix * vec4(transformed, 1.0);

            bool usePrevious = expandAndPrev.y > 0.0;

            vec4 clippedPrevWC, clippedPrevEC;
            bool prevSegmentClipped, prevSegmentCulled;
            clipLineSegmentToNearPlane(prevEC.xyz, positionEC.xyz, clippedPrevWC, prevSegmentClipped, prevSegmentCulled, clippedPrevEC);

            vec4 clippedNextWC, clippedNextEC;
            bool nextSegmentClipped, nextSegmentCulled;
            clipLineSegmentToNearPlane(nextEC.xyz, positionEC.xyz, clippedNextWC, nextSegmentClipped, nextSegmentCulled, clippedNextEC);

            bool segmentClipped, segmentCulled;
            vec4 clippedPositionWC, clippedPositionEC;
            float clippedLength;
            clipLineSegmentWithLengthToNearPlane(
                positionEC.xyz,
                usePrevious ? prevEC.xyz : nextEC.xyz,
                uv.x,
                usePrevious ? prevAndNextLength.x : prevAndNextLength.y,
                clippedPositionWC,
                segmentClipped,
                segmentCulled,
                clippedPositionEC,
                clippedLength
            );

            vClippedLength = clippedLength;
            
            vec2 directionToPrevWC = normalize(clippedPrevWC.xy - clippedPositionWC.xy);
            vec2 directionToNextWC = normalize(clippedNextWC.xy - clippedPositionWC.xy);

            vec4 prevWorld = modelMatrix * vec4(prev, 1.0);
            vec4 nextWorld = modelMatrix * vec4(next, 1.0);
            vec2 directionToPrevWC1 = normalize(nextWorld.xy - prevWorld.xy);
            vec2 directionNormal = vec2(-directionToPrevWC1.y, directionToPrevWC1.x);
            worldPosition = inverse(viewMatrix) * (clippedPositionEC);
            pixelSize = getPixelSize(worldPosition.xyz);
        }
        else {
            worldPosition = modelMatrix * vec4(transformed, 1.0);
            pixelSize = getPixelSize(worldPosition.xyz);
            vClippedLength = uv.x;
        }
    #else 
        vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);
        float pixelSize = getPixelSize(worldPosition.xyz);
        float width = aWidth;
        vClippedLength = uv.x;
    #endif

    // pixelSize\u4E0D\u5982\u7EDF\u4E00\u7684zoomUnits\u7684\u6548\u679C
    // vZoomUnits = branchFreeTernary(useZoomUnits, uZoomUnits, pixelSize);
    vZoomUnits = branchFreeTernary(useZoomUnits, uZoomUnits, zoomUnits);

    float aliasFeatureWidth = 0.5;
    vec3 extrude = normal.xyz * width / 2.0;
    float pixelWidth = width;
    if (keepSize) {
        extrude *= pixelSize;
        pixelWidth *= pixelSize;
        aliasFeatureWidth *= pixelSize;
    }
    if (antialias) {
        extrude += normal.xyz * aliasFeatureWidth;
        vNormal = normalize(normal.xyz);
        vAliasPart = 1. - (2. * aliasFeatureWidth / (pixelWidth / 2. + aliasFeatureWidth));
    }
    worldPosition.xyz += extrude;
    // worldPosition.z += height;

    #ifdef MVT_USE_VERTEX_ZINDEX
        // vec3 worldToEye = cameraPosition - worldPosition.xyz;
        // float dis = length(worldToEye);
        // float layerGap = maxLayerIndex - layerIndex;
        // float zOffset = log2(layerGap * dis + 1.0);
        // float zOffset = exp(layerGap * log2(dis * 10.0));
        // float zOffset = pow(layerGap * log2(dis * 5.0), 1.5);
        // float zOffset = y(dis);
        // worldPosition.z -= zOffset;
        vLayerIndex = layerIndex;
    #endif
    
    #ifdef USE_ANIMATION
        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;

        #ifdef ANIMATION_CHAOS
            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;
        #else
            float currentTime = elapsedTime;
        #endif
        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);
        vAnimationOpacity = (vClippedLength - (currentLength - tailLength)) / tailLength;
    #endif

    vec4 mvPosition = viewMatrix * worldPosition;
    gl_Position = projectionMatrix * mvPosition;

    // #ifdef MVT_USE_VERTEX_ZINDEX
    //     float depth = layerGap * 10.0;
    //     gl_Position.z = gl_Position.z + depth;
    // #endif

    #ifdef MVT_USE_VERTEX_DASHARRAY
    vDashArray = aDashArray;
    #endif

    #ifdef MVT_USE_VERTEX_DASHRATIO
    vDashRatio = aDashRatio;
    #endif

    #include <beginnormal_vertex>
    #include <fog_vertex>
    #include <logdepthbuf_vertex>
}`, cV = `#define GLSLIFY 1
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_depth_range_pars_fragment>

varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef MVT_USE_EXTENT_CLIP
varying vec2 vExtentVertex;
#endif

uniform sampler2D map;
uniform bool useMap;
uniform bool keepSize;
uniform bool antialias;
uniform float lineWidth;
uniform float mapGap;
uniform float opacity;
uniform float alphaTest;
uniform float elapsedTime;
uniform bool flipUv;
uniform bool isSingle;

varying vec2 vUV;
varying vec3 vNormal;
varying vec4 vColor;
varying float vAliasPart;
varying float vCounter;
varying float vLength;
varying float vTotalLength;
varying float vZoomUnits;

#ifdef USE_ANIMATION
uniform float animationInterval;
varying float vAnimationOpacity;
#endif

#ifdef USE_DASH
#ifdef MVT_USE_VERTEX_DASHARRAY
varying float vDashArray;
#else
uniform float dashArray;
#endif
uniform float dashOffset;
#ifdef MVT_USE_VERTEX_DASHRATIO
varying float vDashRatio;
#else
uniform float dashRatio;
#endif
uniform bool keepDashLength;
varying float vDashOpacity;
#endif

varying float vClippedLength;

vec2 branchFreeTernary(bool comparison, vec2 a, vec2 b) {
    float useA = float(comparison);
    return a * useA + b * (1.0 - useA);
}
void main() {

   vec4 c = vColor;

    #ifdef MVT_USE_EXTENT_CLIP
    if (vExtentVertex.x < 0.0 || vExtentVertex.x > 1.0 || vExtentVertex.y < 0.0 || vExtentVertex.y > 1.0) {
        discard;
    }
    #endif
 
    if(useMap) {
        // icon\u4E4B\u95F4\u7684\u95F4\u9694\uFF0C\u7ECF\u9A8C\u503C\u4E3A\u95F4\u969450\u500D\u5BBD\u5EA6\uFF0C\u6BD4\u8F83\u7A00\u758F\u4E14\u597D\u770B
        float margin = lineWidth * mapGap;
        float halfMargin = margin / 2.0;
        float texWidth = lineWidth;
        if (keepSize) {
            margin *= vZoomUnits;
            texWidth *= vZoomUnits;
        }
        float delta = mod(vClippedLength, texWidth + margin);
        float uvx;
        if (isSingle) {
            uvx = vClippedLength / vTotalLength;
        }
        else {
            uvx = (delta - halfMargin) / texWidth;
        }
        if (delta >= halfMargin && delta <= halfMargin + texWidth) {
            vec2 uv = branchFreeTernary(flipUv, vec2(vUV.y, uvx), vec2(uvx, vUV.y));
            vec4 texture = texture2D(map, uv);
            // c = texture.a >= 0.5 ? texture : c;
            c = texture;
        }
    }

    #ifdef USE_ANIMATION
        float animationAlpha = vAnimationOpacity;
        if (animationInterval > 0.0) {
            animationAlpha = mod(vAnimationOpacity, animationInterval);
        }
        if (animationAlpha > 1.0 || animationAlpha < 0.0) {
            discard;
        }
        c.a *= animationAlpha;
    #endif

    #ifdef USE_DASH
        #ifdef MVT_USE_VERTEX_DASHARRAY
        float darray = vDashArray;
        #else
        float darray = dashArray;
        #endif

        #ifdef MVT_USE_VERTEX_DASHRATIO
        float dratio = vDashRatio;
        #else
        float dratio = dashRatio;
        #endif
        if (keepSize && keepDashLength) {
            darray *= vZoomUnits;
        }
        c.a *= step(mod(vClippedLength + dashOffset, darray), (darray * dratio));
    #endif

    if (c.a < alphaTest) {
        discard;
    }

    // \u6297\u952F\u9F7F make line edge antialias
    if (antialias) {
        float blur = 1.0;
        // blur = 1.0 - smoothstep(vAliasPart, 1.0, length(vNormal));
        blur = 1.0 - (length(vNormal) - vAliasPart) / (1.0 - vAliasPart);
        c.a *= blur;
    }

    gl_FragColor = c;

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <mvt_depth_range_fragment>
}`, lV = new Ot(), hV = we.merge([
  Xt.fog,
  zn,
  Ho,
  {
    antialias: { value: !1 },
    lineWidth: { value: 100 },
    keepSize: { value: !1 },
    map: { value: null },
    useMap: { value: !1 },
    mapGap: { value: 50 },
    color: { value: [0, 1, 1] },
    height: { value: 0 },
    opacity: { value: 1 },
    resolution: { value: new Z(1, 1) },
    sizeAttenuation: { value: 1 },
    dashArray: { value: 20 },
    dashOffset: { value: 0 },
    dashRatio: { value: 0.5 },
    alphaTest: { value: 0 },
    repeat: { value: new Z(1, 1) },
    vertexColors: { value: !1 },
    vertexZIndex: { value: !1 },
    maxLayerIndex: { value: 0 },
    elapsedTime: { value: 0 },
    enableAnimation: { value: !1 },
    enableAnimationChaos: { value: !1 },
    animationInterval: { value: 0 },
    animationSpeed: { value: 1 },
    animationTailType: { value: 1 },
    animationTailRatio: { value: 0.2 },
    animationTailLength: { value: 100 },
    animationIdle: { value: 1e3 },
    isEmissive: { value: !1 },
    keepDashLength: { value: !0 },
    depthRange: { value: new Z(0, 1) },
    viewportTransform: { value: new J() },
    cameraNear: { value: 0 },
    cameraFar: { value: 0 },
    fovX: { value: 0 },
    fovY: { value: 0 },
    uZoomUnits: { value: 1 },
    flipUv: { value: !1 },
    useZoomUnits: { value: !1 },
    isSingle: { value: !1 }
  }
]);
class bg extends di {
  constructor(t) {
    super(), this.name = "FatLineMaterial", this.isFatLineMaterial = !0, this.fog = !0, this.fragmentShader = cV, this.vertexShader = gV, Object.assign(this.uniforms, we.clone(hV)), oi(this, [
      "antialias",
      "mapGap",
      "isSingle",
      "flipUv",
      "lineWidth",
      "keepSize",
      "height",
      "opacity",
      "dashArray",
      "dashOffset",
      "dashRatio",
      "alphaTest",
      "maxLayerIndex",
      "animationInterval",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "isEmissive",
      "keepDashLength",
      "depthRange"
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["enableAnimation", "USE_ANIMATION"],
      ["enableAnimationChaos", "ANIMATION_CHAOS"],
      ["dashed", "USE_DASH"],
      ["enableDepthRange", "MVT_USE_DEPTH_RANGE"],
      ["enableExtentClip", "MVT_USE_EXTENT_CLIP"],
      ["vertexDashArray", "MVT_USE_VERTEX_DASHARRAY"],
      ["vertexDashRatio", "MVT_USE_VERTEX_DASHRATIO"],
      ["enablePrevAndNext", "USE_PREV_NEXT"]
    ]), No(this), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const i = this.mapSrc, n = "url_map";
          if (this.userData[n] === e)
            return;
          if (i && i.dispose(), !e) {
            this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[n];
            return;
          }
          const r = lV.load(e);
          r.wrapS = r.wrapT = hs, this.uniforms.map.value = r, this.userData[n] = e, this.uniforms.useMap.value = !0;
        }
      },
      map: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const i = this.map;
          if (!e) {
            i.dispose(), this.uniforms.map.value = null, this.uniforms.useMap.value = !1;
            return;
          }
          this.uniforms.map.value = e, this.uniforms.useMap.value = !0;
        }
      },
      zoomUnits: {
        get: function() {
          return this.uniforms.uZoomUnits.value;
        },
        set: function(e) {
          this.uniforms.uZoomUnits.value = e, this.uniforms.useZoomUnits.value = !0;
        }
      }
    }), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const dV = `#define GLSLIFY 1
#include <common>

attribute vec3 a_diff;
attribute vec3 a_normal;
attribute vec2 a_uv;

varying vec2 vUv;

// uniform float u_scale;
// uniform bool u_flat;

#ifdef MVT_USE_VERTEX_ZINDEX
attribute float layerIndex;
uniform float maxLayerIndex;

#define WORLD_DISTANCE_NEAR 100000.0
#define WORLD_DISTANCE_MID 1500000.0
#define WORLD_DISTANCE_FAR 6000000.0
#define LAYER_INDEX (maxLayerIndex - layerIndex)
// \u5728mid\u548Cfar\u4EA4\u63A5\u90A3\u5757\uFF0C\u56E0\u4E3A\u7EBF\u6570\u636E\u7279\u522B\u788E\uFF0C\u5BFC\u81F4layerIndex\u5F88\u591A\uFF0C\u5730\u9762\u4F1A\u9677\u5F88\u6DF1\uFF0C\u8FD8\u6CA1\u627E\u5230\u6BD4\u8F83\u597D\u7684\u51FD\u6570\u6765\u89E3\u51B3\u8FD9\u4E2Acase

float y1(float x) {
    return pow(LAYER_INDEX * log2(x * 5.), 1.5);
}

float y2(float x) {
    float xx = x - WORLD_DISTANCE_NEAR;
    return LAYER_INDEX * log2(xx) + y1(WORLD_DISTANCE_NEAR);
}

float y3(float x) {
    float xx = x - WORLD_DISTANCE_MID;
    return log2(LAYER_INDEX * xx) + y2(WORLD_DISTANCE_MID);
}

float y4(float x) {
    return 110. * LAYER_INDEX + y3(WORLD_DISTANCE_FAR);
}

/**
y1 = pow(x, 2)                  x: (0, near]
y2 = (x - near) + y1(near)      x: (near, mid]
y3 = sqrt(x - mid) + y2(mid)    x: (mid, far]
y4 = n + y3(far)                x: (far, +\u221E)
*/
float y(float x) {
    if (x <= WORLD_DISTANCE_NEAR) {
        return y1(x);
    }
    if (x > WORLD_DISTANCE_NEAR && x <= WORLD_DISTANCE_MID) {
        return y2(x);
    }
    else if (x > WORLD_DISTANCE_MID && x <= WORLD_DISTANCE_FAR) {
        return y3(x);
    }
    else if (x > WORLD_DISTANCE_FAR) {
        return y4(x);
    }
}
#endif

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>
void main() {
    #include <mvt_selective_vertex>
    
    vec3 currentPosition = position;

    vec4 worldPosition = modelMatrix * vec4(currentPosition, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz) * 1.0;

    float scale = 1.4;
    currentPosition.xyz = currentPosition.xyz + (a_diff * scale * pixelSize) + normalize(a_normal) * 2.5 * scale * pixelSize;

    worldPosition = modelMatrix * vec4(currentPosition, 1.0);

    #ifdef MVT_USE_VERTEX_ZINDEX
        vec3 worldToEye = cameraPosition - worldPosition.xyz;
        float dis = length(worldToEye);
        float layerGap = maxLayerIndex - layerIndex;
        // float zOffset = log2(layerGap * dis + 1.0);
        // float zOffset = exp(layerGap * log2(dis * 10.0));
        // float zOffset = pow(layerGap * log2(dis * 5.0), 1.5);
        float zOffset = y(dis);
        worldPosition.z -= zOffset;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4(currentPosition, 1.0);

    vUv = a_uv;

    #include <logdepthbuf_vertex>
    // gl_PointSize = 10000000000.0; // \u8BBE\u7F6E\u70B9\u7684\u5927\u5C0F
}`, uV = `#define GLSLIFY 1
#include <common>

uniform sampler2D u_image;
uniform int u_draw_part;

varying vec2 vUv;
// varying float v_z;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    // if (u_draw_part == 1) {
    //     if (v_z > 0.0) {
    //         discard;
    //     }
    // } else if (u_draw_part == 2) {
    //     if (v_z == 0.0) {
    //        discard;
    //     }
    // }

    gl_FragColor = texture2D(u_image, vUv);
    gl_FragColor.rgb *= (1.0 - max(0.6, 1.0 - gl_FragColor.a));

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`, W_ = new Ot().load(
  "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ5JREFUeNrsllEKgCAMhp14rsqT1X08Q6VdbDmYLxGUoO5lg72J+9i/3wmIaCTDGuFQAAVQANfyshCCSkBx5pwlAZackUEmSQkIJH2BjJiBAnK8gQBtwzy9I1cidWTLeUm5wHNHduqIlXagEyhMDlmLBNDyR8QvIf4pPNIFkZ3gn8V7SxB52tOwZVRTuCeArzkM+i1XAAVQAGmAW4ABAOOjKXrLR4xWAAAAAElFTkSuQmCC"
);
W_.anisotropy = 8;
let IV = we.merge([
  {
    u_draw_part: { value: 0 },
    u_image: { value: W_ },
    color: { value: new Ce(16711680) },
    u_scale: { value: 1 },
    isGlobe: { value: !1 }
  }
]);
class AV extends di {
  constructor(e) {
    super();
    f(this, "name", "ArrowMaterial");
    f(this, "isArrowMaterial", !0);
    this.vertexShader = dV, this.fragmentShader = uV, Object.assign(this.uniforms, we.clone(IV)), Xn([
      "color"
    ]), oi(this, [
      "u_draw_part",
      "u_image"
    ]), ri(this, [
      ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
      ["isGlobe", "IS_GLOBE"]
    ]), this.setValues(e);
  }
  set color(e) {
    this.uniforms.color.value = e;
  }
}
const or = Math.pow(2, 18) * 256 / 2, CV = 2003772416e-2, Wc = or / CV;
class fV extends id {
  constructor(e, i, n) {
    super(e, i, n);
    f(this, "_maxLevel", 19);
    f(this, "_shouldCheckTileBoundingRange", !0);
    this._coordLevelTileCounts = [1];
    let o = 1;
    for (let r = 1; r <= 19; ++r)
      this._coordLevelTileCounts[r] = o, o *= 2;
  }
  getRootTiles() {
    const e = new va(this, 0, 0, 0);
    return e.projectedBoundingBox = new Ue(
      new B(-or, -or, -100),
      new B(or, or, 100)
    ), e.geoBoundingBox = new Ue(
      new B(-180 * Wc, -90 * Wc, -100),
      new B(180 * Wc, 90 * Wc, 100)
    ), [e];
  }
  getRootBoundingBox() {
    return this._rootBoundingBox;
  }
  getTileReverseY(e) {
    return Math.pow(2, e.z - 1) - e.y - 1;
  }
  getTileSizeAtLevel(e) {
    return Math.pow(2, 18 - e) * 256;
  }
  getTileCoordX(e, i, n) {
    return (e + or) / i;
  }
  getTileCoordY(e, i, n) {
    return (e + or) / i;
  }
  _quadCoordToTileCoord(e, i) {
    return e >= i ? e - i : "M" + (i - e);
  }
  getRasterTileCoord(e, i, n) {
    const o = this._coordLevelTileCounts[e];
    return [e, this._quadCoordToTileCoord(i, o), this._quadCoordToTileCoord(n, o)];
  }
  get zeroLevelPixelSize() {
    return this._zeroLevelPixelSize || (this._zeroLevelPixelSize = 200375083427892e-7 * 2 / 0.597 / 256), this._zeroLevelPixelSize;
  }
}
const Eu = {
  3: 2,
  5: 4,
  7: 4,
  9: 4,
  10: 2,
  12: 8,
  15: 2,
  17: 4
}, b0 = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  5: 4,
  7: 6,
  9: 8,
  10: 10,
  12: 11,
  15: 14,
  17: 15,
  19: 17
}, kl = {
  0: { start: 0, base: 0 },
  1: { start: 0, base: 1 },
  2: { start: 2, base: 2 },
  3: { start: 3, base: 3 },
  4: { start: 4, base: 5 },
  5: { start: 4, base: 5 },
  6: { start: 6, base: 7 },
  7: { start: 6, base: 7 },
  8: { start: 8, base: 9 },
  9: { start: 8, base: 9 },
  10: { start: 10, base: 10 },
  11: { start: 11, base: 12 },
  12: { start: 11, base: 12 },
  13: { start: 11, base: 12 },
  14: { start: 14, base: 15 },
  15: { start: 14, base: 15 },
  16: { start: 16, base: 17 },
  17: { start: 16, base: 17 },
  18: { start: 18, base: 19 },
  19: { start: 18, base: 19 },
  20: { start: 18, base: 19 },
  21: { start: 18, base: 19 }
};
Object.freeze(kl);
class pV extends fV {
  constructor(e, i, n) {
    super(e, i, n);
    f(this, "name", K_);
    f(this, "_maxLevel", 21);
    f(this, "_levels", [0, 1, 2, 3, 5, 7, 9, 10, 12, 15, 17, 19]);
    let o = 1;
    this._coordLevelTileCounts = {
      0: 1,
      1: 1
    };
    for (let r = 1; r < this._levels.length; r++) {
      const a = this._levels[r], g = this._levels[r - 1];
      r < 2 || (Eu[g] !== void 0 ? o *= Eu[g] : o *= 2, this._coordLevelTileCounts[a] = o);
    }
  }
  _quadCoordToTileCoord(e, i, n) {
    let o = 1, r = e - i;
    return Math.floor(r / o);
  }
  getRasterTileCoord(e, i, n) {
    let o = this._coordLevelTileCounts[e];
    return [e, this._quadCoordToTileCoord(i, o, e), this._quadCoordToTileCoord(n, o, e)];
  }
  getNextLevelTileCount(e) {
    return Eu[e] || 2;
  }
  getQuadTreeLevelGap(e, i) {
    const n = kl[e].base, o = kl[i].base, r = b0[n];
    return b0[o] - r;
  }
  getTileLoaderConfig(e) {
    const i = kl[e.z];
    return {
      baseZ: i.base,
      startZ: i.start
    };
  }
}
const Vl = {
  0: { start: 0, end: 0, base: 0 },
  1: { start: 1, end: 1, base: 1 },
  2: { start: 2, end: 2, base: 2 },
  3: { start: 3, end: 4, base: 3 },
  4: { start: 3, end: 4, base: 3 },
  5: { start: 5, end: 6, base: 5 },
  6: { start: 5, end: 6, base: 5 },
  7: { start: 7, end: 8, base: 7 },
  8: { start: 7, end: 8, base: 7 },
  9: { start: 9, end: 9, base: 9 },
  10: { start: 10, end: 12, base: 10 },
  11: { start: 10, end: 12, base: 10 },
  12: { start: 10, end: 12, base: 10 },
  13: { start: 13, end: 14, base: 13 },
  14: { start: 13, end: 14, base: 13 },
  15: { start: 15, end: 16, base: 14 },
  16: { start: 15, end: 16, base: 14 },
  17: { start: 17, end: 23, base: 16 },
  18: { start: 17, end: 23, base: 16 },
  19: { start: 17, end: 23, base: 16 },
  20: { start: 17, end: 23, base: 16 },
  21: { start: 17, end: 23, base: 16 },
  22: { start: 17, end: 23, base: 16 },
  23: { start: 17, end: 23, base: 16 }
};
Object.freeze(Vl);
class mV extends id {
  constructor() {
    super(...arguments);
    f(this, "name", H_);
    f(this, "_maxLevel", 21);
    f(this, "_rootBoundingBox", new Ue(
      new B(-200375083427892e-7, -200375083427892e-7, -100),
      new B(200375083427892e-7, 200375083427892e-7, 100)
    ));
  }
  getRootTiles() {
    const e = new va(this, 0, 0, 0);
    return e.projectedBoundingBox = this._rootBoundingBox, e.geoBoundingBox = new Ue(new B(-180, -90, -100), new B(180, 90, 100)), [e];
  }
  getRootBoundingBox() {
    return this._rootBoundingBox;
  }
  getQuadTreeLevelGap(e, i) {
    const n = Vl[e].base;
    return Vl[i].base - n;
  }
  getTileLoaderConfig(e) {
    const i = Vl[e.z];
    return {
      baseZ: i.base,
      startZ: i.start
    };
  }
}
const yV = (s) => new Promise((t, e) => {
  const i = document.createElement("script");
  i.src = s, i.async = !0, i.onload = t, i.onerror = () => e(new Error(`failed to load script: ${s}`)), document.head.appendChild(i);
});
class sd {
  constructor() {
    f(this, "_retryTimes", 3);
    f(this, "_queued", {});
    f(this, "_cached", {});
  }
  async generate(t) {
    return {};
  }
  async get(t) {
    if (this._cached[t])
      return this._cached[t];
    let e = !1;
    this._queued[t] || (this._queued[t] = [], e = !0);
    const i = new Promise((o, r) => {
      this._queued[t].push([o, r]);
    }), n = this._queued[t];
    if (e) {
      for (let o = 0; o < this._retryTimes; o++)
        try {
          const r = await this.generate(t);
          this._cached[t] = r;
          for (const a of n)
            a[0](r);
          break;
        } catch (r) {
          console.warn(r);
        }
      for (const o of n)
        o[1]();
    }
    return i;
  }
  get keys() {
    return Object.keys(this._cached);
  }
  delete(t) {
    delete this._cached[t], delete this._queued[t];
  }
  clear() {
    this._cached = {}, this._queued = {};
  }
}
class jC {
}
f(jC, "ak", null);
class Z_ {
}
f(Z_, "accessToken", null);
class U_ {
}
f(U_, "tk", null);
const SV = window.location.protocol === "http:" ? "http:" : "https:", bV = SV + "//api.map.baidu.com";
class BV {
  constructor() {
    f(this, "sendMessage", (t) => {
    });
    this.device = { PC: 0, NA: 1 }, this.config = {
      mask: ["FFFFFFFF"],
      open: !1,
      reset: 60 * 60 * 1e3
    }, this.url = bV + "?qt=jsapi_log", this.startTime = Date.now(), this.mark = {}, this.records = {}, this.ak = "";
  }
  init(t, e) {
    this.kill();
    let i = this;
    this.config.open = !!t, e = e || {}, e.reset && (this.config.reset = e.reset), this.sendMessage = function(n) {
      let o = n || 1e3;
      return i._idleWorkerTicker = function(r) {
        return function() {
          r.runJob();
        };
      }(i), function(r) {
        if (window.navigator && !navigator.onLine)
          return;
        Date.now() - i.startTime > i.config.reset && (i.startTime = Date.now(), i.mark = {}, i.records = {});
        const a = r.join("-");
        i.mark[a] || (i.mark[a] = !0, i.records[a] = r), i.checkJob(o);
      };
    }(e.timers);
  }
  runJob() {
    if (Object.keys(this.records).length === 0) {
      clearInterval(this.idleWork), this.idleWork = null;
      return;
    }
    let e = Object.keys(this.records)[0], i = new Date().getTime();
    if (this.config.open)
      try {
        const n = this.ak || jC.ak;
        X_(this.url, {
          ak: n,
          mapvthree: 1,
          device: 0,
          module: this.records[e][0] || "",
          func: this.records[e][1] || "",
          subfunc: this.records[e][2] || "",
          t: i
        }).then((o) => {
          delete this.records[e];
        });
      } catch {
      }
    Object.keys(this.records).length === 0 && (clearInterval(this.idleWork), this.idleWork = null);
  }
  checkJob(t) {
    !this.idleWork && this._idleWorkerTicker && (this.idleWork = setInterval(this._idleWorkerTicker, t));
  }
  kill() {
    this.idleWork && (clearInterval(this.idleWork), this.idleWork = null), this._idleWorkerTicker = null, this.mark = {}, this.records = {};
  }
}
const pA = new BV();
pA.init(!0, {
  reset: 20 * 60 * 1e3
});
new B();
new B();
const Zc = window.location.protocol === "http:" ? "http:" : "https:", wV = [
  `${Zc}//maponline0.bdimg.com`,
  `${Zc}//maponline1.bdimg.com`,
  `${Zc}//maponline2.bdimg.com`,
  `${Zc}//maponline3.bdimg.com`
], _V = (s, t, e) => 0.2 * Math.tan(t / 2) * s / e, xV = new Ot(), zl = new sd();
zl.generate = async (s) => new Promise((t, e) => {
  xV.load(s, (i) => {
    t(i);
  }, null, e);
});
let Ru = null;
function vV(s) {
  let t = "", e, i;
  for (e = 0; e < s.length; e++) {
    i = s.charCodeAt(e) << 1;
    let a = i.toString(2), g = a.length, c = a;
    g < 8 && (c = "00000000" + a, c = c.substr(a.length, 8)), t += c;
  }
  let n = 5 - t.length % 5, o = [];
  for (e = 0; e < n; e++)
    o[e] = "0";
  t = o.join("") + t;
  let r = [];
  for (e = 0; e < t.length / 5; e++) {
    i = t.substr(e * 5, 5);
    let a = parseInt(i, 2) + 50;
    r.push(String.fromCharCode(a));
  }
  return r.join("") + n.toString();
}
const TV = {
  default: 0,
  "grayed-out": 1
}, LV = {
  fontRgba: [0, 0, 0, 0],
  fontSize: 16,
  fontWeight: "400",
  haloRgba: [0, 0, 0, 0],
  haloSize: 0
};
async function GV(s) {
  try {
    const t = document.createElement("script");
    return t.src = s, document.head.appendChild(t), new Promise((e, i) => {
      t.onload = () => {
        e(window.iconSetInfo_high);
      }, t.onerror = () => {
        i(new Error(`Failed to load script: ${s}`));
      };
    });
  } catch (t) {
    throw console.error("Error loading icon set:", t), t;
  }
}
const MV = {
  0: "top",
  1: "left",
  2: "bottom",
  3: "right"
};
class EV extends eV {
  constructor(e = {}) {
    super(e);
    f(this, "name", "BaiduVectorTileProvider");
    f(this, "isBaiduProvider", !0);
    f(this, "_shouldRenderPlaceholder", !0);
    f(this, "_isAttach", !0);
    f(this, "_supportAllProjections", !0);
    f(this, "_defaultStartLevel", 2);
    f(this, "_defaultMaxLevel", 16);
    f(this, "_labels", {});
    f(this, "_loadStyle", async () => {
      let e = null;
      if (this._isOffline) {
        let i = this._styleUrl || pt("assets/map/style/default.json");
        e = await Ta(i).then((n) => n.json()), e.data && e.data.style && (e = e.data.style);
      } else
        this._styleUrl ? (e = await Ta(this._styleUrl).then((i) => i.json()), e.data && e.data.style && (e = e.data.style)) : (Ru || (await yV("https://maponline0.bdimg.com/sty/fs.js"), Ru = window.FeatureStyle), e = Ru);
      this._dataLoader.postMessageToAll({
        type: "changeStyle",
        featureStyles: e
      });
    });
    f(this, "_getMapStyleFile", async (e) => {
      let i = !0;
      typeof e == "string" && e !== "default" && (i = !1);
      const n = i ? "" : "_" + (TV[e] - 1);
      let o = "http://10.228.107.23:8140";
      this._staticUrl ? o = this._staticUrl : window.BMAPGL_STATIC_URL ? o = window.BMAPGL_STATIC_URL : this._url && (o = this._url);
      const r = `${o}/sty/`;
      this._vctMapStyleDomain = r, this._vctMapStyleUrl = r + "icons_2x" + n + ".js";
      const a = await GV(this._vctMapStyleUrl);
      this._dataLoader.postMessageToAll({
        type: "changeIconSetInfo",
        iconSetInfo: a
      });
    });
    const i = e.ak || jC.ak;
    if (this._displayOptions = e.displayOptions, this._url = e.url, this._styleUrl = e.styleUrl, this._isOffline = e.isOffline, this._isOffline)
      this._staticUrl = e.staticUrl, this._sourceProjectionName = W(e.projection, Mt), this._isWebMercator = this._sourceProjectionName === Mt;
    else {
      if (!i)
        throw new Error("\u6CA1\u6709\u6709\u6548\u767E\u5EA6\u5730\u56FEAK\uFF0C\u8BF7\u8BBE\u7F6EBaiduMapConfig.ak\u6216options.ak");
      this._staticUrl = "https://maponline0.bdimg.com", this._sourceProjectionName = Fg, this._isWebMercator = !1, pA.ak = i, pA.sendMessage(["layer", "vector", "normal"]);
    }
    this._isWebMercator ? (this._isAttach = W(e.isAttach, !0), this._defaultMinLevel = 2, this._defaultMaxLevel = 20) : (this._isAttach = !1, this._defaultMinLevel = 3, this._defaultMaxLevel = 21);
  }
  initProjectionAndGrid() {
    this._sourceProjection = bn(this._sourceProjectionName), this._sourceProjectionName === Fg ? this._grid = new pV(this._engine, this._sourceProjection, this._targetProjection) : this._grid = new mV(this._engine, this._sourceProjection, this._targetProjection);
  }
  async _asyncInit() {
    this._dataLoader || (this._dataLoader = new tV(this, iV, 2)), await this._loadStyle(), await this._getMapStyleFile("default");
  }
  getTileURL(e, i, n, o) {
    return o.loaderConfig && (e = o.loaderConfig.baseZ), this._isOffline ? this._getOfflineTileURL(e, i, n, o) : this._getOnlineTileURL(e, i, n, o);
  }
  _getOnlineTileURL(e, i, n, o) {
    const [r, a, g] = o.grid.getRasterTileCoord(e, i, n);
    let c = `${wV[Math.abs(i + n) % 4]}/pvd/?qt=vtile&param=`;
    const l = `x=${a}&y=${g}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0`;
    return c + window.encodeURIComponent(vV(l));
  }
  _getOfflineTileURL(e, i, n, o) {
    let r = e, a = i, g = n;
    this._isWebMercator || ([r, a, g] = o.grid.getRasterTileCoord(e, i, n));
    let c = `http://10.228.107.23:8140/pvd/?qt=vtile&x=${a}&y=${g}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=USER_AK`;
    return this._url ? c = `${this._url}/pvd/?qt=vtile&x=${a}&y=${g}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=USER_AK` : window.BMAPGL_URL && (c = `${window.BMAPGL_URL}/pvd/?qt=vtile&x=${a}&y=${g}&z=${r}&styles=pl&textimg=0&v=088&udt=20190618&json=0&ApiAuthorization=USER_AK`), c += "&customid=vector-tile", c;
  }
  getWorkerOptions() {
    return {
      isAttach: this._isAttach,
      displayOptions: this._displayOptions,
      styleZoomOffset: this._isWebMercator ? 0 : -1
    };
  }
  getFetchOptions(e) {
    return {
      ...e.loaderConfig
    };
  }
  async doRequestTileData(e) {
    const i = await this._dataLoader.requestTile(e), {
      polygon: n,
      polygonOpacity: o,
      line: r,
      dashLine: a,
      textureLine: g,
      gaoqingLine: c,
      polygon3d: l,
      building3d: h,
      poi: d,
      arrow: C,
      maxLayerIndex: p
    } = i.content, m = i.isNormalized, b = this._engine.rendering.features.antialias.samples > 0, S = new mt(), A = new mt();
    if (n && n.indices) {
      const u = new Qe(), y = new Ai(n.attributes, 10);
      u.setAttribute("position", new ve(y, 3, 0)), u.setAttribute("normal", new ve(y, 3, 3)), u.setAttribute("color", new ve(y, 3, 6)), u.setAttribute("layerIndex", new ve(y, 1, 9)), u.setIndex(new Fe(n.indices, 1));
      const I = new Xc({
        depthTest: !0,
        vertexColors: !0,
        vertexZIndex: !0,
        maxLayerIndex: p,
        enableDepthRange: !0
      });
      I.setCommonUniforms(this._engine.rendering.uniforms);
      const M = new le(u, I);
      M.name = "Polygons", A.add(M);
    }
    if (o && o.indices) {
      const u = new Qe(), y = new Ai(o.attributes, 11);
      u.setAttribute("position", new ve(y, 3, 0)), u.setAttribute("normal", new ve(y, 3, 3)), u.setAttribute("aColor", new ve(y, 4, 6)), u.setAttribute("layerIndex", new ve(y, 1, 10)), u.setIndex(new Fe(o.indices, 1));
      const I = new Xc({
        depthTest: !0,
        transparent: !0,
        isColor4: !0,
        vertexColors: !0,
        vertexZIndex: !0,
        maxLayerIndex: p,
        enableDepthRange: !0
      });
      I.setCommonUniforms(this._engine.rendering.uniforms);
      const M = new le(u, I);
      M.name = "Polygons", A.add(M);
    }
    if (r && r.indices) {
      const u = new Qe(), y = new Ai(r.attributes, 12);
      u.setAttribute("position", new ve(y, 3, 0)), u.setAttribute("normal", new ve(y, 3, 3)), u.setAttribute("aColor", new ve(y, 4, 6)), u.setAttribute("layerIndex", new ve(y, 1, 10)), u.setAttribute("aWidth", new ve(y, 1, 11)), u.setIndex(new Fe(r.indices, 1));
      const I = new bg({
        keepSize: !0,
        depthTest: !0,
        transparent: !b,
        antialias: !b,
        lineWidth: 1,
        vertexColors: !0,
        vertexZIndex: !0,
        maxLayerIndex: p,
        enableDepthRange: !0
      });
      I.setCommonUniforms(this._engine.rendering.uniforms);
      const M = new le(u, I);
      M.name = "Links", A.add(M);
    }
    if (a) {
      const u = Object.keys(a);
      for (let y = 0; y < u.length; y++) {
        const I = u[y], M = a[I], G = this._vctMapStyleDomain + "map_icons2x/" + I + ".png", x = new Qe(), L = new Ai(M.attributes, 14);
        x.setAttribute("position", new ve(L, 3, 0)), x.setAttribute("normal", new ve(L, 3, 3)), x.setAttribute("aColor", new ve(L, 4, 6)), x.setAttribute("layerIndex", new ve(L, 1, 10)), x.setAttribute("aWidth", new ve(L, 1, 11)), x.setAttribute("uv", new ve(L, 2, 12)), x.setIndex(new Fe(M.indices, 1));
        const E = new bg({
          keepSize: !0,
          antialias: !0,
          depthTest: !0,
          transparent: !0,
          lineWidth: 100,
          mapGap: 0,
          vertexColors: !0,
          vertexZIndex: !0,
          maxLayerIndex: p,
          enableDepthRange: !0
        });
        E.flipUv = !0, E.setCommonUniforms(this._engine.rendering.uniforms);
        const T = new le(x, E);
        T.onBeforeRender = () => {
          const R = e.targetCenter, w = this._engine.camera, v = this._engine.rendering.renderState, D = w.position, K = R.clone();
          K.x -= v.cameraOffset.x, K.y -= v.cameraOffset.y, K.z -= v.cameraOffset.z;
          const P = D.distanceTo(K), k = _V(
            P,
            w.fov * Math.PI / 180,
            this._engine.container.clientHeight
          );
          E.zoomUnits = k;
        }, T.name = "Links", zl.get(G).then((R) => {
          R.wrapS = R.wrapT = ii, R.generateMipmaps = !1, R.colorSpace = gt, E.useMap = !0, E.map = R, A.add(T);
        });
      }
    }
    if (g) {
      const u = Object.keys(g);
      for (let y = 0; y < u.length; y++) {
        const I = u[y], M = g[I], G = this._vctMapStyleDomain + "map_icons2x/" + I + ".png", x = new Qe(), L = new Ai(M.attributes, 15);
        x.setAttribute("position", new ve(L, 3, 0)), x.setAttribute("normal", new ve(L, 3, 3)), x.setAttribute("aColor", new ve(L, 4, 6)), x.setAttribute("layerIndex", new ve(L, 1, 10)), x.setAttribute("aWidth", new ve(L, 1, 11)), x.setAttribute("uv", new ve(L, 2, 12)), x.setAttribute("totalLength", new ve(L, 1, 14)), x.setIndex(new Fe(M.indices, 1));
        const E = new bg({
          keepSize: !1,
          depthTest: !0,
          transparent: !0,
          mapGap: 0,
          lineWidth: 100,
          vertexColors: !0,
          vertexZIndex: !0,
          maxLayerIndex: p,
          enableDepthRange: !0
        });
        E.isSingle = !0, E.flipUv = !0, E.setCommonUniforms(this._engine.rendering.uniforms);
        const T = new le(x, E);
        T.name = "Links", zl.get(G).then((R) => {
          R.wrapS = R.wrapT = ii, R.generateMipmaps = !1, R.colorSpace = gt, E.useMap = !0, E.map = R, A.add(T);
        });
      }
    }
    if (c) {
      const u = Object.keys(c);
      for (let y = 0; y < u.length; y++) {
        const I = u[y], M = c[I], G = this._vctMapStyleDomain + "map_icons2x/" + I + ".png", x = new Qe(), L = new Ai(M.attributes, 14);
        x.setAttribute("position", new ve(L, 3, 0)), x.setAttribute("normal", new ve(L, 3, 3)), x.setAttribute("aColor", new ve(L, 4, 6)), x.setAttribute("layerIndex", new ve(L, 1, 10)), x.setAttribute("aWidth", new ve(L, 1, 11)), x.setAttribute("uv", new ve(L, 2, 12)), x.setIndex(new Fe(M.indices, 1));
        const E = new bg({
          keepSize: !1,
          antialias: !0,
          depthTest: !0,
          transparent: !0,
          lineWidth: 1,
          mapGap: 0,
          vertexColors: !0,
          vertexZIndex: !0,
          maxLayerIndex: p,
          enableDepthRange: !0
        });
        E.flipUv = !0, E.setCommonUniforms(this._engine.rendering.uniforms);
        const T = new le(x, E);
        T.name = "Links", zl.get(G).then((R) => {
          R.wrapS = R.wrapT = ii, R.generateMipmaps = !1, R.colorSpace = gt, E.useMap = !0, E.map = R, A.add(T);
        });
      }
    }
    if (l && l.indices) {
      const u = new Qe(), y = new Ai(l.attributes, 10);
      u.setAttribute("position", new ve(y, 3, 0)), u.setAttribute("normal", new ve(y, 3, 3)), u.setAttribute("color", new ve(y, 3, 6)), u.setAttribute("layerIndex", new ve(y, 1, 9)), u.setIndex(new Fe(l.indices, 1));
      const I = new Xc({
        depthTest: !0,
        vertexColors: !0,
        vertexZIndex: !0,
        maxLayerIndex: p,
        enableDepthRange: !0
      });
      I.setCommonUniforms(this._engine.rendering.uniforms);
      const M = new le(u, I);
      M.name = "Polygons3D", A.add(M);
    }
    if (h && h.indices) {
      const u = new Qe(), y = new Ai(h.attributes, 11);
      u.setAttribute("position", new ve(y, 3, 0)), u.setAttribute("normal", new ve(y, 3, 3)), u.setAttribute("color", new ve(y, 3, 6)), u.setAttribute("heightAndConcave", new ve(y, 2, 9)), u.setIndex(new Fe(h.indices, 1));
      const I = new Xc({
        depthTest: !0,
        vertexColors: !0
      });
      I.useAO = !0, I.setCommonUniforms(this._engine.rendering.uniforms);
      const M = new le(u, I);
      M.name = "Building3D", S.add(M);
    }
    if (C && C.indices) {
      const u = new Qe(), y = new Ai(C.attributes, 12);
      u.setAttribute("position", new ve(y, 3, 0)), u.setAttribute("a_normal", new ve(y, 3, 3)), u.setAttribute("a_uv", new ve(y, 2, 6)), u.setAttribute("a_diff", new ve(y, 3, 8)), u.setAttribute("layerIndex", new ve(y, 1, 11)), u.setIndex(new Fe(C.indices, 1));
      const I = new AV({
        transparent: !0,
        vertexZIndex: !0,
        isGlobe: !!this._engine.map.isGlobe
      });
      I.setCommonUniforms(this._engine.rendering.uniforms);
      const M = new le(u, I);
      M.name = "Arrow", S.add(M);
    }
    if (d && d.length) {
      let u = [];
      const y = this._engine.map.projectionName, I = `${e.x}-${e.y}-${e.z}`;
      for (let M = 0; M < d.length; M++) {
        const G = d[M].position, x = `${G[0]}-${G[1]}-${G[2]}`;
        let L = d[M].uid ? `${d[M].uid}_${I}` : `${d[M].name}-${x}`;
        const E = d[M].hasText ? d[M].styleConfig : LV, T = W(d[M].iconConfig, {}), R = T.icon ? this._vctMapStyleDomain + "map_icons2x/" + T.icon + ".png" : "", w = W(T.size, [0, 0]), v = W(MV[d[M].direction], "center"), D = T.textDrawOnIcon, K = d[M].hasText;
        let P = "text_fix";
        R && (P = "icon", K && (P = "icon_text")), !(K && !d[M].text) && u.push({
          crs: y,
          id: L,
          forceProjected: y === hi,
          type: d[M].type ? d[M].type : P,
          rotateZ: "rotateZ" in d[M] ? d[M].rotateZ : void 0,
          position: G,
          text: d[M].text,
          rank: d[M].rank,
          textFillStyle: E.fontRgba,
          textSize: E.fontSize / 2,
          textWeight: E.fontWeight,
          textStrokeStyle: E.haloRgba,
          textStrokeWidth: Math.min(E.haloSize / 2, 4),
          textAnchor: v,
          styleId: d[M].styleId,
          icon: R,
          iconSize: w,
          hasText: d[M].hasText,
          textDrawOnIcon: D
        });
      }
      S.poiLabels = u;
    }
    return m ? (e.projectedBoundingBox.getSize(S.scale), S.scale.z = 1, A.scale.copy(S.scale), S.position.copy(e.targetCenter), A.position.copy(e.targetCenter)) : (S.position.copy(e.targetCenter), A.position.copy(e.targetCenter)), [S, A];
  }
  _calculateTolerance(e, i, n) {
    const o = e.tile.z;
    let r = 0;
    return o === 5 && n.text === "\u4E2D\u534E\u4EBA\u6C11\u5171\u548C\u56FD" && (r = -3), o === 6 && n.text === "\u5E7F\u5DDE" && (r = -4), o === 7 ? (r = 4, (n.text === "\u4E09\u6C99" || n.text === "\u4E09\u4E9A" || n.text === "\u510B\u5DDE") && (r = -1)) : o > 7 && (r = 12), (n.text === "\u9999\u6E2F" || n.text === "\u6FB3\u95E8" || n.text === "\u53F0\u5317") && (r = -3), r;
  }
  _addTilePOI(e, i) {
    if (e.object && e.object.poiLabels) {
      const n = e.dataTile.key, o = e.tile._distance, r = e.tile.z < 10, a = [];
      for (let c = 0; c < e.object.poiLabels.length; c++) {
        const l = e.object.poiLabels[c];
        this._labels[l.id] || (this._labels[l.id] = l, l.bucket = n, l.distance = o, l.checkVisible = r, l.tolerance = this._calculateTolerance(e, i, l), a.push(l));
      }
      const g = e.dataTile.key;
      i.rendering.label.addLabels(a, g);
    }
  }
  _removeTilePOI(e, i) {
    if (e.object && e.object.poiLabels) {
      const n = [], o = e.dataTile.key;
      for (let r = 0; r < e.object.poiLabels.length; r++) {
        const a = e.object.poiLabels[r];
        this._labels[a.id] && (delete this._labels[a.id], n.push(a));
      }
      i.rendering.label.removeLabels(n, o);
    }
  }
  onSurfaceTileAdded(e, i) {
    e.isMeetSSE && this._addTilePOI(e, i);
  }
  onSurfaceTileRemoved(e, i) {
    this._removeTilePOI(e, i);
  }
  onSurfaceTileSSEChanged(e, i) {
    e.isMeetSSE ? this._addTilePOI(e, i) : this._removeTilePOI(e, i);
  }
  addAllSymbols() {
    Object.keys(this._labels).forEach((e) => {
      const i = this._labels[e];
      i.isHidden && (i.isHidden = !1, this._engine.rendering.label.addLabel(i));
    });
  }
  removeAllSymbols() {
    Object.keys(this._labels).forEach((e) => {
      const i = this._labels[e];
      i.isHidden || (i.isHidden = !0, this._engine.rendering.label.removeLabel(i));
    });
  }
}
new B();
new B();
class RV extends PA {
  constructor(e, i = {}) {
    super();
    f(this, "_engine");
    f(this, "_map");
    f(this, "_container");
    f(this, "_mapType");
    f(this, "handleViewChange", () => {
      this._engine.rendering.requestRender();
    });
    f(this, "handleResolutionChange", (e) => {
      this._engine.rendering.setResolution(e);
    });
    this._engine = e, this._options = i;
    const n = e.container;
    let o = bn(i.projection || Mt), r = o.name;
    if (n instanceof HTMLElement)
      if (i.customMap) {
        const a = i.customMap;
        this._map = new a(e, n, i), this._container = n, this._mapType = "custom", o = bn(this._map.projectionName || Mt);
      } else
        r === zs ? (this._map = new TF(e, n, i), this._container = n, this._mapType = "earth", this.isGlobe = !0) : i.is3DControl === !1 ? (this._map = new lr(e, n, i), this._container = n, this._mapType = "blank") : (this._map = new SN(e, n, i), this._container = n, this._mapType = "blank_3dcontrol");
    else
      window.BMapGL && n instanceof BMapGL.Map ? (this._map = new bN(e, n, i), this._container = n.container, this._mapType = "bmapgl", o = bn(i.projection || Fg)) : n._mapId && (this._map = new qw(e, n, i), this._container = n._container, this._mapType = "mapbox");
    if (!this._map)
      throw new Error("map is invalid");
    this._projection = o, this._map.projection = o, this._map.projectionName = o.name;
  }
  init() {
    this._map.init(), this._map.onViewChanged = this.handleViewChange, this._map.onResolutionChanged = this.handleResolutionChange;
  }
  afterInit() {
    const e = this._engine, i = this._map;
    i.canvas = e.rendering.canvas, i.camera = e.rendering.camera, Re(this._container, `${Vt}-container`), i.afterInit();
    const n = this._options;
    H(n.center) ? i.lookAt(n.center, {
      range: n.range,
      heading: n.heading,
      pitch: n.pitch
    }) : (H(n.heading) && i.setHeading(n.heading), H(n.pitch) && i.setPitch(n.pitch), H(n.range) && i.setRange(n.range));
    let o = n.provider;
    if (o === null || (o || (o = new EV()), !o))
      return;
    let r = null, a = null;
    if (o.isVectorTileProvider)
      a = o;
    else if (o.isImageryTileProvider)
      r = o;
    else
      throw new Error("invalid tile provider");
    this._mapView = this._engine.add(new qk({
      vectorProvider: a,
      imageryProvider: r
    }));
  }
  setCenter(e) {
    this._map.setCenter(e);
  }
  setZoom(e) {
    this._map.setZoom(e);
  }
  setHeading(e) {
    this._map.setHeading(e);
  }
  setPitch(e) {
    this._map.setPitch(e);
  }
  setRange(e) {
    this._map.setRange(e);
  }
  setBounds(e) {
    this._map.setBounds(e);
  }
  lockDrag(e) {
    this._map.lockDrag(e);
  }
  setMaxRange(e) {
    this._map.setMaxRange(e);
  }
  lookAt(e, i = {}) {
    if (!e) {
      console.error("engine.map.lookAt: target is required");
      return;
    }
    this._map.lookAt(e, i);
  }
  getBoundingBox() {
    return this._map.getBounds();
  }
  getCenter() {
    return this._map.getCenter();
  }
  getRange() {
    return this._map.getRange();
  }
  getZoom() {
    return this._map.getZoom();
  }
  getZoomUnits() {
    return this._map.getZoomUnits();
  }
  getZoomByZoomUnits(e) {
    return this._map.getZoomByZoomUnits(e);
  }
  getZoomUnitsByZoom(e) {
    return this._map.getZoomUnitsByZoom(e);
  }
  getHeading() {
    return this._map.getHeading();
  }
  flyTo(e, i = {}) {
    if (this._map.flyTo)
      return this._map.flyTo(e, i);
    MP("flyTo is not supported by this map");
  }
  getPitch() {
    return this._map.getPitch();
  }
  getProjectionCenter() {
    return this._map.getProjectionCenter();
  }
  getCameraDistance(e) {
    return this._map.getCameraDistance(e);
  }
  getBounds() {
    return this._map.getBounds();
  }
  getProjectionBounds() {
    return this._map.getProjectionBounds();
  }
  getResolution() {
    return this._map.getResolution();
  }
  projectArrayCoordinate(e, i) {
    return this._map.projectArrayCoordinate(e, i);
  }
  unprojectArrayCoordinate(e, i) {
    return this._map.unprojectArrayCoordinate(e, i);
  }
  projectPointArr(e, i) {
    return console.warn("projectPointArr is deprecated, use projectArrayCoordinate instead"), this.projectArrayCoordinate(e, i);
  }
  unprojectPointArr(e, i) {
    return console.warn("unprojectPointArr is deprecated, use unprojectArrayCoordinate instead"), this.unprojectArrayCoordinate(e, i);
  }
  projectCoordinate(e, i) {
    return this._projection.projectCoordinate(e, i);
  }
  unprojectCoordinate(e, i) {
    return this._projection.unprojectCoordinate(e, i);
  }
  projectArrayCoordinates(e) {
    if (Array.isArray(e[0])) {
      const i = [];
      for (let n of e)
        i.push(this.projectArrayCoordinates(n));
      return i;
    } else if (typeof e[0] == "number" || typeof e[0] == "string")
      return this.projectArrayCoordinate(e);
  }
  enableControl() {
    this._map.enableControl();
  }
  disableControl() {
    this._map.disableControl();
  }
  updateCamera() {
    this._map.updateCamera();
  }
  getScaleAt(e) {
    return 1 / Math.cos(Math.PI * e[1] / 180);
  }
  zoomIn() {
    this._map.zoomIn();
  }
  zoomOut() {
    this._map.zoomOut();
  }
  zoomTo(e, i = { range: 0, zoom: 0 }) {
    let n = null;
    if (e.is3DTiles)
      n = e.getBounds();
    else if (e.isInstancedMesh)
      e.computeBoundingBox(), n = e.boundingBox, n = n.clone(), n.applyMatrix4(e.matrixWorld);
    else if (e.isMesh || e.isPoints) {
      const h = e.geometry;
      n = h.boundingBox, n || (h.computeBoundingBox(), n = h.boundingBox), n = n.clone(), n.applyMatrix4(e.matrixWorld);
    } else
      e.boundingBox && (n = e.boundingBox, n = n.clone(), n.applyMatrix4(e.matrixWorld));
    if (!n)
      return;
    const o = this.getResolution(), r = (n.max.x - n.min.x) / o.x, a = (n.max.y - n.min.y) / o.y, g = Math.max(r, a), c = this._map.getZoomByZoomUnits(g), l = [
      (n.max.x + n.min.x) / 2,
      (n.max.y + n.min.y) / 2,
      (n.max.z + n.min.z) / 2
    ];
    if (this._map.isBlankMap3D || this.isGlobe) {
      let d = Math.max(n.max.x - n.min.x, n.max.y - n.min.y) / Math.tan(this.fov / 2 * Math.PI / 180);
      this.lookAt(l, {
        range: d + i.range
      }), this._map.range = d + i.range;
    } else
      this._map.setProjectionCenter(l), this._map.setZoom(c + i.zoom);
    this._engine.requestRender();
  }
  getViewHeight() {
    return this._map.getViewHeight();
  }
  getCameraLocation(e) {
    return this._map.getCameraLocation(e);
  }
  setViewport(e, i = { range: 0, zoom: 0 }) {
    if (!e || e.length < 2) {
      console.warn("setViewport: points require Array with at least 2 points");
      return;
    }
    let n = new Ue(), o = e.map((d) => {
      let C = this.projectArrayCoordinate(d);
      return new B(C[0], C[1], C[2] || 0);
    });
    n.setFromPoints(o);
    const r = this.getResolution(), a = (n.max.x - n.min.x) / r.x, g = (n.max.y - n.min.y) / r.y, c = Math.max(a, g), l = Math.min(30, this._map.getZoomByZoomUnits(c)), h = [
      (n.max.x + n.min.x) / 2,
      (n.max.y + n.min.y) / 2,
      (n.max.z + n.min.z) / 2
    ];
    if (this._map.isBlankMap3D || this.isGlobe) {
      let C = Math.max(n.max.x - n.min.x, n.max.y - n.min.y) / Math.tan(this.fov / 2 * Math.PI / 180);
      this.lookAt(h, {
        range: C + i.range
      }), this._map.range = C + i.range;
    } else
      this._map.setProjectionCenter(h), this._map.setZoom(l + i.zoom);
    this._engine.requestRender();
  }
  bindCanvas() {
    this._map.bindCanvas();
  }
  releaseCanvas() {
    this._map.releaseCanvas();
  }
  pickSeaLevelWorldPosition(e) {
    return this._map.pickSeaLevelWorldPosition(e);
  }
  dispose() {
    this._map.dispose();
  }
  set onResolutionChanged(e) {
    this._map.onResolutionChanged = e;
  }
  get projectionName() {
    return this._projection.name;
  }
  get map() {
    return this._map;
  }
  get mapType() {
    return this._mapType;
  }
  get container() {
    return this._container;
  }
  get fov() {
    return this._map.fov;
  }
  set fov(e) {
    this._map.fov = e, this._engine.camera.fov = e;
  }
  get near() {
    return this._map.near;
  }
  get far() {
    return this._map.far;
  }
  get projection() {
    return this._projection;
  }
  set projection(e) {
    this._projection = e;
  }
  get mapView() {
    return this._mapView;
  }
}
class DV extends Wt {
  constructor() {
    super();
    f(this, "_boxGeometry");
    f(this, "_boxMesh");
    this._boxMaterial = new _t({
      transparent: !0,
      color: 16711680,
      opacity: 0.3
    });
  }
  attach(e) {
    this._object = e;
    const i = e.geometry;
    i.boundingBox || i.computeBoundingBox(), this._boxGeometry && this._boxGeometry.dispose();
    const n = i.boundingBox;
    if (this._boxGeometry = new Nt(
      n.max.x - n.min.x,
      n.max.y - n.min.y,
      n.max.z - n.min.z
    ), this._boxMesh)
      this._boxMesh.geometry = this._boxGeometry;
    else {
      const o = this._boxMesh = new le(this._boxGeometry, this._boxMaterial);
      this.add(o);
    }
  }
  detach() {
    this._object = null, this.remove(this._boxMesh), this._boxMesh = null;
  }
  onBeforeScenePrepareRender() {
    if (this._object) {
      this._object.updateMatrixWorld();
      const e = this._boxMesh;
      this._object.matrixWorld.decompose(e.position, e.rotation, e.scale);
    }
  }
}
const $o = new js(), Hi = new B(), ro = new B(), wt = new Ye(), B0 = {
  X: new B(1, 0, 0),
  Y: new B(0, 1, 0),
  Z: new B(0, 0, 1)
}, Du = { type: "change" }, w0 = { type: "pointerdown" }, _0 = { type: "pointerup", mode: null }, x0 = { type: "pointermove", mode: null }, v0 = { type: "objectChange" };
class O_ extends Wt {
  constructor(e, i) {
    super();
    f(this, "_cameraScale");
    f(this, "_endNorm");
    f(this, "_gizmo");
    f(this, "_getPointer");
    f(this, "_onPointerDown");
    f(this, "_onPointerHover");
    f(this, "_onPointerMove");
    f(this, "_onPointerUp");
    f(this, "_parentPosition");
    f(this, "_parentQuaternion");
    f(this, "_parentQuaternionInv");
    f(this, "_parentScale");
    f(this, "_plane");
    f(this, "_positionStart");
    f(this, "_quaternionStart");
    f(this, "_scaleStart");
    f(this, "_startNorm");
    f(this, "_worldQuaternionInv");
    f(this, "_worldScale");
    f(this, "_worldScaleStart");
    f(this, "_offset");
    f(this, "isTransformControls");
    i === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), i = document), this.visible = !1, this.domElement = i, this.domElement.style.touchAction = "none";
    const n = new Q_();
    this._gizmo = n, this.add(n);
    const o = new Y_();
    this._plane = o, this.add(o);
    const r = this;
    function a(u, y) {
      let I = y;
      Object.defineProperty(r, u, {
        get: function() {
          return I !== void 0 ? I : y;
        },
        set: function(M) {
          I !== M && (I = M, o[u] = M, n[u] = M, r.dispatchEvent({ type: u + "-changed", value: M }), r.dispatchEvent(Du));
        }
      }), r[u] = y, o[u] = y, n[u] = y;
    }
    a("camera", e), a("object", void 0), a("enabled", !0), a("axis", null), a("mode", "translate"), a("translationSnap", null), a("rotationSnap", null), a("scaleSnap", null), a("space", "local"), a("size", 0.7), a("dragging", !1), a("showX", !0), a("showY", !0), a("showZ", !0);
    const g = new B(), c = new B(), l = new Ye(), h = new Ye(), d = new B(), C = new Ye(), p = new B(), m = new B(), b = new B(), S = 0, A = new B();
    a("worldPosition", g), a("worldPositionStart", c), a("worldQuaternion", l), a("worldQuaternionStart", h), a("cameraPosition", d), a("cameraQuaternion", C), a("pointStart", p), a("pointEnd", m), a("rotationAxis", b), a("rotationAngle", S), a("eye", A), this._offset = new B(), this._startNorm = new B(), this._endNorm = new B(), this._cameraScale = new B(), this._parentPosition = new B(), this._parentQuaternion = new Ye(), this._parentQuaternionInv = new Ye(), this._parentScale = new B(), this._worldScaleStart = new B(), this._worldQuaternionInv = new Ye(), this._worldScale = new B(), this._positionStart = new B(), this._quaternionStart = new Ye(), this._scaleStart = new B(), this._getPointer = KV.bind(this), this._onPointerDown = PV.bind(this), this._onPointerHover = HV.bind(this), this._onPointerMove = NV.bind(this), this._onPointerUp = FV.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    $o.setFromCamera(e, this.camera);
    const i = Ku(this._gizmo.picker[this.mode], $o);
    i ? this.axis = i.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      $o.setFromCamera(e, this.camera);
      const i = Ku(this._plane, $o, !0);
      i && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart)), this.dragging = !0, w0.mode = this.mode, this.dispatchEvent(w0);
    }
  }
  pointerMove(e) {
    const i = this.axis, n = this.mode, o = this.object;
    let r = this.space;
    if (n === "scale" ? r = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (r = "world"), o === void 0 || i === null || this.dragging === !1 || e.button !== -1)
      return;
    $o.setFromCamera(e, this.camera);
    const a = Ku(this._plane, $o, !0);
    if (!!a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), r === "local" && i !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), i.indexOf("X") === -1 && (this._offset.x = 0), i.indexOf("Y") === -1 && (this._offset.y = 0), i.indexOf("Z") === -1 && (this._offset.z = 0), r === "local" && i !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), o.position.copy(this._offset).add(this._positionStart), this.translationSnap && (r === "local" && (o.position.applyQuaternion(wt.copy(this._quaternionStart).invert()), i.search("X") !== -1 && (o.position.x = Math.round(o.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (o.position.y = Math.round(o.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (o.position.z = Math.round(o.position.z / this.translationSnap) * this.translationSnap), o.position.applyQuaternion(this._quaternionStart)), r === "world" && (o.parent && o.position.add(Hi.setFromMatrixPosition(o.parent.matrixWorld)), i.search("X") !== -1 && (o.position.x = Math.round(o.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (o.position.y = Math.round(o.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (o.position.z = Math.round(o.position.z / this.translationSnap) * this.translationSnap), o.parent && o.position.sub(Hi.setFromMatrixPosition(o.parent.matrixWorld))));
      else if (n === "scale") {
        if (i.search("XYZ") !== -1) {
          let g = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (g *= -1), ro.set(g, g, g);
        } else
          Hi.copy(this.pointStart), ro.copy(this.pointEnd), Hi.applyQuaternion(this._worldQuaternionInv), ro.applyQuaternion(this._worldQuaternionInv), ro.divide(Hi), i.search("X") === -1 && (ro.x = 1), i.search("Y") === -1 && (ro.y = 1), i.search("Z") === -1 && (ro.z = 1);
        o.scale.copy(this._scaleStart).multiply(ro), this.scaleSnap && (i.search("X") !== -1 && (o.scale.x = Math.round(o.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (o.scale.y = Math.round(o.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (o.scale.z = Math.round(o.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const g = 20 / this.worldPosition.distanceTo(Hi.setFromMatrixPosition(this.camera.matrixWorld));
        i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Hi.copy(this.rotationAxis).cross(this.eye)) * g) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(B0[i]), Hi.copy(B0[i]), r === "local" && Hi.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(Hi.cross(this.eye).normalize()) * g), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), r === "local" && i !== "E" && i !== "XYZE" ? (o.quaternion.copy(this._quaternionStart), o.quaternion.multiply(wt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), o.quaternion.copy(wt.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), o.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Du), this.dispatchEvent(v0), x0.mode = this.mode, this.dispatchEvent(x0);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (_0.mode = this.mode, this.dispatchEvent(_0)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    !this.enabled || this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Du), this.dispatchEvent(v0), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return $o;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
  update() {
    console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
  }
}
O_.prototype.isTransformControls = !0;
function KV(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const t = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - t.left) / t.width * 2 - 1,
      y: -(s.clientY - t.top) / t.height * 2 + 1,
      button: s.button
    };
  }
}
function HV(s) {
  if (!!this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function PV(s) {
  !this.enabled || (this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function NV(s) {
  !this.enabled || this.pointerMove(this._getPointer(s));
}
function FV(s) {
  !this.enabled || (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function Ku(s, t, e) {
  const i = t.intersectObject(s, !0);
  for (let n = 0; n < i.length; n++)
    if (i[n].object.visible || e)
      return i[n];
  return !1;
}
const Uc = new pr(), At = new B(0, 1, 0), T0 = new B(0, 0, 0), L0 = new J(), Oc = new Ye(), Xl = new Ye(), jn = new B(), G0 = new J(), Bg = new B(1, 0, 0), rr = new B(0, 1, 0), wg = new B(0, 0, 1), Qc = new B(), Ja = new B(), qa = new B();
class Q_ extends Wt {
  constructor() {
    super(), this.type = "TransformControlsGizmo";
    const t = new _t({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), e = new _r({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = t.clone();
    i.opacity = 0.15;
    const n = e.clone();
    n.opacity = 0.5;
    const o = t.clone();
    o.color.setHex(16711680);
    const r = t.clone();
    r.color.setHex(65280);
    const a = t.clone();
    a.color.setHex(255);
    const g = t.clone();
    g.color.setHex(16711680), g.opacity = 0.5;
    const c = t.clone();
    c.color.setHex(65280), c.opacity = 0.5;
    const l = t.clone();
    l.color.setHex(255), l.opacity = 0.5;
    const h = t.clone();
    h.opacity = 0.25;
    const d = t.clone();
    d.color.setHex(16776960), d.opacity = 0.25, t.clone().color.setHex(16776960);
    const p = t.clone();
    p.color.setHex(7895160);
    const m = new Ri(0, 0.04, 0.1, 12);
    m.translate(0, 0.05, 0);
    const b = new Nt(0.08, 0.08, 0.08);
    b.translate(0, 0.04, 0);
    const S = new Qe();
    S.setAttribute("position", new ae([0, 0, 0, 1, 0, 0], 3));
    const A = new Ri(75e-4, 75e-4, 0.5, 3);
    A.translate(0, 0.25, 0);
    function u(D, K) {
      const P = new Ha(D, 75e-4, 3, 64, K * Math.PI * 2);
      return P.rotateY(Math.PI / 2), P.rotateX(Math.PI / 2), P;
    }
    function y() {
      const D = new Qe();
      return D.setAttribute("position", new ae([0, 0, 0, 1, 1, 1], 3)), D;
    }
    const I = {
      X: [
        [new le(m, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(m, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new le(A, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new le(m, r), [0, 0.5, 0]],
        [new le(m, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new le(A, r)]
      ],
      Z: [
        [new le(m, a), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new le(m, a), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new le(A, a), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new sc(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new le(new Nt(0.15, 0.15, 0.01), l.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Nt(0.15, 0.15, 0.01), g.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Nt(0.15, 0.15, 0.01), c.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, M = {
      X: [
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(new Ri(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new sc(0.2, 0), i)]
      ],
      XY: [
        [new le(new Nt(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Nt(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Nt(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, G = {
      START: [
        [new le(new sc(0.01, 2), n), null, null, null, "helper"]
      ],
      END: [
        [new le(new sc(0.01, 2), n), null, null, null, "helper"]
      ],
      DELTA: [
        [new es(y(), n), null, null, null, "helper"]
      ],
      X: [
        [new es(S, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new es(S, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new es(S, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, x = {
      XYZE: [
        [new le(u(0.5, 1), p), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new le(u(0.5, 0.5), o)]
      ],
      Y: [
        [new le(u(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new le(u(0.5, 0.5), a), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new le(u(0.75, 1), d), null, [0, Math.PI / 2, 0]]
      ]
    }, L = {
      AXIS: [
        [new es(S, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, E = {
      XYZE: [
        [new le(new XA(0.25, 10, 8), i)]
      ],
      X: [
        [new le(new Ha(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new le(new Ha(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new le(new Ha(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new le(new Ha(0.75, 0.1, 2, 24), i)]
      ]
    }, T = {
      X: [
        [new le(b, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(A, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(b, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new le(b, r), [0, 0.5, 0]],
        [new le(A, r)],
        [new le(b, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new le(b, a), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new le(A, a), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new le(b, a), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new le(new Nt(0.15, 0.15, 0.01), l), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Nt(0.15, 0.15, 0.01), g), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Nt(0.15, 0.15, 0.01), c), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new Nt(0.1, 0.1, 0.1), h.clone())]
      ]
    }, R = {
      X: [
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new le(new Ri(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new le(new Ri(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new le(new Nt(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new le(new Nt(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new le(new Nt(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new le(new Nt(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, w = {
      X: [
        [new es(S, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new es(S, n.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new es(S, n.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function v(D) {
      const K = new Wt();
      for (const P in D)
        for (let k = D[P].length; k--; ) {
          const V = D[P][k][0].clone(), N = D[P][k][1], z = D[P][k][2], O = D[P][k][3], Q = D[P][k][4];
          V.name = P, V.tag = Q, N && V.position.set(N[0], N[1], N[2]), z && V.rotation.set(z[0], z[1], z[2]), O && V.scale.set(O[0], O[1], O[2]), V.updateMatrix();
          const U = V.geometry.clone();
          U.applyMatrix4(V.matrix), V.geometry = U, V.renderOrder = 1 / 0, V.position.set(0, 0, 0), V.rotation.set(0, 0, 0), V.scale.set(1, 1, 1), K.add(V);
        }
      return K;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = v(I)), this.add(this.gizmo.rotate = v(x)), this.add(this.gizmo.scale = v(T)), this.add(this.picker.translate = v(M)), this.add(this.picker.rotate = v(E)), this.add(this.picker.scale = v(R)), this.add(this.helper.translate = v(G)), this.add(this.helper.rotate = v(L)), this.add(this.helper.scale = v(w)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  onBeforeScenePrepareRender() {
    const e = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Xl;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let n = 0; n < i.length; n++) {
      const o = i[n];
      o.visible = !0, o.rotation.set(0, 0, 0), o.position.copy(this.worldPosition);
      let r;
      if (this.camera.isOrthographicCamera ? r = (this.camera.top - this.camera.bottom) / this.camera.zoom : r = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), o.scale.set(1, 1, 1).multiplyScalar(r * this.size / 4), o.tag === "helper") {
        o.visible = !1, o.name === "AXIS" ? (o.position.copy(this.worldPositionStart), o.visible = !!this.axis, this.axis === "X" && (wt.setFromEuler(Uc.set(0, 0, 0)), o.quaternion.copy(e).multiply(wt), Math.abs(At.copy(Bg).applyQuaternion(e).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Y" && (wt.setFromEuler(Uc.set(0, 0, Math.PI / 2)), o.quaternion.copy(e).multiply(wt), Math.abs(At.copy(rr).applyQuaternion(e).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "Z" && (wt.setFromEuler(Uc.set(0, Math.PI / 2, 0)), o.quaternion.copy(e).multiply(wt), Math.abs(At.copy(wg).applyQuaternion(e).dot(this.eye)) > 0.9 && (o.visible = !1)), this.axis === "XYZE" && (wt.setFromEuler(Uc.set(0, Math.PI / 2, 0)), At.copy(this.rotationAxis), o.quaternion.setFromRotationMatrix(L0.lookAt(T0, At, rr)), o.quaternion.multiply(wt), o.visible = this.dragging), this.axis === "E" && (o.visible = !1)) : o.name === "START" ? (o.position.copy(this.worldPositionStart), o.visible = this.dragging) : o.name === "END" ? (o.position.copy(this.worldPosition), o.visible = this.dragging) : o.name === "DELTA" ? (o.position.copy(this.worldPositionStart), o.quaternion.copy(this.worldQuaternionStart), Hi.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Hi.applyQuaternion(this.worldQuaternionStart.clone().invert()), o.scale.copy(Hi), o.visible = this.dragging) : (o.quaternion.copy(e), this.dragging ? o.position.copy(this.worldPositionStart) : o.position.copy(this.worldPosition), this.axis && (o.visible = this.axis.search(o.name) !== -1));
        continue;
      }
      o.quaternion.copy(e), this.mode === "translate" || this.mode === "scale" ? (o.name === "X" && Math.abs(At.copy(Bg).applyQuaternion(e).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Y" && Math.abs(At.copy(rr).applyQuaternion(e).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "Z" && Math.abs(At.copy(wg).applyQuaternion(e).dot(this.eye)) > 0.99 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XY" && Math.abs(At.copy(wg).applyQuaternion(e).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "YZ" && Math.abs(At.copy(Bg).applyQuaternion(e).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1), o.name === "XZ" && Math.abs(At.copy(rr).applyQuaternion(e).dot(this.eye)) < 0.2 && (o.scale.set(1e-10, 1e-10, 1e-10), o.visible = !1)) : this.mode === "rotate" && (Oc.copy(e), At.copy(this.eye).applyQuaternion(wt.copy(e).invert()), o.name.search("E") !== -1 && o.quaternion.setFromRotationMatrix(L0.lookAt(this.eye, T0, rr)), o.name === "X" && (wt.setFromAxisAngle(Bg, Math.atan2(-At.y, At.z)), wt.multiplyQuaternions(Oc, wt), o.quaternion.copy(wt)), o.name === "Y" && (wt.setFromAxisAngle(rr, Math.atan2(At.x, At.z)), wt.multiplyQuaternions(Oc, wt), o.quaternion.copy(wt)), o.name === "Z" && (wt.setFromAxisAngle(wg, Math.atan2(At.y, At.x)), wt.multiplyQuaternions(Oc, wt), o.quaternion.copy(wt))), o.visible = o.visible && (o.name.indexOf("X") === -1 || this.showX), o.visible = o.visible && (o.name.indexOf("Y") === -1 || this.showY), o.visible = o.visible && (o.name.indexOf("Z") === -1 || this.showZ), o.visible = o.visible && (o.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), o.material._color = o.material._color || o.material.color.clone(), o.material._opacity = o.material._opacity || o.material.opacity, o.material.color.copy(o.material._color), o.material.opacity = o.material._opacity, this.enabled && this.axis && (o.name === this.axis || this.axis.split("").some(function(a) {
        return o.name === a;
      })) && (o.material.color.setHex(16776960), o.material.opacity = 1);
    }
  }
}
Q_.prototype.isTransformControlsGizmo = !0;
class Y_ extends le {
  constructor() {
    super(
      new Og(1e5, 1e5, 2, 2),
      new _t({ visible: !1, wireframe: !0, side: xr, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(t) {
    let e = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), Qc.copy(Bg).applyQuaternion(e === "local" ? this.worldQuaternion : Xl), Ja.copy(rr).applyQuaternion(e === "local" ? this.worldQuaternion : Xl), qa.copy(wg).applyQuaternion(e === "local" ? this.worldQuaternion : Xl), At.copy(Ja), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            At.copy(this.eye).cross(Qc), jn.copy(Qc).cross(At);
            break;
          case "Y":
            At.copy(this.eye).cross(Ja), jn.copy(Ja).cross(At);
            break;
          case "Z":
            At.copy(this.eye).cross(qa), jn.copy(qa).cross(At);
            break;
          case "XY":
            jn.copy(qa);
            break;
          case "YZ":
            jn.copy(Qc);
            break;
          case "XZ":
            At.copy(qa), jn.copy(Ja);
            break;
          case "XYZ":
          case "E":
            jn.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        jn.set(0, 0, 0);
    }
    jn.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (G0.lookAt(Hi.set(0, 0, 0), jn, At), this.quaternion.setFromRotationMatrix(G0)), super.updateMatrixWorld(t);
  }
  raycast(t, e) {
    e.length || super.raycast(t, e);
  }
}
Y_.prototype.isTransformControlsPlane = !0;
class kV extends O_ {
  constructor(e) {
    super(e.camera, e.map.container);
    f(this, "_enableKeyboardEvent", !1);
    f(this, "handleKeyboardEvent", (e) => {
      switch (e.keyCode) {
        case 81:
          this.setSpace(this.space === "local" ? "world" : "local");
          break;
        case 87:
          this.setMode("translate");
          break;
        case 69:
          this.setMode("rotate");
          break;
        case 82:
          this.setMode("scale");
          break;
        case 187:
        case 107:
          this.setSize(this.size + 0.1);
          break;
        case 189:
        case 109:
          this.setSize(Math.max(this.size - 0.1, 0.1));
          break;
        case 88:
          this.showX = !this.showX;
          break;
        case 89:
          this.showY = !this.showY;
          break;
        case 90:
          this.showZ = !this.showZ;
          break;
        case 32:
          this.enabled = !this.enabled;
          break;
        case 27:
          this.reset();
          break;
      }
    });
    this.engine = e, this.addEventListener("change", (i) => {
      e.requestRender();
    }), this.addEventListener("objectChange", (i) => {
      e.requestRender();
    }), this.addEventListener("dragging-changed", (i) => {
      i.value ? e.map.disableControl() : e.map.enableControl();
    });
  }
  dispose() {
    super.dispose(), this.enableKeyboardEvent = !1;
  }
  set enableKeyboardEvent(e) {
    e !== this._enableKeyboardEvent && (this._enableKeyboardEvent = e, e ? window.addEventListener("keydown", this.handleKeyboardEvent) : window.removeEventListener("keydown", this.handleKeyboardEvent));
  }
}
class VV extends PA {
  constructor(e, i = {}) {
    super();
    f(this, "_engine");
    f(this, "_boundingBoxHelper");
    f(this, "_selectedObject");
    f(this, "_transformControl");
    this._engine = e;
  }
  isSelected(e) {
    return e === this._selectedObject;
  }
  select(e) {
    e.__engine_selected || (this._selectedObject && (this._selectedObject.__engine_selected = !1), this._boundingBoxHelper || (this._boundingBoxHelper = new DV(), this._engine.add(this._boundingBoxHelper)), this._boundingBoxHelper.attach(e), this._selectedObject = e, e.__engine_selected = !0, this._engine.requestRender());
  }
  deselect(e) {
    !this.isSelected(e) || (this._boundingBoxHelper.detach(), this._selectedObject = null, e.__engine_selected = !1, this._engine.requestRender());
  }
  get transformControl() {
    return this._transformControl || (this._transformControl = new kV(this._engine), this._transformControl.enableKeyboardEvent = !0), this._transformControl;
  }
  attachTransform(e) {
    const i = this._engine, n = this.transformControl;
    i.add(n), n.attach(e), n.updateMatrixWorld(), i.requestRender();
  }
  detachTransform() {
    const e = this._engine, i = this.transformControl;
    e.remove(i), i.detach();
  }
  dispose() {
  }
}
class qs {
  constructor(t, e, i = null) {
    f(this, "_container");
    f(this, "_enabled");
    f(this, "_options", {});
    f(this, "_element");
    f(this, "_engine");
    this._container = t, this._engine = i, e && typeof e == "object" ? (this._options = e, this._enabled = e.enabled) : this._enabled = !1, this._element = null, this._enabled && this.init();
  }
  init() {
    let t = this._element = this.createDom();
    this._container.appendChild(t), this.afterInit();
  }
  afterInit() {
  }
  createDom() {
    return null;
  }
  dispose() {
    this._element && (this.onDispose(), this._element.remove());
  }
  onDispose() {
  }
  get container() {
    return this._container;
  }
  get element() {
    return this._element;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(t) {
    const e = !!t;
    if (this._enabled !== e) {
      const i = e ? "visible" : "hidden";
      this._element ? (this._element.style.visibility = i, this.onDispose()) : i && this.init(), this._enabled = e;
    }
  }
}
class zV extends qs {
  afterInit() {
    this._options && this._options.url && (this.url = this._options.url);
  }
  createDom() {
    return this._element = document.createElement("img"), Re(this._element, "logo"), this._url = this._url || pt("assets/images/bdImg.png"), this._element.src = this._url, this._element;
  }
  set url(t) {
    this._element && (this._element.src = t), this._url = t;
  }
  get url() {
    return this._url;
  }
}
class XV extends qs {
  createDom() {
    this.handleZoomIn = this.handleZoomIn.bind(this), this.handleZoomOut = this.handleZoomOut.bind(this), this._element = document.createElement("div"), Re(this._element, "zoom");
    const t = this._zoomAdd = document.createElement("div");
    Re(t, "zoom-add");
    const e = document.createElement("div");
    Re(e, "zoom-add-tag"), e.setAttribute("style", `background-image: url(${pt("assets/images/mapZoom2x.png")});`), t.addEventListener(ye.DOWN, this.handleZoomIn), t.appendChild(e);
    const i = this._zoomSub = document.createElement("div");
    Re(i, "zoom-sub");
    const n = document.createElement("div");
    return Re(n, "zoom-sub-tag"), n.setAttribute("style", `background-image: url(${pt("assets/images/mapZoom2x.png")});`), i.addEventListener(ye.DOWN, this.handleZoomOut), i.appendChild(n), this._element.appendChild(t), this._element.appendChild(i), this._element;
  }
  handleZoomIn() {
    this._engine.map.zoomIn();
  }
  handleZoomOut() {
    this._engine.map.zoomOut();
  }
  onDispose() {
    this._zoomAdd.removeEventListener(ye.DOWN, this.handleZoomIn), this._zoomSub.removeEventListener(ye.DOWN, this.handleZoomOut);
  }
}
class WV extends qs {
  createDom() {
    this._element = document.createElement("div"), Re(this._element, "scale"), this._text = document.createElement("div"), Re(this._text, "scale-text"), this._text.innerText = "20km";
    const t = document.createElement("div");
    Re(t, "scale-line");
    const e = document.createElement("div");
    Re(e, "scale-line-mid");
    const i = document.createElement("div");
    Re(i, "scale-line-left");
    const n = document.createElement("div");
    return Re(n, "scale-line-right"), t.appendChild(e), t.appendChild(i), t.appendChild(n), this._element.appendChild(this._text), this._element.appendChild(t), this.calculateScale = this.calculateScale.bind(this), this._engine.rendering.addPrepareRenderListener(this.calculateScale), this._element;
  }
  calculateScale() {
    const t = this._engine.map.getZoomUnitsByZoom(this._engine.map.getZoom());
    let e = 0;
    const i = [0.05, 0.1, 0.2];
    for (let n = 0; n < 3 && e < 7; n++) {
      const o = i[n] * Math.pow(10, e), r = o / t;
      if (r >= 50 && r <= 150) {
        if (this._element.style.width = r + "px", e < 1)
          this._text.innerText = (o < 0.1 ? 5 : o * 100) + "cm";
        else if (e < 2)
          this._text.innerText = (o < 1 ? 5 : o * 10) + "dm";
        else {
          const a = o / 1e3, g = a < 1;
          this._text.innerText = g ? o + "m" : a + "km";
        }
        break;
      } else
        n < 1 && e < 1 && r > 150 && (this._element.style.width = "150px", this._text.innerText = "< 5cm");
      n > 1 && (e++, n = 0);
    }
  }
  onDispose() {
    this._engine.rendering.removePrepareRenderListener(this.calculateScale);
  }
}
const M0 = "M358.4 768H426.666667v85.333333H213.333333v-213.333333h85.333334v68.266667l128-128 59.733333 59.733333-128 128z m345.6 0l-128-128 59.733333-59.733333 132.266667 132.266666V640h85.333333v213.333333h-213.333333v-85.333333h64zM358.4 298.666667l128 128-59.733333 59.733333-128-128V426.666667H213.333333V213.333333h213.333334v85.333334H358.4z m345.6 0H640V213.333333h213.333333v213.333334h-85.333333V354.133333l-132.266667 132.266667-59.733333-59.733333 128-128z", ZV = "M298.666667 631.466667H226.133333v-81.066667h217.6v204.8h-85.333333v-68.266667l-128 128L170.666667 759.466667l128-128z m422.4 0l128 128-59.733334 59.733333-128-128v68.266667h-85.333333V554.666667h217.6v81.066666h-72.533333zM298.666667 341.333333L187.733333 230.4 243.2 170.666667l115.2 115.2V217.6h85.333333v204.8H226.133333V341.333333H298.666667z m430.933333 0h64v81.066667h-217.6V217.6h85.333333v72.533333L780.8 170.666667l59.733333 59.733333L729.6 341.333333z";
class UV extends qs {
  createDom() {
    this.handleClick = this.handleClick.bind(this), this.handleFullscreenChange = this.handleFullscreenChange.bind(this), this._element = document.createElement("div"), Re(this._element, "fullscreen");
    const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return t.setAttribute("class", "widgets-group-svg fullscreen-svg"), t.setAttribute("viewBox", "0 0 1024 1024"), t.setAttribute("version", "1.1"), this._path = document.createElementNS("http://www.w3.org/2000/svg", "path"), this._path.setAttribute("d", M0), this._path.setAttribute("class", "fullscreen-path"), t.appendChild(this._path), this._flag = !0, this._element.addEventListener(ye.DOWN, this.handleClick), document.addEventListener("fullscreenchange", this.handleFullscreenChange), this._element.appendChild(t), this._element;
  }
  handleClick() {
    const t = this._engine.container, i = t instanceof HTMLElement || t && typeof t == "object" && t.nodeType === 1 && typeof t.nodeName == "string" ? t : t.container || t._container;
    this._flag ? i.requestFullscreen ? i.requestFullscreen() : i.msRequestFullscreen ? i.msRequestFullscreen() : i.mozRequestFullScreen ? i.mozRequestFullScreen() : i.webkitRequestFullScreen && i.webkitRequestFullScreen() : document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen();
  }
  handleFullscreenChange() {
    this._flag = !this._flag, this._flag ? this._path.setAttribute("d", M0) : this._path.setAttribute("d", ZV);
  }
  onDispose() {
    this._element.removeEventListener(ye.DOWN, this.handleClick), document.removeEventListener("fullscreenchange", this.handleFullscreenChange);
  }
}
class OV extends qs {
  createDom() {
    this.locate = this.locate.bind(this), this._element = document.createElement("div"), Re(this._element, "geo-locate");
    const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    t.setAttribute("class", "widgets-group-svg geo-locate-svg"), t.setAttribute("viewBox", "0 0 1024 1024"), t.setAttribute("version", "1.1");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return e.setAttribute("d", "M87.424 469.312A426.816 426.816 0 0 1 469.312 87.424V0h85.376v87.424a426.816 426.816 0 0 1 381.888 381.888H1024v85.376h-87.424a426.816 426.816 0 0 1-381.888 381.888V1024h-85.376v-87.424A426.816 426.816 0 0 1 87.424 554.688H0v-85.376h87.424z m424.576 384a341.312 341.312 0 1 0 0-682.624 341.312 341.312 0 0 0 0 682.624z m0-170.624a170.688 170.688 0 1 0 0-341.376 170.688 170.688 0 0 0 0 341.376z"), e.setAttribute("class", "geo-locate-path"), t.appendChild(e), this._element.addEventListener(ye.DOWN, this.locate), this._element.appendChild(t), this._element;
  }
  locate() {
    window.navigator.geolocation.getCurrentPosition((t) => {
      var n;
      const { longitude: e, latitude: i } = (n = t.coords) != null ? n : {};
      !isNaN(e) && !isNaN(i) ? (this._engine.map.setCenter([e, i]), this._engine.map.setZoom(18)) : console.error("\u5B9A\u4F4D\u51FA\u9519\uFF0C\u8BF7\u91CD\u65B0\u5B9A\u4F4D\uFF01");
    }, (t) => {
      console.error("\u5B9A\u4F4D\u672A\u5F00\u542F");
    });
  }
  onDispose() {
    this._element.removeEventListener(ye.DOWN, this.locate);
  }
}
class QV extends qs {
  constructor() {
    super(...arguments);
    f(this, "screenshot", (e, i) => {
      const n = this._engine.rendering.canvas, o = this._engine.map.mapType, r = document.createElement("canvas"), a = r.getContext("2d");
      if (r.width = n.width, r.height = n.height, o === "bmapgl") {
        const c = this._engine.container._webglPainter._canvas;
        a.drawImage(c, 0, 0, c.width, c.height);
      } else if (o === "mapbox") {
        const c = this._engine.container._canvas;
        a.drawImage(c, 0, 0, c.width, c.height);
      }
      a.drawImage(n, 0, 0, n.width, n.height);
      let g = r.toDataURL();
      if (i) {
        e = e || "download.png";
        const c = document.createElement("a");
        c.href = g, c.download = e, c.click();
      }
      return g;
    });
  }
  createDom() {
    this.handleClick = this.handleClick.bind(this), this._element = document.createElement("div"), Re(this._element, "export-image");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    e.setAttribute("class", "widgets-group-svg export-image-svg"), e.setAttribute("viewBox", "0 0 1024 1024"), e.setAttribute("version", "1.1");
    const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return i.setAttribute("d", "M867.90864 574.538232V257.779543a50.844091 50.844091 0 0 0-50.844092-50.844091h-610.129096a50.844091 50.844091 0 0 0-50.844092 50.844091v499.797418l430.141013-257.779543a152.532274 152.532274 0 0 1 157.108243 0z m0 118.466733l-177.445879-106.264151a50.844091 50.844091 0 0 0-50.844092 0L254.220457 817.064548h562.844091a50.844091 50.844091 0 0 0 50.844092-50.844091z m-660.973188-587.757696h610.129096a152.532274 152.532274 0 0 1 152.532274 152.532274v508.440914a152.532274 152.532274 0 0 1-152.532274 152.532274h-610.129096a152.532274 152.532274 0 0 1-152.532274-152.532274v-508.440914a152.532274 152.532274 0 0 1 152.532274-152.532274z m127.110228 355.90864a76.266137 76.266137 0 1 1 76.266137-76.266137 76.266137 76.266137 0 0 1-76.266137 76.266137z"), e.appendChild(i), this._element.addEventListener(ye.DOWN, this.handleClick), this._element.appendChild(e), this._element;
  }
  handleClick() {
    this.screenshot("download.png", !0);
  }
  onDispose() {
    this._element.removeEventListener(ye.DOWN, this.handleClick);
  }
}
class YV extends qs {
  constructor() {
    super(...arguments);
    f(this, "_mapInfo", {
      pitch: 0,
      heading: 0,
      zoom: 0,
      range: 0,
      center: [0, 0],
      mousePoint: [0, 0]
    });
    f(this, "_prefix", {
      M: "\u6307\u9488\u4F4D\u7F6E",
      C: "\u4E2D\u5FC3\u70B9",
      Z: "\u7EA7\u522B",
      H: "\u65CB\u8F6C\u89D2",
      P: "\u503E\u89D2",
      R: "\u89C6\u91CE\u8DDD\u79BB"
    });
    f(this, "_separator", " | ");
    f(this, "_template", "CR");
  }
  afterInit() {
    this._options && this._options.template && (this.template = this._options.template), this._options && this._options.prefix && (this.prefix = this._options.prefix), this._options && this._options.separator && (this.separator = this._options.separator);
  }
  createDom() {
    return this._element = document.createElement("div"), Re(this._element, "mouse-location"), this._enableMousePositionTracking = !1, this._eventName = "pointerdown", this.eventCallback = this.update.bind(this), this._engine.map.addEventListener(this._eventName, this.eventCallback), this._viewChangedCallback = () => {
      if (this._engine.rendering.renderState.viewChanged) {
        const i = this._engine.map, n = i.getCenter();
        this._mapInfo.pitch = Yc(i.getPitch()), this._mapInfo.heading = Yc(i.getHeading()), this._mapInfo.zoom = Yc(i.getZoom()), this._mapInfo.center = [n[0].toFixed(6), n[1].toFixed(6)], this._mapInfo.range = Yc(i.getRange()), this.updateInfoText();
      }
    }, this._engine.rendering.addPrepareRenderListener(this._viewChangedCallback), this._element;
  }
  update(e) {
    const i = e.point;
    !i || !/M/gi.test(this._template) || (this._mapInfo.mousePoint = [i[0].toFixed(6), i[1].toFixed(6)], this.updateInfoText());
  }
  updateInfoText() {
    const {
      center: e,
      heading: i,
      pitch: n,
      zoom: o,
      range: r,
      mousePoint: a
    } = this._mapInfo, g = {
      M: a,
      C: e,
      Z: o,
      H: i,
      P: n,
      R: r
    }, c = this.template.replace(
      /[MCZHPR]/gi,
      (l) => `${this.prefix[l.toUpperCase()]}: ${g[l.toUpperCase()]}${this.separator}`
    ).slice(0, -this.separator.length);
    this._element.innerText = c;
  }
  get enableMousePositionTracking() {
    return this._enableMousePositionTracking;
  }
  set enableMousePositionTracking(e) {
    this._enableMousePositionTracking !== e && (this._enableMousePositionTracking = e, this._engine.map.removeEventListener(this._eventName, this.eventCallback), this._eventName = e ? "mousemove" : "pointerdown", this._engine.map.addEventListener(this._eventName, this.eventCallback));
  }
  get template() {
    return this._template;
  }
  set template(e) {
    this._template = e, this.updateInfoText();
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    this._separator = e, this.updateInfoText();
  }
  get prefix() {
    return this._prefix;
  }
  set prefix(e) {
    this._prefix = e, this.updateInfoText();
  }
  onDispose() {
    this._engine.map.removeEventListener(this._eventName, this.eventCallback), this._engine.rendering.removePrepareRenderListener(this._viewChangedCallback);
  }
}
function Yc(s, t) {
  if (!t)
    return Math.round(s);
  const e = 10 * t;
  return Math.round(s * e) / e;
}
class jV extends qs {
  afterInit() {
    if (this._options && this._options.draws) {
      const t = this._options.draws, e = t && t.length > 0 ? t.length : 0, i = document.getElementById(`${Vt}-drawer-content`);
      if (this._drawerCheckboxs = [], e > 0) {
        const n = this.addChangeListener.bind(this);
        for (let o = 0; o < e; o++) {
          const r = t[o], a = document.createElement("div");
          Re(a, "drawer-item");
          const g = document.createElement("input");
          Re(g, "drawer-item-check"), n(g, (l) => {
            l.stopPropagation();
            const h = l.target.checked;
            r.onChange && r.onChange(h, r.data, this._engine);
          }), g.setAttribute("type", "checkbox"), r.defaultChecked && (g.setAttribute("checked", r.defaultChecked), r.onChange && r.onChange(!0, r.data, this._engine)), this._drawerCheckboxs.push(g);
          const c = document.createElement("span");
          Re(c, "drawer-item-name"), c.innerText = r.name, c.onclick = () => {
            g.click();
          }, a.appendChild(g), a.appendChild(c), i.appendChild(a);
        }
      }
    }
  }
  createDom() {
    this._element = document.createElement("div"), Re(this._element, "drawer");
    const t = this._drawerBtn = document.createElement("div");
    Re(t, "drawer-btn");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    e.setAttribute("class", "drawer-icon"), e.setAttribute("viewBox", "0 0 1024 1024"), e.setAttribute("version", "1.1");
    const i = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i.setAttribute("d", "M512 821.504l-416-208-96 48 512 256 512-256-96-48-416 208z m0-181.173333l-416-208-96 48 512 256 512-256-96-48-416 208zM1024 298.666667L512 42.666667 0 298.666667l512 256 512-256zM512 138.058667L833.184 298.666667 512 459.274667 190.816 298.666667 512 138.058667z"), e.appendChild(i), t.addEventListener(ye.DOWN, this.openDrawer.bind(this)), t.appendChild(e);
    const n = this._drawerList = document.createElement("div");
    Re(n, "drawer-list"), n.setAttribute("id", `${Vt}-drawer-list`), n.style.display = "none";
    const o = document.createElement("div");
    Re(o, "drawer-content"), o.setAttribute("id", `${Vt}-drawer-content`);
    const r = document.createElement("div");
    return Re(r, "drawer-arrow"), n.appendChild(o), n.appendChild(r), this._element.appendChild(t), this._element.appendChild(n), this._element;
  }
  addChangeListener(t, e) {
    this._eventMap || (this._eventMap = /* @__PURE__ */ new WeakMap()), t.addEventListener("change", e), this._eventMap.set(t, e);
  }
  removeChangeListener(t) {
    const e = this._eventMap.get(t);
    t.removeEventListener("change", e), this._eventMap.delete(t);
  }
  openDrawer() {
    const t = this._drawerList;
    t.style.display = t.style.display === "none" ? "block" : "none";
  }
  onDispose() {
    this._drawerBtn.removeEventListener(ye.DOWN, this.openDrawer.bind(this));
    for (let t = 0; t < this._drawerCheckboxs.length; t++)
      this.removeChangeListener(this._drawerCheckboxs[t]);
  }
}
class JV extends qs {
  createDom() {
    this.handleUpBtnClick = this.handleUpBtnClick.bind(this), this.handleDownBtnClick = this.handleDownBtnClick.bind(this), this.handleLeftBtnClick = this.handleLeftBtnClick.bind(this), this.handleRightBtnClick = this.handleRightBtnClick.bind(this), this.handleCenterBtnClick = this.handleCenterBtnClick.bind(this), this._element = document.createElement("div"), Re(this._element, "compass"), this._element.setAttribute("style", `background-image: url(${pt("assets/images/mapCompass.png")});`), this._up = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._up.setAttribute("class", "compass-up"), this._up.setAttribute("viewBox", "0 0 1024 1024"), this._up.setAttribute("version", "1.1");
    const t = document.createElementNS("http://www.w3.org/2000/svg", "path");
    t.setAttribute("d", "M910.222222 796.444444c-17.066667 0-34.133333-5.688889-45.511111-17.066666L551.822222 409.6c-11.377778-5.688889-17.066667-11.377778-34.133333-11.377778-5.688889 0-22.755556 5.688889-28.444445 11.377778l-329.955555 364.088889c-22.755556 22.755556-56.888889 22.755556-79.644445 5.688889-22.755556-22.755556-22.755556-56.888889-5.688888-79.644445l329.955555-364.088889c28.444444-34.133333 73.955556-51.2 119.466667-51.2s85.333333 22.755556 119.466666 56.888889l312.888889 364.088889c22.755556 22.755556 17.066667 56.888889-5.688889 79.644445-11.377778 5.688889-28.444444 11.377778-39.822222 11.377777z"), this._up.addEventListener(ye.DOWN, this.handleUpBtnClick), this._up.appendChild(t), this._down = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._down.setAttribute("class", "compass-down"), this._down.setAttribute("viewBox", "0 0 1024 1024"), this._down.setAttribute("version", "1.1");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return e.setAttribute("d", "M517.688889 796.444444c-45.511111 0-85.333333-17.066667-119.466667-51.2L73.955556 381.155556c-22.755556-22.755556-17.066667-56.888889 5.688888-79.644445 22.755556-22.755556 56.888889-17.066667 79.644445 5.688889l329.955555 364.088889c5.688889 5.688889 17.066667 11.377778 28.444445 11.377778s22.755556-5.688889 34.133333-17.066667l312.888889-364.088889c22.755556-22.755556 56.888889-28.444444 79.644445-5.688889 22.755556 22.755556 28.444444 56.888889 5.688888 79.644445L637.155556 739.555556c-28.444444 39.822222-68.266667 56.888889-119.466667 56.888888 5.688889 0 0 0 0 0z"), this._down.addEventListener(ye.DOWN, this.handleDownBtnClick), this._down.appendChild(e), this._left = document.createElement("div"), Re(this._left, "compass-left"), this._left.setAttribute("style", `background-image: url(${pt("assets/images/mapCompass.png")});`), this._left.addEventListener(ye.DOWN, this.handleLeftBtnClick), this._right = document.createElement("div"), Re(this._right, "compass-right"), this._right.setAttribute("style", `background-image: url(${pt("assets/images/mapCompass.png")});`), this._right.addEventListener(ye.DOWN, this.handleRightBtnClick), this._compass = document.createElement("div"), Re(this._compass, "compass-center"), this._compass.setAttribute("style", `background-image: url(${pt("assets/images/mapCompass.png")});`), this._compass.addEventListener(ye.DOWN, this.handleCenterBtnClick), this._element.appendChild(this._up), this._element.appendChild(this._down), this._element.appendChild(this._left), this._element.appendChild(this._right), this._element.appendChild(this._compass), this._engine.rendering.addPrepareRenderListener(() => {
      this._compass.style.transform = `rotate(-${this._engine.map.getHeading()}deg)`;
    }), this._element;
  }
  handleUpBtnClick() {
    const t = this._engine.map.getPitch();
    let e = t + 2;
    e = e > 89 ? 89 : e < 0 ? 0 : e, t !== e && this._engine.map.setPitch(e);
  }
  handleDownBtnClick() {
    const t = this._engine.map.getPitch();
    let e = t - 2;
    e = e > 89 ? 89 : e < 0 ? 0 : e, t !== e && this._engine.map.setPitch(e);
  }
  handleLeftBtnClick() {
    let e = this._engine.map.getHeading() - 2;
    this._engine.map.setHeading((e + 360) % 360);
  }
  handleRightBtnClick() {
    let e = this._engine.map.getHeading() + 2;
    this._engine.map.setHeading(e % 360);
  }
  handleCenterBtnClick() {
    this._engine.map.setHeading(0);
  }
  onDispose() {
    this._up.removeEventListener(ye.DOWN, this.handleUpBtnClick), this._down.removeEventListener(ye.DOWN, this.handleDownBtnClick), this._left.removeEventListener(ye.DOWN, this.handleLeftBtnClick), this._right.removeEventListener(ye.DOWN, this.handleRightBtnClick), this._compass.removeEventListener(ye.DOWN, this.handleCenterBtnClick);
  }
}
class qV {
  constructor(t, e = {}) {
    f(this, "_container");
    f(this, "_engine");
    f(this, "_logo");
    f(this, "_zoom");
    f(this, "_scale");
    f(this, "_fullscreen");
    f(this, "_geoLocate");
    f(this, "_exportImage");
    f(this, "_mapInfo");
    f(this, "_compass");
    f(this, "_drawer");
    const i = t.container, n = i instanceof HTMLElement || i && typeof i == "object" && i.nodeType === 1 && typeof i.nodeName == "string";
    this._container = n ? i : i.container || i._container;
    const o = this._control = document.createElement("div");
    o.id = `${Vt}-widgets`, Re(o, `${Vt}-widgets-pane`), this._container.appendChild(o);
    const r = document.createElement("div");
    Re(r, "bottom-right-anchor"), this._zoom = new XV(r, e.zoom, t), this._compass = new JV(r, e.compass, t), o.appendChild(r);
    const a = document.createElement("div");
    Re(a, "bottom-left-anchor"), o.appendChild(a), this._fullscreen = new UV(a, e.fullscreen, t), this._exportImage = new QV(a, e.exportImage, t), this._geoLocate = new OV(a, e.geoLocate, t), this._logo = new zV(o, e.logo, t), this._scale = new WV(o, e.scale, t), this._mapInfo = new YV(o, e.mapInfo, t), this._drawer = new jV(o, e.drawer, t);
  }
  dispose() {
    this._logo.dispose(), this._zoom.dispose(), this._scale.dispose(), this._fullscreen.dispose(), this._geoLocate.dispose(), this._exportImage.dispose(), this._mapInfo.dispose(), this._compass.dispose(), this._drawer.dispose(), this._control.remove();
  }
  get container() {
    return this._container;
  }
  get engine() {
    return this._engine;
  }
  get compass() {
    return this._compass;
  }
  get logo() {
    return this._logo;
  }
  get zoom() {
    return this._zoom;
  }
  get scale() {
    return this._scale;
  }
  get fullscreen() {
    return this._fullscreen;
  }
  get geoLocate() {
    return this._geoLocate;
  }
  get exportImage() {
    return this._exportImage;
  }
  get mapInfo() {
    return this._mapInfo;
  }
  get drawer() {
    return this._drawer;
  }
}
mE();
class vY {
  constructor(t, e = {}) {
    f(this, "_container");
    f(this, "_event");
    f(this, "_map");
    f(this, "_rendering");
    f(this, "_selection");
    f(this, "_widgets");
    f(this, "isEngine", !0);
    this._container = t, this._event = new $t(this, e.event), this._map = new RV(this, e.map), this._map.init();
    const i = this.map.getResolution();
    this._rendering = new kP(this, {
      resolution: i,
      ...e.rendering
    }), this._rendering.init(), this._map.afterInit(), this._rendering.startRenderLoop(), this._selection = new VV(this, e.selection), this._widgets = new qV(this, e.widgets), this.trackingRequest();
  }
  add(t) {
    return this._rendering.add(t);
  }
  remove(t) {
    this._rendering.remove(t);
  }
  requestRender() {
    this._rendering.requestRender();
  }
  addPrepareRenderListener(t) {
    this._rendering.addPrepareRenderListener(t);
  }
  addBeforeRenderListener(t) {
    this._rendering.addBeforeRenderListener(t);
  }
  removeBeforeRenderListener(t) {
    this._rendering.removeBeforeRenderListener(t);
  }
  removePrepareRenderListener(t) {
    this._rendering.removePrepareRenderListener(t);
  }
  addBeforePrepareRenderObject(t) {
    this._rendering.addBeforePrepareRenderObject(t);
  }
  removeBeforePrepareRenderObject(t) {
    this._rendering.removeBeforePrepareRenderObject(t);
  }
  addBeforeRenderObject(t) {
    this._rendering.addBeforeRenderObject(t);
  }
  removeBeforeRenderObject(t) {
    this._rendering.removeBeforeRenderObject(t);
  }
  lockCamera() {
    this.camera._isLocked = !0;
  }
  unlockCamera() {
    this.camera._isLocked = !1;
  }
  get container() {
    return this._container;
  }
  get map() {
    return this._map;
  }
  get rendering() {
    return this._rendering;
  }
  get widgets() {
    return this._widgets;
  }
  get renderer() {
    return this._rendering.renderer;
  }
  get scene() {
    return this._rendering.scene;
  }
  get camera() {
    return this._rendering.camera;
  }
  get event() {
    return this._event;
  }
  get selection() {
    return this._selection;
  }
  dispose() {
    this._widgets.dispose(), this._event.dispose(), this._selection.dispose(), this._rendering.dispose(), this._map.dispose();
  }
  trackingRequest() {
    var t, e;
    (e = (t = this._map._map) == null ? void 0 : t.map) == null || e._printLog("mapvthree");
  }
}
class $V extends le {
  constructor() {
    super();
    f(this, "_fsQuad");
    f(this, "_hasPaintedScatterBuffer");
    f(this, "_scatteringMaterial");
    f(this, "_scatteringRenderTarget");
    f(this, "_transmittanceMaterial");
    f(this, "_transmittanceRenderTarget");
    f(this, "_viewMaterial");
    f(this, "_viewRenderTarget");
    this.geometry = new XA(1, 32, 32), this.frustumCulled = !1;
    const e = [256, 64], i = [32, 32], n = [400, 400], o = this._transmittanceRenderTarget = new It(e[0], e[1], {
      type: xi,
      depthBuffer: !1
    });
    o.texture.name = "SkyAtmosphere.transmittance", this._transmittanceMaterial = new ze({
      uniforms: we.clone(wd.uniforms),
      vertexShader: wd.vertexShader,
      fragmentShader: wd.fragmentShader
    });
    const r = this._scatteringRenderTarget = new It(i[0], i[1], {
      type: xi,
      depthBuffer: !1
    });
    r.texture.name = "SkyAtmosphere.scattering", this._scatteringMaterial = new ze({
      uniforms: we.clone(_d.uniforms),
      vertexShader: _d.vertexShader,
      fragmentShader: _d.fragmentShader
    }), this._scatteringMaterial.uniforms.transmittanceTexture.value = o.texture, this._scatteringMaterial.uniforms.transmittanceResolution.value = [e[0], e[1]], this._fsQuad = new Ut(null);
    const a = this._viewRenderTarget = new It(n[0], n[1], {
      type: xi,
      depthBuffer: !1
    });
    a.texture.name = "SkyAtmosphere.view";
    const g = this._viewMaterial = new ze({
      uniforms: we.clone(xd.uniforms),
      vertexShader: xd.vertexShader,
      fragmentShader: xd.fragmentShader
    });
    g.uniforms.transmittanceTexture.value = o.texture, g.uniforms.transmittanceResolution.value = [e[0], e[1]], g.uniforms.scatteringTexture.value = r.texture, g.uniforms.scatteringResolution.value = [i[0], i[1]];
    const c = this.material = new ze({
      uniforms: we.clone(Bd.uniforms),
      vertexShader: Bd.vertexShader,
      fragmentShader: Bd.fragmentShader,
      side: xr
    });
    c.uniforms.transmittanceTexture.value = o.texture, c.uniforms.transmittanceResolution.value = [e[0], e[1]], c.uniforms.scatteringTexture.value = r.texture, c.uniforms.scatteringResolution.value = [i[0], i[1]], c.uniforms.viewTexture.value = a.texture, c.uniforms.viewResolution.value = [n[0], n[1]], Object.defineProperties(this.material, {
      isEmissive: {
        get: function() {
          return this.uniforms.isEmissive.value;
        },
        set: function(l) {
          this.uniforms.isEmissive.value = l;
        }
      },
      uTime: {
        get: function() {
          return this.uniforms.uTime.value;
        },
        set: function(l) {
          this.uniforms.uTime.value = l;
        }
      },
      uStarVisible: {
        get: function() {
          return this.uniforms.uStarVisible.value;
        },
        set: function(l) {
          this.uniforms.uStarVisible.value = l;
        }
      },
      uMoonMap: {
        get: function() {
          return this.uniforms.uMoonMap.value;
        },
        set: function(l) {
          this.uniforms.uMoonMap.value = l;
        }
      }
    }), this._fsQuad = new Ut(null), this.scale.multiplyScalar(1e4), this.altitude = 0;
  }
  onBeforeRender(e, i, n) {
  }
  updateRenderTargets(e, i) {
    const n = this._fsQuad;
    this._hasPaintedScatterBuffer || (n.material = this._transmittanceMaterial, e.setRenderTarget(this._transmittanceRenderTarget), e.clear(), n.render(e), n.material = this._scatteringMaterial, e.setRenderTarget(this._scatteringRenderTarget), e.clear(), n.render(e), this._hasPaintedScatterBuffer = !0), n.material = this._viewMaterial, e.setRenderTarget(this._viewRenderTarget), e.clear(), n.render(e), e.setRenderTarget(null);
  }
  dispose() {
    this.geometry.dispose(), this._transmittanceRenderTarget.dispose(), this._scatteringRenderTarget.dispose(), this._viewRenderTarget.dispose(), this._transmittanceMaterial.dispose(), this._scatteringMaterial.dispose(), this._viewMaterial.dispose(), this.material.dispose(), this._fsQuad.dispose();
  }
  get altitude() {
    return this.material.uniforms.altitude.value;
  }
  set altitude(e) {
    this._transmittanceMaterial.uniforms.altitude.value = e, this._scatteringMaterial.uniforms.altitude.value = e, this._viewMaterial.uniforms.altitude.value = e, this.material.uniforms.altitude.value = e;
  }
  get viewHeight() {
    return this.material.uniforms.viewHeight.value;
  }
  set viewHeight(e) {
    this._transmittanceMaterial.uniforms.viewHeight.value = e, this._scatteringMaterial.uniforms.viewHeight.value = e, this._viewMaterial.uniforms.viewHeight.value = e, this.material.uniforms.viewHeight.value = e;
  }
  get mixGrayFactor() {
    return this._viewMaterial.uniforms.mixGrayFactor.value;
  }
  set mixGrayFactor(e) {
    this._viewMaterial.uniforms.mixGrayFactor.value = e;
  }
}
const E0 = new B(), ez = new B(0, 0, 1);
class tz extends Xi {
  constructor() {
    super(), this.uniforms = we.clone(Wf.uniforms), this.material = new ze({
      defines: {
        MVT_USE_NORMAL_TEXTURE: !1
      },
      uniforms: this.uniforms,
      vertexShader: Ht.vertexShader,
      fragmentShader: Wf.fragmentShader,
      depthTest: !1,
      depthWrite: !1,
      name: "SkyAtmospherePass"
    }), this.needsSwap = !0, this.fsQuad = new Ut(null), this.needsDepthTexture = !0, this.needsNormalTextureWhenMRT = !0;
  }
  _consoleIfBigDiff(t, e, i) {
    const n = t.pitch, o = t.roll, r = t.heading;
    this[e] && (Math.abs(n - this[e].pitch), Math.abs(o - this[e].roll), Math.abs(r - this[e].heading)), this[e] = {
      pitch: n,
      roll: o,
      heading: r
    };
  }
  render(t, e, i) {
    const n = this.sky;
    if (!n)
      return;
    const o = this.rendering, r = o.camera, a = n.skyAtmosphere, g = this.uniforms;
    g.altitude.value = a.altitude, g.tDiffuse.value = i.texture, g.tDepth.value = o.main.sceneRendering.depthTexture, g.tAtmosphere.value = a.material.uniforms.viewTexture.value, g.isGlobe.value = a.material.uniforms.isGlobe.value, g.projectionInverseMatrix.value.copy(r.projectionMatrixInverse), g.viewInverseMatrix.value.copy(r.matrixWorld), g.cameraNear.value = r.near, g.cameraFar.value = r.far, g.cameraPosition.value.copy(r.position), g.viewHeight.value = a.material.uniforms.viewHeight.value, g.transmittanceTexture.value = a.material.uniforms.transmittanceTexture.value, g.transmittanceResolution.value = a.material.uniforms.transmittanceResolution.value, g.scatteringTexture.value = a.material.uniforms.scatteringTexture.value, g.scatteringResolution.value = a.material.uniforms.scatteringResolution.value, g.viewTexture.value = a.material.uniforms.viewTexture.value, g.viewResolution.value = a.material.uniforms.viewResolution.value, g.mvt_viewMatrix.value.copy(r.matrixWorldInverse), g.resolution = o.uniforms.resolution, g.sunDirection.value.copy(n.localSunDirection);
    const c = o.main.sceneRendering.normalTexture;
    g.tNormal.value = c;
    const l = !!c;
    l !== this.material.defines.MVT_USE_NORMAL_TEXTURE && (this.material.defines.MVT_USE_NORMAL_TEXTURE = l, this.material.needsUpdate = !0);
    let h = 0, d = 1;
    if (o._engine.map.mapType === "earth") {
      let b = o._engine.map._map._ellipsoidCamera;
      if (b.positionCartographic.z, !this._sphereCamera) {
        const G = new De(6371e3, 6371e3, 6371e3);
        this._sphereCamera = new _o({
          _ellipsoid: G,
          mapProjection: new Da(G),
          camera: r
        });
      }
      const S = this._sphereCamera;
      S.position.copy(b.position), S.direction.copy(b.direction), S.up.copy(b.up), S.right.copy(b.right), a._transformChanged = !0, b = S, g.viewInverseMatrix.value.copy(b.getLocalTransform());
      const A = g.viewInverseMatrix.value.elements;
      E0.set(A[8], A[9], A[10]);
      const u = ce.clamp(E0.dot(ez), 0.1, 1), y = g.viewHeight.value * 1e6 / u, I = ce.mapLinear(Math.sqrt(g.viewHeight.value * 10), 0, 1, 20, 2), M = Math.max(y + 100, y * I);
      h = o.renderState.getDepthByDistance(y), d = o.renderState.getDepthByDistance(M);
    }
    g.fogDepthRange.value.set(h, d);
    const C = t.autoClear, p = t.getRenderTarget();
    t.autoClear = !1, this.fsQuad.material = this.material, t.setRenderTarget(this.renderToScreen ? null : e), t.clear(!0, !1, !1), this.fsQuad.render(t), t.autoClear = C, t.setRenderTarget(p);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const JC = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// 1 unit correspondents to SCENE_SCALE meter.

#define SCENE_SCALE (1.)
#define INV_SCENE_SCALE (1.)

// #define MOUNTAIN_HEIGHT (5000.)
// #define MOUNTAIN_HW_RATIO (0.00016)

// #define SUN_DIR normalize(vec3(-.1,.4,.15))
// #define SUN_COLOR (vec3(1.,.9,.85)*1.4)

#define FLAG_POSITION (vec3(3900.5,720.,-2516.)*INV_SCENE_SCALE)
#define HUMANOID_SCALE (2.)

// #define CAMERA_RO (vec3(3980.,730.,-2650.)*INV_SCENE_SCALE)
// #define CAMERA_FL 2.

#define HEIGHT_BASED_FOG_B 0.02
#define HEIGHT_BASED_FOG_C 0.05

// mat3 getCamera( in float time, in vec4 mouse, inout vec3 ro, inout vec3 ta ) {
//     ro = CAMERA_RO;
//     vec3 cw;
//     if (mouse.z > 0.) {
//         vec2 m = (mouse.xy - .5) * 2.3;
//         float my = -sin(m.y);
//         cw = normalize(vec3(-sin(-m.x), my+.15, cos(-m.x)));
//     } else {
//     	ro.x += -cos(time*.13)*5.*INV_SCENE_SCALE;
//     	ro.z += (-cos(time*.1)*100.+20.)*INV_SCENE_SCALE;
//     	cw = normalize(vec3(-.1,.18,1.));
//     }   
//     ta = ro + cw*(200.*INV_SCENE_SCALE);
// 	vec3 cp = vec3(0.0,1.0, 0.0);
// 	vec3 cu = normalize( cross(cw,cp) );
// 	vec3 cv = normalize( cross(cu,cw) );
//     return mat3( cu, cv, cw );
// }

// void getRay( in float time, in vec2 fragCoord, in vec2 resolution, in vec4 mouse, inout vec3 ro, inout vec3 rd) {
// 	vec3 ta;
// 	mat3 cam = getCamera( time, mouse, ro, ta );
//     vec2 p = (-resolution.xy + 2.0*(fragCoord))/resolution.y;
//     rd = cam * normalize(vec3(p,CAMERA_FL));     
// }

//
// To reduce noise I use temporal reprojection (both for clouds (Buffer D) and the terrain 
// (Buffer C) seperatly. The temporal repojection code is based on code from the shader
// "Rain Forest" (again by \xCD\xF1igo Qu\xEDlez):
//
// https://www.shadertoy.com/view/4ttSWf
// 
// vec4 saveCamera( in float time, in vec2 fragCoord, in vec4 mouse ) {   
//     vec3 ro, ta;
//     mat3 cam = getCamera( time, mouse, ro, ta );
//     vec4 fragColor;
    
//     if( abs(fragCoord.x-4.5)<0.5 ) fragColor = vec4( cam[2], -dot(cam[2],ro) );
//     if( abs(fragCoord.x-3.5)<0.5 ) fragColor = vec4( cam[1], -dot(cam[1],ro) );
//     if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( cam[0], -dot(cam[0],ro) );
    
//     return fragColor;
// }

// vec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {
//     mat4 oldCam = mat4( texelFetch(storage,ivec2(2,0),0),
//                         texelFetch(storage,ivec2(3,0),0),
//                         texelFetch(storage,ivec2(4,0),0),
//                         0.0, 0.0, 0.0, 1.0 );

//     vec4 wpos = vec4(pos,1.0);
//     vec3 cpos = (wpos*oldCam).xyz; 
//     vec2 npos = CAMERA_FL * cpos.xy / cpos.z;
//     return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);
// }

//
// Fast skycolor function by \xCD\xF1igo Qu\xEDlez
// https://www.shadertoy.com/view/MdX3Rr
//
// vec3 getSkyColor(vec3 rd) {
//     float sundot = clamp(dot(rd,SUN_DIR),0.0,1.0);
// 	vec3 col = vec3(0.2,0.5,0.85)*1.1 - max(rd.y,0.01)*max(rd.y,0.01)*0.5;
//     col = mix( col, 0.85*vec3(0.7,0.75,0.85), pow(1.0-max(rd.y,0.0), 6.0) );

//     col += 0.25*vec3(1.0,0.7,0.4)*pow( sundot,5.0 );
//     col += 0.25*vec3(1.0,0.8,0.6)*pow( sundot,64.0 );
//     col += 0.20*vec3(1.0,0.8,0.6)*pow( sundot,512.0 );
    
//     col += clamp((0.1-rd.y)*10., 0., 1.) * vec3(.0,.1,.2);
//     col += 0.2*vec3(1.0,0.8,0.6)*pow( sundot, 8.0 );
//     return col;
// }

// bool letterBox(vec2 fragCoord, const vec2 resolution, const float aspect) { 
//     if( fragCoord.x < 0. || fragCoord.x > resolution.x ||
//         abs(2.*fragCoord.y-resolution.y) > resolution.x * (1./aspect) ) {
//         return true;
//     } else {
//         return false;
//     }
// }

//
// Noise functions
//
// Hash without Sine by DaveHoskins 
//
// https://www.shadertoy.com/view/4djSRW
//
float hash12( vec2 p ) {
    p  = 50.0*fract( p*0.3183099 );
    return fract( p.x*p.y*(p.x+p.y) );
}

float hash13(vec3 p3) {
    p3  = fract(p3 * 1031.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

vec3 hash33(vec3 p3) {
	p3 = fract(p3 * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+19.19);
    return fract((p3.xxy + p3.yxx)*p3.zyx);
}

float valueHash(vec3 p3) {
    p3  = fract(p3 * 0.1031);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}

//
// Noise functions used for cloud shapes
//
float valueNoise( in vec3 x, float tile ) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f*f*(3.0-2.0*f);
	
    return mix(mix(mix( valueHash(mod(p+vec3(0,0,0),tile)), 
                        valueHash(mod(p+vec3(1,0,0),tile)),f.x),
                   mix( valueHash(mod(p+vec3(0,1,0),tile)), 
                        valueHash(mod(p+vec3(1,1,0),tile)),f.x),f.y),
               mix(mix( valueHash(mod(p+vec3(0,0,1),tile)), 
                        valueHash(mod(p+vec3(1,0,1),tile)),f.x),
                   mix( valueHash(mod(p+vec3(0,1,1),tile)), 
                        valueHash(mod(p+vec3(1,1,1),tile)),f.x),f.y),f.z);
}

float voronoi( vec3 x, float tile ) {
    vec3 p = floor(x);
    vec3 f = fract(x);

    float res = 100.;
    for(int k=-1; k<=1; k++){
        for(int j=-1; j<=1; j++) {
            for(int i=-1; i<=1; i++) {
                vec3 b = vec3(i, j, k);
                vec3 c = p + b;

                if( tile > 0. ) {
                    c = mod( c, vec3(tile) );
                }

                vec3 r = vec3(b) - f + hash13( c );
                float d = dot(r, r);

                if(d < res) {
                    res = d;
                }
            }
        }
    }

    return 1.-res;
}

float tilableVoronoi( vec3 p, const int octaves, float tile ) {
    float f = 1.;
    float a = 1.;
    float c = 0.;
    float w = 0.;

    if( tile > 0. ) f = tile;

    for (int i = 0; i < 100; i++) {
        if (i >= octaves) break;
        c += a*voronoi( p * f, f );
        f *= 2.0;
        w += a;
        a *= 0.5;
    }

    return c / w;
}

float tilableFbm( vec3 p, const int octaves, float tile ) {
    float f = 1.;
    float a = 1.;
    float c = 0.;
    float w = 0.;

    if( tile > 0. ) f = tile;

    for (int i = 0; i < 100; i++) {
        if (i >= octaves) break;
        c += a*valueNoise( p * f, f );
        f *= 2.0;
        w += a;
        a *= 0.5;
    }

    return c / w;
}

`, qC = `#define GLSLIFY 1
varying vec3 vWorldPosition;
varying vec2 vUv;
void main() {
    vUv = uv;
    vWorldPosition = normalize(vec3(position.x, position.y, position.z));
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    // gl_Position.z = gl_Position.w;
}
`, iz = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// I started this shader by trying to implement the clouds of Horizon Zero Dawn, as
// described in "The real-time volumetric cloudscapes of Horizon Zero Dawn" by 
// Andrew Schneider and Nathan Vos.[1] To model the shape of the clouds, two look-up
// textures are created with different frequencies of (Perlin -) Worley noise:
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
//           
// Because it is not possible (yet) to create buffers with fixed size, or 3D buffers, the
// look-up texture in Buffer A is 2D, and a slice of the volume that is described in the 
// article. Therefore, and because I didn't have any slots left (in Buffer C) to use a 
// cloud type/cloud coverage texture, the modelling of the cloud shapes in this shader is 
// in the end mostly based on trial and error, and is probably far from the code used in 
// Horizon Zero Dawn.
//
// Buffer D: Rendering of the clouds.
//
// I render the clouds using the improved integration method of volumetric media, as described 
// in "Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite" by 
// S\xE9bastien Hillaire.[2]
//
// You can find the (excellent) example shaders of S\xE9bastien Hillaire (SebH) here:
//
// https://www.shadertoy.com/view/XlBSRz
// https://www.shadertoy.com/view/MdlyDs
//
// #define MVT_CLOUD_MARCH_STEPS 8
// #define MVT_CLOUD_SELF_SHADOW_STEPS 3

#define EARTH_RADIUS    (637100.) // (6371000.)
#define CLOUDS_BOTTOM   (1350.)
#define CLOUDS_TOP      (2350.)

#define CLOUDS_LAYER_BOTTOM   (-150.)
#define CLOUDS_LAYER_TOP      (-70.)

#define CLOUDS_LAYER_COVERAGE (.41)

#define CLOUDS_DETAIL_STRENGTH (.225)
#define CLOUDS_BASE_EDGE_SOFTNESS (.1)
#define CLOUDS_BOTTOM_SOFTNESS (.25)
#define CLOUDS_SHADOW_MARGE_STEP_SIZE (10.)
#define CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE (4.)
#define CLOUDS_SHADOW_MARGE_STEP_MULTIPLY (1.3)
#define CLOUDS_FORWARD_SCATTERING_G (.8)
#define CLOUDS_BACKWARD_SCATTERING_G (-.2)
#define CLOUDS_SCATTERING_LERP (.5)

#define CLOUDS_AMBIENT_COLOR_TOP (vec3(149., 167., 200.)*(1.5/255.))
// #define ambientColorBottom (vec3(39., 67., 87.)*(1.5/255.))
// #define ambientColorBottom (vec3(20., 20., 20.)*(1.5/255.))
#define CLOUDS_MIN_TRANSMITTANCE .1

// #define shapeScale 5.51
#define CLOUDS_DETAIL_SCALE 50.

#ifdef MVT_USE_VOULEMTRIC
uniform sampler2D tShape; // cloud shape
uniform sampler2D tPrevious; // previous frame
uniform sampler2D tDetail; // cloud detail
#else
uniform sampler2D tWeather; // cloud shape
uniform sampler2D tNoise; // cloud detail
#endif
uniform sampler2D tDepth; // depth buffer
uniform sampler2D tDiffuse;
uniform sampler2D tBlueNoise;
uniform vec2 resolution;
uniform float iTime;
uniform vec3 cameraDirection;
uniform mat4 mvt_viewMatrixInverse;
uniform mat4 mvt_projectionMatrixInverse;
uniform vec3 mvt_cameraPosition;
uniform mat4 uCameraMatrix;
uniform mat4 uLastCameraMatrix;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform float coverage;
uniform float density;
uniform float speed;
uniform bool cameraChanged;
uniform vec3 ambientColorBottom;
uniform float previousRatio;
// .x baseScale .y detailScale
uniform vec4 shapeScale;
//
// Cloud shape modelling and rendering 
//

float HenyeyGreenstein( float sundotrd, float g) {
	float gg = g * g;
	return (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);
}

// float interectCloudSphere( vec3 rd, float r ) {
//     float b = EARTH_RADIUS * rd.y;
//     float d = b * b + r * r + 2. * EARTH_RADIUS * r;
//     return -b + sqrt( d );
// }

float interectCloudSphere(vec3 ro, vec3 rd, float rad) {
    rad += EARTH_RADIUS;
    float b = dot(ro, rd);
    float c = dot(ro, ro) - rad*rad;
    if (c > 0.0 && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    // Special case: inside sphere, use far discriminant
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}

float linearstep( const float s, const float e, float v ) {
    return clamp( (v-s)*(1./(e-s)), 0., 1. );
}

float linearstep0( const float e, float v ) {
    return min( v*(1./e), 1. );
}

float remap(float v, float s, float e) {
	return (v - s) / (e - s);
}

float remap2(float v, float l0, float h0, float ln, float hn) {
    return ln + (v - l0) * (hn - ln) / (h0 - l0);
}
#ifdef MVT_USE_VOULEMTRIC
float cloudMapBase(vec3 p, float norY) {
	vec3 uv = p * (0.00005 * shapeScale.x);
    vec3 cloud = texture2D(tShape, uv.xz * 2.5 + iTime * 0.002 * speed).rgb;
   
    float n = norY*norY;
    n *= cloud.b ;
        n+= pow(1.-norY, 16.); 
	return remap( cloud.r - n, cloud.g, 1.);
}

float cloudMapDetail(vec3 p) { 
    // 3d lookup in 2d texture :(
    p = abs(p) * (0.0016 * shapeScale.x * shapeScale.y);
    p += iTime * 0.02 * speed;
    float yi = mod(p.y,32.);
    ivec2 offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;
    float a = texture2D(tDetail, (mod(p.xz,32.)+vec2(offset.xy)+1.)/resolution.xy).r;
    
    yi = mod(p.y+1.,32.);
    offset = ivec2(mod(yi,8.), mod(floor(yi/8.),4.))*34 + 1;
    float b = texture2D(tDetail, (mod(p.xz,32.)+vec2(offset.xy)+1.)/resolution.xy).r;
    
    return mix(a,b,fract(p.y));
}

float cloudGradient( float norY ) {
    return linearstep( 0., .05, norY ) - linearstep( .8, 1.2, norY);
}

float cloudMap(vec3 pos, vec3 rd, float norY) {
    vec3 ps = pos;
    
    float m = cloudMapBase(ps, norY);
	m *= cloudGradient( norY );

	float dstrength = smoothstep(1., 0.5, m);
    
    // erode with detail
    if(dstrength > 0.) {
		m -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;
    }

	m = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(coverage-1.) );
    m *= linearstep0(CLOUDS_BOTTOM_SOFTNESS, norY);

    return clamp(m * density * (1.+max((ps.x-100000.)*0.005,0.)), 0., 1.);
}

float volumetricShadow(in vec3 from, in float sundotrd ) {
    float dd = CLOUDS_SHADOW_MARGE_STEP_SIZE;
    vec3 rd = sunDirection;
    float d = dd * .5;
    float shadow = 1.0;

    for(int s=0; s<MVT_CLOUD_SELF_SHADOW_STEPS; s++) {
        vec3 pos = from + rd * d;
        float norY = (length(pos) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM));

        if(norY > 1.) return shadow;

        float muE = cloudMap( pos, rd, norY );
        shadow *= exp(-muE * dd);

        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;
        d += dd;
    }
    return shadow;
}

vec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {
    if( rd.y < 0. ) {
        return vec4(0,0,0,1);
    }

    // ro.x += -cos(iTime * 0.13) * 0.5;
    // ro.z += (-cos(iTime * 0.1) * 100. + 20.) * 0.1;
    // ro += rand();
    // ro.xz *= SCENE_SCALE;
    // \u4F4D\u7F6E
    // ro.x += iTime * 0.;
    ro.y += EARTH_RADIUS;
    // ro.y = sqrt(EARTH_RADIUS*EARTH_RADIUS-dot(ro.xz,ro.xz));

    float start = interectCloudSphere(ro, rd, CLOUDS_BOTTOM );
    float end  = interectCloudSphere(ro,  rd, CLOUDS_TOP );
    
    if (start > dist) {
        return vec4(0,0,0,1);
    }
    
    end = min(end, dist);
    
    float sundotrd = dot( rd, -sunDirection);

    // raymarch
    float d = start;
    float dD = (end-start) / float(MVT_CLOUD_MARCH_STEPS);

    float h = hash13(rd + fract(iTime) );
    d -= dD * h;

    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),
        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );

    float transmittance = 1.0;
    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);

    dist = EARTH_RADIUS;

    for(int s=0; s<MVT_CLOUD_MARCH_STEPS; s++) {
        vec3 p = ro + d * rd;

        float norY = clamp( (length(p) - (EARTH_RADIUS + CLOUDS_BOTTOM)) * (1./(CLOUDS_TOP - CLOUDS_BOTTOM)), 0., 1.);

        float alpha = cloudMap( p, rd, norY );

        if( alpha > 0. ) {
            dist = min( dist, d);
            vec3 ambientLight = mix( ambientColorBottom, CLOUDS_AMBIENT_COLOR_TOP, norY );

            vec3 S = (ambientLight + sunColor * (scattering * volumetricShadow(p, sundotrd))) * alpha;
            float dTrans = exp(-alpha * dD);
            vec3 Sint = (S - S * dTrans) * (1. / alpha);
            scatteredLight += transmittance * Sint; 
            transmittance *= dTrans;
        }

        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;

        d += dD;
    }

    return vec4(scatteredLight, transmittance);
}
//
//
// !Because I wanted a second cloud layer (below the horizon), I copy-pasted 
// almost all of the code above:
//

float cloudMapLayer(vec3 pos, vec3 rd, float norY) {
    vec3 ps = pos;

    float m = cloudMapBase(ps, norY);
	// m *= cloudGradient( norY );
	float dstrength = smoothstep(1., 0.5, m);
    
    // erode with detail
    if (dstrength > 0.) {
		m -= cloudMapDetail( ps ) * dstrength * CLOUDS_DETAIL_STRENGTH;
    }

	m = smoothstep( 0., CLOUDS_BASE_EDGE_SOFTNESS, m+(CLOUDS_LAYER_COVERAGE-1.) );

    return clamp(m * density, 0., 1.);
}

float volumetricShadowLayer(in vec3 from, in float sundotrd ) {
    float dd = CLOUDS_LAYER_SHADOW_MARGE_STEP_SIZE;
    vec3 rd = sunDirection;
    float d = dd * .5;
    float shadow = 1.0;

    for(int s=0; s<MVT_CLOUD_SELF_SHADOW_STEPS; s++) {
        vec3 pos = from + rd * d;
        float norY = clamp( (pos.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);

        if(norY > 1.) return shadow;

        float muE = cloudMapLayer( pos, rd, norY );
        shadow *= exp(-muE * dd);

        dd *= CLOUDS_SHADOW_MARGE_STEP_MULTIPLY;
        d += dd;
    }
    return shadow;
}

vec4 renderCloudLayer( vec3 ro, vec3 rd, inout float dist ) {
    if( rd.y > 0. ) {
        return vec4(0,0,0,10);
    }

    ro.xz *= SCENE_SCALE;
    ro.y += EARTH_RADIUS;
    // ro.y = 0.;

    float start = CLOUDS_LAYER_TOP/rd.y;
    float end  = CLOUDS_LAYER_BOTTOM/rd.y;
    
    if (start > dist) {
        return vec4(0,0,0,10);
    }
    
    end = min(end, dist);
    
    float sundotrd = dot( rd, -sunDirection);

    // raymarch
    float d = start;
    float dD = (end-start) / float(MVT_CLOUD_MARCH_STEPS);

    float h = hash13(rd + fract(iTime) );
    d -= dD * h;

    float scattering =  mix( HenyeyGreenstein(sundotrd, CLOUDS_FORWARD_SCATTERING_G),
        HenyeyGreenstein(sundotrd, CLOUDS_BACKWARD_SCATTERING_G), CLOUDS_SCATTERING_LERP );

    float transmittance = 1.0;
    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);

    dist = EARTH_RADIUS;

    for(int s=0; s<MVT_CLOUD_MARCH_STEPS; s++) {
        vec3 p = ro + d * rd;

        float norY = clamp( (p.y - CLOUDS_LAYER_BOTTOM ) * (1./(CLOUDS_LAYER_TOP - CLOUDS_LAYER_BOTTOM)), 0., 1.);

        float alpha = cloudMapLayer( p, rd, norY );

        if( alpha > 0. ) {
            dist = min( dist, d);
            vec3 ambientLight = mix( ambientColorBottom, CLOUDS_AMBIENT_COLOR_TOP, norY );

            vec3 S = .7 * (ambientLight +  sunColor * (scattering * volumetricShadowLayer(p, sundotrd))) * alpha;
            float dTrans = exp(-alpha * dD);
            vec3 Sint = (S - S * dTrans) * (1. / alpha);
            scatteredLight += transmittance * Sint; 
            transmittance *= dTrans;
        }

        if( transmittance <= CLOUDS_MIN_TRANSMITTANCE ) break;

        d += dD;
    }

    return vec4(scatteredLight, transmittance);
}

vec2 reprojectPos( in vec3 pos, in vec2 resolution, in sampler2D storage ) {
    vec4 wpos = vec4(pos.xyz,1.0);
    vec3 cpos = (wpos*uLastCameraMatrix).xzy; 
    vec2 npos = 2. * cpos.xy / cpos.z;
    return 0.5 + 0.5*npos*vec2(resolution.y/resolution.x,1.0);
}
#else
/**
* simple cloud
*/
vec4 renderClouds( vec3 ro, vec3 rd, inout float dist ) {
    if( rd.y < 0. ) {
        return vec4(0,0,0,1);
    }
    ro.y += EARTH_RADIUS;

    vec3 p = ro + rd * 60000.;
    vec4 col = vec4(1.0);

    // vec2 cloudUV = p.xz * 0.1;
    float r = sqrt(2.0 * (1.0 - rd.y));
    float theta = atan(rd.x, rd.z);

    vec2 cloudUV = vec2(r * cos(theta) * 0.5 + 0.5, r * sin(theta) * 0.5 + 0.5) * 10000.0;
    float uvOffset = iTime / 1000.0 * speed;
    vec4 weatherColor = texture2D(tWeather, cloudUV * 0.00003 + uvOffset);
    float wmc = max(weatherColor.x, clamp(coverage * 1.0 - 0.5, 0.0, 1.0) * weatherColor.y * 2.0);
    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);
    // SNsample = R(snr, (sng \xD70.625+snb \xD70.25+sna \xD70.125)\u22121, 1, 0, 1)
    vec4 noiseColor = texture2D(tNoise, (cloudUV + uvOffset) * 1.0);
    float sn_sample = remap2(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);
    float sn = clamp(remap2(sn_sample, 1.0 - coverage * 1.0 * wmc, 1.0, 0.0, 1.0), 0.0, 1.0);
 
    float thickness = clamp(sn * 1.0 + 0.1, 0.0, 1.0);
    float cloudAlpha = clamp(thickness, 0.0, 1.0); // remap2(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);
    // vec3 cloudColor = vec3(remap2(clamp(cloudAlpha, 0.0, 1.0), 0.0, 1.0, 1.0, 0.6));
    vec3 cloudColor = vec3(cloudAlpha);
    // \u592A\u9633\u6563\u5C04\uFF0C\u6839\u636E\u539A\u5EA6\u53D1\u751F\u53D8\u5316
    // vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;
    // if (mixGrayFactor > 0.0) {
    //     vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);
    //     sunLightColor = mix(sunLightColor, gray, mixGrayFactor);
    // }
    // cloudColor = sunLightColor;
    // cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));
    
    // // \u5929\u7A7A\u5927\u6C14\u989C\u8272
    // vec3 sunDir = getSunDir();
    // vec3 rayDir = normalize(vWorldPosition.xzy);

    // cloudColor *= clamp(remap(dot(rayDir, sunDir), -1.0, 1.0, 0.75, 2.0), 0.75, 2.0);

    // vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);
    // atmosphereColor *= 100.0;
    // atmosphereColor = jodieReinhardTonemap(atmosphereColor);
    // atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));
    // atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;

    // float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);
    // atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);
    // cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);

    // // \u548C\u5929\u7A7A\u5927\u6C14\u6DF7\u5408
    // cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));

    // cloudColor = atmosphereColor; // lum;
    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;
    return vec4(cloudColor, 1.0 - cloudAlpha);
    // return vec4(cloudUV, 0.0, 1.0);
    // return col;
}
#endif
float getDepthValue(sampler2D depthTexture, vec2 uv) {
    return texture2D(depthTexture, uv).r;
}

vec3 ReinhardToneMapping( vec3 color ) {
	return clamp( color / ( vec3( 1.0 ) + color ), 0.0, 1.0 );

}

void main() {
    // if (gl_FragCoord.y < 1.5) {
    //     gl_FragColor = saveCamera(iTime, gl_FragCoord, iMouse/resolution.xyxy);
    //     if( abs(gl_FragCoord.x-1.5)<0.5 ) gl_FragColor = vec4(iMouse);
    //     if( abs(gl_FragCoord.x-0.5)<0.5 ) gl_FragColor = mouseChanged() ? vec4(0) : vec4(resolution.xy,0,0);
    // } else {
    //     if( letterBox(gl_FragCoord, resolution.xy, 2.25) ) {
    //     	gl_FragColor = vec4( 0., 0., 0., 1. );
    //    		return;
    //     } else {
    float depthValue = texelFetch(tDepth, ivec2(gl_FragCoord), 0).r;
    // vec2 depthValueUV = gl_FragCoord.xy / resolution;
    // float depthValue = getDepthValue(tDepth, depthValueUV);
    if (depthValue < 0.99) {
        gl_FragColor = vec4(0,0,0,1);
        return;
    }
    float dist = 60000.0; // texelFetch(tDepth, ivec2(gl_FragCoord),0).w * SCENE_SCALE;
    // dist = 30000.0 * SCENE_SCALE;
    vec4 col = vec4(0,0,0,1);
    vec3 camRight   = vec3( uCameraMatrix[0][0],  uCameraMatrix[0][1],  uCameraMatrix[0][2]);
    vec3 camUp      = vec3( uCameraMatrix[1][0],  uCameraMatrix[1][1],  uCameraMatrix[1][2]);
	vec3 camForward = vec3(-uCameraMatrix[2][0], -uCameraMatrix[2][1], -uCameraMatrix[2][2]);

	// calculate unique seed for rng() function
	// seed = uvec2(uFrameCounter, uFrameCounter + 1.0) * uvec2(gl_FragCoord);
	// initialize rand() variables
	// randNumber = 0.0; // the final randomly-generated number (range: 0.0 to 1.0)
	float blueNoise = texelFetch(tBlueNoise, ivec2(mod(floor(gl_FragCoord.xy), 128.0)), 0).r * 0.5;
    // vec2 blueNoiseUV = mod(gl_FragCoord.xy, vec2(128.0)) / 128.0;
    // float blueNoise = getDepthValue(tBlueNoise, blueNoiseUV) * 0.5;

	// vec2 pixelOffset = vec2( tentFilter(rand()), tentFilter(rand()) ) * 0.5;
	// // we must map pixelPos into the range -1.0 to +1.0

    float camFOVWidth = 35.0 / 180.0 * 3.1415926;
    float camHeightScale = tan(camFOVWidth / 2.0);
    float camWidthScale = camHeightScale * resolution.x / resolution.y;
    vec2 uv = (gl_FragCoord.xy + vec2(0.5) + blueNoise) / resolution;
	vec2 pixelPos = uv * 2.0 - 1.0;

	vec3 rayDir = normalize( pixelPos.x * camRight * camWidthScale + pixelPos.y * camUp * camHeightScale + camForward );

	// depth of field
	// vec3 focalPoint = uFocusDistance * rayDir;
	// float randomAngle = rng() * TWO_PI; // pick random point on aperture
	// float randomRadius = rng() * uApertureSize;
	// vec3  randomAperturePos = ( cos(randomAngle) * camRight + sin(randomAngle) * camUp ) * sqrt(randomRadius);
	// // point on aperture to focal point
	// vec3 finalRayDir = normalize(focalPoint - randomAperturePos);

	// vec3 ro = vec3(0., 0., 0.); // cameraPosition.xzy; // CAMERA_RO; // cameraPosition.xzy / 10.;
    vec3 ro = mvt_cameraPosition.xzy;
    // ro += blueNoise;
	vec3 rd = rayDir.xzy;
    if( rd.y > 0. ) {
        // clouds
        col = renderClouds(ro, rd, dist);
        // TODO: \u8C03\u6574\u4E91\u7684\u9AD8\u5149\u533A\u57DF\uFF0C\u9632\u6B62\u8FC7\u66DD
       //  col.rgb = ReinhardToneMapping(col.rgb);
        // float fogAmount = 1.-(.1 + exp(-dist*0.000001));
        float fogAmount = 1.0 - clamp(rd.y * 20.0, 0.0, 1.0);
        // vec3 skyColor = getSkyColor(rd);
        vec3 skyColor = clamp(texture2D(tDiffuse, uv).rgb, 0.0, 1.0);
        col.rgb = mix(col.rgb, skyColor*(1.-col.a), fogAmount);
    } else {
        // cloud layer below horizon
        // col = renderCloudLayer(ro, rd, dist);
        // // height based fog, see https://iquilezles.org/articles/fog
        // float fogAmount = HEIGHT_BASED_FOG_C * 
        //     (1.-exp( -dist*rd.y*(INV_SCENE_SCALE*HEIGHT_BASED_FOG_B)))/rd.y;
        // vec3 skyColor = texture(tDiffuse, uv).rgb;
        // col.rgb = mix(col.rgb, skyColor*(1.-col.a), clamp(fogAmount,0.,1.));
    }
    // vec4 previousColor = texelFetch(tPrevious, ivec2(gl_FragCoord.xy), 0);
    // gl_FragColor = col * 0.1 + previousColor * 0.9;	
    #ifdef MVT_USE_VOULEMTRIC
    if( col.w > 1. ) {
         gl_FragColor = vec4(0,0,0,1);
    } else {
        // float ratio = 0.3;
        // if (!cameraChanged) {
        //     // vec2 spos = reprojectPos(ro+rd*dist, resolution.xy, tPrevious);
        //     // \u7B80\u5316\u53E0\u52A0
        //     // col.r = ocol.a;
        //     // col.x += 0.5;
        //     ratio = 0.2;
        // }
        // else {

        // }
        vec2 spos = uv;
        vec4 ocol = texture2D( tPrevious, spos, 0.0 ).xyzw;
        col = mix(ocol, col, previousRatio);
    }
    #endif
    gl_FragColor = col;
}`, nz = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
// 
varying vec2 vUv;
void main() { 

    vec3 coord = fract(vec3(vUv + vec2(.2,0.62), .5));
    
    vec4 col = vec4(1);
    
    float mfbm = 0.9;
    float mvor = 0.7;
    
    col.r = mix(1., tilableFbm( coord, 7, 4. ), mfbm) * 
            mix(1., tilableVoronoi( coord, 8, 9. ), mvor);
    col.g = 0.625 * tilableVoronoi( coord + 0., 3, 15. ) +
            0.250 * tilableVoronoi(  coord + 0., 3, 19. ) +
            0.125 * tilableVoronoi( coord + 0., 3, 23. ) 
            -1.;
    col.b = 1. - tilableVoronoi( coord + 0.5, 6, 9. );
    
    gl_FragColor = col;
}`, sz = `#define GLSLIFY 1
// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
// 

void main() { 
    
        // pack 32x32x32 3d texture in 2d texture (with padding)
    float z = floor(gl_FragCoord.x/34.) + 8.*floor(gl_FragCoord.y/34.);
    vec2 uv = mod(gl_FragCoord.xy, 34.) - 1.;
    vec3 coord = vec3(uv, z) / 32.;

    float r = tilableVoronoi( coord, 16,  3. );
    float g = tilableVoronoi( coord,  4,  8. );
    float b = tilableVoronoi( coord,  4, 16. );

    float c = max(0., 1.-(r + g * .5 + b * .25) / 1.75);

    gl_FragColor = vec4(c,c,c,c);

}`, Hu = {
  uniforms: {},
  vertexShader: qC,
  fragmentShader: JC + `
` + nz
}, Pu = {
  uniforms: {},
  vertexShader: qC,
  fragmentShader: JC + `
` + sz
}, Nu = {
  uniforms: {
    tShape: {
      value: null
    },
    tPrevious: {
      value: null
    },
    tDepth: {
      value: null
    },
    tDetail: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    tBlueNoise: {
      value: null
    },
    tWeather: {
      value: null
    },
    tNoise: {
      value: null
    },
    resolution: {
      value: new Z(1, 1)
    },
    iTime: {
      value: 0
    },
    mvt_projectionMatrixInverse: {
      value: new J()
    },
    mvt_viewMatrixInverse: {
      value: new J()
    },
    uCameraMatrix: {
      value: new J()
    },
    uLastCameraMatrix: {
      value: new J()
    },
    mvt_cameraPosition: {
      value: new B()
    },
    sunColor: {
      value: new B(1, 1, 1)
    },
    sunDirection: {
      value: new B(0, 1, 0)
    },
    coverage: {
      value: 0.52
    },
    density: {
      value: 0.03
    },
    speed: {
      value: 1
    },
    cameraChanged: {
      value: !1
    },
    ambientColorBottom: {
      value: new B(0.2, 0.35, 0.5)
    },
    shapeScale: {
      value: new Me(5.51, 50, 1, 1)
    },
    previousRatio: {
      value: 0.5
    }
  },
  vertexShader: qC,
  fragmentShader: JC + `
` + iz
}, oz = `
    uniform sampler2D tDiffuse;
    uniform sampler2D tClold;
    varying vec2 vUv;
    void main() {
        vec4 color = texture2D(tDiffuse, vUv);
        vec4 cloud = texture2D(tClold, vUv);
        // gl_FragColor.rgb = mix(color.rgb, cloud.rgb, 1.0 - clamp(cloud.a, 0.0, 1.0));
        gl_FragColor.rgb = cloud.rgb + color.rgb * cloud.a;
        gl_FragColor.a = 1.0;
        // gl_FragColor.rgb += cloud.rgb;
        // gl_FragColor = cloud;
        // gl_FragColor = vec4(cloud.a, 0.0, 0.0, 1.0);
        // gl_FragColor = vec4(cloud.rgb, 1.0);
    }
`;
class rz extends Xi {
  constructor(e = {}) {
    super();
    f(this, "_coverage", 0.56);
    f(this, "_density", 0.015);
    f(this, "_speed", 1);
    f(this, "_shapeBaseScale", 0.55);
    f(this, "_shapeDetailScale", 20);
    f(this, "_sunColor", new B(1, 1, 1));
    f(this, "_sunDirection", new B(0, 1, 0));
    f(this, "_ambientColorBottom", new B(0.2, 0.35, 0.5));
    f(this, "_useVolumetric", !0);
    this._fsQuad = new Ut(null), this._shapeRenderTarget = new It(1280, 720, {
      format: "RGBA",
      depthBuffer: !1,
      stencilBuffer: !1
    }), this._shapeRenderTarget.texture.generateMipmaps = !1, this._shapeRenderTarget.texture.minFilter = Gt, this._shapeRenderTarget.texture.magFilter = Gt, this._shapeRenderTarget.texture.wrapS = ii, this._shapeRenderTarget.texture.wrapT = ii, this._shapeMaterial = new ze({
      uniforms: we.clone(Hu.uniforms),
      vertexShader: Hu.vertexShader,
      fragmentShader: Hu.fragmentShader,
      depthTest: !1,
      depthWrite: !1
    }), this._detailRenderTarget = new It(1024, 512, {
      format: "RGBA",
      depthBuffer: !1,
      stencilBuffer: !1
    }), this._detailRenderTarget.texture.generateMipmaps = !1, this._detailRenderTarget.texture.wrapS = ii, this._detailRenderTarget.texture.wrapT = ii, this._detailRenderTarget.texture.minFilter = Gt, this._detailRenderTarget.texture.magFilter = Gt, this._detailMaterial = new ze({
      uniforms: we.clone(Pu.uniforms),
      vertexShader: Pu.vertexShader,
      fragmentShader: Pu.fragmentShader,
      depthTest: !1,
      depthWrite: !1
    });
    const i = {
      MVT_CLOUD_MARCH_STEPS: 8,
      MVT_CLOUD_SELF_SHADOW_STEPS: 3
    };
    this._useVolumetric && (i.MVT_USE_VOULEMTRIC = !0);
    const n = this._mainMaterial = new ze({
      uniforms: we.clone(Nu.uniforms),
      vertexShader: Nu.vertexShader,
      fragmentShader: Nu.fragmentShader,
      defines: i,
      depthTest: !1,
      depthWrite: !1,
      name: "VolumetricCloudsShader"
    });
    n.uniforms.tShape.value = this._shapeRenderTarget.texture, n.uniforms.tDetail.value = this._detailRenderTarget.texture, n.uniforms.tBlueNoise.value = e.tBlueNoise, n.uniforms.tWeather.value = e.tWeather, n.uniforms.tNoise.value = e.tNoise, this._previousRenderTarget = new It(1, 1, {
      format: "RGBA",
      depthBuffer: !1,
      stencilBuffer: !1
    }), this._copyMaterial = new ze({
      uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1 }
      },
      vertexShader: Ht.vertexShader,
      fragmentShader: Ht.fragmentShader,
      name: "VolumetricCloudsCopyShader",
      depthTest: !1,
      depthWrite: !1
    }), n.uniforms.tPrevious.value = this._previousRenderTarget.texture, this._compostionMaterial = new ze({
      uniforms: {
        tDiffuse: { value: null },
        tClold: { value: null }
      },
      vertexShader: Ht.vertexShader,
      fragmentShader: oz,
      name: "VolumetricCloudsCompostionShader",
      depthTest: !1,
      depthWrite: !1
    }), this.needsDepthTexture = !0;
  }
  render(e, i, n, o, r) {
    if (!this.sky)
      return;
    const g = this.rendering, c = g.camera, l = g.resolution, h = g.pixelRatio, d = e.autoClear, C = this._mainMaterial, p = this._copyMaterial, m = this._fsQuad;
    if (e.autoClear = !1, !this._hasRenderShapeTexture || g.renderState.isRendererRecreated) {
      m.material = this._shapeMaterial, e.setRenderTarget(this._shapeRenderTarget), e.clear(!0, !1, !1), m.render(e);
      const y = this._detailMaterial;
      m.material = y, e.setRenderTarget(this._detailRenderTarget), e.clear(!0, !1, !1), m.render(e), this._hasRenderShapeTexture = !0;
    }
    if (C.uniforms.tDiffuse.value = n.texture, C.uniforms.tDepth.value = this.rendering.main.sceneRendering.depthTexture, C.uniforms.mvt_projectionMatrixInverse.value.copy(c.projectionMatrixInverse), C.uniforms.mvt_viewMatrixInverse.value.copy(c.matrixWorld), C.uniforms.cameraChanged.value = g.renderState.viewChanged, C.uniforms.speed.value = this._speed, C.uniforms.ambientColorBottom.value.copy(this._ambientColorBottom), C.uniforms.sunColor.value.copy(this._sunColor), C.uniforms.sunDirection.value.copy(this._sunDirection), C.uniforms.coverage.value = this._coverage, C.uniforms.density.value = this._density, C.uniforms.shapeScale.value.set(this._shapeBaseScale, this._shapeDetailScale, 1, 1), g._engine.map.isGlobe) {
      let I = g._engine.map._map._ellipsoidCamera;
      C.uniforms.uCameraMatrix.value.copy(I.getLocalTransform());
      const M = I.positionCartographic.z;
      C.uniforms.mvt_cameraPosition.value.set(0, 0, M);
    } else
      C.uniforms.uCameraMatrix.value.copy(c.matrixWorld), C.uniforms.mvt_cameraPosition.value.set(0, 0, 0);
    C.uniforms.coverage.value = this._coverage, C.uniforms.density.value = this._density, C.uniforms.iTime.value += o;
    let b = !1;
    (this._previousRenderTarget.width !== l.x * h || this._previousRenderTarget.height !== l.y * h) && (this._previousRenderTarget.setSize(l.x * h, l.y * h), C.uniforms.resolution.value.set(l.x * h, l.y * h), b = !0);
    const S = g.renderState.viewChanged;
    b ? (C.previousRatio = 0, this._stableFrames = 0) : S ? (C.uniforms.previousRatio.value = 0.5, this._stableFrames = 0) : (C.uniforms.previousRatio.value = 0.1, this._stableFrames++), this._stableFrames < 30 && g.requestRender();
    const A = g.sharedFullScreenRenderTargets.getAvailableRenderTarget();
    e.setRenderTarget(A), m.material = C, e.clear(!0, !1, !1), m.render(e), e.setRenderTarget(this._previousRenderTarget), p.uniforms.tDiffuse.value = A.texture, m.material = p, e.clear(!0, !1, !1), m.render(e);
    const u = this._compostionMaterial;
    u.uniforms.tDiffuse.value = n.texture, u.uniforms.tClold.value = A.texture, m.material = u, e.setRenderTarget(this.renderToScreen ? null : i), e.clear(!0, !1, !1), m.render(e), C.uniforms.uLastCameraMatrix.value.copy(C.uniforms.uCameraMatrix.value), e.autoClear = d;
  }
  getCurrentUsedTextures() {
    return [
      this._shapeRenderTarget.texture,
      this._detailRenderTarget.texture
    ];
  }
  _resetStableState() {
    this._stableFrames = 0;
  }
  get coverage() {
    return this._coverage;
  }
  set coverage(e) {
    this._coverage = e, this._mainMaterial.uniforms.coverage.value = e, this._resetStableState();
  }
  get density() {
    return this._density;
  }
  set density(e) {
    this._density = e, this._mainMaterial.uniforms.density.value = e, this._resetStableState();
  }
  get speed() {
    return this._speed;
  }
  set speed(e) {
    this._speed = e, this._mainMaterial.uniforms.speed.value = e, this._resetStableState();
  }
  get sunColor() {
    return this._sunColor;
  }
  set sunColor(e) {
    this._sunColor.copy(e), this._mainMaterial.uniforms.sunColor.value.copy(e), this._resetStableState();
  }
  get sunDirection() {
    return this._sunDirection;
  }
  set sunDirection(e) {
    this._sunDirection.copy(e), this._mainMaterial.uniforms.sunDirection.value.copy(e), this._resetStableState();
  }
  get ambientColorBottom() {
    return this._ambientColorBottom;
  }
  set ambientColorBottom(e) {
    this._ambientColorBottom.copy(e), this._mainMaterial.uniforms.ambientColorBottom.value.copy(e), this._resetStableState();
  }
  get shapeBaseScale() {
    return this._shapeBaseScale;
  }
  set shapeBaseScale(e) {
    this._shapeBaseScale = e, this._mainMaterial.uniforms.shapeScale.value.x = e, this._resetStableState();
  }
  get shapeDetailScale() {
    return this._shapeDetailScale;
  }
  set shapeDetailScale(e) {
    this._shapeDetailScale = e, this._mainMaterial.uniforms.shapeScale.value.y = e, this._resetStableState();
  }
  get useVolumetric() {
    return this._useVolumetric;
  }
  set useVolumetric(e) {
    this._useVolumetric = e, e ? this._mainMaterial.defines.MVT_USE_VOULEMTRIC = !0 : delete this._mainMaterial.defines.MVT_USE_VOULEMTRIC, this._mainMaterial.needsUpdate = !0, this._resetStableState();
  }
  get marchSteps() {
    return this._mainMaterial.defines.MVT_CLOUD_MARCH_STEPS;
  }
  set marchSteps(e) {
    this._mainMaterial.defines.MVT_CLOUD_MARCH_STEPS = parseInt(e, 10), this._mainMaterial.needsUpdate = !0;
  }
  get selfShadowSteps() {
    return this._mainMaterial.defines.MVT_CLOUD_SELF_SHADOW_STEPS;
  }
  set selfShadowSteps(e) {
    this._mainMaterial.defines.MVT_CLOUD_SELF_SHADOW_STEPS = parseInt(e, 10), this._mainMaterial.needsUpdate = !0;
  }
}
const R0 = 2, Bs = new B(), jc = new Ce(), D0 = new J();
new Zt(new B(0, 0, 1), 0);
class TY extends gh {
  constructor(e = {}) {
    super(e);
    f(this, "isDynamicSky", !0);
    f(this, "_rtFlipCount", 0);
    f(this, "_skyNeedsCapture", !0);
    f(this, "_skyNeedsUpdate", !0);
    f(this, "_staticEnvMapNeedsUpdate", !0);
    f(this, "_realtimeCapture", !0);
    f(this, "_envMapType", R0);
    f(this, "_PMREMGenerator", null);
    f(this, "_cloud", null);
    f(this, "_envRenderTarget1", null);
    f(this, "_envRenderTarget2", null);
    f(this, "_skyAtmosphere", null);
    f(this, "_lastCameraZ", -1 / 0);
    f(this, "name", "DynamicSky");
    f(this, "dynamicCloud", !1);
    f(this, "_envCaptureLocationKey", "");
    f(this, "_setupClouds", () => {
      const e = this._engine, i = new Ot(), n = i.load(pt("assets/textures/cloud/weather_1.png"), (g) => {
        n.wrapS = n.wrapT = ii;
      }), o = i.load(pt("assets/textures/cloud/shape_1.png"), (g) => {
        o.wrapS = o.wrapT = ii;
      }), r = i.load(
        pt("assets/textures/cloud/BlueNoise_R_128.png"),
        (g) => {
          r.wrapS = r.wrapT = ii;
        }
      ), a = this._volumetricCloudsPass = new rz({
        tBlueNoise: r,
        tWeather: n,
        tNoise: o
      });
      a.renderOrder = 2001, a.sky = this, e.rendering.main.postprocessings.add(a);
    });
    f(this, "updateRealtimeEnvironment", () => {
      const e = this._engine;
      if (this._skyAtmosphere.material.uStarVisible = !1, !this._cubeRenderTarget) {
        const a = this._cubeRenderTarget = new ib(256);
        a.texture.type = xi, a.texture.minFilter = wr, a.texture.magFilter = Gt, a.texture.generateMipmaps = !0, this._cubeCamera = new nb(1, 1e3, a);
      }
      e.rendering.objectsScene.visible = !1, e.rendering.environmentScene.visible = !0;
      const i = e.scene;
      let n = i.background;
      i.background = {};
      const o = e.rendering.environmentScene;
      e.map.isGlobe && (e.map.projection.localFrameToFixedFrame(e.rendering.camera.position, D0), D0.decompose(Bs, o.quaternion, Bs), o.updateMatrixWorld()), this._cubeCamera.update(e.renderer, i), this._PMREMGenerator || (this._PMREMGenerator = new rT(e.renderer)), this._envRT = this._PMREMGenerator.fromCubemap(this._cubeRenderTarget.texture, this._envRT), e.rendering.scene.environment = this._envRT.texture, i.background = n, e.rendering.objectsScene.visible = !0, e.rendering.environmentScene.visible = !1, this._skyAtmosphere.material.uStarVisible = !0;
    });
    f(this, "disposeEnvRenderTarget", (e) => {
      this._envRenderTarget1 && (this._envRenderTarget1.dispose(), this._envRenderTarget1 = null), this._envRenderTarget2 && (this._envRenderTarget2.dispose(), this._envRenderTarget2 = null);
    });
    this._affectWorld = !0, this._upDirection = new B(0, 0, 1);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), this._engine = e, this.initEnv();
  }
  initEnv() {
    const e = this._engine, i = this._skyAtmosphere = new $V();
    i.collisionDisabled = !0, i.__isEnvironment = !0, i.renderOrder = -100, e.add(i);
    const n = this._postPass = new tz();
    n.renderOrder = 50, n.sky = this, e.rendering.main.opaquePostprocessings.add(n), this._cloudAmbientBottomColorGradient = new nA([
      [0, new Ce("#010105")],
      [5.5 / 24, new Ce("#010105")],
      [5.8 / 24, new Ce("#aa0000")],
      [6.1 / 24, new Ce("#aa9944")],
      [7.5 / 24, new Ce("#aaaaaa")],
      [12 / 24, new Ce("#bbccdd")]
    ]), this._cloudSunIntensityGradient = new nA([
      [0, 0.01],
      [5.5 / 24, 0.05],
      [7.5 / 24, 0.1],
      [12 / 24, 0.4]
    ]), this._setupClouds();
  }
  onBeforeScenePrepareRender() {
    super.onBeforeScenePrepareRender();
    const e = this._engine, i = e.map.isGlobe, n = this._skyAtmosphere, o = this._cloud;
    e.camera, n.material.uTime = e.rendering.uniforms.elapsedTime.value, n.material.uniforms.isGlobe.value = i, e.rendering.renderState.isRendererRecreated && (this.disposeEnvRenderTarget(), n._hasPaintedScatterBuffer = !1, this._skyNeedsUpdate = !0, this._skyNeedsCapture = !0, this._hasCaptureSky = !1, o && o.updateRenderCacheData());
    let r = e.map.getViewHeight();
    const a = Math.abs(r - (this._lastViewHeight || -1 / 0));
    if (this._lastViewHeight = r, i) {
      a > 1 && (this._skyNeedsUpdate = !0), e.map.getCameraLocation(Bs);
      const g = `${Math.round(Bs.x / 10)}-${Math.round(Bs.y / 10)}`;
      g !== this._envCaptureLocationKey && (this._envCaptureLocationKey = g, this._skyNeedsCapture = !0, this._hasCaptureSky = !1);
    } else
      this._skyNeedsUpdate = !1;
    (this._skyNeedsCapture || this._skyNeedsUpdate) && (i ? n.viewHeight = Math.max(r / 1e6, 2e-4) : n.viewHeight = 2e-4, n.updateRenderTargets(e.rendering.renderer, e.rendering.camera), o && (o.material.uniforms.skyAltitude.value = n.altitude)), this.dynamicCloud && (o.material.uniforms.time.value = e.rendering.uniforms.elapsedTime.value), this._hasCaptureSky || (this._skyNeedsCapture = !0), r > 1e4 && (this._skyNeedsCapture = !1), (this._skyNeedsCapture || this.dynamicCloud) && (n.position.set(0, 0, 0), n.updateMatrixWorld(), o && (o.position.set(0, 0, 0), o.updateMatrixWorld()), this._affectWorld && (e.rendering.stats.beginTimeStatsItem("Sky.CaptureEnvironment"), this.updateRealtimeEnvironment(), e.rendering.stats.endTimeStatsItem("Sky.CaptureEnvironment")), this._hasCaptureSky = !0), this._affectWorld || (e.rendering.scene.environment = null), n.position.copy(e.rendering.camera.position), n.position.z -= 0, o && o.position.copy(e.rendering.camera.position), this._skyNeedsCapture = !1;
  }
  updateLight() {
    if (super.updateLight(), this._lensflare) {
      const e = this._sunDirection.z, i = this._sunDirection.x;
      let n = this._engine.map.getCameraDistance() * 10;
      if (e > 0.01 && this.sunLight.intensity > 0.1 && n < 1e6) {
        this._lensflare.visible = !0;
        const [o, r] = this._engine.map.getProjectionCenter();
        this._lensflare.position.set(o + i * n, r, e * n);
      } else
        this._lensflare.visible = !1;
    }
  }
  onTimeChanged(e) {
    const i = this._skyAtmosphere;
    i.altitude = (e / 86400 - 0.25) * Math.PI * 2, this._skyNeedsCapture = !0, this._updateClouds();
  }
  _updateClouds() {
    const e = this._volumetricCloudsPass;
    if (e) {
      const i = this._timeRatio > 0.5 ? 1 - this._timeRatio : this._timeRatio, n = this._cloudSunIntensityGradient.lerp(i), o = this.sunLight.color;
      e.sunColor = Bs.set(o.r, o.g, o.b).multiplyScalar(n * (1 - this.mixGrayFactor)), e.sunDirection = Bs.set(
        -this.localSunDirection.x,
        -this.localSunDirection.y,
        -this.localSunDirection.z
      ), this._cloudAmbientBottomColorGradient.lerp(i, jc), Bs.set(jc.r, jc.g, jc.b).multiplyScalar(1 - this.mixGrayFactor), e.ambientColorBottom = Bs;
    }
  }
  getTextures() {
    return this._envMapType === R0 ? [this._envRenderTarget1.texture, this._envRenderTarget2.texture] : [];
  }
  beforeRemoveFromEngine(e) {
    this.disposeEnvRenderTarget(this._realtimeCapture), e.remove(this._skyAtmosphere), e.remove(this._cloud), e.rendering.main.postprocessings.remove(this._postPass), e.rendering.main.postprocessings.remove(this._volumetricCloudsPass), this._skyNeedsUpdate = !0, this._skyNeedsCapture = !0, this._timeChanged = !0, super.beforeRemoveFromEngine(e);
  }
  dispose() {
    super.dispose();
  }
  set useVolumetricClouds(e) {
    this._volumetricCloudsPass.useVolumetric = e;
  }
  get useVolumetricClouds() {
    return this._volumetricCloudsPass.useVolumetric;
  }
  set affectWorld(e) {
    this._skyNeedsCapture = !0, this._affectWorld = e;
  }
  get affectWorld() {
    return this._affectWorld;
  }
  get cloudIntensity() {
    return this._cloud && this._cloud.coverage || 0;
  }
  set cloudIntensity(e) {
    this._cloud && (this._cloud.coverage = e, this._skyNeedsCapture = !0);
  }
  get mixGrayFactor() {
    return this._skyAtmosphere.mixGrayFactor;
  }
  set mixGrayFactor(e) {
    this._skyAtmosphere.mixGrayFactor = e, this._skyNeedsCapture = !0, this._updateClouds();
  }
  get realtimeCapture() {
    return this._realtimeCapture;
  }
  set realtimeCapture(e) {
    e !== this._realtimeCapture && (console.warn("has not been supported"), this._skyNeedsCapture = !0, this._realtimeCapture = e);
  }
  get skyAtmosphere() {
    return this._skyAtmosphere;
  }
  get clipUnderground() {
    return !1;
  }
  set clipUnderground(e) {
    console.warn("has not been supported");
  }
  get enablePostPass() {
    return this._postPass.enabled || !1;
  }
  set enablePostPass(e) {
    this._postPass && (this._postPass.enabled = e);
  }
  get enableVolumetricClouds() {
    return this._volumetricCloudsPass && this._volumetricCloudsPass.enabled || !1;
  }
  set enableVolumetricClouds(e) {
    this._volumetricCloudsPass && (this._volumetricCloudsPass.enabled = e);
  }
  get cloudCoverage() {
    return this._volumetricCloudsPass && this._volumetricCloudsPass.coverage || 0;
  }
  set cloudCoverage(e) {
    this._volumetricCloudsPass && (this._volumetricCloudsPass.coverage = e);
  }
  get cloudDensity() {
    return this._volumetricCloudsPass && this._volumetricCloudsPass.density || 0;
  }
  set cloudDensity(e) {
    this._volumetricCloudsPass && (this._volumetricCloudsPass.density = e);
  }
  get cloudSpeed() {
    return this._volumetricCloudsPass && this._volumetricCloudsPass.speed || 1;
  }
  set cloudSpeed(e) {
    this._volumetricCloudsPass && (this._volumetricCloudsPass.speed = e);
  }
  get cloudShapeBaseScale() {
    return this._volumetricCloudsPass && this._volumetricCloudsPass.shapeBaseScale || 1;
  }
  set cloudShapeBaseScale(e) {
    this._volumetricCloudsPass && (this._volumetricCloudsPass.shapeBaseScale = e);
  }
  get cloudShapeDetailScale() {
    return this._volumetricCloudsPass && this._volumetricCloudsPass.shapeDetailScale || 1;
  }
  set cloudShapeDetailScale(e) {
    this._volumetricCloudsPass && (this._volumetricCloudsPass.shapeDetailScale = e);
  }
  get cloudMarchSteps() {
    return this._volumetricCloudsPass.marchSteps;
  }
  set cloudMarchSteps(e) {
    this._volumetricCloudsPass.marchSteps = e;
  }
  get cloudSelfShadowSteps() {
    return this._volumetricCloudsPass.selfShadowSteps;
  }
  set cloudSelfShadowSteps(e) {
    this._volumetricCloudsPass.selfShadowSteps = e;
  }
  get upDirection() {
    return this._upDirection;
  }
}
const K0 = [
  "//tile.osm.org",
  "//a.tile.osm.org",
  "//b.tile.osm.org",
  "//c.tile.osm.org"
];
class LY extends OC {
  constructor(e) {
    super({
      ...e,
      projection: Mt
    });
    f(this, "name", "OSMImageryTileProvider");
    f(this, "_supportedTargetProjectionNames", [Mt, hi]);
    f(this, "_defaultStartLevel", 1);
    f(this, "_defaultMaxLevel", 18);
    f(this, "_maxParallelRequestNum", 24);
    f(this, "_useWebMeractorProjectionAndGrid", !0);
  }
  getTileURL(e, i, n, o) {
    const r = Math.abs(i + n) % K0.length;
    return `${K0[r]}/${e}/${i}/${o.reverseY}.png`;
  }
}
class GY extends OC {
  constructor(e) {
    super({
      ...e
    });
    f(this, "name", "TiandituImageryTileProvider");
    f(this, "_tk", "");
    f(this, "_supportedTargetProjectionNames", [hi, Mt]);
    f(this, "_defaultMaxLevel", 18);
    this._tk = e.tk || U_.tk;
  }
  initProjectionAndGrid() {
    this._sourceProjection = this._targetProjection, this._sourceProjection.name === Mt ? this._grid = new nd(this._engine, this._sourceProjection, this._targetProjection) : this._sourceProjection.name === hi && (this._grid = new UC(this._engine, this._sourceProjection, this._targetProjection));
  }
  getTileURL(e, i, n, o) {
    if (e === 0)
      return !1;
    const a = this._sourceProjection.name === hi ? "vec_c" : "vec_w";
    return `https://t2.tianditu.gov.cn/DataServer?tk=${this._tk}&T=${a}&x=${i}&y=${o.reverseY}&l=${e}`;
  }
}
const ni = {
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123,
  UNSIGNED_INT: 5125
};
ni.getSizeInBytes = function(s) {
  switch (s) {
    case ni.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case ni.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case ni.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
  }
  throw new re(
    "indexDatatype is required and must be a valid IndexDatatype constant."
  );
};
ni.fromSizeInBytes = function(s) {
  switch (s) {
    case 2:
      return ni.UNSIGNED_SHORT;
    case 4:
      return ni.UNSIGNED_INT;
    case 1:
      return ni.UNSIGNED_BYTE;
    default:
      throw new re(
        "Size in bytes cannot be mapped to an IndexDatatype"
      );
  }
};
ni.validate = function(s) {
  return H(s) && (s === ni.UNSIGNED_BYTE || s === ni.UNSIGNED_SHORT || s === ni.UNSIGNED_INT);
};
ni.createTypedArray = function(s, t) {
  if (!H(s))
    throw new re("numberOfVertices is required.");
  return s >= X.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t) : new Uint16Array(t);
};
ni.createTypedArrayFromArrayBuffer = function(s, t, e, i) {
  if (!H(s))
    throw new re("numberOfVertices is required.");
  if (!H(t))
    throw new re("sourceArray is required.");
  if (!H(e))
    throw new re("byteOffset is required.");
  return s >= X.SIXTY_FOUR_KILOBYTES ? new Uint32Array(t, e, i) : new Uint16Array(t, e, i);
};
ni.fromTypedArray = function(s) {
  if (s instanceof Uint8Array)
    return ni.UNSIGNED_BYTE;
  if (s instanceof Uint16Array)
    return ni.UNSIGNED_SHORT;
  if (s instanceof Uint32Array)
    return ni.UNSIGNED_INT;
  throw new re(
    "array must be a Uint8Array, Uint16Array, or Uint32Array."
  );
};
const xo = Object.freeze(ni), Jc = [];
function qc(s, t, e) {
  Jc.length = s.length;
  let i = !1;
  for (let n = 0, o = s.length; n < o; ++n)
    Jc[n] = s[n], i = i || n > 0 && t(s[n - 1], s[n]) > 0;
  return i ? (Jc.sort(t), xo.createTypedArray(e, Jc)) : s;
}
function Fu(s) {
  return s >> 1 ^ -(s & 1);
}
function az(s, t, e) {
  const i = s.length;
  let n = 0, o = 0, r = 0;
  for (let a = 0; a < i; ++a)
    n += Fu(s[a]), o += Fu(t[a]), s[a] = n, t[a] = o, H(e) && (r += Fu(e[a]), e[a] = r);
}
class mh {
  constructor(t) {
    if (!H(t) || !H(t.quantizedVertices))
      throw new re("options.quantizedVertices is required.");
    if (!H(t.indices))
      throw new re("options.indices is required.");
    if (!H(t.minimumHeight))
      throw new re("options.minimumHeight is required.");
    if (!H(t.maximumHeight))
      throw new re("options.maximumHeight is required.");
    if (!H(t.maximumHeight))
      throw new re("options.maximumHeight is required.");
    if (!H(t.westIndices))
      throw new re("options.westIndices is required.");
    if (!H(t.southIndices))
      throw new re("options.southIndices is required.");
    if (!H(t.eastIndices))
      throw new re("options.eastIndices is required.");
    if (!H(t.northIndices))
      throw new re("options.northIndices is required.");
    this._quantizedVertices = t.quantizedVertices, this._encodedNormals = t.encodedNormals, this._indices = t.indices, this._minimumHeight = t.minimumHeight, this._maximumHeight = t.maximumHeight, this._boundingSphere = t.boundingSphere, this._horizonOcclusionPoint = t.horizonOcclusionPoint;
    const e = this._quantizedVertices.length / 3, i = this._uValues = this._quantizedVertices.subarray(
      0,
      e
    ), n = this._vValues = this._quantizedVertices.subarray(
      e,
      2 * e
    );
    this._heightValues = this._quantizedVertices.subarray(
      2 * e,
      3 * e
    );
    function o(a, g) {
      return n[a] - n[g];
    }
    function r(a, g) {
      return i[a] - i[g];
    }
    this._westIndices = qc(
      t.westIndices,
      o,
      e
    ), this._southIndices = qc(
      t.southIndices,
      r,
      e
    ), this._eastIndices = qc(
      t.eastIndices,
      o,
      e
    ), this._northIndices = qc(
      t.northIndices,
      r,
      e
    ), this._childTileMask = W(t.childTileMask, 15), this._mesh = void 0;
  }
  static createQuantizedMeshTerrainData(t) {
    let e = 0;
    const i = 3, n = i + 1, o = Float64Array.BYTES_PER_ELEMENT * i, r = Float64Array.BYTES_PER_ELEMENT * n, a = 3, g = Uint16Array.BYTES_PER_ELEMENT * a, c = 3;
    let l = Uint16Array.BYTES_PER_ELEMENT, h = l * c;
    const d = new DataView(t);
    e += o;
    const C = d.getFloat32(e, !0);
    e += Float32Array.BYTES_PER_ELEMENT;
    const p = d.getFloat32(e, !0);
    e += Float32Array.BYTES_PER_ELEMENT;
    const m = {
      center: new B(
        d.getFloat64(e, !0),
        d.getFloat64(e + 8, !0),
        d.getFloat64(e + 16, !0)
      ),
      radius: d.getFloat64(e + o, !0)
    };
    e += r;
    const b = new B(
      d.getFloat64(e, !0),
      d.getFloat64(e + 8, !0),
      d.getFloat64(e + 16, !0)
    );
    e += o;
    const S = d.getUint32(e, !0);
    e += Uint32Array.BYTES_PER_ELEMENT;
    const A = new Uint16Array(t, e, S * 3);
    e += S * g, S > 64 * 1024 && (l = Uint32Array.BYTES_PER_ELEMENT, h = l * c);
    const u = A.subarray(0, S), y = A.subarray(S, 2 * S), I = A.subarray(
      S * 2,
      3 * S
    );
    az(u, y, I), e % l !== 0 && (e += l - e % l);
    const M = d.getUint32(e, !0);
    e += Uint32Array.BYTES_PER_ELEMENT;
    const G = xo.createTypedArrayFromArrayBuffer(
      S,
      t,
      e,
      M * c
    );
    e += M * h;
    let x = 0;
    const L = G.length;
    for (let k = 0; k < L; ++k) {
      const V = G[k];
      G[k] = x - V, V === 0 && ++x;
    }
    const E = d.getUint32(e, !0);
    e += Uint32Array.BYTES_PER_ELEMENT;
    const T = xo.createTypedArrayFromArrayBuffer(
      S,
      t,
      e,
      E
    );
    e += E * l;
    const R = d.getUint32(e, !0);
    e += Uint32Array.BYTES_PER_ELEMENT;
    const w = xo.createTypedArrayFromArrayBuffer(
      S,
      t,
      e,
      R
    );
    e += R * l;
    const v = d.getUint32(e, !0);
    e += Uint32Array.BYTES_PER_ELEMENT;
    const D = xo.createTypedArrayFromArrayBuffer(
      S,
      t,
      e,
      v
    );
    e += v * l;
    const K = d.getUint32(e, !0);
    e += Uint32Array.BYTES_PER_ELEMENT;
    const P = xo.createTypedArrayFromArrayBuffer(
      S,
      t,
      e,
      K
    );
    return e += K * l, new mh({
      minimumHeight: C,
      maximumHeight: p,
      boundingSphere: m,
      horizonOcclusionPoint: b,
      quantizedVertices: A,
      indices: G,
      westIndices: T,
      southIndices: w,
      eastIndices: D,
      northIndices: P
    });
  }
}
class gz {
  constructor(t, e, i, n, o, r, a, g, c, l, h, d, C, p, m, b) {
    this.center = t, this.vertices = e, this.stride = W(l, 6), this.indices = i, this.indexCountWithoutSkirts = n, this.vertexCountWithoutSkirts = o, this.minimumHeight = r, this.maximumHeight = a, this.boundingSphere3D = g, this.occludeePointInScaledSpace = c, this.orientedBoundingBox = h, this.encoding = d, this.westIndicesSouthToNorth = C, this.southIndicesEastToWest = p, this.eastIndicesNorthToSouth = m, this.northIndicesWestToEast = b;
  }
}
class cz {
  constructor(t, e, i) {
    this.provider = t, this._workerTaskScheduler = new V_(e, i), this._workerTaskScheduler.getResponseMessageId = this.getResponseMessageId, this._workerTaskScheduler.isMessageCompleted = this.isMessageCompleted;
  }
  isMessageCompleted(t, e) {
    return t.type === "terrainMeshCreated" || t.type === "terrainDataUpsampled";
  }
  getResponseMessageId(t, e) {
    return t.tileKey;
  }
  _vectorToArray(t) {
    return [t.x, t.y, t.z];
  }
  _boxToArray(t) {
    return [t.min.x, t.min.y, t.min.z, t.max.x, t.max.y, t.max.z];
  }
  async upsample(t, e, i) {
    const n = this.provider, o = n._engine.map.map._ellipsoid, r = e.x, a = e.y, g = i.x, c = i.y;
    if (!H(t) || !H(t._mesh))
      return;
    const l = t._mesh, h = r * 2 !== g, d = a * 2 !== c, C = Oe.fromBox(i.geoBoundingBox), p = "upsampleTerrainData", m = {
      type: p,
      tileKey: i.key,
      isEastChild: h,
      isNorthChild: d,
      childRectangle: C,
      ellipsoid: o,
      vertices: l.vertices,
      indices: l.indices,
      vertexCountWithoutSkirts: l.vertexCountWithoutSkirts,
      indexCountWithoutSkirts: l.indexCountWithoutSkirts,
      minimumHeight: l.minimumHeight,
      maximumHeight: l.maximumHeight
    };
    if (n.getFetchOptions) {
      const y = n.getFetchOptions(i);
      m.fetchOptions = y;
    }
    if (n.getWorkerOptions) {
      const y = n.getWorkerOptions(i);
      m.workerOptions = y;
    }
    let b = await this._workerTaskScheduler.postMessage(m, [], p + "-" + i.key);
    b = b.content;
    const S = new Uint16Array(b.vertices), A = xo.createTypedArray(
      S.length / 3,
      b.indices
    );
    return new mh({
      quantizedVertices: S,
      indices: A,
      minimumHeight: b.minimumHeight,
      maximumHeight: b.maximumHeight,
      westIndices: b.westIndices,
      southIndices: b.southIndices,
      eastIndices: b.eastIndices,
      northIndices: b.northIndices,
      childTileMask: 0
    });
  }
  async requestTile(t) {
    const e = this.provider;
    let i = e.getTileURL(t.z, t.x, t.y, t), n;
    try {
      const r = e.getFetchOptions(t);
      n = await Ta(
        i,
        {
          responseType: "arraybuffer",
          ...r
        }
      ).then((a) => a.arrayBuffer());
    } catch {
      console.warn("no tile");
      return;
    }
    return n ? mh.createQuantizedMeshTerrainData(n) : Promise.reject("Mesh buffer dosen't exist");
  }
  async createMesh(t, e, i) {
    const n = this.provider, o = n._engine.map.map._ellipsoid, r = Oe.fromBox(e.geoBoundingBox), a = "createTerrainMesh";
    let g = e.targetCenter;
    const c = {
      type: a,
      tileKey: e.key,
      tileCenter: g,
      minimumHeight: t._minimumHeight,
      maximumHeight: t._maximumHeight,
      quantizedVertices: t._quantizedVertices,
      indices: t._indices,
      westIndices: t._westIndices,
      southIndices: t._southIndices,
      eastIndices: t._eastIndices,
      northIndices: t._northIndices,
      rectangle: r,
      level: e.z,
      ellipsoid: o
    };
    if (n.getFetchOptions) {
      const u = n.getFetchOptions(e);
      c.fetchOptions = u;
    }
    if (n.getWorkerOptions) {
      const u = n.getWorkerOptions(e);
      c.workerOptions = u;
    }
    const l = await this._workerTaskScheduler.postMessage(c, [], a + "-" + e.key);
    if (!H(l.content))
      return;
    const h = l.content, d = t._quantizedVertices.length / 3, C = d + t._westIndices.length + t._southIndices.length + t._eastIndices.length + t._northIndices.length, p = xo.createTypedArray(
      C,
      h.indices
    ), m = new Float32Array(h.vertices), b = h.center, S = h.minimumHeight, A = h.maximumHeight;
    return t._mesh = new gz(
      b,
      m,
      p,
      h.indexCountWithoutSkirts,
      d,
      S,
      A,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      h.westIndicesSouthToNorth,
      h.southIndicesEastToWest,
      h.eastIndicesNorthToSouth,
      h.northIndicesWestToEast
    ), t._quantizedVertices = void 0, t._encodedNormals = void 0, t._indices = void 0, t._uValues = void 0, t._vValues = void 0, t._heightValues = void 0, t._westIndices = void 0, t._southIndices = void 0, t._eastIndices = void 0, t._northIndices = void 0, t._mesh;
  }
  postMessageToAll(t, e) {
    this._workerTaskScheduler.initWorkers(), this._workerTaskScheduler.postMessageToAll(t, e);
  }
}
const j_ = "dmFyIHZ0ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5Owp2YXIgdGkgPSAoZSwgdCwgaSkgPT4gdCBpbiBlID8gdnQoZSwgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogaSB9KSA6IGVbdF0gPSBpOwp2YXIgcCA9IChlLCB0LCBpKSA9PiAodGkoZSwgdHlwZW9mIHQgIT0gInN5bWJvbCIgPyB0ICsgIiIgOiB0LCBpKSwgaSk7Ci8qKgogKiBAbGljZW5zZQogKiBDb3B5cmlnaHQgMjAxMC0yMDIzIFRocmVlLmpzIEF1dGhvcnMKICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVAogKi8KY29uc3QgR3QgPSAiMTU4IiwgSCA9IFsiMDAiLCAiMDEiLCAiMDIiLCAiMDMiLCAiMDQiLCAiMDUiLCAiMDYiLCAiMDciLCAiMDgiLCAiMDkiLCAiMGEiLCAiMGIiLCAiMGMiLCAiMGQiLCAiMGUiLCAiMGYiLCAiMTAiLCAiMTEiLCAiMTIiLCAiMTMiLCAiMTQiLCAiMTUiLCAiMTYiLCAiMTciLCAiMTgiLCAiMTkiLCAiMWEiLCAiMWIiLCAiMWMiLCAiMWQiLCAiMWUiLCAiMWYiLCAiMjAiLCAiMjEiLCAiMjIiLCAiMjMiLCAiMjQiLCAiMjUiLCAiMjYiLCAiMjciLCAiMjgiLCAiMjkiLCAiMmEiLCAiMmIiLCAiMmMiLCAiMmQiLCAiMmUiLCAiMmYiLCAiMzAiLCAiMzEiLCAiMzIiLCAiMzMiLCAiMzQiLCAiMzUiLCAiMzYiLCAiMzciLCAiMzgiLCAiMzkiLCAiM2EiLCAiM2IiLCAiM2MiLCAiM2QiLCAiM2UiLCAiM2YiLCAiNDAiLCAiNDEiLCAiNDIiLCAiNDMiLCAiNDQiLCAiNDUiLCAiNDYiLCAiNDciLCAiNDgiLCAiNDkiLCAiNGEiLCAiNGIiLCAiNGMiLCAiNGQiLCAiNGUiLCAiNGYiLCAiNTAiLCAiNTEiLCAiNTIiLCAiNTMiLCAiNTQiLCAiNTUiLCAiNTYiLCAiNTciLCAiNTgiLCAiNTkiLCAiNWEiLCAiNWIiLCAiNWMiLCAiNWQiLCAiNWUiLCAiNWYiLCAiNjAiLCAiNjEiLCAiNjIiLCAiNjMiLCAiNjQiLCAiNjUiLCAiNjYiLCAiNjciLCAiNjgiLCAiNjkiLCAiNmEiLCAiNmIiLCAiNmMiLCAiNmQiLCAiNmUiLCAiNmYiLCAiNzAiLCAiNzEiLCAiNzIiLCAiNzMiLCAiNzQiLCAiNzUiLCAiNzYiLCAiNzciLCAiNzgiLCAiNzkiLCAiN2EiLCAiN2IiLCAiN2MiLCAiN2QiLCAiN2UiLCAiN2YiLCAiODAiLCAiODEiLCAiODIiLCAiODMiLCAiODQiLCAiODUiLCAiODYiLCAiODciLCAiODgiLCAiODkiLCAiOGEiLCAiOGIiLCAiOGMiLCAiOGQiLCAiOGUiLCAiOGYiLCAiOTAiLCAiOTEiLCAiOTIiLCAiOTMiLCAiOTQiLCAiOTUiLCAiOTYiLCAiOTciLCAiOTgiLCAiOTkiLCAiOWEiLCAiOWIiLCAiOWMiLCAiOWQiLCAiOWUiLCAiOWYiLCAiYTAiLCAiYTEiLCAiYTIiLCAiYTMiLCAiYTQiLCAiYTUiLCAiYTYiLCAiYTciLCAiYTgiLCAiYTkiLCAiYWEiLCAiYWIiLCAiYWMiLCAiYWQiLCAiYWUiLCAiYWYiLCAiYjAiLCAiYjEiLCAiYjIiLCAiYjMiLCAiYjQiLCAiYjUiLCAiYjYiLCAiYjciLCAiYjgiLCAiYjkiLCAiYmEiLCAiYmIiLCAiYmMiLCAiYmQiLCAiYmUiLCAiYmYiLCAiYzAiLCAiYzEiLCAiYzIiLCAiYzMiLCAiYzQiLCAiYzUiLCAiYzYiLCAiYzciLCAiYzgiLCAiYzkiLCAiY2EiLCAiY2IiLCAiY2MiLCAiY2QiLCAiY2UiLCAiY2YiLCAiZDAiLCAiZDEiLCAiZDIiLCAiZDMiLCAiZDQiLCAiZDUiLCAiZDYiLCAiZDciLCAiZDgiLCAiZDkiLCAiZGEiLCAiZGIiLCAiZGMiLCAiZGQiLCAiZGUiLCAiZGYiLCAiZTAiLCAiZTEiLCAiZTIiLCAiZTMiLCAiZTQiLCAiZTUiLCAiZTYiLCAiZTciLCAiZTgiLCAiZTkiLCAiZWEiLCAiZWIiLCAiZWMiLCAiZWQiLCAiZWUiLCAiZWYiLCAiZjAiLCAiZjEiLCAiZjIiLCAiZjMiLCAiZjQiLCAiZjUiLCAiZjYiLCAiZjciLCAiZjgiLCAiZjkiLCAiZmEiLCAiZmIiLCAiZmMiLCAiZmQiLCAiZmUiLCAiZmYiXTsKbGV0IFZ0ID0gMTIzNDU2NzsKY29uc3QgWHQgPSBNYXRoLlBJIC8gMTgwLCBadCA9IDE4MCAvIE1hdGguUEk7CmZ1bmN0aW9uIGlpKCkgewogIGNvbnN0IGUgPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDAsIHQgPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDAsIGkgPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDAsIG4gPSBNYXRoLnJhbmRvbSgpICogNDI5NDk2NzI5NSB8IDA7CiAgcmV0dXJuIChIW2UgJiAyNTVdICsgSFtlID4+IDggJiAyNTVdICsgSFtlID4+IDE2ICYgMjU1XSArIEhbZSA+PiAyNCAmIDI1NV0gKyAiLSIgKyBIW3QgJiAyNTVdICsgSFt0ID4+IDggJiAyNTVdICsgIi0iICsgSFt0ID4+IDE2ICYgMTUgfCA2NF0gKyBIW3QgPj4gMjQgJiAyNTVdICsgIi0iICsgSFtpICYgNjMgfCAxMjhdICsgSFtpID4+IDggJiAyNTVdICsgIi0iICsgSFtpID4+IDE2ICYgMjU1XSArIEhbaSA+PiAyNCAmIDI1NV0gKyBIW24gJiAyNTVdICsgSFtuID4+IDggJiAyNTVdICsgSFtuID4+IDE2ICYgMjU1XSArIEhbbiA+PiAyNCAmIDI1NV0pLnRvTG93ZXJDYXNlKCk7Cn0KZnVuY3Rpb24gU3QoZSwgdCwgaSkgewogIHJldHVybiBNYXRoLm1heCh0LCBNYXRoLm1pbihpLCBlKSk7Cn0KZnVuY3Rpb24ganQoZSwgdCkgewogIHJldHVybiAoZSAlIHQgKyB0KSAlIHQ7Cn0KZnVuY3Rpb24gbmkoZSwgdCwgaSwgbiwgcykgewogIHJldHVybiBuICsgKGUgLSB0KSAqIChzIC0gbikgLyAoaSAtIHQpOwp9CmZ1bmN0aW9uIGVpKGUsIHQsIGkpIHsKICByZXR1cm4gZSAhPT0gdCA/IChpIC0gZSkgLyAodCAtIGUpIDogMDsKfQpmdW5jdGlvbiBRdChlLCB0LCBpKSB7CiAgcmV0dXJuICgxIC0gaSkgKiBlICsgaSAqIHQ7Cn0KZnVuY3Rpb24gc2koZSwgdCwgaSwgbikgewogIHJldHVybiBRdChlLCB0LCAxIC0gTWF0aC5leHAoLWkgKiBuKSk7Cn0KZnVuY3Rpb24gaGkoZSwgdCA9IDEpIHsKICByZXR1cm4gdCAtIE1hdGguYWJzKGp0KGUsIHQgKiAyKSAtIHQpOwp9CmZ1bmN0aW9uIHJpKGUsIHQsIGkpIHsKICByZXR1cm4gZSA8PSB0ID8gMCA6IGUgPj0gaSA/IDEgOiAoZSA9IChlIC0gdCkgLyAoaSAtIHQpLCBlICogZSAqICgzIC0gMiAqIGUpKTsKfQpmdW5jdGlvbiBvaShlLCB0LCBpKSB7CiAgcmV0dXJuIGUgPD0gdCA/IDAgOiBlID49IGkgPyAxIDogKGUgPSAoZSAtIHQpIC8gKGkgLSB0KSwgZSAqIGUgKiBlICogKGUgKiAoZSAqIDYgLSAxNSkgKyAxMCkpOwp9CmZ1bmN0aW9uIGFpKGUsIHQpIHsKICByZXR1cm4gZSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0IC0gZSArIDEpKTsKfQpmdW5jdGlvbiBjaShlLCB0KSB7CiAgcmV0dXJuIGUgKyBNYXRoLnJhbmRvbSgpICogKHQgLSBlKTsKfQpmdW5jdGlvbiB1aShlKSB7CiAgcmV0dXJuIGUgKiAoMC41IC0gTWF0aC5yYW5kb20oKSk7Cn0KZnVuY3Rpb24gZGkoZSkgewogIGUgIT09IHZvaWQgMCAmJiAoVnQgPSBlKTsKICBsZXQgdCA9IFZ0ICs9IDE4MzE1NjU4MTM7CiAgcmV0dXJuIHQgPSBNYXRoLmltdWwodCBeIHQgPj4+IDE1LCB0IHwgMSksIHQgXj0gdCArIE1hdGguaW11bCh0IF4gdCA+Pj4gNywgdCB8IDYxKSwgKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7Cn0KZnVuY3Rpb24gZmkoZSkgewogIHJldHVybiBlICogWHQ7Cn0KZnVuY3Rpb24geWkoZSkgewogIHJldHVybiBlICogWnQ7Cn0KZnVuY3Rpb24geGkoZSkgewogIHJldHVybiAoZSAmIGUgLSAxKSA9PT0gMCAmJiBlICE9PSAwOwp9CmZ1bmN0aW9uIGxpKGUpIHsKICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5jZWlsKE1hdGgubG9nKGUpIC8gTWF0aC5MTjIpKTsKfQpmdW5jdGlvbiBfaShlKSB7CiAgcmV0dXJuIE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2coZSkgLyBNYXRoLkxOMikpOwp9CmZ1bmN0aW9uIG1pKGUsIHQsIGksIG4sIHMpIHsKICBjb25zdCBoID0gTWF0aC5jb3MsIGEgPSBNYXRoLnNpbiwgciA9IGgoaSAvIDIpLCBvID0gYShpIC8gMiksIGMgPSBoKCh0ICsgbikgLyAyKSwgeSA9IGEoKHQgKyBuKSAvIDIpLCB1ID0gaCgodCAtIG4pIC8gMiksIGQgPSBhKCh0IC0gbikgLyAyKSwgZiA9IGgoKG4gLSB0KSAvIDIpLCB4ID0gYSgobiAtIHQpIC8gMik7CiAgc3dpdGNoIChzKSB7CiAgICBjYXNlICJYWVgiOgogICAgICBlLnNldChyICogeSwgbyAqIHUsIG8gKiBkLCByICogYyk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAiWVpZIjoKICAgICAgZS5zZXQobyAqIGQsIHIgKiB5LCBvICogdSwgciAqIGMpOwogICAgICBicmVhazsKICAgIGNhc2UgIlpYWiI6CiAgICAgIGUuc2V0KG8gKiB1LCBvICogZCwgciAqIHksIHIgKiBjKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJYWlgiOgogICAgICBlLnNldChyICogeSwgbyAqIHgsIG8gKiBmLCByICogYyk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAiWVhZIjoKICAgICAgZS5zZXQobyAqIGYsIHIgKiB5LCBvICogeCwgciAqIGMpOwogICAgICBicmVhazsKICAgIGNhc2UgIlpZWiI6CiAgICAgIGUuc2V0KG8gKiB4LCBvICogZiwgciAqIHksIHIgKiBjKTsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICBjb25zb2xlLndhcm4oIlRIUkVFLk1hdGhVdGlsczogLnNldFF1YXRlcm5pb25Gcm9tUHJvcGVyRXVsZXIoKSBlbmNvdW50ZXJlZCBhbiB1bmtub3duIG9yZGVyOiAiICsgcyk7CiAgfQp9CmZ1bmN0aW9uIHBpKGUsIHQpIHsKICBzd2l0Y2ggKHQuY29uc3RydWN0b3IpIHsKICAgIGNhc2UgRmxvYXQzMkFycmF5OgogICAgICByZXR1cm4gZTsKICAgIGNhc2UgVWludDMyQXJyYXk6CiAgICAgIHJldHVybiBlIC8gNDI5NDk2NzI5NTsKICAgIGNhc2UgVWludDE2QXJyYXk6CiAgICAgIHJldHVybiBlIC8gNjU1MzU7CiAgICBjYXNlIFVpbnQ4QXJyYXk6CiAgICAgIHJldHVybiBlIC8gMjU1OwogICAgY2FzZSBJbnQzMkFycmF5OgogICAgICByZXR1cm4gTWF0aC5tYXgoZSAvIDIxNDc0ODM2NDcsIC0xKTsKICAgIGNhc2UgSW50MTZBcnJheToKICAgICAgcmV0dXJuIE1hdGgubWF4KGUgLyAzMjc2NywgLTEpOwogICAgY2FzZSBJbnQ4QXJyYXk6CiAgICAgIHJldHVybiBNYXRoLm1heChlIC8gMTI3LCAtMSk7CiAgICBkZWZhdWx0OgogICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIik7CiAgfQp9CmZ1bmN0aW9uIHdpKGUsIHQpIHsKICBzd2l0Y2ggKHQuY29uc3RydWN0b3IpIHsKICAgIGNhc2UgRmxvYXQzMkFycmF5OgogICAgICByZXR1cm4gZTsKICAgIGNhc2UgVWludDMyQXJyYXk6CiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGUgKiA0Mjk0OTY3Mjk1KTsKICAgIGNhc2UgVWludDE2QXJyYXk6CiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGUgKiA2NTUzNSk7CiAgICBjYXNlIFVpbnQ4QXJyYXk6CiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGUgKiAyNTUpOwogICAgY2FzZSBJbnQzMkFycmF5OgogICAgICByZXR1cm4gTWF0aC5yb3VuZChlICogMjE0NzQ4MzY0Nyk7CiAgICBjYXNlIEludDE2QXJyYXk6CiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGUgKiAzMjc2Nyk7CiAgICBjYXNlIEludDhBcnJheToKICAgICAgcmV0dXJuIE1hdGgucm91bmQoZSAqIDEyNyk7CiAgICBkZWZhdWx0OgogICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgY29tcG9uZW50IHR5cGUuIik7CiAgfQp9CmNvbnN0IEwgPSB7CiAgREVHMlJBRDogWHQsCiAgUkFEMkRFRzogWnQsCiAgZ2VuZXJhdGVVVUlEOiBpaSwKICBjbGFtcDogU3QsCiAgZXVjbGlkZWFuTW9kdWxvOiBqdCwKICBtYXBMaW5lYXI6IG5pLAogIGludmVyc2VMZXJwOiBlaSwKICBsZXJwOiBRdCwKICBkYW1wOiBzaSwKICBwaW5ncG9uZzogaGksCiAgc21vb3Roc3RlcDogcmksCiAgc21vb3RoZXJzdGVwOiBvaSwKICByYW5kSW50OiBhaSwKICByYW5kRmxvYXQ6IGNpLAogIHJhbmRGbG9hdFNwcmVhZDogdWksCiAgc2VlZGVkUmFuZG9tOiBkaSwKICBkZWdUb1JhZDogZmksCiAgcmFkVG9EZWc6IHlpLAogIGlzUG93ZXJPZlR3bzogeGksCiAgY2VpbFBvd2VyT2ZUd286IGxpLAogIGZsb29yUG93ZXJPZlR3bzogX2ksCiAgc2V0UXVhdGVybmlvbkZyb21Qcm9wZXJFdWxlcjogbWksCiAgbm9ybWFsaXplOiB3aSwKICBkZW5vcm1hbGl6ZTogcGkKfTsKY2xhc3MgbHQgewogIGNvbnN0cnVjdG9yKHQgPSAwLCBpID0gMCkgewogICAgbHQucHJvdG90eXBlLmlzVmVjdG9yMiA9ICEwLCB0aGlzLnggPSB0LCB0aGlzLnkgPSBpOwogIH0KICBnZXQgd2lkdGgoKSB7CiAgICByZXR1cm4gdGhpcy54OwogIH0KICBzZXQgd2lkdGgodCkgewogICAgdGhpcy54ID0gdDsKICB9CiAgZ2V0IGhlaWdodCgpIHsKICAgIHJldHVybiB0aGlzLnk7CiAgfQogIHNldCBoZWlnaHQodCkgewogICAgdGhpcy55ID0gdDsKICB9CiAgc2V0KHQsIGkpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSBpLCB0aGlzOwogIH0KICBzZXRTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQsIHRoaXMueSA9IHQsIHRoaXM7CiAgfQogIHNldFgodCkgewogICAgcmV0dXJuIHRoaXMueCA9IHQsIHRoaXM7CiAgfQogIHNldFkodCkgewogICAgcmV0dXJuIHRoaXMueSA9IHQsIHRoaXM7CiAgfQogIHNldENvbXBvbmVudCh0LCBpKSB7CiAgICBzd2l0Y2ggKHQpIHsKICAgICAgY2FzZSAwOgogICAgICAgIHRoaXMueCA9IGk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMToKICAgICAgICB0aGlzLnkgPSBpOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgICByZXR1cm4gdGhpczsKICB9CiAgZ2V0Q29tcG9uZW50KHQpIHsKICAgIHN3aXRjaCAodCkgewogICAgICBjYXNlIDA6CiAgICAgICAgcmV0dXJuIHRoaXMueDsKICAgICAgY2FzZSAxOgogICAgICAgIHJldHVybiB0aGlzLnk7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgIH0KICB9CiAgY2xvbmUoKSB7CiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy54LCB0aGlzLnkpOwogIH0KICBjb3B5KHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LngsIHRoaXMueSA9IHQueSwgdGhpczsKICB9CiAgYWRkKHQpIHsKICAgIHJldHVybiB0aGlzLnggKz0gdC54LCB0aGlzLnkgKz0gdC55LCB0aGlzOwogIH0KICBhZGRTY2FsYXIodCkgewogICAgcmV0dXJuIHRoaXMueCArPSB0LCB0aGlzLnkgKz0gdCwgdGhpczsKICB9CiAgYWRkVmVjdG9ycyh0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54ICsgaS54LCB0aGlzLnkgPSB0LnkgKyBpLnksIHRoaXM7CiAgfQogIGFkZFNjYWxlZFZlY3Rvcih0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ICs9IHQueCAqIGksIHRoaXMueSArPSB0LnkgKiBpLCB0aGlzOwogIH0KICBzdWIodCkgewogICAgcmV0dXJuIHRoaXMueCAtPSB0LngsIHRoaXMueSAtPSB0LnksIHRoaXM7CiAgfQogIHN1YlNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54IC09IHQsIHRoaXMueSAtPSB0LCB0aGlzOwogIH0KICBzdWJWZWN0b3JzKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggLSBpLngsIHRoaXMueSA9IHQueSAtIGkueSwgdGhpczsKICB9CiAgbXVsdGlwbHkodCkgewogICAgcmV0dXJuIHRoaXMueCAqPSB0LngsIHRoaXMueSAqPSB0LnksIHRoaXM7CiAgfQogIG11bHRpcGx5U2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggKj0gdCwgdGhpcy55ICo9IHQsIHRoaXM7CiAgfQogIGRpdmlkZSh0KSB7CiAgICByZXR1cm4gdGhpcy54IC89IHQueCwgdGhpcy55IC89IHQueSwgdGhpczsKICB9CiAgZGl2aWRlU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyB0KTsKICB9CiAgYXBwbHlNYXRyaXgzKHQpIHsKICAgIGNvbnN0IGkgPSB0aGlzLngsIG4gPSB0aGlzLnksIHMgPSB0LmVsZW1lbnRzOwogICAgcmV0dXJuIHRoaXMueCA9IHNbMF0gKiBpICsgc1szXSAqIG4gKyBzWzZdLCB0aGlzLnkgPSBzWzFdICogaSArIHNbNF0gKiBuICsgc1s3XSwgdGhpczsKICB9CiAgbWluKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHQueCksIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdC55KSwgdGhpczsKICB9CiAgbWF4KHQpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0aGlzLngsIHQueCksIHRoaXMueSA9IE1hdGgubWF4KHRoaXMueSwgdC55KSwgdGhpczsKICB9CiAgY2xhbXAodCwgaSkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHQueCwgTWF0aC5taW4oaS54LCB0aGlzLngpKSwgdGhpcy55ID0gTWF0aC5tYXgodC55LCBNYXRoLm1pbihpLnksIHRoaXMueSkpLCB0aGlzOwogIH0KICBjbGFtcFNjYWxhcih0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodCwgTWF0aC5taW4oaSwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQsIE1hdGgubWluKGksIHRoaXMueSkpLCB0aGlzOwogIH0KICBjbGFtcExlbmd0aCh0LCBpKSB7CiAgICBjb25zdCBuID0gdGhpcy5sZW5ndGgoKTsKICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihuIHx8IDEpLm11bHRpcGx5U2NhbGFyKE1hdGgubWF4KHQsIE1hdGgubWluKGksIG4pKSk7CiAgfQogIGZsb29yKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KSwgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpLCB0aGlzOwogIH0KICBjZWlsKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KSwgdGhpczsKICB9CiAgcm91bmQoKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSksIHRoaXM7CiAgfQogIHJvdW5kVG9aZXJvKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgudHJ1bmModGhpcy54KSwgdGhpcy55ID0gTWF0aC50cnVuYyh0aGlzLnkpLCB0aGlzOwogIH0KICBuZWdhdGUoKSB7CiAgICByZXR1cm4gdGhpcy54ID0gLXRoaXMueCwgdGhpcy55ID0gLXRoaXMueSwgdGhpczsKICB9CiAgZG90KHQpIHsKICAgIHJldHVybiB0aGlzLnggKiB0LnggKyB0aGlzLnkgKiB0Lnk7CiAgfQogIGNyb3NzKHQpIHsKICAgIHJldHVybiB0aGlzLnggKiB0LnkgLSB0aGlzLnkgKiB0Lng7CiAgfQogIGxlbmd0aFNxKCkgewogICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTsKICB9CiAgbGVuZ3RoKCkgewogICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpOwogIH0KICBtYW5oYXR0YW5MZW5ndGgoKSB7CiAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSk7CiAgfQogIG5vcm1hbGl6ZSgpIHsKICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpIHx8IDEpOwogIH0KICBhbmdsZSgpIHsKICAgIHJldHVybiBNYXRoLmF0YW4yKC10aGlzLnksIC10aGlzLngpICsgTWF0aC5QSTsKICB9CiAgYW5nbGVUbyh0KSB7CiAgICBjb25zdCBpID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIHQubGVuZ3RoU3EoKSk7CiAgICBpZiAoaSA9PT0gMCkKICAgICAgcmV0dXJuIE1hdGguUEkgLyAyOwogICAgY29uc3QgbiA9IHRoaXMuZG90KHQpIC8gaTsKICAgIHJldHVybiBNYXRoLmFjb3MoU3QobiwgLTEsIDEpKTsKICB9CiAgZGlzdGFuY2VUbyh0KSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodCkpOwogIH0KICBkaXN0YW5jZVRvU3F1YXJlZCh0KSB7CiAgICBjb25zdCBpID0gdGhpcy54IC0gdC54LCBuID0gdGhpcy55IC0gdC55OwogICAgcmV0dXJuIGkgKiBpICsgbiAqIG47CiAgfQogIG1hbmhhdHRhbkRpc3RhbmNlVG8odCkgewogICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHQueCkgKyBNYXRoLmFicyh0aGlzLnkgLSB0LnkpOwogIH0KICBzZXRMZW5ndGgodCkgewogICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCk7CiAgfQogIGxlcnAodCwgaSkgewogICAgcmV0dXJuIHRoaXMueCArPSAodC54IC0gdGhpcy54KSAqIGksIHRoaXMueSArPSAodC55IC0gdGhpcy55KSAqIGksIHRoaXM7CiAgfQogIGxlcnBWZWN0b3JzKHQsIGksIG4pIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggKyAoaS54IC0gdC54KSAqIG4sIHRoaXMueSA9IHQueSArIChpLnkgLSB0LnkpICogbiwgdGhpczsKICB9CiAgZXF1YWxzKHQpIHsKICAgIHJldHVybiB0LnggPT09IHRoaXMueCAmJiB0LnkgPT09IHRoaXMueTsKICB9CiAgZnJvbUFycmF5KHQsIGkgPSAwKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdFtpXSwgdGhpcy55ID0gdFtpICsgMV0sIHRoaXM7CiAgfQogIHRvQXJyYXkodCA9IFtdLCBpID0gMCkgewogICAgcmV0dXJuIHRbaV0gPSB0aGlzLngsIHRbaSArIDFdID0gdGhpcy55LCB0OwogIH0KICBmcm9tQnVmZmVyQXR0cmlidXRlKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LmdldFgoaSksIHRoaXMueSA9IHQuZ2V0WShpKSwgdGhpczsKICB9CiAgcm90YXRlQXJvdW5kKHQsIGkpIHsKICAgIGNvbnN0IG4gPSBNYXRoLmNvcyhpKSwgcyA9IE1hdGguc2luKGkpLCBoID0gdGhpcy54IC0gdC54LCBhID0gdGhpcy55IC0gdC55OwogICAgcmV0dXJuIHRoaXMueCA9IGggKiBuIC0gYSAqIHMgKyB0LngsIHRoaXMueSA9IGggKiBzICsgYSAqIG4gKyB0LnksIHRoaXM7CiAgfQogIHJhbmRvbSgpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLnJhbmRvbSgpLCB0aGlzLnkgPSBNYXRoLnJhbmRvbSgpLCB0aGlzOwogIH0KICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICB5aWVsZCB0aGlzLngsIHlpZWxkIHRoaXMueTsKICB9Cn0KY2xhc3MgemkgewogIGNvbnN0cnVjdG9yKHQgPSAwLCBpID0gMCwgbiA9IDAsIHMgPSAxKSB7CiAgICB0aGlzLmlzUXVhdGVybmlvbiA9ICEwLCB0aGlzLl94ID0gdCwgdGhpcy5feSA9IGksIHRoaXMuX3ogPSBuLCB0aGlzLl93ID0gczsKICB9CiAgc3RhdGljIHNsZXJwRmxhdCh0LCBpLCBuLCBzLCBoLCBhLCByKSB7CiAgICBsZXQgbyA9IG5bcyArIDBdLCBjID0gbltzICsgMV0sIHkgPSBuW3MgKyAyXSwgdSA9IG5bcyArIDNdOwogICAgY29uc3QgZCA9IGhbYSArIDBdLCBmID0gaFthICsgMV0sIHggPSBoW2EgKyAyXSwgTyA9IGhbYSArIDNdOwogICAgaWYgKHIgPT09IDApIHsKICAgICAgdFtpICsgMF0gPSBvLCB0W2kgKyAxXSA9IGMsIHRbaSArIDJdID0geSwgdFtpICsgM10gPSB1OwogICAgICByZXR1cm47CiAgICB9CiAgICBpZiAociA9PT0gMSkgewogICAgICB0W2kgKyAwXSA9IGQsIHRbaSArIDFdID0gZiwgdFtpICsgMl0gPSB4LCB0W2kgKyAzXSA9IE87CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICh1ICE9PSBPIHx8IG8gIT09IGQgfHwgYyAhPT0gZiB8fCB5ICE9PSB4KSB7CiAgICAgIGxldCBTID0gMSAtIHI7CiAgICAgIGNvbnN0IHcgPSBvICogZCArIGMgKiBmICsgeSAqIHggKyB1ICogTywgcSA9IHcgPj0gMCA/IDEgOiAtMSwgQSA9IDEgLSB3ICogdzsKICAgICAgaWYgKEEgPiBOdW1iZXIuRVBTSUxPTikgewogICAgICAgIGNvbnN0IEkgPSBNYXRoLnNxcnQoQSksIGsgPSBNYXRoLmF0YW4yKEksIHcgKiBxKTsKICAgICAgICBTID0gTWF0aC5zaW4oUyAqIGspIC8gSSwgciA9IE1hdGguc2luKHIgKiBrKSAvIEk7CiAgICAgIH0KICAgICAgY29uc3QgTiA9IHIgKiBxOwogICAgICBpZiAobyA9IG8gKiBTICsgZCAqIE4sIGMgPSBjICogUyArIGYgKiBOLCB5ID0geSAqIFMgKyB4ICogTiwgdSA9IHUgKiBTICsgTyAqIE4sIFMgPT09IDEgLSByKSB7CiAgICAgICAgY29uc3QgSSA9IDEgLyBNYXRoLnNxcnQobyAqIG8gKyBjICogYyArIHkgKiB5ICsgdSAqIHUpOwogICAgICAgIG8gKj0gSSwgYyAqPSBJLCB5ICo9IEksIHUgKj0gSTsKICAgICAgfQogICAgfQogICAgdFtpXSA9IG8sIHRbaSArIDFdID0gYywgdFtpICsgMl0gPSB5LCB0W2kgKyAzXSA9IHU7CiAgfQogIHN0YXRpYyBtdWx0aXBseVF1YXRlcm5pb25zRmxhdCh0LCBpLCBuLCBzLCBoLCBhKSB7CiAgICBjb25zdCByID0gbltzXSwgbyA9IG5bcyArIDFdLCBjID0gbltzICsgMl0sIHkgPSBuW3MgKyAzXSwgdSA9IGhbYV0sIGQgPSBoW2EgKyAxXSwgZiA9IGhbYSArIDJdLCB4ID0gaFthICsgM107CiAgICByZXR1cm4gdFtpXSA9IHIgKiB4ICsgeSAqIHUgKyBvICogZiAtIGMgKiBkLCB0W2kgKyAxXSA9IG8gKiB4ICsgeSAqIGQgKyBjICogdSAtIHIgKiBmLCB0W2kgKyAyXSA9IGMgKiB4ICsgeSAqIGYgKyByICogZCAtIG8gKiB1LCB0W2kgKyAzXSA9IHkgKiB4IC0gciAqIHUgLSBvICogZCAtIGMgKiBmLCB0OwogIH0KICBnZXQgeCgpIHsKICAgIHJldHVybiB0aGlzLl94OwogIH0KICBzZXQgeCh0KSB7CiAgICB0aGlzLl94ID0gdCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpOwogIH0KICBnZXQgeSgpIHsKICAgIHJldHVybiB0aGlzLl95OwogIH0KICBzZXQgeSh0KSB7CiAgICB0aGlzLl95ID0gdCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpOwogIH0KICBnZXQgeigpIHsKICAgIHJldHVybiB0aGlzLl96OwogIH0KICBzZXQgeih0KSB7CiAgICB0aGlzLl96ID0gdCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpOwogIH0KICBnZXQgdygpIHsKICAgIHJldHVybiB0aGlzLl93OwogIH0KICBzZXQgdyh0KSB7CiAgICB0aGlzLl93ID0gdCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpOwogIH0KICBzZXQodCwgaSwgbiwgcykgewogICAgcmV0dXJuIHRoaXMuX3ggPSB0LCB0aGlzLl95ID0gaSwgdGhpcy5feiA9IG4sIHRoaXMuX3cgPSBzLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cpOwogIH0KICBjb3B5KHQpIHsKICAgIHJldHVybiB0aGlzLl94ID0gdC54LCB0aGlzLl95ID0gdC55LCB0aGlzLl96ID0gdC56LCB0aGlzLl93ID0gdC53LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHNldEZyb21FdWxlcih0LCBpKSB7CiAgICBjb25zdCBuID0gdC5feCwgcyA9IHQuX3ksIGggPSB0Ll96LCBhID0gdC5fb3JkZXIsIHIgPSBNYXRoLmNvcywgbyA9IE1hdGguc2luLCBjID0gcihuIC8gMiksIHkgPSByKHMgLyAyKSwgdSA9IHIoaCAvIDIpLCBkID0gbyhuIC8gMiksIGYgPSBvKHMgLyAyKSwgeCA9IG8oaCAvIDIpOwogICAgc3dpdGNoIChhKSB7CiAgICAgIGNhc2UgIlhZWiI6CiAgICAgICAgdGhpcy5feCA9IGQgKiB5ICogdSArIGMgKiBmICogeCwgdGhpcy5feSA9IGMgKiBmICogdSAtIGQgKiB5ICogeCwgdGhpcy5feiA9IGMgKiB5ICogeCArIGQgKiBmICogdSwgdGhpcy5fdyA9IGMgKiB5ICogdSAtIGQgKiBmICogeDsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiWVhaIjoKICAgICAgICB0aGlzLl94ID0gZCAqIHkgKiB1ICsgYyAqIGYgKiB4LCB0aGlzLl95ID0gYyAqIGYgKiB1IC0gZCAqIHkgKiB4LCB0aGlzLl96ID0gYyAqIHkgKiB4IC0gZCAqIGYgKiB1LCB0aGlzLl93ID0gYyAqIHkgKiB1ICsgZCAqIGYgKiB4OwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJaWFkiOgogICAgICAgIHRoaXMuX3ggPSBkICogeSAqIHUgLSBjICogZiAqIHgsIHRoaXMuX3kgPSBjICogZiAqIHUgKyBkICogeSAqIHgsIHRoaXMuX3ogPSBjICogeSAqIHggKyBkICogZiAqIHUsIHRoaXMuX3cgPSBjICogeSAqIHUgLSBkICogZiAqIHg7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlpZWCI6CiAgICAgICAgdGhpcy5feCA9IGQgKiB5ICogdSAtIGMgKiBmICogeCwgdGhpcy5feSA9IGMgKiBmICogdSArIGQgKiB5ICogeCwgdGhpcy5feiA9IGMgKiB5ICogeCAtIGQgKiBmICogdSwgdGhpcy5fdyA9IGMgKiB5ICogdSArIGQgKiBmICogeDsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiWVpYIjoKICAgICAgICB0aGlzLl94ID0gZCAqIHkgKiB1ICsgYyAqIGYgKiB4LCB0aGlzLl95ID0gYyAqIGYgKiB1ICsgZCAqIHkgKiB4LCB0aGlzLl96ID0gYyAqIHkgKiB4IC0gZCAqIGYgKiB1LCB0aGlzLl93ID0gYyAqIHkgKiB1IC0gZCAqIGYgKiB4OwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJYWlkiOgogICAgICAgIHRoaXMuX3ggPSBkICogeSAqIHUgLSBjICogZiAqIHgsIHRoaXMuX3kgPSBjICogZiAqIHUgLSBkICogeSAqIHgsIHRoaXMuX3ogPSBjICogeSAqIHggKyBkICogZiAqIHUsIHRoaXMuX3cgPSBjICogeSAqIHUgKyBkICogZiAqIHg7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgY29uc29sZS53YXJuKCJUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogIiArIGEpOwogICAgfQogICAgcmV0dXJuIGkgIT09ICExICYmIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgc2V0RnJvbUF4aXNBbmdsZSh0LCBpKSB7CiAgICBjb25zdCBuID0gaSAvIDIsIHMgPSBNYXRoLnNpbihuKTsKICAgIHJldHVybiB0aGlzLl94ID0gdC54ICogcywgdGhpcy5feSA9IHQueSAqIHMsIHRoaXMuX3ogPSB0LnogKiBzLCB0aGlzLl93ID0gTWF0aC5jb3MobiksIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgc2V0RnJvbVJvdGF0aW9uTWF0cml4KHQpIHsKICAgIGNvbnN0IGkgPSB0LmVsZW1lbnRzLCBuID0gaVswXSwgcyA9IGlbNF0sIGggPSBpWzhdLCBhID0gaVsxXSwgciA9IGlbNV0sIG8gPSBpWzldLCBjID0gaVsyXSwgeSA9IGlbNl0sIHUgPSBpWzEwXSwgZCA9IG4gKyByICsgdTsKICAgIGlmIChkID4gMCkgewogICAgICBjb25zdCBmID0gMC41IC8gTWF0aC5zcXJ0KGQgKyAxKTsKICAgICAgdGhpcy5fdyA9IDAuMjUgLyBmLCB0aGlzLl94ID0gKHkgLSBvKSAqIGYsIHRoaXMuX3kgPSAoaCAtIGMpICogZiwgdGhpcy5feiA9IChhIC0gcykgKiBmOwogICAgfSBlbHNlIGlmIChuID4gciAmJiBuID4gdSkgewogICAgICBjb25zdCBmID0gMiAqIE1hdGguc3FydCgxICsgbiAtIHIgLSB1KTsKICAgICAgdGhpcy5fdyA9ICh5IC0gbykgLyBmLCB0aGlzLl94ID0gMC4yNSAqIGYsIHRoaXMuX3kgPSAocyArIGEpIC8gZiwgdGhpcy5feiA9IChoICsgYykgLyBmOwogICAgfSBlbHNlIGlmIChyID4gdSkgewogICAgICBjb25zdCBmID0gMiAqIE1hdGguc3FydCgxICsgciAtIG4gLSB1KTsKICAgICAgdGhpcy5fdyA9IChoIC0gYykgLyBmLCB0aGlzLl94ID0gKHMgKyBhKSAvIGYsIHRoaXMuX3kgPSAwLjI1ICogZiwgdGhpcy5feiA9IChvICsgeSkgLyBmOwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgZiA9IDIgKiBNYXRoLnNxcnQoMSArIHUgLSBuIC0gcik7CiAgICAgIHRoaXMuX3cgPSAoYSAtIHMpIC8gZiwgdGhpcy5feCA9IChoICsgYykgLyBmLCB0aGlzLl95ID0gKG8gKyB5KSAvIGYsIHRoaXMuX3ogPSAwLjI1ICogZjsKICAgIH0KICAgIHJldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHNldEZyb21Vbml0VmVjdG9ycyh0LCBpKSB7CiAgICBsZXQgbiA9IHQuZG90KGkpICsgMTsKICAgIHJldHVybiBuIDwgTnVtYmVyLkVQU0lMT04gPyAobiA9IDAsIE1hdGguYWJzKHQueCkgPiBNYXRoLmFicyh0LnopID8gKHRoaXMuX3ggPSAtdC55LCB0aGlzLl95ID0gdC54LCB0aGlzLl96ID0gMCwgdGhpcy5fdyA9IG4pIDogKHRoaXMuX3ggPSAwLCB0aGlzLl95ID0gLXQueiwgdGhpcy5feiA9IHQueSwgdGhpcy5fdyA9IG4pKSA6ICh0aGlzLl94ID0gdC55ICogaS56IC0gdC56ICogaS55LCB0aGlzLl95ID0gdC56ICogaS54IC0gdC54ICogaS56LCB0aGlzLl96ID0gdC54ICogaS55IC0gdC55ICogaS54LCB0aGlzLl93ID0gbiksIHRoaXMubm9ybWFsaXplKCk7CiAgfQogIGFuZ2xlVG8odCkgewogICAgcmV0dXJuIDIgKiBNYXRoLmFjb3MoTWF0aC5hYnMoU3QodGhpcy5kb3QodCksIC0xLCAxKSkpOwogIH0KICByb3RhdGVUb3dhcmRzKHQsIGkpIHsKICAgIGNvbnN0IG4gPSB0aGlzLmFuZ2xlVG8odCk7CiAgICBpZiAobiA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBjb25zdCBzID0gTWF0aC5taW4oMSwgaSAvIG4pOwogICAgcmV0dXJuIHRoaXMuc2xlcnAodCwgcyksIHRoaXM7CiAgfQogIGlkZW50aXR5KCkgewogICAgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDEpOwogIH0KICBpbnZlcnQoKSB7CiAgICByZXR1cm4gdGhpcy5jb25qdWdhdGUoKTsKICB9CiAgY29uanVnYXRlKCkgewogICAgcmV0dXJuIHRoaXMuX3ggKj0gLTEsIHRoaXMuX3kgKj0gLTEsIHRoaXMuX3ogKj0gLTEsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgZG90KHQpIHsKICAgIHJldHVybiB0aGlzLl94ICogdC5feCArIHRoaXMuX3kgKiB0Ll95ICsgdGhpcy5feiAqIHQuX3ogKyB0aGlzLl93ICogdC5fdzsKICB9CiAgbGVuZ3RoU3EoKSB7CiAgICByZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7CiAgfQogIGxlbmd0aCgpIHsKICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cpOwogIH0KICBub3JtYWxpemUoKSB7CiAgICBsZXQgdCA9IHRoaXMubGVuZ3RoKCk7CiAgICByZXR1cm4gdCA9PT0gMCA/ICh0aGlzLl94ID0gMCwgdGhpcy5feSA9IDAsIHRoaXMuX3ogPSAwLCB0aGlzLl93ID0gMSkgOiAodCA9IDEgLyB0LCB0aGlzLl94ID0gdGhpcy5feCAqIHQsIHRoaXMuX3kgPSB0aGlzLl95ICogdCwgdGhpcy5feiA9IHRoaXMuX3ogKiB0LCB0aGlzLl93ID0gdGhpcy5fdyAqIHQpLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIG11bHRpcGx5KHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModGhpcywgdCk7CiAgfQogIHByZW11bHRpcGx5KHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModCwgdGhpcyk7CiAgfQogIG11bHRpcGx5UXVhdGVybmlvbnModCwgaSkgewogICAgY29uc3QgbiA9IHQuX3gsIHMgPSB0Ll95LCBoID0gdC5feiwgYSA9IHQuX3csIHIgPSBpLl94LCBvID0gaS5feSwgYyA9IGkuX3osIHkgPSBpLl93OwogICAgcmV0dXJuIHRoaXMuX3ggPSBuICogeSArIGEgKiByICsgcyAqIGMgLSBoICogbywgdGhpcy5feSA9IHMgKiB5ICsgYSAqIG8gKyBoICogciAtIG4gKiBjLCB0aGlzLl96ID0gaCAqIHkgKyBhICogYyArIG4gKiBvIC0gcyAqIHIsIHRoaXMuX3cgPSBhICogeSAtIG4gKiByIC0gcyAqIG8gLSBoICogYywgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogIH0KICBzbGVycCh0LCBpKSB7CiAgICBpZiAoaSA9PT0gMCkKICAgICAgcmV0dXJuIHRoaXM7CiAgICBpZiAoaSA9PT0gMSkKICAgICAgcmV0dXJuIHRoaXMuY29weSh0KTsKICAgIGNvbnN0IG4gPSB0aGlzLl94LCBzID0gdGhpcy5feSwgaCA9IHRoaXMuX3osIGEgPSB0aGlzLl93OwogICAgbGV0IHIgPSBhICogdC5fdyArIG4gKiB0Ll94ICsgcyAqIHQuX3kgKyBoICogdC5fejsKICAgIGlmIChyIDwgMCA/ICh0aGlzLl93ID0gLXQuX3csIHRoaXMuX3ggPSAtdC5feCwgdGhpcy5feSA9IC10Ll95LCB0aGlzLl96ID0gLXQuX3osIHIgPSAtcikgOiB0aGlzLmNvcHkodCksIHIgPj0gMSkKICAgICAgcmV0dXJuIHRoaXMuX3cgPSBhLCB0aGlzLl94ID0gbiwgdGhpcy5feSA9IHMsIHRoaXMuX3ogPSBoLCB0aGlzOwogICAgY29uc3QgbyA9IDEgLSByICogcjsKICAgIGlmIChvIDw9IE51bWJlci5FUFNJTE9OKSB7CiAgICAgIGNvbnN0IGYgPSAxIC0gaTsKICAgICAgcmV0dXJuIHRoaXMuX3cgPSBmICogYSArIGkgKiB0aGlzLl93LCB0aGlzLl94ID0gZiAqIG4gKyBpICogdGhpcy5feCwgdGhpcy5feSA9IGYgKiBzICsgaSAqIHRoaXMuX3ksIHRoaXMuX3ogPSBmICogaCArIGkgKiB0aGlzLl96LCB0aGlzLm5vcm1hbGl6ZSgpLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICBjb25zdCBjID0gTWF0aC5zcXJ0KG8pLCB5ID0gTWF0aC5hdGFuMihjLCByKSwgdSA9IE1hdGguc2luKCgxIC0gaSkgKiB5KSAvIGMsIGQgPSBNYXRoLnNpbihpICogeSkgLyBjOwogICAgcmV0dXJuIHRoaXMuX3cgPSBhICogdSArIHRoaXMuX3cgKiBkLCB0aGlzLl94ID0gbiAqIHUgKyB0aGlzLl94ICogZCwgdGhpcy5feSA9IHMgKiB1ICsgdGhpcy5feSAqIGQsIHRoaXMuX3ogPSBoICogdSArIHRoaXMuX3ogKiBkLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgfQogIHNsZXJwUXVhdGVybmlvbnModCwgaSwgbikgewogICAgcmV0dXJuIHRoaXMuY29weSh0KS5zbGVycChpLCBuKTsKICB9CiAgcmFuZG9tKCkgewogICAgY29uc3QgdCA9IE1hdGgucmFuZG9tKCksIGkgPSBNYXRoLnNxcnQoMSAtIHQpLCBuID0gTWF0aC5zcXJ0KHQpLCBzID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpLCBoID0gMiAqIE1hdGguUEkgKiBNYXRoLnJhbmRvbSgpOwogICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICBpICogTWF0aC5jb3MocyksCiAgICAgIG4gKiBNYXRoLnNpbihoKSwKICAgICAgbiAqIE1hdGguY29zKGgpLAogICAgICBpICogTWF0aC5zaW4ocykKICAgICk7CiAgfQogIGVxdWFscyh0KSB7CiAgICByZXR1cm4gdC5feCA9PT0gdGhpcy5feCAmJiB0Ll95ID09PSB0aGlzLl95ICYmIHQuX3ogPT09IHRoaXMuX3ogJiYgdC5fdyA9PT0gdGhpcy5fdzsKICB9CiAgZnJvbUFycmF5KHQsIGkgPSAwKSB7CiAgICByZXR1cm4gdGhpcy5feCA9IHRbaV0sIHRoaXMuX3kgPSB0W2kgKyAxXSwgdGhpcy5feiA9IHRbaSArIDJdLCB0aGlzLl93ID0gdFtpICsgM10sIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICB9CiAgdG9BcnJheSh0ID0gW10sIGkgPSAwKSB7CiAgICByZXR1cm4gdFtpXSA9IHRoaXMuX3gsIHRbaSArIDFdID0gdGhpcy5feSwgdFtpICsgMl0gPSB0aGlzLl96LCB0W2kgKyAzXSA9IHRoaXMuX3csIHQ7CiAgfQogIGZyb21CdWZmZXJBdHRyaWJ1dGUodCwgaSkgewogICAgcmV0dXJuIHRoaXMuX3ggPSB0LmdldFgoaSksIHRoaXMuX3kgPSB0LmdldFkoaSksIHRoaXMuX3ogPSB0LmdldFooaSksIHRoaXMuX3cgPSB0LmdldFcoaSksIHRoaXM7CiAgfQogIHRvSlNPTigpIHsKICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKTsKICB9CiAgX29uQ2hhbmdlKHQpIHsKICAgIHJldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gdCwgdGhpczsKICB9CiAgX29uQ2hhbmdlQ2FsbGJhY2soKSB7CiAgfQogICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgIHlpZWxkIHRoaXMuX3gsIHlpZWxkIHRoaXMuX3ksIHlpZWxkIHRoaXMuX3osIHlpZWxkIHRoaXMuX3c7CiAgfQp9CmNsYXNzIG0gewogIGNvbnN0cnVjdG9yKHQgPSAwLCBpID0gMCwgbiA9IDApIHsKICAgIG0ucHJvdG90eXBlLmlzVmVjdG9yMyA9ICEwLCB0aGlzLnggPSB0LCB0aGlzLnkgPSBpLCB0aGlzLnogPSBuOwogIH0KICBzZXQodCwgaSwgbikgewogICAgcmV0dXJuIG4gPT09IHZvaWQgMCAmJiAobiA9IHRoaXMueiksIHRoaXMueCA9IHQsIHRoaXMueSA9IGksIHRoaXMueiA9IG4sIHRoaXM7CiAgfQogIHNldFNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCwgdGhpcy55ID0gdCwgdGhpcy56ID0gdCwgdGhpczsKICB9CiAgc2V0WCh0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCwgdGhpczsKICB9CiAgc2V0WSh0KSB7CiAgICByZXR1cm4gdGhpcy55ID0gdCwgdGhpczsKICB9CiAgc2V0Wih0KSB7CiAgICByZXR1cm4gdGhpcy56ID0gdCwgdGhpczsKICB9CiAgc2V0Q29tcG9uZW50KHQsIGkpIHsKICAgIHN3aXRjaCAodCkgewogICAgICBjYXNlIDA6CiAgICAgICAgdGhpcy54ID0gaTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAxOgogICAgICAgIHRoaXMueSA9IGk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMjoKICAgICAgICB0aGlzLnogPSBpOwogICAgICAgIGJyZWFrOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgICByZXR1cm4gdGhpczsKICB9CiAgZ2V0Q29tcG9uZW50KHQpIHsKICAgIHN3aXRjaCAodCkgewogICAgICBjYXNlIDA6CiAgICAgICAgcmV0dXJuIHRoaXMueDsKICAgICAgY2FzZSAxOgogICAgICAgIHJldHVybiB0aGlzLnk7CiAgICAgIGNhc2UgMjoKICAgICAgICByZXR1cm4gdGhpcy56OwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICB9CiAgfQogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLnopOwogIH0KICBjb3B5KHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LngsIHRoaXMueSA9IHQueSwgdGhpcy56ID0gdC56LCB0aGlzOwogIH0KICBhZGQodCkgewogICAgcmV0dXJuIHRoaXMueCArPSB0LngsIHRoaXMueSArPSB0LnksIHRoaXMueiArPSB0LnosIHRoaXM7CiAgfQogIGFkZFNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54ICs9IHQsIHRoaXMueSArPSB0LCB0aGlzLnogKz0gdCwgdGhpczsKICB9CiAgYWRkVmVjdG9ycyh0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54ICsgaS54LCB0aGlzLnkgPSB0LnkgKyBpLnksIHRoaXMueiA9IHQueiArIGkueiwgdGhpczsKICB9CiAgYWRkU2NhbGVkVmVjdG9yKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLnggKz0gdC54ICogaSwgdGhpcy55ICs9IHQueSAqIGksIHRoaXMueiArPSB0LnogKiBpLCB0aGlzOwogIH0KICBzdWIodCkgewogICAgcmV0dXJuIHRoaXMueCAtPSB0LngsIHRoaXMueSAtPSB0LnksIHRoaXMueiAtPSB0LnosIHRoaXM7CiAgfQogIHN1YlNjYWxhcih0KSB7CiAgICByZXR1cm4gdGhpcy54IC09IHQsIHRoaXMueSAtPSB0LCB0aGlzLnogLT0gdCwgdGhpczsKICB9CiAgc3ViVmVjdG9ycyh0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC54IC0gaS54LCB0aGlzLnkgPSB0LnkgLSBpLnksIHRoaXMueiA9IHQueiAtIGkueiwgdGhpczsKICB9CiAgbXVsdGlwbHkodCkgewogICAgcmV0dXJuIHRoaXMueCAqPSB0LngsIHRoaXMueSAqPSB0LnksIHRoaXMueiAqPSB0LnosIHRoaXM7CiAgfQogIG11bHRpcGx5U2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLnggKj0gdCwgdGhpcy55ICo9IHQsIHRoaXMueiAqPSB0LCB0aGlzOwogIH0KICBtdWx0aXBseVZlY3RvcnModCwgaSkgewogICAgcmV0dXJuIHRoaXMueCA9IHQueCAqIGkueCwgdGhpcy55ID0gdC55ICogaS55LCB0aGlzLnogPSB0LnogKiBpLnosIHRoaXM7CiAgfQogIGFwcGx5RXVsZXIodCkgewogICAgcmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKEN0LnNldEZyb21FdWxlcih0KSk7CiAgfQogIGFwcGx5QXhpc0FuZ2xlKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihDdC5zZXRGcm9tQXhpc0FuZ2xlKHQsIGkpKTsKICB9CiAgYXBwbHlNYXRyaXgzKHQpIHsKICAgIGNvbnN0IGkgPSB0aGlzLngsIG4gPSB0aGlzLnksIHMgPSB0aGlzLnosIGggPSB0LmVsZW1lbnRzOwogICAgcmV0dXJuIHRoaXMueCA9IGhbMF0gKiBpICsgaFszXSAqIG4gKyBoWzZdICogcywgdGhpcy55ID0gaFsxXSAqIGkgKyBoWzRdICogbiArIGhbN10gKiBzLCB0aGlzLnogPSBoWzJdICogaSArIGhbNV0gKiBuICsgaFs4XSAqIHMsIHRoaXM7CiAgfQogIGFwcGx5Tm9ybWFsTWF0cml4KHQpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4Myh0KS5ub3JtYWxpemUoKTsKICB9CiAgYXBwbHlNYXRyaXg0KHQpIHsKICAgIGNvbnN0IGkgPSB0aGlzLngsIG4gPSB0aGlzLnksIHMgPSB0aGlzLnosIGggPSB0LmVsZW1lbnRzLCBhID0gMSAvIChoWzNdICogaSArIGhbN10gKiBuICsgaFsxMV0gKiBzICsgaFsxNV0pOwogICAgcmV0dXJuIHRoaXMueCA9IChoWzBdICogaSArIGhbNF0gKiBuICsgaFs4XSAqIHMgKyBoWzEyXSkgKiBhLCB0aGlzLnkgPSAoaFsxXSAqIGkgKyBoWzVdICogbiArIGhbOV0gKiBzICsgaFsxM10pICogYSwgdGhpcy56ID0gKGhbMl0gKiBpICsgaFs2XSAqIG4gKyBoWzEwXSAqIHMgKyBoWzE0XSkgKiBhLCB0aGlzOwogIH0KICBhcHBseVF1YXRlcm5pb24odCkgewogICAgY29uc3QgaSA9IHRoaXMueCwgbiA9IHRoaXMueSwgcyA9IHRoaXMueiwgaCA9IHQueCwgYSA9IHQueSwgciA9IHQueiwgbyA9IHQudywgYyA9IDIgKiAoYSAqIHMgLSByICogbiksIHkgPSAyICogKHIgKiBpIC0gaCAqIHMpLCB1ID0gMiAqIChoICogbiAtIGEgKiBpKTsKICAgIHJldHVybiB0aGlzLnggPSBpICsgbyAqIGMgKyBhICogdSAtIHIgKiB5LCB0aGlzLnkgPSBuICsgbyAqIHkgKyByICogYyAtIGggKiB1LCB0aGlzLnogPSBzICsgbyAqIHUgKyBoICogeSAtIGEgKiBjLCB0aGlzOwogIH0KICBwcm9qZWN0KHQpIHsKICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkSW52ZXJzZSkuYXBwbHlNYXRyaXg0KHQucHJvamVjdGlvbk1hdHJpeCk7CiAgfQogIHVucHJvamVjdCh0KSB7CiAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQodC5wcm9qZWN0aW9uTWF0cml4SW52ZXJzZSkuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpOwogIH0KICB0cmFuc2Zvcm1EaXJlY3Rpb24odCkgewogICAgY29uc3QgaSA9IHRoaXMueCwgbiA9IHRoaXMueSwgcyA9IHRoaXMueiwgaCA9IHQuZWxlbWVudHM7CiAgICByZXR1cm4gdGhpcy54ID0gaFswXSAqIGkgKyBoWzRdICogbiArIGhbOF0gKiBzLCB0aGlzLnkgPSBoWzFdICogaSArIGhbNV0gKiBuICsgaFs5XSAqIHMsIHRoaXMueiA9IGhbMl0gKiBpICsgaFs2XSAqIG4gKyBoWzEwXSAqIHMsIHRoaXMubm9ybWFsaXplKCk7CiAgfQogIGRpdmlkZSh0KSB7CiAgICByZXR1cm4gdGhpcy54IC89IHQueCwgdGhpcy55IC89IHQueSwgdGhpcy56IC89IHQueiwgdGhpczsKICB9CiAgZGl2aWRlU2NhbGFyKHQpIHsKICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyB0KTsKICB9CiAgbWluKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHQueCksIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdC55KSwgdGhpcy56ID0gTWF0aC5taW4odGhpcy56LCB0LnopLCB0aGlzOwogIH0KICBtYXgodCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdC54KSwgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB0LnkpLCB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIHQueiksIHRoaXM7CiAgfQogIGNsYW1wKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1heCh0LngsIE1hdGgubWluKGkueCwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQueSwgTWF0aC5taW4oaS55LCB0aGlzLnkpKSwgdGhpcy56ID0gTWF0aC5tYXgodC56LCBNYXRoLm1pbihpLnosIHRoaXMueikpLCB0aGlzOwogIH0KICBjbGFtcFNjYWxhcih0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodCwgTWF0aC5taW4oaSwgdGhpcy54KSksIHRoaXMueSA9IE1hdGgubWF4KHQsIE1hdGgubWluKGksIHRoaXMueSkpLCB0aGlzLnogPSBNYXRoLm1heCh0LCBNYXRoLm1pbihpLCB0aGlzLnopKSwgdGhpczsKICB9CiAgY2xhbXBMZW5ndGgodCwgaSkgewogICAgY29uc3QgbiA9IHRoaXMubGVuZ3RoKCk7CiAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIobiB8fCAxKS5tdWx0aXBseVNjYWxhcihNYXRoLm1heCh0LCBNYXRoLm1pbihpLCBuKSkpOwogIH0KICBmbG9vcigpIHsKICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56ID0gTWF0aC5mbG9vcih0aGlzLnopLCB0aGlzOwogIH0KICBjZWlsKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KSwgdGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueiksIHRoaXM7CiAgfQogIHJvdW5kKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueiksIHRoaXM7CiAgfQogIHJvdW5kVG9aZXJvKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgudHJ1bmModGhpcy54KSwgdGhpcy55ID0gTWF0aC50cnVuYyh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnRydW5jKHRoaXMueiksIHRoaXM7CiAgfQogIG5lZ2F0ZSgpIHsKICAgIHJldHVybiB0aGlzLnggPSAtdGhpcy54LCB0aGlzLnkgPSAtdGhpcy55LCB0aGlzLnogPSAtdGhpcy56LCB0aGlzOwogIH0KICBkb3QodCkgewogICAgcmV0dXJuIHRoaXMueCAqIHQueCArIHRoaXMueSAqIHQueSArIHRoaXMueiAqIHQuejsKICB9CiAgbGVuZ3RoU3EoKSB7CiAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56OwogIH0KICBsZW5ndGgoKSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7CiAgfQogIG1hbmhhdHRhbkxlbmd0aCgpIHsKICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KSArIE1hdGguYWJzKHRoaXMueik7CiAgfQogIG5vcm1hbGl6ZSgpIHsKICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpIHx8IDEpOwogIH0KICBzZXRMZW5ndGgodCkgewogICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCk7CiAgfQogIGxlcnAodCwgaSkgewogICAgcmV0dXJuIHRoaXMueCArPSAodC54IC0gdGhpcy54KSAqIGksIHRoaXMueSArPSAodC55IC0gdGhpcy55KSAqIGksIHRoaXMueiArPSAodC56IC0gdGhpcy56KSAqIGksIHRoaXM7CiAgfQogIGxlcnBWZWN0b3JzKHQsIGksIG4pIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnggKyAoaS54IC0gdC54KSAqIG4sIHRoaXMueSA9IHQueSArIChpLnkgLSB0LnkpICogbiwgdGhpcy56ID0gdC56ICsgKGkueiAtIHQueikgKiBuLCB0aGlzOwogIH0KICBjcm9zcyh0KSB7CiAgICByZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnModGhpcywgdCk7CiAgfQogIGNyb3NzVmVjdG9ycyh0LCBpKSB7CiAgICBjb25zdCBuID0gdC54LCBzID0gdC55LCBoID0gdC56LCBhID0gaS54LCByID0gaS55LCBvID0gaS56OwogICAgcmV0dXJuIHRoaXMueCA9IHMgKiBvIC0gaCAqIHIsIHRoaXMueSA9IGggKiBhIC0gbiAqIG8sIHRoaXMueiA9IG4gKiByIC0gcyAqIGEsIHRoaXM7CiAgfQogIHByb2plY3RPblZlY3Rvcih0KSB7CiAgICBjb25zdCBpID0gdC5sZW5ndGhTcSgpOwogICAgaWYgKGkgPT09IDApCiAgICAgIHJldHVybiB0aGlzLnNldCgwLCAwLCAwKTsKICAgIGNvbnN0IG4gPSB0LmRvdCh0aGlzKSAvIGk7CiAgICByZXR1cm4gdGhpcy5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKG4pOwogIH0KICBwcm9qZWN0T25QbGFuZSh0KSB7CiAgICByZXR1cm4gTHQuY29weSh0aGlzKS5wcm9qZWN0T25WZWN0b3IodCksIHRoaXMuc3ViKEx0KTsKICB9CiAgcmVmbGVjdCh0KSB7CiAgICByZXR1cm4gdGhpcy5zdWIoTHQuY29weSh0KS5tdWx0aXBseVNjYWxhcigyICogdGhpcy5kb3QodCkpKTsKICB9CiAgYW5nbGVUbyh0KSB7CiAgICBjb25zdCBpID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3EoKSAqIHQubGVuZ3RoU3EoKSk7CiAgICBpZiAoaSA9PT0gMCkKICAgICAgcmV0dXJuIE1hdGguUEkgLyAyOwogICAgY29uc3QgbiA9IHRoaXMuZG90KHQpIC8gaTsKICAgIHJldHVybiBNYXRoLmFjb3MoU3QobiwgLTEsIDEpKTsKICB9CiAgZGlzdGFuY2VUbyh0KSB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQodCkpOwogIH0KICBkaXN0YW5jZVRvU3F1YXJlZCh0KSB7CiAgICBjb25zdCBpID0gdGhpcy54IC0gdC54LCBuID0gdGhpcy55IC0gdC55LCBzID0gdGhpcy56IC0gdC56OwogICAgcmV0dXJuIGkgKiBpICsgbiAqIG4gKyBzICogczsKICB9CiAgbWFuaGF0dGFuRGlzdGFuY2VUbyh0KSB7CiAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdC54KSArIE1hdGguYWJzKHRoaXMueSAtIHQueSkgKyBNYXRoLmFicyh0aGlzLnogLSB0LnopOwogIH0KICBzZXRGcm9tU3BoZXJpY2FsKHQpIHsKICAgIHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHModC5yYWRpdXMsIHQucGhpLCB0LnRoZXRhKTsKICB9CiAgc2V0RnJvbVNwaGVyaWNhbENvb3Jkcyh0LCBpLCBuKSB7CiAgICBjb25zdCBzID0gTWF0aC5zaW4oaSkgKiB0OwogICAgcmV0dXJuIHRoaXMueCA9IHMgKiBNYXRoLnNpbihuKSwgdGhpcy55ID0gTWF0aC5jb3MoaSkgKiB0LCB0aGlzLnogPSBzICogTWF0aC5jb3MobiksIHRoaXM7CiAgfQogIHNldEZyb21DeWxpbmRyaWNhbCh0KSB7CiAgICByZXR1cm4gdGhpcy5zZXRGcm9tQ3lsaW5kcmljYWxDb29yZHModC5yYWRpdXMsIHQudGhldGEsIHQueSk7CiAgfQogIHNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LCBpLCBuKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdCAqIE1hdGguc2luKGkpLCB0aGlzLnkgPSBuLCB0aGlzLnogPSB0ICogTWF0aC5jb3MoaSksIHRoaXM7CiAgfQogIHNldEZyb21NYXRyaXhQb3NpdGlvbih0KSB7CiAgICBjb25zdCBpID0gdC5lbGVtZW50czsKICAgIHJldHVybiB0aGlzLnggPSBpWzEyXSwgdGhpcy55ID0gaVsxM10sIHRoaXMueiA9IGlbMTRdLCB0aGlzOwogIH0KICBzZXRGcm9tTWF0cml4U2NhbGUodCkgewogICAgY29uc3QgaSA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAwKS5sZW5ndGgoKSwgbiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAxKS5sZW5ndGgoKSwgcyA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAyKS5sZW5ndGgoKTsKICAgIHJldHVybiB0aGlzLnggPSBpLCB0aGlzLnkgPSBuLCB0aGlzLnogPSBzLCB0aGlzOwogIH0KICBzZXRGcm9tTWF0cml4Q29sdW1uKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLCBpICogNCk7CiAgfQogIHNldEZyb21NYXRyaXgzQ29sdW1uKHQsIGkpIHsKICAgIHJldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLCBpICogMyk7CiAgfQogIHNldEZyb21FdWxlcih0KSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC5feCwgdGhpcy55ID0gdC5feSwgdGhpcy56ID0gdC5feiwgdGhpczsKICB9CiAgc2V0RnJvbUNvbG9yKHQpIHsKICAgIHJldHVybiB0aGlzLnggPSB0LnIsIHRoaXMueSA9IHQuZywgdGhpcy56ID0gdC5iLCB0aGlzOwogIH0KICBlcXVhbHModCkgewogICAgcmV0dXJuIHQueCA9PT0gdGhpcy54ICYmIHQueSA9PT0gdGhpcy55ICYmIHQueiA9PT0gdGhpcy56OwogIH0KICBmcm9tQXJyYXkodCwgaSA9IDApIHsKICAgIHJldHVybiB0aGlzLnggPSB0W2ldLCB0aGlzLnkgPSB0W2kgKyAxXSwgdGhpcy56ID0gdFtpICsgMl0sIHRoaXM7CiAgfQogIHRvQXJyYXkodCA9IFtdLCBpID0gMCkgewogICAgcmV0dXJuIHRbaV0gPSB0aGlzLngsIHRbaSArIDFdID0gdGhpcy55LCB0W2kgKyAyXSA9IHRoaXMueiwgdDsKICB9CiAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBpKSB7CiAgICByZXR1cm4gdGhpcy54ID0gdC5nZXRYKGkpLCB0aGlzLnkgPSB0LmdldFkoaSksIHRoaXMueiA9IHQuZ2V0WihpKSwgdGhpczsKICB9CiAgcmFuZG9tKCkgewogICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucmFuZG9tKCksIHRoaXMueSA9IE1hdGgucmFuZG9tKCksIHRoaXMueiA9IE1hdGgucmFuZG9tKCksIHRoaXM7CiAgfQogIHJhbmRvbURpcmVjdGlvbigpIHsKICAgIGNvbnN0IHQgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLCBpID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLCBuID0gTWF0aC5zcXJ0KDEgLSB0ICoqIDIpOwogICAgcmV0dXJuIHRoaXMueCA9IG4gKiBNYXRoLmNvcyhpKSwgdGhpcy55ID0gbiAqIE1hdGguc2luKGkpLCB0aGlzLnogPSB0LCB0aGlzOwogIH0KICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICB5aWVsZCB0aGlzLngsIHlpZWxkIHRoaXMueSwgeWllbGQgdGhpcy56OwogIH0KfQpjb25zdCBMdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgbSgpLCBDdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgemkoKTsKdHlwZW9mIF9fVEhSRUVfREVWVE9PTFNfXyA8ICJ1IiAmJiBfX1RIUkVFX0RFVlRPT0xTX18uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoInJlZ2lzdGVyIiwgeyBkZXRhaWw6IHsKICByZXZpc2lvbjogR3QKfSB9KSk7CnR5cGVvZiB3aW5kb3cgPCAidSIgJiYgKHdpbmRvdy5fX1RIUkVFX18gPyBjb25zb2xlLndhcm4oIldBUk5JTkc6IE11bHRpcGxlIGluc3RhbmNlcyBvZiBUaHJlZS5qcyBiZWluZyBpbXBvcnRlZC4iKSA6IHdpbmRvdy5fX1RIUkVFX18gPSBHdCk7CmZ1bmN0aW9uIEMoZSkgewogIHJldHVybiBlICE9IG51bGw7Cn0KZnVuY3Rpb24gcnQoZSwgdCkgewogIHJldHVybiBlICE9IG51bGwgPyBlIDogdDsKfQpydC5FTVBUWV9PQkpFQ1QgPSBPYmplY3QuZnJlZXplKHt9KTsKZnVuY3Rpb24gRShlKSB7CiAgdGhpcy5uYW1lID0gIkRldmVsb3BlckVycm9yIiwgdGhpcy5tZXNzYWdlID0gZTsKICBsZXQgdDsKICB0cnkgewogICAgdGhyb3cgbmV3IEVycm9yKCk7CiAgfSBjYXRjaCAoaSkgewogICAgdCA9IGkuc3RhY2s7CiAgfQogIHRoaXMuc3RhY2sgPSB0Owp9CkMoT2JqZWN0LmNyZWF0ZSkgJiYgKEUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpLCBFLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEUpOwpFLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkgewogIGxldCBlID0gdGhpcy5uYW1lICsgIjogIiArIHRoaXMubWVzc2FnZTsKICByZXR1cm4gQyh0aGlzLnN0YWNrKSAmJiAoZSArPSBgCmAgKyB0aGlzLnN0YWNrLnRvU3RyaW5nKCkpLCBlOwp9OwpFLnRocm93SW5zdGFudGlhdGlvbkVycm9yID0gZnVuY3Rpb24oKSB7CiAgdGhyb3cgbmV3IEUoCiAgICAiVGhpcyBmdW5jdGlvbiBkZWZpbmVzIGFuIGludGVyZmFjZSBhbmQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuIgogICk7Cn07CmNvbnN0IEYgPSBjbGFzcyB7CiAgc3RhdGljIGVxdWFsc0Vwc2lsb24odCwgaSwgbiwgcykgewogICAgbiA9IHJ0KG4sIDApLCBzID0gcnQocywgbik7CiAgICBjb25zdCBoID0gTWF0aC5hYnModCAtIGkpOwogICAgcmV0dXJuIGggPD0gcyB8fCBoIDw9IG4gKiBNYXRoLm1heChNYXRoLmFicyh0KSwgTWF0aC5hYnMoaSkpOwogIH0KICBzdGF0aWMgdG9SYWRpYW5zKHQpIHsKICAgIHJldHVybiBMLmRlZ1RvUmFkKHQpOwogIH0KICBzdGF0aWMgY2xhbXAodCwgaSwgbikgewogICAgcmV0dXJuIHQgPCBpID8gaSA6IHQgPiBuID8gbiA6IHQ7CiAgfQogIHN0YXRpYyBhY29zQ2xhbXBlZCh0KSB7CiAgICByZXR1cm4gTWF0aC5hY29zKEYuY2xhbXAodCwgLTEsIDEpKTsKICB9CiAgc3RhdGljIGFzaW5DbGFtcGVkKHQpIHsKICAgIHJldHVybiBNYXRoLmFzaW4oRi5jbGFtcCh0LCAtMSwgMSkpOwogIH0KICBzdGF0aWMgc2lnbih0KSB7CiAgICByZXR1cm4gTWF0aC5zaWduKHQpOwogIH0KICBzdGF0aWMgemVyb1RvVHdvUGkodCkgewogICAgaWYgKHQgPj0gMCAmJiB0IDw9IEYuVFdPX1BJKQogICAgICByZXR1cm4gdDsKICAgIGNvbnN0IGkgPSBGLm1vZCh0LCBGLlRXT19QSSk7CiAgICByZXR1cm4gTWF0aC5hYnMoaSkgPCBGLkVQU0lMT04xNCAmJiBNYXRoLmFicyh0KSA+IEYuRVBTSUxPTjE0ID8gRi5UV09fUEkgOiBpOwogIH0KICBzdGF0aWMgbW9kKHQsIGkpIHsKICAgIHJldHVybiBGLnNpZ24odCkgPT09IEYuc2lnbihpKSAmJiBNYXRoLmFicyh0KSA8IE1hdGguYWJzKGkpID8gdCA6ICh0ICUgaSArIGkpICUgaTsKICB9CiAgc3RhdGljIGNob3JkTGVuZ3RoKHQsIGkpIHsKICAgIHJldHVybiAyICogaSAqIE1hdGguc2luKHQgKiAwLjUpOwogIH0KICBzdGF0aWMgbmVnYXRpdmVQaVRvUGkodCkgewogICAgaWYgKCFDKHQpKQogICAgICB0aHJvdyBuZXcgRSgiYW5nbGUgaXMgcmVxdWlyZWQuIik7CiAgICByZXR1cm4gdCA+PSAtRi5QSSAmJiB0IDw9IEYuUEkgPyB0IDogRi56ZXJvVG9Ud29QaSh0ICsgRi5QSSkgLSBGLlBJOwogIH0KICBzdGF0aWMgbm9ybWFsaXplKHQsIGksIG4pIHsKICAgIHJldHVybiBuID0gTWF0aC5tYXgobiAtIGksIDApLCBuID09PSAwID8gMCA6IEYuY2xhbXAoKHQgLSBpKSAvIG4sIDAsIDEpOwogIH0KfTsKbGV0IF8gPSBGOwpwKF8sICJFUFNJTE9OMSIsIDAuMSksIHAoXywgIkVQU0lMT04yIiwgMC4wMSksIHAoXywgIkVQU0lMT04zIiwgMWUtMyksIHAoXywgIkVQU0lMT040IiwgMWUtNCksIHAoXywgIkVQU0lMT041IiwgMWUtNSksIHAoXywgIkVQU0lMT042IiwgMWUtNiksIHAoXywgIkVQU0lMT043IiwgMWUtNyksIHAoXywgIkVQU0lMT044IiwgMWUtOCksIHAoXywgIkVQU0lMT045IiwgMWUtOSksIHAoXywgIkVQU0lMT04xMCIsIDFlLTEwKSwgcChfLCAiRVBTSUxPTjExIiwgMWUtMTEpLCBwKF8sICJFUFNJTE9OMTIiLCAxZS0xMiksIHAoXywgIkVQU0lMT04xMyIsIDFlLTEzKSwgcChfLCAiRVBTSUxPTjE0IiwgMWUtMTQpLCBwKF8sICJFUFNJTE9OMTUiLCAxZS0xNSksIHAoXywgIkVQU0lMT04xNiIsIDFlLTE2KSwgcChfLCAiRVBTSUxPTjE3IiwgMWUtMTcpLCBwKF8sICJFUFNJTE9OMTgiLCAxZS0xOCksIHAoXywgIkVQU0lMT04xOSIsIDFlLTE5KSwgcChfLCAiRVBTSUxPTjIwIiwgMWUtMjApLCBwKF8sICJFUFNJTE9OMjEiLCAxZS0yMSksIHAoXywgIlBJIiwgTWF0aC5QSSksIHAoXywgIk9ORV9PVkVSX1BJIiwgMSAvIE1hdGguUEkpLCBwKF8sICJQSV9PVkVSX1RXTyIsIE1hdGguUEkgLyAyKSwgcChfLCAiUElfT1ZFUl9USFJFRSIsIE1hdGguUEkgLyAzKSwgcChfLCAiUElfT1ZFUl9GT1VSIiwgTWF0aC5QSSAvIDQpLCBwKF8sICJQSV9PVkVSX1NJWCIsIE1hdGguUEkgLyA2KSwgcChfLCAiVEhSRUVfUElfT1ZFUl9UV08iLCAzICogTWF0aC5QSSAvIDIpLCBwKF8sICJUV09fUEkiLCAyICogTWF0aC5QSSksIHAoXywgIk9ORV9PVkVSX1RXT19QSSIsIDEgLyAoMiAqIE1hdGguUEkpKSwgcChfLCAiUkFESUFOU19QRVJfREVHUkVFIiwgTWF0aC5QSSAvIDE4MCk7CmNsYXNzIFUgewogIGNvbnN0cnVjdG9yKHQsIGksIG4sIHMpIHsKICAgIHRoaXMud2VzdCA9IHQgfHwgMCwgdGhpcy5zb3V0aCA9IGkgfHwgMCwgdGhpcy5lYXN0ID0gbiB8fCAwLCB0aGlzLm5vcnRoID0gcyB8fCAwOwogIH0KICBnZXQgd2lkdGgoKSB7CiAgICByZXR1cm4gVS5jb21wdXRlV2lkdGgodGhpcyk7CiAgfQogIGdldCBoZWlnaHQoKSB7CiAgICByZXR1cm4gVS5jb21wdXRlSGVpZ2h0KHRoaXMpOwogIH0KfQpVLmZyb21EZWdyZWVzID0gZnVuY3Rpb24oZSwgdCwgaSwgbiwgcykgewogIHJldHVybiBlID0gTC5kZWdUb1JhZChydChlLCAwKSksIHQgPSBMLmRlZ1RvUmFkKHJ0KHQsIDApKSwgaSA9IEwuZGVnVG9SYWQocnQoaSwgMCkpLCBuID0gTC5kZWdUb1JhZChydChuLCAwKSksIEMocykgPyAocy53ZXN0ID0gZSwgcy5zb3V0aCA9IHQsIHMuZWFzdCA9IGksIHMubm9ydGggPSBuLCBzKSA6IG5ldyBVKGUsIHQsIGksIG4pOwp9OwpVLmNvbXB1dGVXaWR0aCA9IGZ1bmN0aW9uKGUpIHsKICBsZXQgdCA9IGUuZWFzdDsKICBjb25zdCBpID0gZS53ZXN0OwogIHJldHVybiB0IDwgaSAmJiAodCArPSBfLlRXT19QSSksIHQgLSBpOwp9OwpVLmNvbXB1dGVIZWlnaHQgPSBmdW5jdGlvbihlKSB7CiAgcmV0dXJuIGUubm9ydGggLSBlLnNvdXRoOwp9OwpVLmNsb25lID0gZnVuY3Rpb24oZSwgdCkgewogIGlmICghIUMoZSkpCiAgICByZXR1cm4gQyh0KSA/ICh0Lndlc3QgPSBlLndlc3QsIHQuc291dGggPSBlLnNvdXRoLCB0LmVhc3QgPSBlLmVhc3QsIHQubm9ydGggPSBlLm5vcnRoLCB0KSA6IG5ldyBVKGUud2VzdCwgZS5zb3V0aCwgZS5lYXN0LCBlLm5vcnRoKTsKfTsKVS5zb3V0aHdlc3QgPSBmdW5jdGlvbihlLCB0KSB7CiAgcmV0dXJuIEModCkgPyAodC54ID0gZS53ZXN0LCB0LnkgPSBlLnNvdXRoLCB0LnogPSAwLCB0KSA6IG5ldyBtKGUud2VzdCwgZS5zb3V0aCk7Cn07ClUubm9ydGhlYXN0ID0gZnVuY3Rpb24oZSwgdCkgewogIHJldHVybiBDKHQpID8gKHQueCA9IGUuZWFzdCwgdC55ID0gZS5ub3J0aCwgdC56ID0gMCwgdCkgOiBuZXcgbShlLmVhc3QsIGUubm9ydGgpOwp9OwpVLnNvdXRoZWFzdCA9IGZ1bmN0aW9uKGUsIHQpIHsKICByZXR1cm4gQyh0KSA/ICh0LnggPSBlLmVhc3QsIHQueSA9IGUuc291dGgsIHQueiA9IDAsIHQpIDogbmV3IG0oZS5lYXN0LCBlLnNvdXRoKTsKfTsKVS5ub3J0aHdlc3QgPSBmdW5jdGlvbihlLCB0KSB7CiAgcmV0dXJuIEModCkgPyAodC54ID0gZS53ZXN0LCB0LnkgPSBlLm5vcnRoLCB0LnogPSAwLCB0KSA6IG5ldyBtKGUud2VzdCwgZS5ub3J0aCk7Cn07ClUuY2VudGVyID0gZnVuY3Rpb24oZSwgdCkgewogIGxldCBpID0gZS5lYXN0OwogIGNvbnN0IG4gPSBlLndlc3Q7CiAgaSA8IG4gJiYgKGkgKz0gXy5UV09fUEkpOwogIGNvbnN0IHMgPSBfLm5lZ2F0aXZlUGlUb1BpKChuICsgaSkgKiAwLjUpLCBoID0gKGUuc291dGggKyBlLm5vcnRoKSAqIDAuNTsKICByZXR1cm4gQyh0KSA/ICh0LnggPSBzLCB0LnkgPSBoLCB0LnogPSAwLCB0KSA6IG5ldyBtKHMsIGgpOwp9OwpVLmNvbnRhaW5zID0gZnVuY3Rpb24oZSwgdCkgewogIGxldCBpID0gdC54OwogIGNvbnN0IG4gPSB0LnksIHMgPSBlLndlc3Q7CiAgbGV0IGggPSBlLmVhc3Q7CiAgcmV0dXJuIGggPCBzICYmIChoICs9IF8uVFdPX1BJLCBpIDwgMCAmJiAoaSArPSBfLlRXT19QSSkpLCAoaSA+IHMgfHwgXy5lcXVhbHNFcHNpbG9uKGksIHMsIF8uRVBTSUxPTjE0KSkgJiYgKGkgPCBoIHx8IF8uZXF1YWxzRXBzaWxvbihpLCBoLCBfLkVQU0lMT04xNCkpICYmIG4gPj0gZS5zb3V0aCAmJiBuIDw9IGUubm9ydGg7Cn07CmNvbnN0IER0ID0gTWF0aC5QSSArIDFlLTUsIEJ0ID0gLU1hdGguUEkgLSAxZS01LCBGdCA9IF8uUElfT1ZFUl9UV08gKyAxZS01LCBZdCA9IC1fLlBJX09WRVJfVFdPIC0gMWUtNTsKVS5mcm9tQm94ID0gZnVuY3Rpb24oZSwgdCwgaSA9ICExKSB7CiAgY29uc3QgbiA9IGUubWluLCBzID0gZS5tYXg7CiAgbGV0IGggPSBuLnggLyAxODAgKiBNYXRoLlBJLCBhID0gbi55IC8gMTgwICogTWF0aC5QSSwgciA9IHMueCAvIDE4MCAqIE1hdGguUEksIG8gPSBzLnkgLyAxODAgKiBNYXRoLlBJOwogIHJldHVybiBpICYmIChoIDwgQnQgJiYgKGggPSAtTWF0aC5QSSksIGggPiBEdCAmJiAoaCA9IE1hdGguUEkpLCBhIDwgWXQgJiYgKGEgPSAtXy5QSV9PVkVSX1RXTyksIGEgPiBGdCAmJiAoYSA9IF8uUElfT1ZFUl9UV08pLCByID4gRHQgJiYgKHIgPSBNYXRoLlBJKSwgciA8IEJ0ICYmIChyID0gLU1hdGguUEkpLCBvID4gRnQgJiYgKG8gPSBfLlBJX09WRVJfVFdPKSwgbyA8IFl0ICYmIChvID0gLV8uUElfT1ZFUl9UV08pKSwgQyh0KSA/ICh0Lndlc3QgPSBoLCB0LnNvdXRoID0gYSwgdC5lYXN0ID0gciwgdC5ub3J0aCA9IG8sIHQpIDogbmV3IFUoaCwgYSwgciwgbyk7Cn07ClUuTUFYX1ZBTFVFID0gT2JqZWN0LmZyZWV6ZSgKICBuZXcgVSgKICAgIC1NYXRoLlBJLAogICAgLV8uUElfT1ZFUl9UV08sCiAgICBNYXRoLlBJLAogICAgXy5QSV9PVkVSX1RXTwogICkKKTsKY29uc3QgTWkgPSBuZXcgbSgpLCBnaSA9IG5ldyBtKCk7CmZ1bmN0aW9uIElpKGUsIHQsIGksIG4sIHMpIHsKICBjb25zdCBoID0gZS54LCBhID0gZS55LCByID0gZS56LCBvID0gdC54LCBjID0gdC55LCB5ID0gdC56LCB1ID0gaCAqIGggKiBvICogbywgZCA9IGEgKiBhICogYyAqIGMsIGYgPSByICogciAqIHkgKiB5LCB4ID0gdSArIGQgKyBmLCBPID0gTWF0aC5zcXJ0KDEgLyB4KSwgUyA9IE1pLmNvcHkoZSkubXVsdGlwbHlTY2FsYXIoTyk7CiAgaWYgKHggPCBuKQogICAgcmV0dXJuIHMgfHwgKHMgPSBuZXcgbSgpKSwgaXNGaW5pdGUoTykgPyBzLmNvcHkoUykgOiB2b2lkIDA7CiAgY29uc3QgdyA9IGkueCwgcSA9IGkueSwgQSA9IGkueiwgTiA9IGdpOwogIE4ueCA9IFMueCAqIHcgKiAyLCBOLnkgPSBTLnkgKiBxICogMiwgTi56ID0gUy56ICogQSAqIDI7CiAgbGV0IEkgPSAoMSAtIE8pICogZS5sZW5ndGgoKSAvICgwLjUgKiBOLmxlbmd0aCgpKSwgayA9IDAsIEQsIEcsIGwsIFcsIE0sIFQsIFksIFAsIFYsIGV0LCB1dDsKICBkbyB7CiAgICBJIC09IGssIGwgPSAxIC8gKDEgKyBJICogdyksIFcgPSAxIC8gKDEgKyBJICogcSksIE0gPSAxIC8gKDEgKyBJICogQSksIFQgPSBsICogbCwgWSA9IFcgKiBXLCBQID0gTSAqIE0sIFYgPSBUICogbCwgZXQgPSBZICogVywgdXQgPSBQICogTSwgRCA9IHUgKiBUICsgZCAqIFkgKyBmICogUCAtIDEsIEcgPSB1ICogViAqIHcgKyBkICogZXQgKiBxICsgZiAqIHV0ICogQTsKICAgIGxldCB2ID0gLTIgKiBHOwogICAgayA9IEQgLyB2OwogIH0gd2hpbGUgKE1hdGguYWJzKEQpID4gMWUtMTIpOwogIHJldHVybiBzID8gKHMueCA9IGggKiBsLCBzLnkgPSBhICogVywgcy56ID0gciAqIE0sIHMpIDogbmV3IG0oCiAgICBoICogbCwKICAgIGEgKiBXLAogICAgciAqIE0KICApOwp9CmNvbnN0IFNpID0gbmV3IG0oKTsKbGV0ICQgPSBuZXcgbSgpLCBmdCA9IG5ldyBtKCk7CmNvbnN0IFRpID0gbmV3IG0oCiAgNjM3ODEzNyAqIDYzNzgxMzcsCiAgNjM3ODEzNyAqIDYzNzgxMzcsCiAgNjM1Njc1MjMxNDI0NTE3OWUtOSAqIDYzNTY3NTIzMTQyNDUxNzllLTkKKSwgSXQgPSBuZXcgbSgpLCBVdCA9IG5ldyBtKCksIGIgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IoKSB7CiAgICBwKHRoaXMsICJDT0xVTU4wUk9XMCIsIDApOwogICAgcCh0aGlzLCAiQ09MVU1OMFJPVzEiLCAxKTsKICAgIHAodGhpcywgIkNPTFVNTjBST1cyIiwgMik7CiAgICBwKHRoaXMsICJDT0xVTU4xUk9XMCIsIDMpOwogICAgcCh0aGlzLCAiQ09MVU1OMVJPVzEiLCA0KTsKICAgIHAodGhpcywgIkNPTFVNTjFST1cyIiwgNSk7CiAgICBwKHRoaXMsICJDT0xVTU4yUk9XMCIsIDYpOwogICAgcCh0aGlzLCAiQ09MVU1OMlJPVzEiLCA3KTsKICAgIHAodGhpcywgIkNPTFVNTjJST1cyIiwgOCk7CiAgfQogIHN0YXRpYyBjbG9uZSh0LCBpKSB7CiAgICBpZiAoISF0KQogICAgICByZXR1cm4gaS5jb3B5KHQpLCBpOwogIH0KICBzdGF0aWMgZXF1YWxzKHQsIGkpIHsKICAgIHJldHVybiBDKHQpICYmIEMoaSkgPyB0LmVxdWFscyhpKSA6ICExOwogIH0KICBzdGF0aWMgbm9ybWFsaXplKHQsIGkpIHsKICAgIHJldHVybiB0ID09PSBpID8gKHQubm9ybWFsaXplKCksIHQpIDogKGkuY29weSh0KSwgaS5ub3JtYWxpemUoKSwgaSk7CiAgfQogIHN0YXRpYyBhZGQodCwgaSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgbSgpKSwgbi5hZGRWZWN0b3JzKHQsIGkpOwogIH0KICBzdGF0aWMgZG90KHQsIGkpIHsKICAgIHJldHVybiB0LmRvdChpKTsKICB9CiAgc3RhdGljIGNyb3NzKHQsIGksIG4pIHsKICAgIHJldHVybiBuIHx8IChuID0gbmV3IG0oKSksIG4uY3Jvc3NWZWN0b3JzKHQsIGkpLCBuOwogIH0KICBzdGF0aWMgbWFnbml0dWRlU3F1YXJlZCh0KSB7CiAgICByZXR1cm4gdC5sZW5ndGhTcSgpOwogIH0KICBzdGF0aWMgbXVsdGlwbHlCeVNjYWxhcih0LCBpLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBtKCkpLCBuLmNvcHkodCkubXVsdGlwbHlTY2FsYXIoaSksIG47CiAgfQogIHN0YXRpYyBkaXZpZGVCeVNjYWxhcih0LCBpLCBuKSB7CiAgICByZXR1cm4gbiB8fCAobiA9IG5ldyBtKCkpLCBuLnggPSB0LnggLyBpLCBuLnkgPSB0LnkgLyBpLCBuLnogPSB0LnogLyBpLCBuOwogIH0KICBzdGF0aWMgc3VidHJhY3QodCwgaSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgbSgpKSwgbi5zdWJWZWN0b3JzKHQsIGkpLCBuOwogIH0KICBzdGF0aWMgZGlzdGFuY2UodCwgaSkgewogICAgcmV0dXJuIHQuZGlzdGFuY2VUbyhpKTsKICB9CiAgc3RhdGljIG5lZ2F0ZSh0LCBpKSB7CiAgICByZXR1cm4gaSB8fCAoaSA9IG5ldyBtKCkpLCBpLmNvcHkodCksIGkubmVnYXRlKCksIGk7CiAgfQogIHN0YXRpYyBtdWx0aXBseUNvbXBvbmVudHModCwgaSwgbikgewogICAgcmV0dXJuIG4gfHwgKG4gPSBuZXcgbSgpKSwgbi5tdWx0aXBseVZlY3RvcnModCwgaSksIG47CiAgfQogIHN0YXRpYyBtYWduaXR1ZGUodCkgewogICAgcmV0dXJuIHQubGVuZ3RoKCk7CiAgfQogIHN0YXRpYyBlcXVhbHNFcHNpbG9uKHQsIGksIG4sIHMpIHsKICAgIHJldHVybiB0ID09PSBpIHx8IEModCkgJiYgQyhpKSAmJiBfLmVxdWFsc0Vwc2lsb24oCiAgICAgIHQueCwKICAgICAgaS54LAogICAgICBuLAogICAgICBzCiAgICApICYmIF8uZXF1YWxzRXBzaWxvbigKICAgICAgdC55LAogICAgICBpLnksCiAgICAgIG4sCiAgICAgIHMKICAgICkgJiYgXy5lcXVhbHNFcHNpbG9uKAogICAgICB0LnosCiAgICAgIGkueiwKICAgICAgbiwKICAgICAgcwogICAgKTsKICB9CiAgc3RhdGljIGZyb21DYXJ0ZXNpYW40KHQsIGkpIHsKICAgIHJldHVybiBpIHx8IChpID0gbmV3IG0oKSksIGkuc2V0KHQueCwgdC55LCB0LnopLCBpOwogIH0KICBzdGF0aWMgZnJvbUVsZW1lbnRzKHQsIGksIG4sIHMpIHsKICAgIHJldHVybiBzIHx8IChzID0gbmV3IG0oKSksIHMuc2V0KHQsIGksIG4pLCBzOwogIH0KICBzdGF0aWMgZnJvbVJhZGlhbnModCwgaSwgbiwgcywgaCkgewogICAgbiA9IHJ0KG4sIDApOwogICAgY29uc3QgYSA9IEMocykgPyBzLnJhZGlpU3F1YXJlZCA6IFRpLCByID0gTWF0aC5jb3MoaSk7CiAgICAkLnggPSByICogTWF0aC5jb3ModCksICQueSA9IHIgKiBNYXRoLnNpbih0KSwgJC56ID0gTWF0aC5zaW4oaSksICQgPSBiLm5vcm1hbGl6ZSgkLCAkKSwgYi5tdWx0aXBseUNvbXBvbmVudHMoYSwgJCwgZnQpOwogICAgY29uc3QgbyA9IE1hdGguc3FydChiLmRvdCgkLCBmdCkpOwogICAgcmV0dXJuIGZ0ID0gYi5kaXZpZGVCeVNjYWxhcihmdCwgbywgZnQpLCAkID0gYi5tdWx0aXBseUJ5U2NhbGFyKCQsIG4sICQpLCBDKGgpIHx8IChoID0gbmV3IG0oKSksIGIuYWRkKGZ0LCAkLCBoKTsKICB9CiAgc3RhdGljIGFuZ2xlQmV0d2Vlbih0LCBpKSB7CiAgICBiLm5vcm1hbGl6ZSh0LCBJdCksIGIubm9ybWFsaXplKGksIFV0KTsKICAgIGNvbnN0IG4gPSBiLmRvdChJdCwgVXQpLCBzID0gYi5tYWduaXR1ZGUoCiAgICAgIGIuY3Jvc3MoCiAgICAgICAgSXQsCiAgICAgICAgVXQsCiAgICAgICAgSXQKICAgICAgKQogICAgKTsKICAgIHJldHVybiBNYXRoLmF0YW4yKHMsIG4pOwogIH0KICBzdGF0aWMgZnJvbURlZ3JlZXModCwgaSwgbiwgcywgaCkgewogICAgcmV0dXJuIHQgPSBfLnRvUmFkaWFucyh0KSwgaSA9IF8udG9SYWRpYW5zKGkpLCBiLmZyb21SYWRpYW5zKHQsIGksIG4sIHMsIGgpOwogIH0KfTsKbGV0IGogPSBiOwpwKGosICJaRVJPIiwgT2JqZWN0LmZyZWV6ZShuZXcgbSgpKSksIHAoaiwgIlVOSVRfWCIsIE9iamVjdC5mcmVlemUobmV3IG0oMSwgMCwgMCkpKSwgcChqLCAiVU5JVF9ZIiwgT2JqZWN0LmZyZWV6ZShuZXcgbSgwLCAxLCAwKSkpLCBwKGosICJVTklUX1oiLCBPYmplY3QuZnJlZXplKG5ldyBtKDAsIDAsIDEpKSksIHAoaiwgImFicyIsIGZ1bmN0aW9uKHQsIGkpIHsKICByZXR1cm4gaS54ID0gTWF0aC5hYnModC54KSwgaS55ID0gTWF0aC5hYnModC55KSwgaS56ID0gTWF0aC5hYnModC56KSwgaTsKfSksIHAoaiwgIm1vc3RPcnRob2dvbmFsQXhpcyIsIGZ1bmN0aW9uKHQsIGkpIHsKICBjb25zdCBuID0gYi5ub3JtYWxpemUodCwgU2kpOwogIHJldHVybiBiLmFicyhuLCBuKSwgbi54IDw9IG4ueSA/IG4ueCA8PSBuLnogPyBpID0gYi5jbG9uZShiLlVOSVRfWCwgaSkgOiBpID0gYi5jbG9uZShiLlVOSVRfWiwgaSkgOiBuLnkgPD0gbi56ID8gaSA9IGIuY2xvbmUoYi5VTklUX1ksIGkpIDogaSA9IGIuY2xvbmUoYi5VTklUX1osIGkpLCBpOwp9KTsKY29uc3Qga3QgPSBuZXcgbSgpLCBFaSA9IG5ldyBtKCk7CmNsYXNzIHh0IHsKICBjb25zdHJ1Y3Rvcih0LCBpLCBuKSB7CiAgICB0aGlzLl9yYWRpaSA9IG5ldyBtKHQsIGksIG4pLCB0aGlzLl9yYWRpaVNxdWFyZWQgPSBuZXcgbSh0ICogdCwgaSAqIGksIG4gKiBuKSwgdGhpcy5fcmFkaWlUb1RoZUZvdXJ0aCA9IG5ldyBtKAogICAgICB0ICogdCAqIHQgKiB0LAogICAgICBpICogaSAqIGkgKiBpLAogICAgICBuICogbiAqIG4gKiBuCiAgICApLCB0aGlzLl9vbmVPdmVyUmFkaWkgPSBuZXcgbSgKICAgICAgdCA9PT0gMCA/IDAgOiAxIC8gdCwKICAgICAgaSA9PT0gMCA/IDAgOiAxIC8gaSwKICAgICAgbiA9PT0gMCA/IDAgOiAxIC8gbgogICAgKSwgdGhpcy5fb25lT3ZlclJhZGlpU3F1YXJlZCA9IG5ldyBtKAogICAgICB0ID09PSAwID8gMCA6IDEgLyAodCAqIHQpLAogICAgICBpID09PSAwID8gMCA6IDEgLyAoaSAqIGkpLAogICAgICBuID09PSAwID8gMCA6IDEgLyAobiAqIG4pCiAgICApLCB0aGlzLl9taW5pbXVtUmFkaXVzID0gTWF0aC5taW4odCwgaSwgbiksIHRoaXMuX21heGltdW1SYWRpdXMgPSBNYXRoLm1heCh0LCBpLCBuKSwgdGhpcy5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZCA9IDAuMSwgdGhpcy5fcmFkaWlTcXVhcmVkLnogIT09IDAgJiYgKHRoaXMuX3NxdWFyZWRYT3ZlclNxdWFyZWRaID0gdGhpcy5fcmFkaWlTcXVhcmVkLnggLyB0aGlzLl9yYWRpaVNxdWFyZWQueik7CiAgfQogIHN0YXRpYyBmcm9tQ2FydGVzaWFuMyh0KSB7CiAgICByZXR1cm4gbmV3IHh0KHQueCwgdC55LCB0LnopOwogIH0KICBnZW9kZXRpY1N1cmZhY2VOb3JtYWxDYXJ0b2dyYXBoaWModCwgaSkgewogICAgaSB8fCAoaSA9IG5ldyBtKCkpOwogICAgY29uc3QgbiA9IHQueCwgcyA9IHQueSwgaCA9IE1hdGguY29zKHMpLCBhID0gaCAqIE1hdGguY29zKG4pLCByID0gaCAqIE1hdGguc2luKG4pLCBvID0gTWF0aC5zaW4ocyk7CiAgICByZXR1cm4gaS5zZXQoYSwgciwgbyksIGkubm9ybWFsaXplKCksIGk7CiAgfQogIGNhcnRvZ3JhcGhpY0RlZ3JlZVRvQ2FydGVzaWFuKHQsIGkpIHsKICAgIHJldHVybiBrdC5zZXQoCiAgICAgIEwuZGVnVG9SYWQodC54KSwKICAgICAgTC5kZWdUb1JhZCh0LnkpLAogICAgICB0LnoKICAgICksIHRoaXMuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oa3QsIGkpOwogIH0KICBjYXJ0b2dyYXBoaWNUb0NhcnRlc2lhbih0LCBpKSB7CiAgICBjb25zdCBuID0gdGhpcy5nZW9kZXRpY1N1cmZhY2VOb3JtYWxDYXJ0b2dyYXBoaWModCk7CiAgICBpIHx8IChpID0gbmV3IG0oKSksIGkubXVsdGlwbHlWZWN0b3JzKHRoaXMuX3JhZGlpU3F1YXJlZCwgbik7CiAgICBjb25zdCBzID0gTWF0aC5zcXJ0KG4uY2xvbmUoKS5kb3QoaSkpOwogICAgcmV0dXJuIGkuZGl2aWRlU2NhbGFyKHMpLCBuLm11bHRpcGx5U2NhbGFyKHQueiksIGkuYWRkKG4pLCBpOwogIH0KICBjYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpY0RlZ3JlZSh0LCBpKSB7CiAgICBjb25zdCBuID0gdGhpcy5jYXJ0ZXNpYW5Ub0NhcnRvZ3JhcGhpYyh0LCBpKTsKICAgIGlmICghIW4pCiAgICAgIHJldHVybiBpID0gbiwgaS54ID0gTC5yYWRUb0RlZyhpLngpLCBpLnkgPSBMLnJhZFRvRGVnKGkueSksIGk7CiAgfQogIHNjYWxlVG9HZW9kZXRpY1N1cmZhY2UodCwgaSkgewogICAgcmV0dXJuIElpKAogICAgICB0LAogICAgICB0aGlzLl9vbmVPdmVyUmFkaWksCiAgICAgIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQsCiAgICAgIHRoaXMuX2NlbnRlclRvbGVyYW5jZVNxdWFyZWQsCiAgICAgIGkKICAgICk7CiAgfQogIHNjYWxlVG9HZW9jZW50cmljU3VyZmFjZSh0LCBpKSB7CiAgICBpIHx8IChpID0gbmV3IG0oKSk7CiAgICBjb25zdCBuID0gdC54LCBzID0gdC55LCBoID0gdC56LCBhID0gdGhpcy5fb25lT3ZlclJhZGlpU3F1YXJlZCwgciA9IDEgLyBNYXRoLnNxcnQoCiAgICAgIG4gKiBuICogYS54ICsgcyAqIHMgKiBhLnkgKyBoICogaCAqIGEuegogICAgKTsKICAgIHJldHVybiBpLmNvcHkodCkubXVsdGlwbHlTY2FsYXIocik7CiAgfQogIGNhcnRlc2lhblRvQ2FydG9ncmFwaGljKHQsIGkpIHsKICAgIGNvbnN0IG4gPSB0aGlzLnNjYWxlVG9HZW9kZXRpY1N1cmZhY2UoCiAgICAgIHQsCiAgICAgIEVpCiAgICApOwogICAgaWYgKCFuKQogICAgICByZXR1cm47CiAgICBjb25zdCBzID0gdGhpcy5nZW9kZXRpY1N1cmZhY2VOb3JtYWwobiksIGggPSB0LmNsb25lKCk7CiAgICBoLnN1YihuKTsKICAgIGNvbnN0IGEgPSBNYXRoLmF0YW4yKHMueSwgcy54KSwgciA9IE1hdGguYXNpbihzLnopLCBvID0gTWF0aC5zaWduKGguZG90KHQpKSAqIGgubGVuZ3RoKCk7CiAgICByZXR1cm4gaSB8fCAoaSA9IG5ldyBtKCkpLCBpLnNldChhLCByLCBvKSwgaTsKICB9CiAgZ2VvZGV0aWNTdXJmYWNlTm9ybWFsKHQsIGkpIHsKICAgIHJldHVybiBDKGkpIHx8IChpID0gbmV3IG0oKSksIGkubXVsdGlwbHlWZWN0b3JzKHQsIHRoaXMuX29uZU92ZXJSYWRpaVNxdWFyZWQpLCBpLm5vcm1hbGl6ZSgpLCBpOwogIH0KICBnZXRTdXJmYWNlTm9ybWFsSW50ZXJzZWN0aW9uV2l0aFpBeGlzKHQsIGksIG4pIHsKICAgIGkgPSBydChpLCAwKTsKICAgIGNvbnN0IHMgPSB0aGlzLl9zcXVhcmVkWE92ZXJTcXVhcmVkWjsKICAgIGlmIChDKG4pIHx8IChuID0gbmV3IG0oKSksIG4ueCA9IDAsIG4ueSA9IDAsIG4ueiA9IHQueiAqICgxIC0gcyksICEoTWF0aC5hYnMobi56KSA+PSB0aGlzLl9yYWRpaS56IC0gaSkpCiAgICAgIHJldHVybiBuOwogIH0KICB0cmFuc2Zvcm1Qb3NpdGlvblRvU2NhbGVkU3BhY2UodCwgaSkgewogICAgcmV0dXJuIGoubXVsdGlwbHlDb21wb25lbnRzKHQsIHRoaXMuX29uZU92ZXJSYWRpaSwgaSk7CiAgfQogIHN0YXRpYyBjbG9uZSh0LCBpKSB7CiAgICBpZiAoIXQpCiAgICAgIHJldHVybjsKICAgIGNvbnN0IG4gPSB0Ll9yYWRpaTsKICAgIHJldHVybiBpID8gKGouY2xvbmUobiwgaS5fcmFkaWkpLCBqLmNsb25lKHQuX3JhZGlpU3F1YXJlZCwgaS5fcmFkaWlTcXVhcmVkKSwgai5jbG9uZSh0Ll9yYWRpaVRvVGhlRm91cnRoLCBpLl9yYWRpaVRvVGhlRm91cnRoKSwgai5jbG9uZSh0Ll9vbmVPdmVyUmFkaWksIGkuX29uZU92ZXJSYWRpaSksIGouY2xvbmUodC5fb25lT3ZlclJhZGlpU3F1YXJlZCwgaS5fb25lT3ZlclJhZGlpU3F1YXJlZCksIGkuX21pbmltdW1SYWRpdXMgPSB0Ll9taW5pbXVtUmFkaXVzLCBpLl9tYXhpbXVtUmFkaXVzID0gdC5fbWF4aW11bVJhZGl1cywgaS5fY2VudGVyVG9sZXJhbmNlU3F1YXJlZCA9IHQuX2NlbnRlclRvbGVyYW5jZVNxdWFyZWQsIGkpIDogbmV3IHh0KG4ueCwgbi55LCBuLnopOwogIH0KICBnZXQgcmFkaWkoKSB7CiAgICByZXR1cm4gdGhpcy5fcmFkaWk7CiAgfQogIGdldCByYWRpaVNxdWFyZWQoKSB7CiAgICByZXR1cm4gdGhpcy5fcmFkaWlTcXVhcmVkOwogIH0KICBnZXQgcmFkaWlUb1RoZUZvdXJ0aCgpIHsKICAgIHJldHVybiB0aGlzLnJhZGlpVG9UaGVGb3VydGg7CiAgfQogIGdldCBvbmVPdmVyUmFkaWkoKSB7CiAgICByZXR1cm4gdGhpcy5fb25lT3ZlclJhZGlpOwogIH0KICBnZXQgb25lT3ZlclJhZGlpU3F1YXJlZCgpIHsKICAgIHJldHVybiB0aGlzLl9vbmVPdmVyUmFkaWlTcXVhcmVkOwogIH0KICBnZXQgbWF4aW11bVJhZGl1cygpIHsKICAgIHJldHVybiB0aGlzLl9tYXhpbXVtUmFkaXVzOwogIH0KICBnZXQgbWluaW11bVJhZGl1cygpIHsKICAgIHJldHVybiB0aGlzLl9taW5pbXVtUmFkaXVzOwogIH0KfQp4dC5XR1M4NCA9IE9iamVjdC5mcmVlemUoCiAgbmV3IHh0KDYzNzgxMzcsIDYzNzgxMzcsIDYzNTY3NTIzMTQyNDUxNzllLTkpCik7CmZ1bmN0aW9uIGcoZSkgewogIHJldHVybiBlICE9IG51bGw7Cn0KY29uc3QgeXQgPSB7fTsKeXQuY2xpcFRyaWFuZ2xlQXRBeGlzQWxpZ25lZFRocmVzaG9sZCA9IGZ1bmN0aW9uKGUsIHQsIGksIG4sIHMsIGgpIHsKICBpZiAoIWcoZSkpCiAgICB0aHJvdyBuZXcgRSgidGhyZXNob2xkIGlzIHJlcXVpcmVkLiIpOwogIGlmICghZyh0KSkKICAgIHRocm93IG5ldyBFKCJrZWVwQWJvdmUgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFnKGkpKQogICAgdGhyb3cgbmV3IEUoInUwIGlzIHJlcXVpcmVkLiIpOwogIGlmICghZyhuKSkKICAgIHRocm93IG5ldyBFKCJ1MSBpcyByZXF1aXJlZC4iKTsKICBpZiAoIWcocykpCiAgICB0aHJvdyBuZXcgRSgidTIgaXMgcmVxdWlyZWQuIik7CiAgZyhoKSA/IGgubGVuZ3RoID0gMCA6IGggPSBbXTsKICBsZXQgYSwgciwgbzsKICB0ID8gKGEgPSBpIDwgZSwgciA9IG4gPCBlLCBvID0gcyA8IGUpIDogKGEgPSBpID4gZSwgciA9IG4gPiBlLCBvID0gcyA+IGUpOwogIGNvbnN0IGMgPSBhICsgciArIG87CiAgbGV0IHksIHUsIGQsIGYsIHgsIE87CiAgcmV0dXJuIGMgPT09IDEgPyBhID8gKHkgPSAoZSAtIGkpIC8gKG4gLSBpKSwgdSA9IChlIC0gaSkgLyAocyAtIGkpLCBoLnB1c2goMSksIGgucHVzaCgyKSwgdSAhPT0gMSAmJiAoaC5wdXNoKC0xKSwgaC5wdXNoKDApLCBoLnB1c2goMiksIGgucHVzaCh1KSksIHkgIT09IDEgJiYgKGgucHVzaCgtMSksIGgucHVzaCgwKSwgaC5wdXNoKDEpLCBoLnB1c2goeSkpKSA6IHIgPyAoZCA9IChlIC0gbikgLyAocyAtIG4pLCBmID0gKGUgLSBuKSAvIChpIC0gbiksIGgucHVzaCgyKSwgaC5wdXNoKDApLCBmICE9PSAxICYmIChoLnB1c2goLTEpLCBoLnB1c2goMSksIGgucHVzaCgwKSwgaC5wdXNoKGYpKSwgZCAhPT0gMSAmJiAoaC5wdXNoKC0xKSwgaC5wdXNoKDEpLCBoLnB1c2goMiksIGgucHVzaChkKSkpIDogbyAmJiAoeCA9IChlIC0gcykgLyAoaSAtIHMpLCBPID0gKGUgLSBzKSAvIChuIC0gcyksIGgucHVzaCgwKSwgaC5wdXNoKDEpLCBPICE9PSAxICYmIChoLnB1c2goLTEpLCBoLnB1c2goMiksIGgucHVzaCgxKSwgaC5wdXNoKE8pKSwgeCAhPT0gMSAmJiAoaC5wdXNoKC0xKSwgaC5wdXNoKDIpLCBoLnB1c2goMCksIGgucHVzaCh4KSkpIDogYyA9PT0gMiA/ICFhICYmIGkgIT09IGUgPyAoZiA9IChlIC0gbikgLyAoaSAtIG4pLCB4ID0gKGUgLSBzKSAvIChpIC0gcyksIGgucHVzaCgwKSwgaC5wdXNoKC0xKSwgaC5wdXNoKDEpLCBoLnB1c2goMCksIGgucHVzaChmKSwgaC5wdXNoKC0xKSwgaC5wdXNoKDIpLCBoLnB1c2goMCksIGgucHVzaCh4KSkgOiAhciAmJiBuICE9PSBlID8gKE8gPSAoZSAtIHMpIC8gKG4gLSBzKSwgeSA9IChlIC0gaSkgLyAobiAtIGkpLCBoLnB1c2goMSksIGgucHVzaCgtMSksIGgucHVzaCgyKSwgaC5wdXNoKDEpLCBoLnB1c2goTyksIGgucHVzaCgtMSksIGgucHVzaCgwKSwgaC5wdXNoKDEpLCBoLnB1c2goeSkpIDogIW8gJiYgcyAhPT0gZSAmJiAodSA9IChlIC0gaSkgLyAocyAtIGkpLCBkID0gKGUgLSBuKSAvIChzIC0gbiksIGgucHVzaCgyKSwgaC5wdXNoKC0xKSwgaC5wdXNoKDApLCBoLnB1c2goMiksIGgucHVzaCh1KSwgaC5wdXNoKC0xKSwgaC5wdXNoKDEpLCBoLnB1c2goMiksIGgucHVzaChkKSkgOiBjICE9PSAzICYmIChoLnB1c2goMCksIGgucHVzaCgxKSwgaC5wdXNoKDIpKSwgaDsKfTsKeXQuY29tcHV0ZUJhcnljZW50cmljQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbihlLCB0LCBpLCBuLCBzLCBoLCBhLCByLCBvKSB7CiAgaWYgKCFnKGUpKQogICAgdGhyb3cgbmV3IEUoInggaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFnKHQpKQogICAgdGhyb3cgbmV3IEUoInkgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFnKGkpKQogICAgdGhyb3cgbmV3IEUoIngxIGlzIHJlcXVpcmVkLiIpOwogIGlmICghZyhuKSkKICAgIHRocm93IG5ldyBFKCJ5MSBpcyByZXF1aXJlZC4iKTsKICBpZiAoIWcocykpCiAgICB0aHJvdyBuZXcgRSgieDIgaXMgcmVxdWlyZWQuIik7CiAgaWYgKCFnKGgpKQogICAgdGhyb3cgbmV3IEUoInkyIGlzIHJlcXVpcmVkLiIpOwogIGlmICghZyhhKSkKICAgIHRocm93IG5ldyBFKCJ4MyBpcyByZXF1aXJlZC4iKTsKICBpZiAoIWcocikpCiAgICB0aHJvdyBuZXcgRSgieTMgaXMgcmVxdWlyZWQuIik7CiAgY29uc3QgYyA9IGkgLSBhLCB5ID0gYSAtIHMsIHUgPSBoIC0gciwgZCA9IG4gLSByLCBmID0gMSAvICh1ICogYyArIHkgKiBkKSwgeCA9IHQgLSByLCBPID0gZSAtIGEsIFMgPSAodSAqIE8gKyB5ICogeCkgKiBmLCB3ID0gKC1kICogTyArIGMgKiB4KSAqIGYsIHEgPSAxIC0gUyAtIHc7CiAgcmV0dXJuIGcobykgPyAoby54ID0gUywgby55ID0gdywgby56ID0gcSwgbykgOiBuZXcgbShTLCB3LCBxKTsKfTsKeXQuY29tcHV0ZUxpbmVTZWdtZW50TGluZVNlZ21lbnRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihlLCB0LCBpLCBuLCBzLCBoLCBhLCByLCBvKSB7CiAgY29uc3QgYyA9IChhIC0gcykgKiAodCAtIGgpIC0gKHIgLSBoKSAqIChlIC0gcyksIHkgPSAoaSAtIGUpICogKHQgLSBoKSAtIChuIC0gdCkgKiAoZSAtIHMpLCB1ID0gKHIgLSBoKSAqIChpIC0gZSkgLSAoYSAtIHMpICogKG4gLSB0KTsKICBpZiAodSA9PT0gMCkKICAgIHJldHVybjsKICBjb25zdCBkID0gYyAvIHUsIGYgPSB5IC8gdTsKICBpZiAoZCA+PSAwICYmIGQgPD0gMSAmJiBmID49IDAgJiYgZiA8PSAxKQogICAgcmV0dXJuIGcobykgfHwgKG8gPSBuZXcgbHQoKSksIG8ueCA9IGUgKyBkICogKGkgLSBlKSwgby55ID0gdCArIGQgKiAobiAtIHQpLCBvOwp9Owpjb25zdCBCID0gewogIFVOU0lHTkVEX0JZVEU6IDUxMjEsCiAgVU5TSUdORURfU0hPUlQ6IDUxMjMsCiAgVU5TSUdORURfSU5UOiA1MTI1Cn07CkIuZ2V0U2l6ZUluQnl0ZXMgPSBmdW5jdGlvbihlKSB7CiAgc3dpdGNoIChlKSB7CiAgICBjYXNlIEIuVU5TSUdORURfQllURToKICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7CiAgICBjYXNlIEIuVU5TSUdORURfU0hPUlQ6CiAgICAgIHJldHVybiBVaW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICAgIGNhc2UgQi5VTlNJR05FRF9JTlQ6CiAgICAgIHJldHVybiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDsKICB9CiAgdGhyb3cgbmV3IEUoCiAgICAiaW5kZXhEYXRhdHlwZSBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHZhbGlkIEluZGV4RGF0YXR5cGUgY29uc3RhbnQuIgogICk7Cn07CkIuZnJvbVNpemVJbkJ5dGVzID0gZnVuY3Rpb24oZSkgewogIHN3aXRjaCAoZSkgewogICAgY2FzZSAyOgogICAgICByZXR1cm4gQi5VTlNJR05FRF9TSE9SVDsKICAgIGNhc2UgNDoKICAgICAgcmV0dXJuIEIuVU5TSUdORURfSU5UOwogICAgY2FzZSAxOgogICAgICByZXR1cm4gQi5VTlNJR05FRF9CWVRFOwogICAgZGVmYXVsdDoKICAgICAgdGhyb3cgbmV3IEUoCiAgICAgICAgIlNpemUgaW4gYnl0ZXMgY2Fubm90IGJlIG1hcHBlZCB0byBhbiBJbmRleERhdGF0eXBlIgogICAgICApOwogIH0KfTsKQi52YWxpZGF0ZSA9IGZ1bmN0aW9uKGUpIHsKICByZXR1cm4gZyhlKSAmJiAoZSA9PT0gQi5VTlNJR05FRF9CWVRFIHx8IGUgPT09IEIuVU5TSUdORURfU0hPUlQgfHwgZSA9PT0gQi5VTlNJR05FRF9JTlQpOwp9OwpCLmNyZWF0ZVR5cGVkQXJyYXkgPSBmdW5jdGlvbihlLCB0KSB7CiAgaWYgKCFnKGUpKQogICAgdGhyb3cgbmV3IEUoIm51bWJlck9mVmVydGljZXMgaXMgcmVxdWlyZWQuIik7CiAgcmV0dXJuIGUgPj0gXy5TSVhUWV9GT1VSX0tJTE9CWVRFUyA/IG5ldyBVaW50MzJBcnJheSh0KSA6IG5ldyBVaW50MTZBcnJheSh0KTsKfTsKQi5jcmVhdGVUeXBlZEFycmF5RnJvbUFycmF5QnVmZmVyID0gZnVuY3Rpb24oZSwgdCwgaSwgbikgewogIGlmICghZyhlKSkKICAgIHRocm93IG5ldyBFKCJudW1iZXJPZlZlcnRpY2VzIGlzIHJlcXVpcmVkLiIpOwogIGlmICghZyh0KSkKICAgIHRocm93IG5ldyBFKCJzb3VyY2VBcnJheSBpcyByZXF1aXJlZC4iKTsKICBpZiAoIWcoaSkpCiAgICB0aHJvdyBuZXcgRSgiYnl0ZU9mZnNldCBpcyByZXF1aXJlZC4iKTsKICByZXR1cm4gZSA+PSBfLlNJWFRZX0ZPVVJfS0lMT0JZVEVTID8gbmV3IFVpbnQzMkFycmF5KHQsIGksIG4pIDogbmV3IFVpbnQxNkFycmF5KHQsIGksIG4pOwp9OwpCLmZyb21UeXBlZEFycmF5ID0gZnVuY3Rpb24oZSkgewogIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSkKICAgIHJldHVybiBCLlVOU0lHTkVEX0JZVEU7CiAgaWYgKGUgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkKICAgIHJldHVybiBCLlVOU0lHTkVEX1NIT1JUOwogIGlmIChlIGluc3RhbmNlb2YgVWludDMyQXJyYXkpCiAgICByZXR1cm4gQi5VTlNJR05FRF9JTlQ7CiAgdGhyb3cgbmV3IEUoCiAgICAiYXJyYXkgbXVzdCBiZSBhIFVpbnQ4QXJyYXksIFVpbnQxNkFycmF5LCBvciBVaW50MzJBcnJheS4iCiAgKTsKfTsKdmFyIEt0ID0gT2JqZWN0LmZyZWV6ZShCKTsKY2xhc3MgSiB7CiAgY29uc3RydWN0b3IoKSB7CiAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IHZvaWQgMCwgdGhpcy5pbmRleCA9IHZvaWQgMCwgdGhpcy5maXJzdCA9IHZvaWQgMCwgdGhpcy5zZWNvbmQgPSB2b2lkIDAsIHRoaXMucmF0aW8gPSB2b2lkIDA7CiAgfQogIGNsb25lKHQpIHsKICAgIHJldHVybiBnKHQpIHx8ICh0ID0gbmV3IEooKSksIHQudUJ1ZmZlciA9IHRoaXMudUJ1ZmZlciwgdC52QnVmZmVyID0gdGhpcy52QnVmZmVyLCB0LmhlaWdodEJ1ZmZlciA9IHRoaXMuaGVpZ2h0QnVmZmVyLCB0Lm5vcm1hbEJ1ZmZlciA9IHRoaXMubm9ybWFsQnVmZmVyLCB0LmluZGV4ID0gdGhpcy5pbmRleCwgdC5maXJzdCA9IHRoaXMuZmlyc3QsIHQuc2Vjb25kID0gdGhpcy5zZWNvbmQsIHQucmF0aW8gPSB0aGlzLnJhdGlvLCB0OwogIH0KICBpbml0aWFsaXplSW5kZXhlZCh0LCBpLCBuLCBzLCBoKSB7CiAgICB0aGlzLnVCdWZmZXIgPSB0LCB0aGlzLnZCdWZmZXIgPSBpLCB0aGlzLmhlaWdodEJ1ZmZlciA9IG4sIHRoaXMubm9ybWFsQnVmZmVyID0gcywgdGhpcy5pbmRleCA9IGgsIHRoaXMuZmlyc3QgPSB2b2lkIDAsIHRoaXMuc2Vjb25kID0gdm9pZCAwLCB0aGlzLnJhdGlvID0gdm9pZCAwOwogIH0KICBpbml0aWFsaXplRnJvbUNsaXBSZXN1bHQodCwgaSwgbikgewogICAgbGV0IHMgPSBpICsgMTsKICAgIHJldHVybiB0W2ldICE9PSAtMSA/IG5bdFtpXV0uY2xvbmUodGhpcykgOiAodGhpcy52ZXJ0ZXhCdWZmZXIgPSB2b2lkIDAsIHRoaXMuaW5kZXggPSB2b2lkIDAsIHRoaXMuZmlyc3QgPSBuW3Rbc11dLCArK3MsIHRoaXMuc2Vjb25kID0gblt0W3NdXSwgKytzLCB0aGlzLnJhdGlvID0gdFtzXSwgKytzKSwgczsKICB9CiAgZ2V0SCgpIHsKICAgIHJldHVybiBnKHRoaXMuaW5kZXgpID8gdGhpcy5oZWlnaHRCdWZmZXJbdGhpcy5pbmRleF0gOiBMLmxlcnAodGhpcy5maXJzdC5nZXRIKCksIHRoaXMuc2Vjb25kLmdldEgoKSwgdGhpcy5yYXRpbyk7CiAgfQogIGdldFUoKSB7CiAgICByZXR1cm4gZyh0aGlzLmluZGV4KSA/IHRoaXMudUJ1ZmZlclt0aGlzLmluZGV4XSA6IEwubGVycCh0aGlzLmZpcnN0LmdldFUoKSwgdGhpcy5zZWNvbmQuZ2V0VSgpLCB0aGlzLnJhdGlvKTsKICB9CiAgZ2V0VigpIHsKICAgIHJldHVybiBnKHRoaXMuaW5kZXgpID8gdGhpcy52QnVmZmVyW3RoaXMuaW5kZXhdIDogTC5sZXJwKHRoaXMuZmlyc3QuZ2V0VigpLCB0aGlzLnNlY29uZC5nZXRWKCksIHRoaXMucmF0aW8pOwogIH0KICBpc0luZGV4ZWQoKSB7CiAgICByZXR1cm4gZyh0aGlzLmluZGV4KTsKICB9CiAgZ2V0S2V5KCkgewogICAgcmV0dXJuIHRoaXMuaXNJbmRleGVkKCkgPyB0aGlzLmluZGV4IDogSlNPTi5zdHJpbmdpZnkoewogICAgICBmaXJzdDogdGhpcy5maXJzdC5nZXRLZXkoKSwKICAgICAgc2Vjb25kOiB0aGlzLnNlY29uZC5nZXRLZXkoKSwKICAgICAgcmF0aW86IHRoaXMucmF0aW8KICAgIH0pOwogIH0KfQpjb25zdCBaID0gW107CloucHVzaChuZXcgSigpKTsKWi5wdXNoKG5ldyBKKCkpOwpaLnB1c2gobmV3IEooKSk7CloucHVzaChuZXcgSigpKTsKc2VsZi5hZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwgKGUpID0+IHsKICBjb25zdCB0ID0gZS5kYXRhLCB7CiAgICB0eXBlOiBpCiAgfSA9IHQ7CiAgaSA9PT0gImNyZWF0ZVRlcnJhaW5NZXNoIiA/IHNlbGYuY3JlYXRlVmVydGljZXNGcm9tUXVhbnRpemVkVGVycmFpbk1lc2godCkgOiBpID09PSAidXBzYW1wbGVUZXJyYWluRGF0YSIgPyBzZWxmLnVwc2FtcGxlUXVhbnRpemVkVGVycmFpbk1lc2godCkgOiBjb25zb2xlLmxvZyh0KTsKfSk7CnNlbGYuY2FsY3VsYXRlVXZGcm9tUG9zaXRpb25zID0gKGUpID0+IHsKICBjb25zdCB0ID0gW107CiAgZm9yIChsZXQgaSA9IDAsIG4gPSBlLmxlbmd0aCAtIDI7IGkgPCBuOyBpICs9IDMpCiAgICB0LnB1c2goCiAgICAgIGVbaV0sCiAgICAgIGVbaSArIDFdCiAgICApOwogIHJldHVybiB0Owp9OwpzZWxmLnppZ1phZ0RlY29kZSA9IChlKSA9PiBlID4+IDEgXiAtKGUgJiAxKTsKc2VsZi5kZWNvZGVJbmRpY2VzID0gKGUpID0+IHsKICBsZXQgdCA9IDA7CiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgKytpKSB7CiAgICBsZXQgbiA9IGVbaV07CiAgICBlW2ldID0gdCAtIG4sIG4gPT09IDAgJiYgKyt0OwogIH0KfTsKY29uc3QgUiA9IDMyNzY3LCBudCA9IFIgLyAyIHwgMCwgTmkgPSBbXSwgV3QgPSBbXSwgT2kgPSBbXSwgYmkgPSBbXSwgUGkgPSBbXSwgUmkgPSBbXSwgcWkgPSBbXSwgQWkgPSBuZXcgbHQoKSwgTGkgPSBuZXcgbSgpLCBVaSA9IG5ldyBtKCksIFEgPSBuZXcgbSgpLCBjdCA9IG5ldyBtKCksICR0ID0gbmV3IG0oMCwgMCwgMCk7CnNlbGYudXBzYW1wbGVRdWFudGl6ZWRUZXJyYWluTWVzaCA9IChlKSA9PiB7CiAgY29uc3QgdCA9IGUuaXNFYXN0Q2hpbGQsIGkgPSBlLmlzTm9ydGhDaGlsZCwgbiA9IHQgPyBudCA6IDAsIHMgPSB0ID8gUiA6IG50LCBoID0gaSA/IG50IDogMCwgYSA9IGkgPyBSIDogbnQsIHIgPSBPaSwgbyA9IGJpLCBjID0gUGksIHkgPSBSaSwgdSA9IHFpOwogIHIubGVuZ3RoID0gMCwgby5sZW5ndGggPSAwLCBjLmxlbmd0aCA9IDAsIHkubGVuZ3RoID0gMCwgdS5sZW5ndGggPSAwOwogIGNvbnN0IGQgPSB7fSwgZiA9IGUudmVydGljZXM7CiAgbGV0IHggPSBlLmluZGljZXM7CiAgeCA9IHguc3ViYXJyYXkoMCwgZS5pbmRleENvdW50V2l0aG91dFNraXJ0cyk7CiAgbGV0IE8gPSAwOwogIGNvbnN0IFMgPSBlLnZlcnRleENvdW50V2l0aG91dFNraXJ0cywgdyA9IGUubWluaW11bUhlaWdodCwgcSA9IGUubWF4aW11bUhlaWdodCwgQSA9IG5ldyBBcnJheShTKSwgTiA9IG5ldyBBcnJheShTKSwgSSA9IG5ldyBBcnJheShTKSwgayA9IHZvaWQgMCwgRCA9IDIwOwogIGxldCBHLCBsLCBXLCBNLCBUOwogIGZvciAobCA9IDAsIFcgPSAwOyBsIDwgUzsgKytsLCBXICs9IDIpIHsKICAgIGNvbnN0IFggPSBzZWxmLmRlY29kZVRleHR1cmVDb29yZGluYXRlcyhmLCBsLCBBaSk7CiAgICBHID0gc2VsZi5kZWNvZGVIZWlnaHQoZiwgbCksIE0gPSBMLmNsYW1wKFgueCAqIFIgfCAwLCAwLCBSKSwgVCA9IEwuY2xhbXAoWC55ICogUiB8IDAsIDAsIFIpLCBJW2xdID0gTC5jbGFtcCgKICAgICAgKEcgLSB3KSAvIChxIC0gdykgKiBSIHwgMCwKICAgICAgMCwKICAgICAgUgogICAgKSwgTSA8IEQgJiYgKE0gPSAwKSwgVCA8IEQgJiYgKFQgPSAwKSwgUiAtIE0gPCBEICYmIChNID0gUiksIFIgLSBUIDwgRCAmJiAoVCA9IFIpLCBBW2xdID0gTSwgTltsXSA9IFQsICh0ICYmIE0gPj0gbnQgfHwgIXQgJiYgTSA8PSBudCkgJiYgKGkgJiYgVCA+PSBudCB8fCAhaSAmJiBUIDw9IG50KSAmJiAoZFtsXSA9IE8sIHIucHVzaChNKSwgby5wdXNoKFQpLCBjLnB1c2goSVtsXSksICsrTyk7CiAgfQogIGNvbnN0IFkgPSBbXTsKICBZLnB1c2gobmV3IEooKSksIFkucHVzaChuZXcgSigpKSwgWS5wdXNoKG5ldyBKKCkpOwogIGNvbnN0IFAgPSBbXTsKICBQLnB1c2gobmV3IEooKSksIFAucHVzaChuZXcgSigpKSwgUC5wdXNoKG5ldyBKKCkpOwogIGxldCBWLCBldDsKICBmb3IgKGwgPSAwOyBsIDwgeC5sZW5ndGg7IGwgKz0gMykgewogICAgY29uc3QgWCA9IHhbbF0sIHN0ID0geFtsICsgMV0sIHR0ID0geFtsICsgMl0sIE50ID0gQVtYXSwgT3QgPSBBW3N0XSwgYnQgPSBBW3R0XTsKICAgIFlbMF0uaW5pdGlhbGl6ZUluZGV4ZWQoCiAgICAgIEEsCiAgICAgIE4sCiAgICAgIEksCiAgICAgIGssCiAgICAgIFgKICAgICksIFlbMV0uaW5pdGlhbGl6ZUluZGV4ZWQoCiAgICAgIEEsCiAgICAgIE4sCiAgICAgIEksCiAgICAgIGssCiAgICAgIHN0CiAgICApLCBZWzJdLmluaXRpYWxpemVJbmRleGVkKAogICAgICBBLAogICAgICBOLAogICAgICBJLAogICAgICBrLAogICAgICB0dAogICAgKTsKICAgIGNvbnN0IHogPSB5dC5jbGlwVHJpYW5nbGVBdEF4aXNBbGlnbmVkVGhyZXNob2xkKAogICAgICBudCwKICAgICAgdCwKICAgICAgTnQsCiAgICAgIE90LAogICAgICBidCwKICAgICAgTmkKICAgICk7CiAgICBWID0gMCwgIShWID49IHoubGVuZ3RoKSAmJiAoViA9IFBbMF0uaW5pdGlhbGl6ZUZyb21DbGlwUmVzdWx0KAogICAgICB6LAogICAgICBWLAogICAgICBZCiAgICApLCAhKFYgPj0gei5sZW5ndGgpICYmIChWID0gUFsxXS5pbml0aWFsaXplRnJvbUNsaXBSZXN1bHQoCiAgICAgIHosCiAgICAgIFYsCiAgICAgIFkKICAgICksICEoViA+PSB6Lmxlbmd0aCkgJiYgKFYgPSBQWzJdLmluaXRpYWxpemVGcm9tQ2xpcFJlc3VsdCgKICAgICAgeiwKICAgICAgViwKICAgICAgWQogICAgKSwgZXQgPSB5dC5jbGlwVHJpYW5nbGVBdEF4aXNBbGlnbmVkVGhyZXNob2xkKAogICAgICBudCwKICAgICAgaSwKICAgICAgUFswXS5nZXRWKCksCiAgICAgIFBbMV0uZ2V0VigpLAogICAgICBQWzJdLmdldFYoKSwKICAgICAgV3QKICAgICksIEh0KAogICAgICByLAogICAgICBvLAogICAgICBjLAogICAgICB5LAogICAgICB1LAogICAgICBkLAogICAgICBldCwKICAgICAgUCwKICAgICAgITEKICAgICksIFYgPCB6Lmxlbmd0aCAmJiAoUFsyXS5jbG9uZShQWzFdKSwgUFsyXS5pbml0aWFsaXplRnJvbUNsaXBSZXN1bHQoCiAgICAgIHosCiAgICAgIFYsCiAgICAgIFkKICAgICksIGV0ID0geXQuY2xpcFRyaWFuZ2xlQXRBeGlzQWxpZ25lZFRocmVzaG9sZCgKICAgICAgbnQsCiAgICAgIGksCiAgICAgIFBbMF0uZ2V0VigpLAogICAgICBQWzFdLmdldFYoKSwKICAgICAgUFsyXS5nZXRWKCksCiAgICAgIFd0CiAgICApLCBIdCgKICAgICAgciwKICAgICAgbywKICAgICAgYywKICAgICAgeSwKICAgICAgdSwKICAgICAgZCwKICAgICAgZXQsCiAgICAgIFAsCiAgICAgICExCiAgICApKSkpKTsKICB9CiAgY29uc3QgdXQgPSB0ID8gLVIgOiAwLCB2ID0gaSA/IC1SIDogMCwgX3QgPSBbXSwgbXQgPSBbXSwgcHQgPSBbXSwgenQgPSBbXTsKICBsZXQgb3QgPSBOdW1iZXIuTUFYX1ZBTFVFLCBkdCA9IC1vdDsKICBjb25zdCBNdCA9IFUuY2xvbmUoZS5jaGlsZFJlY3RhbmdsZSk7CiAgZm9yIChNdC5lYXN0LCBNdC53ZXN0LCBsID0gMDsgbCA8IHIubGVuZ3RoOyBsKyspCiAgICBNID0gTWF0aC5yb3VuZChyW2xdKSwgTSA8PSBuID8gKF90LnB1c2gobCksIE0gPSAwKSA6IE0gPj0gcyA/IChwdC5wdXNoKGwpLCBNID0gUikgOiBNID0gTSAqIDIgKyB1dCwgcltsXSA9IE0sIFQgPSBNYXRoLnJvdW5kKG9bbF0pLCBUIDw9IGggPyAobXQucHVzaChsKSwgVCA9IDApIDogVCA+PSBhID8gKHp0LnB1c2gobCksIFQgPSBSKSA6IFQgPSBUICogMiArIHYsIG9bbF0gPSBULCBHID0gTC5sZXJwKHcsIHEsIGNbbF0gLyBSKSwgb3QgPSBNYXRoLm1pbihvdCwgRyksIGR0ID0gTWF0aC5tYXgoZHQsIEcpLCBjW2xdID0gRzsKICBjb25zdCBUdCA9IGR0IC0gb3QsIGF0ID0gbmV3IFVpbnQxNkFycmF5KAogICAgci5sZW5ndGggKyBvLmxlbmd0aCArIGMubGVuZ3RoCiAgKTsKICBmb3IgKGwgPSAwOyBsIDwgci5sZW5ndGg7ICsrbCkKICAgIGF0W2xdID0gcltsXTsKICBsZXQgd3QgPSByLmxlbmd0aDsKICBmb3IgKGwgPSAwOyBsIDwgby5sZW5ndGg7ICsrbCkKICAgIGF0W3d0ICsgbF0gPSBvW2xdOwogIGZvciAod3QgKz0gby5sZW5ndGgsIGwgPSAwOyBsIDwgYy5sZW5ndGg7ICsrbCkgewogICAgY29uc3QgWCA9IFIgKiAoY1tsXSAtIG90KSAvIFR0OwogICAgYXRbd3QgKyBsXSA9IFg7CiAgfQogIGNvbnN0IGd0ID0gS3QuY3JlYXRlVHlwZWRBcnJheSgKICAgIHIubGVuZ3RoLAogICAgdQogICksIEsgPSB7CiAgICB2ZXJ0aWNlczogYXQuYnVmZmVyLAogICAgaW5kaWNlczogZ3QuYnVmZmVyLAogICAgbWluaW11bUhlaWdodDogb3QsCiAgICBtYXhpbXVtSGVpZ2h0OiBkdCwKICAgIHdlc3RJbmRpY2VzOiBfdCwKICAgIHNvdXRoSW5kaWNlczogbXQsCiAgICBlYXN0SW5kaWNlczogcHQsCiAgICBub3J0aEluZGljZXM6IHp0CiAgfSwgRXQgPSBbCiAgICBhdC5idWZmZXIsCiAgICBndC5idWZmZXIKICBdLCBodCA9IGUudHlwZTsKICBzZWxmLnBvc3RNZXNzYWdlKHsKICAgIHR5cGU6ICJ0ZXJyYWluRGF0YVVwc2FtcGxlZCIsCiAgICB0aWxlS2V5OiBodCArICItIiArIGUudGlsZUtleSwKICAgIGNvbnRlbnQ6IEsKICB9LCBFdCk7Cn07CnNlbGYuZGVjb2RlVGV4dHVyZUNvb3JkaW5hdGVzID0gKGUsIHQsIGkpID0+IChpIHx8IChpID0gbmV3IGx0KCkpLCB0ICo9IDYsIGkueCA9IGVbdCArIDRdLCBpLnkgPSBlW3QgKyA1XSwgaSk7CnNlbGYuZGVjb2RlSGVpZ2h0ID0gKGUsIHQpID0+ICh0ICo9IDYsIGVbdCArIDNdKTsKc2VsZi5jcmVhdGVWZXJ0aWNlc0Zyb21RdWFudGl6ZWRUZXJyYWluTWVzaCA9IChlKSA9PiB7CiAgY29uc3QgdCA9IGUudGlsZUtleSwgaSA9IGUudGlsZUNlbnRlciwgbiA9IGUucXVhbnRpemVkVmVydGljZXMsIHMgPSBuLmxlbmd0aCAvIDMsIGggPSBlLndlc3RJbmRpY2VzLmxlbmd0aCArIGUuZWFzdEluZGljZXMubGVuZ3RoICsgZS5zb3V0aEluZGljZXMubGVuZ3RoICsgZS5ub3J0aEluZGljZXMubGVuZ3RoLCBhID0gVS5jbG9uZShlLnJlY3RhbmdsZSksIHIgPSBhLndlc3QsIG8gPSBhLnNvdXRoLCBjID0gYS5lYXN0LCB5ID0gYS5ub3J0aCwgdSA9IHh0LmNsb25lKGUuZWxsaXBzb2lkKSwgZCA9IGUubWluaW11bUhlaWdodCwgZiA9IGUubWF4aW11bUhlaWdodCwgeCA9IG4uc3ViYXJyYXkoMCwgcyksIE8gPSBuLnN1YmFycmF5KAogICAgcywKICAgIDIgKiBzCiAgKSwgUyA9IG4uc3ViYXJyYXkoCiAgICBzICogMiwKICAgIDMgKiBzCiAgKSwgdyA9IG5ldyBBcnJheShzKSwgcSA9IG5ldyBBcnJheShzKSwgQSA9IG5ldyBBcnJheShzKSwgTiA9IExpOwogIE4ueCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTi55ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOLnogPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CiAgY29uc3QgSSA9IFVpOwogIEkueCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgSS55ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBJLnogPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgbGV0IGsgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIEQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIEcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGwgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgZm9yIChsZXQgeiA9IDA7IHogPCBzOyB6KyspIHsKICAgIGNvbnN0IGl0ID0geFt6XSwgSnQgPSBPW3pdLCBQdCA9IGl0IC8gUiwgUnQgPSBKdCAvIFIsIHF0ID0gTC5sZXJwKAogICAgICBkLAogICAgICBmLAogICAgICBTW3pdIC8gUgogICAgKTsKICAgIFEueCA9IEwubGVycChyLCBjLCBQdCksIFEueSA9IEwubGVycChvLCB5LCBSdCksIFEueiA9IHF0LCBrID0gTWF0aC5taW4oUS54LCBrKSwgRCA9IE1hdGgubWF4KFEueCwgRCksIEcgPSBNYXRoLm1pbihRLnksIEcpLCBsID0gTWF0aC5tYXgoUS55LCBsKTsKICAgIGxldCBBdDsKICAgIGcodSkgPyBBdCA9IHUuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oUSkgOiBBdCA9IG5ldyBtKFB0IC0gMC41LCBSdCAtIDAuNSwgcXQpLCB3W3pdID0gbmV3IGx0KFB0LCBSdCksIHFbel0gPSBxdCwgQVt6XSA9IEF0OwogIH0KICBjb25zdCBXID0gZS53ZXN0SW5kaWNlcy5zbGljZSgpLnNvcnQoKHosIGl0KSA9PiB3W3pdLnkgLSB3W2l0XS55KSwgTSA9IGUuZWFzdEluZGljZXMuc2xpY2UoKS5zb3J0KCh6LCBpdCkgPT4gd1tpdF0ueSAtIHdbel0ueSksIFQgPSBlLnNvdXRoSW5kaWNlcy5zbGljZSgpLnNvcnQoKHosIGl0KSA9PiB3W2l0XS54IC0gd1t6XS54KSwgWSA9IGUubm9ydGhJbmRpY2VzLnNsaWNlKCkuc29ydCgoeiwgaXQpID0+IHdbel0ueCAtIHdbaXRdLngpLCBWID0gNjM3ZTQgLyAoMiA8PCBlLmxldmVsKSAvIDIsIGV0ID0gTWF0aC5tYXgoMCwgKGggLSA0KSAqIDIpLCB1dCA9IGUuaW5kaWNlcy5sZW5ndGggKyBldCAqIDMsIHYgPSBLdC5jcmVhdGVUeXBlZEFycmF5KAogICAgcyArIGV0LAogICAgdXQKICApOwogIHYuc2V0KGUuaW5kaWNlcywgMCk7CiAgY29uc3QgX3QgPSAxZS00LCBtdCA9IChEIC0gaykgKiBfdCwgcHQgPSAobCAtIEcpICogX3QsIHp0ID0gLW10LCBvdCA9IDAsIGR0ID0gbXQsIE10ID0gMCwgVHQgPSAwLCBhdCA9IHB0LCB3dCA9IDAsIGd0ID0gLXB0OwogIGxldCBLID0gMDsKICBjb25zdCBFdCA9IHMgKiA2ICsgaCAqIDYsIGh0ID0gbmV3IEZsb2F0MzJBcnJheShFdCk7CiAgZm9yIChsZXQgeiA9IDAsIGl0ID0gczsgeiA8IGl0OyB6KyspCiAgICBLID0gc2VsZi5lbmNvZGUoCiAgICAgIGh0LAogICAgICBLLAogICAgICBnKHUpID8gaSA6ICR0LAogICAgICBBW3pdLAogICAgICB3W3pdLAogICAgICBxW3pdCiAgICApOwogIGxldCBYID0gZS5pbmRpY2VzLmxlbmd0aCwgc3QgPSBBLmxlbmd0aCwgdHQgPSBzZWxmLmFkZFNraXJ0KAogICAgaHQsCiAgICBzdCwKICAgIHYsCiAgICBpLAogICAgSywKICAgIHcsCiAgICBxLAogICAgVywKICAgIFYsCiAgICBYLAogICAgenQsCiAgICBvdCwKICAgIGEsCiAgICB1CiAgKTsKICBYID0gdHQub2Zmc2V0LCBLID0gdHQuYnVmZmVySW5kZXgsIHN0ICs9IFcubGVuZ3RoLCB0dCA9IHNlbGYuYWRkU2tpcnQoCiAgICBodCwKICAgIHN0LAogICAgdiwKICAgIGksCiAgICBLLAogICAgdywKICAgIHEsCiAgICBULAogICAgViwKICAgIFgsCiAgICB3dCwKICAgIGd0LAogICAgYSwKICAgIHUKICApLCBYID0gdHQub2Zmc2V0LCBLID0gdHQuYnVmZmVySW5kZXgsIHN0ICs9IFQubGVuZ3RoLCB0dCA9IHNlbGYuYWRkU2tpcnQoCiAgICBodCwKICAgIHN0LAogICAgdiwKICAgIGksCiAgICBLLAogICAgdywKICAgIHEsCiAgICBNLAogICAgViwKICAgIFgsCiAgICBkdCwKICAgIE10LAogICAgYSwKICAgIHUKICApLCBYID0gdHQub2Zmc2V0LCBLID0gdHQuYnVmZmVySW5kZXgsIHN0ICs9IE0ubGVuZ3RoLCBzZWxmLmFkZFNraXJ0KAogICAgaHQsCiAgICBzdCwKICAgIHYsCiAgICBpLAogICAgSywKICAgIHcsCiAgICBxLAogICAgWSwKICAgIFYsCiAgICBYLAogICAgVHQsCiAgICBhdCwKICAgIGEsCiAgICB1CiAgKTsKICBjb25zdCBOdCA9IHsKICAgIHZlcnRpY2VzOiBodCwKICAgIGJ1ZmZlckluZGV4OiBLLAogICAgaW5kZXhDb3VudFdpdGhvdXRTa2lydHM6IGUuaW5kaWNlcy5sZW5ndGgsCiAgICBpbmRpY2VzOiB2LAogICAgd2VzdEluZGljZXNTb3V0aFRvTm9ydGg6IFcsCiAgICBzb3V0aEluZGljZXNFYXN0VG9XZXN0OiBULAogICAgZWFzdEluZGljZXNOb3J0aFRvU291dGg6IE0sCiAgICBub3J0aEluZGljZXNXZXN0VG9FYXN0OiBZLAogICAgbWluaW11bUhlaWdodDogZCwKICAgIG1heGltdW1IZWlnaHQ6IGYKICB9LCBPdCA9IFsKICAgIGh0LmJ1ZmZlciwKICAgIHYuYnVmZmVyCiAgXSwgYnQgPSBlLnR5cGU7CiAgc2VsZi5wb3N0TWVzc2FnZSh7CiAgICB0eXBlOiAidGVycmFpbk1lc2hDcmVhdGVkIiwKICAgIHRpbGVLZXk6IGJ0ICsgIi0iICsgdCwKICAgIGNvbnRlbnQ6IE50CiAgfSwgT3QpOwp9OwpzZWxmLmVuY29kZSA9IChlLCB0LCBpLCBuLCBzLCBoKSA9PiB7CiAgY29uc3QgYSA9IHMueCwgciA9IHMueTsKICByZXR1cm4gai5zdWJ0cmFjdChuLCBpLCBjdCksIGVbdCsrXSA9IGN0LngsIGVbdCsrXSA9IGN0LnksIGVbdCsrXSA9IGN0LnosIGVbdCsrXSA9IGgsIGVbdCsrXSA9IGEsIGVbdCsrXSA9IHIsIHQ7Cn07CnNlbGYuYWRkU2tpcnQgPSAoZSwgdCwgaSwgbiwgcywgaCwgYSwgciwgbywgYywgeSwgdSwgZCwgZikgPT4gewogIGNvbnN0IHggPSBkLm5vcnRoLCBPID0gZC5zb3V0aDsKICBsZXQgUyA9IGQuZWFzdDsKICBjb25zdCB3ID0gZC53ZXN0OwogIFMgPCB3ICYmIChTICs9IF8uVFdPX1BJKTsKICBjb25zdCBxID0gci5sZW5ndGg7CiAgbGV0IEEgPSByWzBdOwogIGZvciAobGV0IE4gPSAwOyBOIDwgcTsgTisrKSB7CiAgICBjb25zdCBJID0gcltOXSwgayA9IGFbSV0sIEQgPSBoW0ldOwogICAgaWYgKGcoZikpIHsKICAgICAgUS54ID0gTC5sZXJwKHcsIFMsIEQueCkgKyB5LCBRLnkgPSBMLmxlcnAoTywgeCwgRC55KSArIHUsIFEueiA9IGsgLSBvICogMjsKICAgICAgY29uc3QgVCA9IGYuY2FydG9ncmFwaGljVG9DYXJ0ZXNpYW4oCiAgICAgICAgUSwKICAgICAgICBjdAogICAgICApOwogICAgICBzID0gc2VsZi5lbmNvZGUoCiAgICAgICAgZSwKICAgICAgICBzLAogICAgICAgIG4sCiAgICAgICAgVCwKICAgICAgICBELAogICAgICAgIFEuegogICAgICApOwogICAgfSBlbHNlCiAgICAgIGN0LnNldChELnggLSAwLjUsIEQueSAtIDAuNSwgayAtIG8gKiAyKSwgcyA9IHNlbGYuZW5jb2RlKAogICAgICAgIGUsCiAgICAgICAgcywKICAgICAgICAkdCwKICAgICAgICBjdCwKICAgICAgICBELAogICAgICAgIFEuegogICAgICApOwogICAgaWYgKE4gPT09IDApCiAgICAgIGNvbnRpbnVlOwogICAgY29uc3QgRyA9IEEsIGwgPSB0ICsgTiAtIDEsIFcgPSBJLCBNID0gdCArIE47CiAgICBpW2MrK10gPSBHLCBpW2MrK10gPSBXLCBpW2MrK10gPSBsLCBpW2MrK10gPSBsLCBpW2MrK10gPSBXLCBpW2MrK10gPSBNLCBBID0gSTsKICB9CiAgcmV0dXJuIHsKICAgIG9mZnNldDogYywKICAgIGJ1ZmZlckluZGV4OiBzCiAgfTsKfTsKZnVuY3Rpb24gSHQoZSwgdCwgaSwgbiwgcywgaCwgYSwgciwgbykgewogIGlmIChvID0gITEsIGEubGVuZ3RoID09PSAwKQogICAgcmV0dXJuOwogIGxldCBjID0gMCwgeSA9IDA7CiAgZm9yICg7IHkgPCBhLmxlbmd0aDsgKQogICAgeSA9IFpbYysrXS5pbml0aWFsaXplRnJvbUNsaXBSZXN1bHQoCiAgICAgIGEsCiAgICAgIHksCiAgICAgIHIKICAgICk7CiAgZm9yIChsZXQgdSA9IDA7IHUgPCBjOyArK3UpIHsKICAgIGNvbnN0IGQgPSBaW3VdOwogICAgaWYgKGQuaXNJbmRleGVkKCkpCiAgICAgIGQubmV3SW5kZXggPSBoW2QuaW5kZXhdLCBkLnVCdWZmZXIgPSBlLCBkLnZCdWZmZXIgPSB0LCBkLmhlaWdodEJ1ZmZlciA9IGksIG8gJiYgKGQubm9ybWFsQnVmZmVyID0gbik7CiAgICBlbHNlIHsKICAgICAgY29uc3QgZiA9IGQuZ2V0S2V5KCk7CiAgICAgIGlmIChnKGhbZl0pKQogICAgICAgIGQubmV3SW5kZXggPSBoW2ZdOwogICAgICBlbHNlIHsKICAgICAgICBjb25zdCB4ID0gZS5sZW5ndGg7CiAgICAgICAgZS5wdXNoKGQuZ2V0VSgpKSwgdC5wdXNoKGQuZ2V0VigpKSwgaS5wdXNoKGQuZ2V0SCgpKSwgbyAmJiAobi5wdXNoKGQuZ2V0Tm9ybWFsWCgpKSwgbi5wdXNoKGQuZ2V0Tm9ybWFsWSgpKSksIGQubmV3SW5kZXggPSB4LCBoW2ZdID0geDsKICAgICAgfQogICAgfQogIH0KICBjID09PSAzID8gKHMucHVzaChaWzBdLm5ld0luZGV4KSwgcy5wdXNoKFpbMV0ubmV3SW5kZXgpLCBzLnB1c2goWlsyXS5uZXdJbmRleCkpIDogYyA9PT0gNCAmJiAocy5wdXNoKFpbMF0ubmV3SW5kZXgpLCBzLnB1c2goWlsxXS5uZXdJbmRleCksIHMucHVzaChaWzJdLm5ld0luZGV4KSwgcy5wdXNoKFpbMF0ubmV3SW5kZXgpLCBzLnB1c2goWlsyXS5uZXdJbmRleCksIHMucHVzaChaWzNdLm5ld0luZGV4KSk7Cn0K", H0 = typeof window < "u" && window.Blob && new Blob([atob(j_)], { type: "text/javascript;charset=utf-8" });
function lz() {
  const s = H0 && (window.URL || window.webkitURL).createObjectURL(H0);
  try {
    return s ? new Worker(s) : new Worker("data:application/javascript;base64," + j_, { type: "module" });
  } finally {
    s && (window.URL || window.webkitURL).revokeObjectURL(s);
  }
}
const ku = new B();
new B();
const $a = new B();
class MY extends k_ {
  constructor(e = {}) {
    super(e);
    f(this, "name", "CesiumTerrainTileProvider");
    f(this, "_supportedTargetProjectionNames", [zs, Mt, hi]);
    f(this, "_url", "https://assets.ion.cesium.com/ap-northeast-1/asset_depot/1/CesiumWorldTerrain/v1.2");
    f(this, "_defaultMaxLevel", 16);
    f(this, "_shouldCheckTileAvailable", !0);
    f(this, "_canUpsample", !0);
    f(this, "_isDefaultCesium", !0);
    this._accessToken = e.accessToken || Z_.accessToken, e.url && (this._url = e.url, this._isDefaultCesium = !1);
  }
  initProjectionAndGrid() {
    this._sourceProjection.name === Mt ? this._grid = new nd(this._engine, this._sourceProjection, this._targetProjection) : this._sourceProjection.name === hi && (this._grid = new UC(this._engine, this._sourceProjection, this._targetProjection));
    const e = this._targetProjection.name;
    let i = null;
    e === Mt ? i = bn(Mt) : i = bn(hi), this.rasterProjection = i, this._grid.rasterProjection = i;
  }
  async _asyncInit() {
    await this._refreshAccessToken();
    let e = null;
    const i = {};
    this._isDefaultCesium && (e = {
      Accept: "application/json",
      Authorization: "Bearer " + this._sessionToken
    }, i.headers = e);
    const n = await Ta(`${this._url}/layer.json`, i).then((a) => a.json());
    this._layerConfig = n, this._urlTemplate = this._url + "/" + n.tiles[0], this._version = n.version;
    const o = this._availableTiles = n.available;
    this._maxLevel = o.length - 1;
    const r = n.projection || hi;
    this._sourceProjection = bn(r), this._dataLoader = new cz(this, lz, 2);
  }
  async _refreshAccessToken() {
    if (!this._isDefaultCesium)
      return;
    const e = await Ta(`https://api.cesium.com/v1/assets/1/endpoint?access_token=${this._accessToken}`, {
      headers: {
        Accept: "application/json",
        Authorization: "Bearer " + this._accessToken
      }
    }).then((i) => i.json());
    this._sessionToken = e.accessToken, this._lastRefreshTokenTime = Date.now();
  }
  async _checkAndRefreshAccessToken() {
    !this._isDefaultCesium || Date.now() - this._lastRefreshTokenTime > 3600 * 1e3 && await this._refreshAccessToken();
  }
  getTileURL(e, i, n, o) {
    return this._urlTemplate.replace("{version}", this._version).replace("{z}", this._sourceProjection.name === hi ? e - 1 : e).replace("{x}", i).replace("{y}", n);
  }
  getFetchOptions() {
    return this._isDefaultCesium ? {
      headers: {
        Accept: "application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01",
        Authorization: "Bearer " + this._sessionToken
      }
    } : {};
  }
  isTileAvailable(e, i, n) {
    this._sourceProjection.name === hi && (e -= 1);
    const o = this._availableTiles;
    if (!o || o.length === 0)
      return;
    if (e >= o.length)
      return !1;
    const r = o[e];
    for (let a = 0, g = r.length; a < g; ++a) {
      const c = r[a];
      if (i >= c.startX && i <= c.endX && n >= c.startY && n <= c.endY)
        return !0;
    }
    return !1;
  }
  async doRequestTileData(e) {
    const i = this._targetProjection.name;
    await this._checkAndRefreshAccessToken();
    let n, o;
    if (e.needUpSample) {
      const g = e.parentKey.split("-").map((l) => +l);
      $a.set(g[1], g[2], g[0]);
      const c = this._quadtree.getTile($a.z, $a.x, $a.y);
      n = await this._dataLoader.upsample(
        c.terrainData,
        $a,
        e
      );
    } else
      n = await this._dataLoader.requestTile(e), e.quantizedMesh = n;
    if (e.terrainData = n, n && (o = await this._dataLoader.createMesh(n, e, {})), !o)
      return console.warn(`no data for tile ${e.key}`), i === zs ? this._requestEcefTileData(e) : this._requestPlaneTileData(e);
    const r = new Qe(), a = new Ai(o.vertices, 6);
    return r.setAttribute("position", new ve(a, 3, 0)), r.setAttribute("uv", new ve(a, 2, 4)), r.setIndex(new Fe(o.indices, 1)), r._heights = [o.minimumHeight, o.maximumHeight], i !== zs && (e.targetBoundingBox.getSize(ku), r.scale(ku.x, ku.y, 1)), r;
  }
}
function hz(s) {
  let t = 0;
  for (const i in s.attributes) {
    const n = s.getAttribute(i);
    t += n.count * n.itemSize * n.array.BYTES_PER_ELEMENT;
  }
  const e = s.getIndex();
  return t += e ? e.count * e.itemSize * e.array.BYTES_PER_ELEMENT : 0, t;
}
function yh(s, t) {
  if (t === aT)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (t === eh || t === WA) {
    let e = s.getIndex();
    if (e === null) {
      const r = [], a = s.getAttribute("position");
      if (a !== void 0) {
        for (let g = 0; g < a.count; g++)
          r.push(g);
        s.setIndex(r), e = s.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
    }
    const i = e.count - 2, n = [];
    if (t === eh)
      for (let r = 1; r <= i; r++)
        n.push(e.getX(0)), n.push(e.getX(r)), n.push(e.getX(r + 1));
    else
      for (let r = 0; r < i; r++)
        r % 2 === 0 ? (n.push(e.getX(r)), n.push(e.getX(r + 1)), n.push(e.getX(r + 2))) : (n.push(e.getX(r + 2)), n.push(e.getX(r + 1)), n.push(e.getX(r)));
    n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const o = s.clone();
    return o.setIndex(n), o.clearGroups(), o;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), s;
}
const P0 = parseInt(Hh, 10) >= 165, dz = parseInt(Hh, 10) >= 166, eg = /* @__PURE__ */ new gT(), N0 = /* @__PURE__ */ new Me(), Vu = /* @__PURE__ */ new Z(), $c = new class {
  constructor() {
    this._renderer = new VA(), this._target = new It(1, 1), this._texTarget = new It(), this._quad = new Ut(new ze({
      blending: kA,
      blendDst: ql,
      blendSrc: Ll,
      uniforms: {
        map: { value: null },
        pixel: { value: new Z() }
      },
      vertexShader: `
				void main() {

					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

				}
			`,
      fragmentShader: `
				uniform sampler2D map;
				uniform ivec2 pixel;

				void main() {

					gl_FragColor = texelFetch( map, pixel, 0 );

				}
			`
    }));
  }
  increaseSizeTo(s) {
    this._target.setSize(Math.max(this._target.width, s), 1);
  }
  readDataAsync(s) {
    const { _renderer: t, _target: e } = this;
    return P0 ? t.readRenderTargetPixelsAsync(e, 0, 0, s.length / 4, 1, s) : Promise.resolve().then(() => this.readData(s));
  }
  readData(s) {
    const { _renderer: t, _target: e } = this;
    t.readRenderTargetPixels(e, 0, 0, s.length / 4, 1, s);
  }
  renderPixelToTarget(s, t, e) {
    const { _quad: i, _renderer: n, _target: o, _texTarget: r } = this;
    if (dz)
      eg.min.copy(t), eg.max.copy(t), eg.max.x += 1, eg.max.y += 1, n.initRenderTarget(o), n.copyTextureToTexture(s, o.texture, eg, e, 0);
    else {
      const a = n.autoClear, g = n.getRenderTarget(), c = n.getScissorTest();
      n.getScissor(N0), r.setSize(s.image.width, s.image.height), n.setRenderTarget(r), Vu.set(0, 0), P0 ? n.copyTextureToTexture(s, r.texture, null, Vu) : n.copyTextureToTexture(Vu, s, r.texture), i.material.uniforms.map.value = r.texture, i.material.uniforms.pixel.value.copy(t), n.setRenderTarget(o), n.setScissorTest(!0), n.setScissor(e.x, e.y, 1, 1), n.autoClear = !1, i.render(n), n.setScissorTest(c), n.setScissor(N0), n.setRenderTarget(g), n.autoClear = a, r.dispose();
    }
  }
}(), F0 = /* @__PURE__ */ new Z(), k0 = /* @__PURE__ */ new Z(), V0 = /* @__PURE__ */ new Z();
function uz(s, t) {
  return t === 0 ? s.getAttribute("uv") : s.getAttribute(`uv${t}`);
}
function Iz(s, t, e = new Array(3)) {
  let i = 3 * t, n = 3 * t + 1, o = 3 * t + 2;
  return s.index && (i = s.index.getX(i), n = s.index.getX(n), o = s.index.getX(o)), e[0] = i, e[1] = n, e[2] = o, e;
}
function Az(s, t, e, i, n) {
  const [o, r, a] = i, g = uz(s, t);
  F0.fromBufferAttribute(g, o), k0.fromBufferAttribute(g, r), V0.fromBufferAttribute(g, a), n.set(0, 0, 0).addScaledVector(F0, e.x).addScaledVector(k0, e.y).addScaledVector(V0, e.z);
}
function Cz(s, t, e, i) {
  const n = s.x - Math.floor(s.x), o = s.y - Math.floor(s.y), r = Math.floor(n * t % t), a = Math.floor(o * e % e);
  return i.set(r, a), i;
}
const z0 = /* @__PURE__ */ new Z(), X0 = /* @__PURE__ */ new Z(), W0 = /* @__PURE__ */ new Z();
function fz(s) {
  return s.x > s.y && s.x > s.z ? 0 : s.y > s.z ? 1 : 2;
}
class pz {
  constructor(t, e, i) {
    this.geometry = t, this.textures = e, this.data = i, this._asyncRead = !1, this.featureIds = i.featureIds.map((n) => {
      const { texture: o, ...r } = n, a = {
        label: null,
        propertyTable: null,
        nullFeatureId: null,
        ...r
      };
      return o && (a.texture = {
        texCoord: 0,
        channels: [0],
        ...o
      }), a;
    });
  }
  getTextures() {
    return this.textures;
  }
  getFeatureInfo() {
    return this.featureIds;
  }
  getFeaturesAsync(...t) {
    this._asyncRead = !0;
    const e = this.getFeatures(...t);
    return this._asyncRead = !1, e;
  }
  getFeatures(t, e) {
    const { geometry: i, textures: n, featureIds: o } = this, r = new Array(o.length).fill(null), a = o.length;
    $c.increaseSizeTo(a);
    const g = Iz(i, t), c = g[fz(e)];
    for (let d = 0, C = o.length; d < C; d++) {
      const p = o[d], m = "nullFeatureId" in p ? p.nullFeatureId : null;
      if ("texture" in p) {
        const b = n[p.texture.index];
        Az(i, p.texture.texCoord, e, g, z0), Cz(z0, b.image.width, b.image.height, X0), W0.set(d, 0), $c.renderPixelToTarget(n[p.texture.index], X0, W0);
      } else if ("attribute" in p) {
        const S = i.getAttribute(`_feature_id_${p.attribute}`).getX(c);
        S !== m && (r[d] = S);
      } else {
        const b = c;
        b !== m && (r[d] = b);
      }
    }
    const l = new Uint8Array(a * 4);
    if (this._asyncRead)
      return $c.readDataAsync(l).then(() => (h(), r));
    return $c.readData(l), h(), r;
    function h() {
      const d = new Uint32Array(1);
      for (let C = 0, p = o.length; C < p; C++) {
        const m = o[C], b = "nullFeatureId" in m ? m.nullFeatureId : null;
        if ("texture" in m) {
          const { channels: S } = m.texture, A = S.map((y) => l[4 * C + y]);
          new Uint8Array(d.buffer).set(A);
          const u = d[0];
          u !== b && (r[C] = u);
        }
      }
    }
  }
  dispose() {
    this.textures.forEach((t) => {
      t && (t.dispose(), t.image instanceof ImageBitmap && t.image.close());
    });
  }
}
const Sh = "EXT_mesh_features";
function Z0(s, t, e) {
  s.traverse((i) => {
    if (t.associations.has(i)) {
      const { meshes: n, primitives: o } = t.associations.get(i);
      if (H(n) && H(o)) {
        const r = t.json.meshes[n].primitives[o];
        r && r.extensions && r.extensions[Sh] && e(i, r.extensions[Sh]);
      }
    }
  });
}
class mz {
  constructor(t) {
    this.parser = t, this.name = Sh;
  }
  async afterRoot({ scene: t, parser: e }) {
    var a;
    const i = e.json.extensionsUsed;
    if (!i || !i.includes(Sh))
      return;
    const n = ((a = e.json.textures) == null ? void 0 : a.length) || 0, o = new Array(n).fill(null);
    Z0(t, e, (g, { featureIds: c }) => {
      c.forEach((l) => {
        if (l.texture && o[l.texture.index] === null) {
          const h = l.texture.index;
          o[h] = e.loadTexture(h);
        }
      });
    });
    const r = await Promise.all(o);
    Z0(t, e, (g, c) => {
      g.userData.meshFeatures = new pz(g.geometry, r, c);
    });
  }
}
class J_ {
  constructor(t) {
    t = W(t, W.EMPTY_OBJECT), this._schema = t.schema;
    const e = t.propertyTables;
    this._propertyTableCount = H(e) ? e.length : 0, this._propertyTables = e, this._propertyTextures = t.propertyTextures, this._propertyAttributes = t.propertyAttributes, this._statistics = t.statistics, this._extras = t.extras, this._extensions = t.extensions;
  }
  get schema() {
    return this._schema;
  }
  get statistics() {
    return this._statistics;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  get propertyTableCount() {
    return this._propertyTableCount;
  }
  get propertyTables() {
    return this._propertyTables;
  }
  get propertyTextures() {
    return this._propertyTextures;
  }
  get propertyAttributes() {
    return this._propertyAttributes;
  }
  get propertyTablesByteLength() {
    if (!H(this._propertyTables))
      return 0;
    let t = 0;
    const e = this._propertyTables.length;
    for (let i = 0; i < e; i++)
      t += this._propertyTables[i].byteLength;
    return t;
  }
  getPropertyTable(t) {
    return this._propertyTables[t];
  }
  getPropertyTexture(t) {
    return this._propertyTextures[t];
  }
  getPropertyAttribute(t) {
    return this._propertyAttributes[t];
  }
  dispose() {
  }
}
function Vg() {
  return typeof BigInt < "u";
}
const Se = {
  INT8: "INT8",
  UINT8: "UINT8",
  INT16: "INT16",
  UINT16: "UINT16",
  INT32: "INT32",
  UINT32: "UINT32",
  INT64: "INT64",
  UINT64: "UINT64",
  FLOAT32: "FLOAT32",
  FLOAT64: "FLOAT64"
};
Se.getMinimum = function(s) {
  switch (s) {
    case Se.INT8:
      return -128;
    case Se.UINT8:
      return 0;
    case Se.INT16:
      return -32768;
    case Se.UINT16:
      return 0;
    case Se.INT32:
      return -2147483648;
    case Se.UINT32:
      return 0;
    case Se.INT64:
      return Vg() ? BigInt("-9223372036854775808") : -Math.pow(2, 63);
    case Se.UINT64:
      return Vg() ? BigInt(0) : 0;
    case Se.FLOAT32:
      return -34028234663852886e22;
    case Se.FLOAT64:
      return -Number.MAX_VALUE;
  }
};
Se.getMaximum = function(s) {
  switch (s) {
    case Se.INT8:
      return 127;
    case Se.UINT8:
      return 255;
    case Se.INT16:
      return 32767;
    case Se.UINT16:
      return 65535;
    case Se.INT32:
      return 2147483647;
    case Se.UINT32:
      return 4294967295;
    case Se.INT64:
      return Vg() ? BigInt("9223372036854775807") : Math.pow(2, 63) - 1;
    case Se.UINT64:
      return Vg() ? BigInt("18446744073709551615") : Math.pow(2, 64) - 1;
    case Se.FLOAT32:
      return 34028234663852886e22;
    case Se.FLOAT64:
      return Number.MAX_VALUE;
  }
};
Se.isIntegerType = function(s) {
  switch (s) {
    case Se.INT8:
    case Se.UINT8:
    case Se.INT16:
    case Se.UINT16:
    case Se.INT32:
    case Se.UINT32:
    case Se.INT64:
    case Se.UINT64:
      return !0;
    default:
      return !1;
  }
};
Se.isUnsignedIntegerType = function(s) {
  switch (s) {
    case Se.UINT8:
    case Se.UINT16:
    case Se.UINT32:
    case Se.UINT64:
      return !0;
    default:
      return !1;
  }
};
Se.isVectorCompatible = function(s) {
  switch (s) {
    case Se.INT8:
    case Se.UINT8:
    case Se.INT16:
    case Se.UINT16:
    case Se.INT32:
    case Se.UINT32:
    case Se.FLOAT32:
    case Se.FLOAT64:
      return !0;
    default:
      return !1;
  }
};
Se.normalize = function(s, t) {
  return Math.max(
    Number(s) / Number(Se.getMaximum(t)),
    -1
  );
};
Se.unnormalize = function(s, t) {
  const e = Se.getMaximum(t), i = Se.isUnsignedIntegerType(t) ? 0 : -e;
  return s = X.sign(s) * Math.round(Math.abs(s) * Number(e)), (t === Se.INT64 || t === Se.UINT64) && Vg() && (s = BigInt(s)), s > e ? e : s < i ? i : s;
};
Se.applyValueTransform = function(s, t, e) {
  return e * s + t;
};
Se.unapplyValueTransform = function(s, t, e) {
  return e === 0 ? 0 : (s - t) / e;
};
Se.getSizeInBytes = function(s) {
  switch (s) {
    case Se.INT8:
    case Se.UINT8:
      return 1;
    case Se.INT16:
    case Se.UINT16:
      return 2;
    case Se.INT32:
    case Se.UINT32:
      return 4;
    case Se.INT64:
    case Se.UINT64:
      return 8;
    case Se.FLOAT32:
      return 4;
    case Se.FLOAT64:
      return 8;
  }
};
const Ne = Object.freeze(Se);
class $C {
  constructor(t) {
    t = W(t, {});
    const e = t.value, i = t.name;
    this._value = e, this._name = i, this._description = t.description, this._extras = dt(t.extras, !0), this._extensions = dt(t.extensions, !0);
  }
  static fromJson(t) {
    return new $C({
      value: t.value,
      name: t.name,
      description: t.description,
      extras: t.extras,
      extensions: t.extensions
    });
  }
  get value() {
    return this._value;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class ef {
  constructor(t) {
    t = W(t, {});
    const e = t.id, i = t.values, n = {}, o = {}, r = i.length;
    for (let g = 0; g < r; ++g) {
      const c = i[g];
      n[c.value] = c.name, o[c.name] = c.value;
    }
    const a = W(
      t.valueType,
      Ne.UINT16
    );
    this._values = i, this._namesByValue = n, this._valuesByName = o, this._valueType = a, this._id = e, this._name = t.name, this._description = t.description, this._extras = dt(t.extras, !0), this._extensions = dt(t.extensions, !0);
  }
  static fromJson(t) {
    t = W(t, {});
    const e = t.id, i = t.enum, n = i.values.map(function(o) {
      return $C.fromJson(o);
    });
    return new ef({
      id: e,
      values: n,
      valueType: Ne[i.valueType],
      name: i.name,
      description: i.description,
      extras: i.extras,
      extensions: i.extensions
    });
  }
  get values() {
    return this._values;
  }
  get namesByValue() {
    return this._namesByValue;
  }
  get valuesByName() {
    return this._valuesByName;
  }
  get valueType() {
    return this._valueType;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
const Be = {
  SCALAR: "SCALAR",
  VEC2: "VEC2",
  VEC3: "VEC3",
  VEC4: "VEC4",
  MAT2: "MAT2",
  MAT3: "MAT3",
  MAT4: "MAT4",
  BOOLEAN: "BOOLEAN",
  STRING: "STRING",
  ENUM: "ENUM"
};
Be.isVectorType = function(s) {
  switch (s) {
    case Be.VEC2:
    case Be.VEC3:
    case Be.VEC4:
      return !0;
    default:
      return !1;
  }
};
Be.isMatrixType = function(s) {
  switch (s) {
    case Be.MAT2:
    case Be.MAT3:
    case Be.MAT4:
      return !0;
    default:
      return !1;
  }
};
Be.getComponentCount = function(s) {
  switch (s) {
    case Be.SCALAR:
    case Be.STRING:
    case Be.ENUM:
    case Be.BOOLEAN:
      return 1;
    case Be.VEC2:
      return 2;
    case Be.VEC3:
      return 3;
    case Be.VEC4:
      return 4;
    case Be.MAT2:
      return 4;
    case Be.MAT3:
      return 9;
    case Be.MAT4:
      return 16;
    default:
      throw new Error(`Invalid metadata type ${s}`);
  }
};
Be.getMathType = function(s) {
  switch (s) {
    case Be.VEC2:
      return Z;
    case Be.VEC3:
      return B;
    case Be.VEC4:
      return Me;
    case Be.MAT2:
      console.warn("not support mat2");
      return;
    case Be.MAT3:
      return qe;
    case Be.MAT4:
      return J;
    default:
      return;
  }
};
function yz(s, t, e) {
  const i = t.length;
  H(e) ? e.length = i / 2 : e = new Array(i / 2);
  for (let n = 0; n < i; n += 2) {
    const o = n / 2;
    H(e[o]) || (e[o] = new s()), e[o] = e[o].fromArray(t, n);
  }
  return e;
}
class To {
  constructor(t) {
    t = W(t, {});
    const e = t.id, i = t.type, n = t.componentType, o = t.enumType, r = H(n) && Ne.isIntegerType(n) && W(t.normalized, !1);
    this._id = e, this._name = t.name, this._description = t.description, this._semantic = t.semantic, this._isLegacyExtension = t.isLegacyExtension, this._type = i, this._componentType = n, this._enumType = o, this._valueType = H(o) ? o.valueType : n, this._isArray = W(t.isArray, !1), this._isVariableLengthArray = W(
      t.isVariableLengthArray,
      !1
    ), this._arrayLength = t.arrayLength, this._min = dt(t.min, !0), this._max = dt(t.max, !0), this._normalized = r;
    let a = dt(t.offset, !0), g = dt(t.scale, !0);
    const c = H(a) || H(g), l = !0;
    H(a) || (a = this.expandConstant(0, l)), H(g) || (g = this.expandConstant(1, l)), this._offset = a, this._scale = g, this._hasValueTransform = c, this._noData = dt(t.noData, !0), this._default = dt(t.default, !0), this._required = W(t.required, !0), this._extras = dt(t.extras, !0), this._extensions = dt(t.extensions, !0);
  }
  static fromJson(t) {
    t = W(t, {});
    const e = t.id, i = t.property, n = Sz(i), o = bz(i, t.enums);
    let r;
    return H(n) ? n ? r = H(i.optional) ? !i.optional : !0 : r = W(i.required, !1) : r = !1, new To({
      id: e,
      type: o.type,
      componentType: o.componentType,
      enumType: o.enumType,
      isArray: o.isArray,
      isVariableLengthArray: o.isVariableLengthArray,
      arrayLength: o.arrayLength,
      normalized: i.normalized,
      min: i.min,
      max: i.max,
      offset: i.offset,
      scale: i.scale,
      noData: i.noData,
      default: i.default,
      required: r,
      name: i.name,
      description: i.description,
      semantic: i.semantic,
      extras: i.extras,
      extensions: i.extensions,
      isLegacyExtension: n
    });
  }
  normalize(t) {
    return this._normalized ? mA(
      t,
      this._valueType,
      Ne.normalize
    ) : t;
  }
  unnormalize(t) {
    return this._normalized ? mA(
      t,
      this._valueType,
      Ne.unnormalize
    ) : t;
  }
  applyValueTransform(t) {
    return !this._hasValueTransform || this._isVariableLengthArray ? t : To.valueTransformInPlace(
      t,
      this._offset,
      this._scale,
      Ne.applyValueTransform
    );
  }
  unapplyValueTransform(t) {
    return !this._hasValueTransform || this._isVariableLengthArray ? t : To.valueTransformInPlace(
      t,
      this._offset,
      this._scale,
      Ne.unapplyValueTransform
    );
  }
  expandConstant(t, e) {
    e = W(e, !1);
    const i = this._isArray, n = this._arrayLength, o = Be.getComponentCount(this._type), r = i && o > 1;
    if (!i && o === 1)
      return t;
    if (!i)
      return new Array(o).fill(t);
    if (!r)
      return new Array(n).fill(t);
    if (!e)
      return new Array(this._arrayLength * o).fill(t);
    const a = new Array(o).fill(t);
    return new Array(this._arrayLength).fill(a);
  }
  handleNoData(t) {
    const e = this._noData;
    if (!H(e))
      return t;
    if (!q_(t, e))
      return t;
  }
  unpackVectorAndMatrixTypes(t, e) {
    e = W(e, !1);
    const i = Be.getMathType(this._type), n = this._isArray, o = Be.getComponentCount(this._type), r = n && o > 1;
    return H(i) ? e && r ? t.map(function(a) {
      return new i().fromArray(a);
    }) : n ? yz(i, t) : new i().fromArray(t) : t;
  }
  packVectorAndMatrixTypes(t) {
    if (!(!H(t) && H(this._default)))
      return this._required && !H(t) ? "required property must have a value" : this._isArray ? Bz(this, t) : $_(this, t);
  }
  valueTransformInPlace(t, e, i, n) {
    if (!Array.isArray(t))
      return n(t, e, i);
    for (let o = 0; o < t.length; o++)
      t[o] = To.valueTransformInPlace(
        t[o],
        e[o],
        i[o],
        n
      );
    return t;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get type() {
    return this._type;
  }
  get enumType() {
    return this._enumType;
  }
  get componentType() {
    return this._componentType;
  }
  get valueType() {
    return this._valueType;
  }
  get isArray() {
    return this._isArray;
  }
  get isVariableLengthArray() {
    return this._isVariableLengthArray;
  }
  get arrayLength() {
    return this._arrayLength;
  }
  get normalized() {
    return this._normalized;
  }
  get max() {
    return this._max;
  }
  get min() {
    return this._min;
  }
  get noData() {
    return this._noData;
  }
  get default() {
    return this._default;
  }
  get required() {
    return this._required;
  }
  get semantic() {
    return this._semantic;
  }
  get hasValueTransform() {
    return this._hasValueTransform;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
function mA(s, t, e) {
  if (!Array.isArray(s))
    return e(s, t);
  for (let i = 0; i < s.length; i++)
    s[i] = mA(s[i], t, e);
  return s;
}
function Sz(s) {
  if (s.type === "ARRAY")
    return !0;
  const t = s.type;
  if (t === Be.SCALAR || Be.isMatrixType(t) || Be.isVectorType(t))
    return !1;
  if (H(Ne[t]))
    return !0;
  if (H(s.noData) || H(s.scale) || H(s.offset) || H(s.required) || H(s.count) || H(s.array) || H(s.optional))
    return !1;
}
function bz(s, t) {
  const e = s.type, i = s.componentType, n = e === "ARRAY";
  let o, r, a;
  n ? (o = !0, r = s.componentCount, a = !H(r)) : s.array ? (o = !0, r = s.count, a = !H(s.count)) : (o = !1, r = void 0, a = !1);
  let g;
  if (H(s.enumType) && (g = t[s.enumType]), e === Be.ENUM)
    return {
      type: e,
      componentType: void 0,
      enumType: g,
      valueType: g.valueType,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  if (n && i === Be.ENUM)
    return {
      type: i,
      componentType: void 0,
      enumType: g,
      valueType: g.valueType,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  if (e === Be.SCALAR || Be.isMatrixType(e) || Be.isVectorType(e))
    return {
      type: e,
      componentType: i,
      enumType: void 0,
      valueType: i,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  if (e === Be.BOOLEAN || e === Be.STRING)
    return {
      type: e,
      componentType: void 0,
      enumType: void 0,
      valueType: void 0,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  if (n && (i === Be.BOOLEAN || i === Be.STRING))
    return {
      type: i,
      componentType: void 0,
      enumType: void 0,
      valueType: void 0,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  if (H(i) && H(Ne[i]))
    return {
      type: Be.SCALAR,
      componentType: i,
      enumType: void 0,
      valueType: i,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  if (H(Ne[e]))
    return {
      type: Be.SCALAR,
      componentType: e,
      enumType: void 0,
      valueType: e,
      isArray: o,
      isVariableLengthArray: a,
      arrayLength: r
    };
  throw new Error(
    `unknown metadata type {type: ${e}, componentType: ${i})`
  );
}
function q_(s, t) {
  if (!Array.isArray(s))
    return s === t;
  if (!Array.isArray(t) || s.length !== t.length)
    return !1;
  for (let e = 0; e < s.length; e++)
    if (!q_(s[e], t[e]))
      return !1;
  return !0;
}
function Bz(s, t) {
  if (!Array.isArray(t))
    return `value ${t} must be an array`;
  const e = t.length;
  if (!s._isVariableLengthArray && e !== s._arrayLength)
    return "Array length does not match property.arrayLength";
  for (let i = 0; i < e; i++) {
    const n = $_(s, t[i]);
    if (H(n))
      return n;
  }
}
function $_(s, t) {
  const e = s._type, i = s._componentType, n = s._enumType, o = s._normalized;
  return Be.isVectorType(e) ? wz(t, e, i) : Be.isMatrixType(e) ? _z(t, e, i) : e === Be.STRING ? xz(t) : e === Be.BOOLEAN ? vz(t) : e === Be.ENUM ? Tz(t, n) : Lz(t, i, o);
}
function wz(s, t, e) {
  if (!Ne.isVectorCompatible(e))
    return `componentType ${e} is incompatible with vector type ${t}`;
  if (t === Be.VEC2 && !(s instanceof Z))
    return `vector value ${s} must be a Vector2`;
  if (t === Be.VEC3 && !(s instanceof B))
    return `vector value ${s} must be a Vector3`;
  if (t === Be.VEC4 && !(s instanceof Me))
    return `vector value ${s} must be a Vector4`;
}
function _z(s, t, e) {
  if (!Ne.isVectorCompatible(e))
    return `componentType ${e} is incompatible with matrix type ${t}`;
  if (t === Be.MAT2 && console.warn("not support mat2"), t === Be.MAT3 && !(s instanceof qe))
    return `matrix value ${s} must be a Matrix3`;
  if (t === Be.MAT4 && !(s instanceof J))
    return `matrix value ${s} must be a Matrix4`;
}
function xz(s) {
  if (typeof s != "string")
    return bh(s, Be.STRING);
}
function vz(s) {
  if (typeof s != "boolean")
    return bh(s, Be.BOOLEAN);
}
function Tz(s, t) {
  const e = typeof s;
  if (H(t))
    return e !== "string" || !H(t.valuesByName[s]) ? `value ${s} is not a valid enum name for ${t.id}` : void 0;
}
function Lz(s, t, e) {
  const i = typeof s;
  switch (t) {
    case Ne.INT8:
    case Ne.UINT8:
    case Ne.INT16:
    case Ne.UINT16:
    case Ne.INT32:
    case Ne.UINT32:
    case Ne.FLOAT32:
    case Ne.FLOAT64:
      return i !== "number" ? bh(s, t) : isFinite(s) ? O0(s, t, e) : Q0(s, t);
    case Ne.INT64:
    case Ne.UINT64:
      return i !== "number" && i !== "bigint" ? bh(s, t) : i === "number" && !isFinite(s) ? Q0(s, t) : O0(s, t, e);
  }
}
function bh(s, t) {
  return `value ${s} does not match type ${t}`;
}
function U0(s, t, e) {
  let i = `value ${s} is out of range for type ${t}`;
  return e && (i += " (normalized)"), i;
}
function O0(s, t, e) {
  if (e) {
    const i = Ne.isUnsignedIntegerType(t) ? 0 : -1, n = 1;
    return s < i || s > n ? U0(s, t, e) : void 0;
  }
  if (s < Ne.getMinimum(t) || s > Ne.getMaximum(t))
    return U0(s, t, e);
}
function Q0(s, t) {
  return `value ${s} of type ${t} must be finite`;
}
const pf = class {
  constructor(t) {
    t = W(t, {});
    const e = t.id, i = W(t.properties, {}), n = {};
    for (const o in i)
      if (i.hasOwnProperty(o)) {
        const r = i[o];
        H(r.semantic) && (n[r.semantic] = r);
      }
    this._id = e, this._name = t.name, this._description = t.description, this._properties = i, this._propertiesBySemantic = n, this._extras = dt(t.extras, !0), this._extensions = dt(t.extensions, !0);
  }
  static fromJson(t) {
    t = W(t, {});
    const e = t.id, i = t.class, n = {};
    for (const o in i.properties)
      if (i.properties.hasOwnProperty(o)) {
        const r = To.fromJson({
          id: o,
          property: i.properties[o],
          enums: t.enums
        });
        n[o] = r;
      }
    return new pf({
      id: e,
      name: i.name,
      description: i.description,
      properties: n,
      extras: i.extras,
      extensions: i.extensions
    });
  }
  get properties() {
    return this._properties;
  }
  get propertiesBySemantic() {
    return this._propertiesBySemantic;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
};
let Wl = pf;
f(Wl, "BATCH_TABLE_CLASS_NAME", "_batchTable");
class ec {
  constructor(t) {
    t = W(t, {});
    const e = W(t.classes, {}), i = W(t.enums, {});
    this._classes = e, this._enums = i, this._id = t.id, this._name = t.name, this._description = t.description, this._version = t.version, this._extras = dt(t.extras, !0), this._extensions = dt(t.extensions, !0);
  }
  static fromJson(t) {
    const e = {};
    if (H(t.enums))
      for (const n in t.enums)
        t.enums.hasOwnProperty(n) && (e[n] = ef.fromJson({
          id: n,
          enum: t.enums[n]
        }));
    const i = {};
    if (H(t.classes))
      for (const n in t.classes)
        t.classes.hasOwnProperty(n) && (i[n] = Wl.fromJson({
          id: n,
          class: t.classes[n],
          enums: e
        }));
    return new ec({
      id: t.id,
      name: t.name,
      description: t.description,
      version: t.version,
      classes: i,
      enums: e,
      extras: t.extras,
      extensions: t.extensions
    });
  }
  get classes() {
    return this._classes;
  }
  get enums() {
    return this._enums;
  }
  get id() {
    return this._id;
  }
  get name() {
    return this._name;
  }
  get description() {
    return this._description;
  }
  get version() {
    return this._version;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class ke {
  static hasProperty(t, e, i) {
    if (H(e[t]))
      return !0;
    const n = i.properties;
    if (!H(n))
      return !1;
    const o = n[t];
    return !!(H(o) && H(o.default));
  }
  static hasPropertyBySemantic(t, e, i) {
    const n = i.propertiesBySemantic;
    if (!H(n))
      return !1;
    const o = n[t];
    return H(o);
  }
  static getPropertyIds(t, e, i) {
    i = H(i) ? i : [], i.length = 0;
    for (const o in t)
      t.hasOwnProperty(o) && H(t[o]) && i.push(o);
    const n = e.properties;
    if (H(n))
      for (const o in n)
        n.hasOwnProperty(o) && !H(t[o]) && H(n[o].default) && i.push(o);
    return i;
  }
  static getProperty(t, e, i) {
    const n = i.properties[t];
    let o = e[t];
    Array.isArray(o) && (o = o.slice());
    const r = !0;
    if (o = n.handleNoData(o), !H(o) && H(n.default))
      return o = dt(n.default, !0), n.unpackVectorAndMatrixTypes(o, r);
    if (!!H(o))
      return o = n.normalize(o), o = n.unpackVectorAndMatrixTypes(o, r), o;
  }
  static setProperty(t, e, i, n) {
    const o = n.properties[t];
    e = o.packVectorAndMatrixTypes(e);
    const r = o.transform(e);
    return H(r) ? (Array.isArray(r) ? i[t] = r.slice() : i[t] = r, !0) : !1;
  }
  static getPropertyBySemantic(t, e, i) {
    const n = i.propertiesBySemantic;
    if (!H(n))
      return;
    const o = n[t];
    if (!!H(o))
      return ke.getProperty(o.id, e, i);
  }
  static setPropertyBySemantic(t, e, i, n) {
    const o = n.propertiesBySemantic;
    if (!H(o))
      return !1;
    const r = o[t];
    return H(r) ? ke.setProperty(r.id, e, i, n) : !1;
  }
}
const Gz = {
  UNISSUED: 0,
  ISSUED: 1,
  ACTIVE: 2,
  RECEIVED: 3,
  CANCELLED: 4,
  FAILED: 5
}, Et = Object.freeze(Gz);
class tc {
  constructor(t = {}) {
    const e = W(t.throttleByServer, !1), i = W(t.throttle, !1);
    this.url = t.url, this.requestFunction = t.requestFunction, this.cancelFunction = t.cancelFunction, this.priorityFunction = t.priorityFunction, this.priority = W(t.priority, 0), this.throttle = i, this.throttleByServer = e, this.serverKey = t.serverKey, this.state = Et.UNISSUED, this.deferred = void 0, this.cancelled = !1;
  }
  cancel() {
    this.cancelled = !0;
  }
  clone(t) {
    return H(t) ? (t.url = this.url, t.requestFunction = this.requestFunction, t.cancelFunction = this.cancelFunction, t.priorityFunction = this.priorityFunction, t.priority = this.priority, t.throttle = this.throttle, t.throttleByServer = this.throttleByServer, t.type = this.type, t.serverKey = this.serverKey, t.state = Et.UNISSUED, t.deferred = void 0, t.cancelled = !1, t) : new tc(this);
  }
}
function Sn(s, t, e) {
  if (!H(s))
    throw new Error("uint8Array is required.");
  if (t < 0)
    throw new Error("byteOffset cannot be negative.");
  if (e < 0)
    throw new Error("byteLength cannot be negative.");
  if (t + e > s.byteLength)
    throw new Error("sub-region exceeds array bounds.");
  return t = W(t, 0), e = W(e, s.byteLength - t), s = s.subarray(t, t + e), Sn.decode(s);
}
Sn.decodeWithTextDecoder = function(s) {
  return new TextDecoder("utf-8").decode(s);
};
Sn.decodeWithFromCharCode = function(s) {
  let t = "";
  const e = Mz(s), i = e.length;
  for (let n = 0; n < i; ++n) {
    let o = e[n];
    o <= 65535 ? t += String.fromCharCode(o) : (o -= 65536, t += String.fromCharCode((o >> 10) + 55296, (o & 1023) + 56320));
  }
  return t;
};
function tg(s, t, e) {
  return t <= s && s <= e;
}
function Mz(s) {
  let t = 0, e = 0, i = 0, n = 128, o = 191;
  const r = [], a = s.length;
  for (let g = 0; g < a; ++g) {
    const c = s[g];
    if (i === 0) {
      if (tg(c, 0, 127)) {
        r.push(c);
        continue;
      }
      if (tg(c, 194, 223)) {
        i = 1, t = c & 31;
        continue;
      }
      if (tg(c, 224, 239)) {
        c === 224 && (n = 160), c === 237 && (o = 159), i = 2, t = c & 15;
        continue;
      }
      if (tg(c, 240, 244)) {
        c === 240 && (n = 144), c === 244 && (o = 143), i = 3, t = c & 7;
        continue;
      }
      throw new Error("String decoding failed.");
    }
    if (!tg(c, n, o)) {
      t = i = e = 0, n = 128, o = 191, --g;
      continue;
    }
    n = 128, o = 191, t = t << 6 | c & 63, ++e, e === i && (r.push(t), t = i = e = 0);
  }
  return r;
}
typeof TextDecoder < "u" ? Sn.decode = Sn.decodeWithTextDecoder : Sn.decode = Sn.decodeWithFromCharCode;
function ex(s, t) {
  return t = W(t, 0), Sn(
    s,
    t,
    Math.min(4, s.length)
  );
}
function Ez(s, t, e) {
  return JSON.parse(
    Sn(s, t, e)
  );
}
class Rz {
  constructor(t) {
    t = W(t, W.EMPTY_OBJECT);
    const e = t.count, i = t.property, n = t.classProperty, o = t.bufferViews, r = n.type, a = n.isArray, g = n.isVariableLengthArray;
    let c = n.valueType;
    const l = n.enumType, h = r === Be.STRING, d = r === Be.BOOLEAN;
    let C = 0, p;
    if (g) {
      let R = W(
        i.arrayOffsetType,
        i.offsetType
      );
      R = W(
        Ne[R],
        Ne.UINT32
      );
      const w = W(
        i.arrayOffsets,
        i.arrayOffsetBufferView
      );
      p = new zu(
        o[w],
        R,
        e + 1
      ), C += p.typedArray.byteLength;
    }
    const m = Be.getComponentCount(r);
    let b;
    g ? b = p.get(e) - p.get(0) : a ? b = e * n.arrayLength : b = e;
    const S = m * b;
    let A;
    if (h) {
      let R = W(
        i.stringOffsetType,
        i.offsetType
      );
      R = W(
        Ne[R],
        Ne.UINT32
      );
      const w = W(
        i.stringOffsets,
        i.stringOffsetBufferView
      );
      A = new zu(
        o[w],
        R,
        S + 1
      ), C += A.typedArray.byteLength;
    }
    (h || d) && (c = Ne.UINT8);
    let u;
    h ? u = A.get(S) - A.get(0) : d ? u = Math.ceil(S / 8) : u = S;
    const y = W(i.values, i.bufferView), I = new zu(
      o[y],
      c,
      u
    );
    C += I.typedArray.byteLength;
    let M = i.offset, G = i.scale;
    const x = n.hasValueTransform || H(M) || H(G);
    M = W(M, n.offset), G = W(G, n.scale), M = Y0(M), G = Y0(G);
    let L, E;
    const T = this;
    h ? L = function(R) {
      return Hz(R, T._values, T._stringOffsets);
    } : d ? (L = function(R) {
      return Pz(R, T._values);
    }, E = function(R, w) {
      Nz(R, T._values, w);
    }) : H(l) ? (L = function(R) {
      const w = T._values.get(R);
      return l.namesByValue[w];
    }, E = function(R, w) {
      const v = l.valuesByName[w];
      T._values.set(R, v);
    }) : (L = function(R) {
      return T._values.get(R);
    }, E = function(R, w) {
      T._values.set(R, w);
    }), this._arrayOffsets = p, this._stringOffsets = A, this._values = I, this._classProperty = n, this._count = e, this._vectorComponentCount = m, this._min = i.min, this._max = i.max, this._offset = M, this._scale = G, this._hasValueTransform = x, this._getValue = L, this._setValue = E, this._unpackedValues = void 0, this._extras = i.extras, this._extensions = i.extensions, this._byteLength = C;
  }
  get(t) {
    let e = Dz(this, t);
    return e = this._classProperty.handleNoData(e), H(e) ? (e = this._classProperty.normalize(e), e = Uz(this, e), this._classProperty.unpackVectorAndMatrixTypes(e)) : (e = this._classProperty.default, this._classProperty.unpackVectorAndMatrixTypes(e));
  }
  set(t, e) {
    const i = this._classProperty;
    e = i.packVectorAndMatrixTypes(e), e = Oz(this, e), e = i.unnormalize(e), Kz(this, t, e);
  }
  getTypedArray() {
    if (H(this._values))
      return this._values.typedArray;
  }
  get hasValueTransform() {
    return this._hasValueTransform;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get extensions() {
    return this._extensions;
  }
  get byteLength() {
    return this._byteLength;
  }
}
function zu(s, t, e) {
  const i = this;
  let n, o, r;
  t === Ne.INT64 ? j0() ? sx() ? (n = new BigInt64Array(
    s.buffer,
    s.byteOffset,
    e
  ), r = function(a, g) {
    i.typedArray[a] = BigInt(g);
  }) : (n = new Uint8Array(
    s.buffer,
    s.byteOffset,
    e * 8
  ), o = function(a) {
    return kz(a, i);
  }) : ($i(
    "INT64 type is not fully supported on this platform. Values greater than 2^53 - 1 or less than -(2^53 - 1) may lose precision when read."
  ), n = new Uint8Array(
    s.buffer,
    s.byteOffset,
    e * 8
  ), o = function(a) {
    return Fz(a, i);
  }) : t === Ne.UINT64 ? j0() ? ox() ? (n = new BigUint64Array(
    s.buffer,
    s.byteOffset,
    e
  ), r = function(a, g) {
    i.typedArray[a] = BigInt(g);
  }) : (n = new Uint8Array(
    s.buffer,
    s.byteOffset,
    e * 8
  ), o = function(a) {
    return zz(a, i);
  }) : ($i(
    "UINT64 type is not fully supported on this platform. Values greater than 2^53 - 1 may lose precision when read."
  ), n = new Uint8Array(
    s.buffer,
    s.byteOffset,
    e * 8
  ), o = function(a) {
    return Vz(a, i);
  }) : (n = Xz(
    t,
    s.buffer,
    s.byteOffset,
    e
  ), r = function(a, g) {
    i.typedArray[a] = g;
  }), H(o) || (o = function(a) {
    return i.typedArray[a];
  }), this.typedArray = n, this.dataView = new DataView(n.buffer, n.byteOffset), this.get = o, this.set = r, this._componentType = t;
}
function Y0(s) {
  if (!Array.isArray(s))
    return s;
  const t = [];
  for (let e = 0; e < s.length; e++) {
    const i = s[e];
    Array.isArray(i) ? t.push.apply(t, i) : t.push(i);
  }
  return t;
}
function Dz(s, t) {
  ix(s) && nx(s);
  const e = s._classProperty, i = e.isArray, n = e.type, o = Be.getComponentCount(n);
  if (H(s._unpackedValues)) {
    const r = s._unpackedValues[t];
    return i ? dt(r, !0) : r;
  }
  return !i && o === 1 ? s._getValue(t) : tx(s, e, t);
}
function tx(s, t, e) {
  let i, n;
  if (t.isVariableLengthArray) {
    i = s._arrayOffsets.get(e), n = s._arrayOffsets.get(e + 1) - i;
    const r = Be.getComponentCount(t.type);
    i *= r, n *= r;
  } else {
    const a = W(t.arrayLength, 1) * s._vectorComponentCount;
    i = e * a, n = a;
  }
  const o = new Array(n);
  for (let r = 0; r < n; r++)
    o[r] = s._getValue(i + r);
  return o;
}
function Kz(s, t, e) {
  Wz(s, t, e) && nx(s);
  const i = s._classProperty, n = i.isArray, o = i.type, r = Be.getComponentCount(o);
  if (H(s._unpackedValues)) {
    i.isArray && (e = dt(e, !0)), s._unpackedValues[t] = e;
    return;
  }
  if (!n && r === 1) {
    s._setValue(t, e);
    return;
  }
  let a, g;
  if (i.isVariableLengthArray)
    a = s._arrayOffsets.get(t), g = s._arrayOffsets.get(t + 1) - a;
  else {
    const l = W(i.arrayLength, 1) * s._vectorComponentCount;
    a = t * l, g = l;
  }
  for (let c = 0; c < g; ++c)
    s._setValue(a + c, e[c]);
}
function Hz(s, t, e) {
  const i = e.get(s), n = e.get(s + 1) - i;
  return Sn(
    t.typedArray,
    i,
    n
  );
}
function Pz(s, t) {
  const e = s >> 3, i = s % 8;
  return (t.typedArray[e] >> i & 1) === 1;
}
function Nz(s, t, e) {
  const i = s >> 3, n = s % 8;
  e ? t.typedArray[i] |= 1 << n : t.typedArray[i] &= ~(1 << n);
}
function Fz(s, t) {
  const e = t.dataView, i = s * 8;
  let n = 0;
  const o = (e.getUint8(i + 7) & 128) > 0;
  let r = !0;
  for (let a = 0; a < 8; ++a) {
    let g = e.getUint8(i + a);
    o && (r ? g !== 0 && (g = ~(g - 1) & 255, r = !1) : g = ~g & 255), n += g * Math.pow(256, a);
  }
  return o && (n = -n), n;
}
function kz(s, t) {
  const e = t.dataView, i = s * 8;
  let n = BigInt(0);
  const o = (e.getUint8(i + 7) & 128) > 0;
  let r = !0;
  for (let a = 0; a < 8; ++a) {
    let g = e.getUint8(i + a);
    o && (r ? g !== 0 && (g = ~(g - 1) & 255, r = !1) : g = ~g & 255), n += BigInt(g) * (BigInt(1) << BigInt(a * 8));
  }
  return o && (n = -n), n;
}
function Vz(s, t) {
  const e = t.dataView, i = s * 8, n = e.getUint32(i, !0), o = e.getUint32(i + 4, !0);
  return n + 4294967296 * o;
}
function zz(s, t) {
  const e = t.dataView, i = s * 8, n = BigInt(e.getUint32(i, !0)), o = BigInt(e.getUint32(i + 4, !0));
  return n + BigInt(4294967296) * o;
}
function Xz(s, t, e, i) {
  switch (s) {
    case Ne.INT8:
      return new Int8Array(t, e, i);
    case Ne.UINT8:
      return new Uint8Array(t, e, i);
    case Ne.INT16:
      return new Int16Array(t, e, i);
    case Ne.UINT16:
      return new Uint16Array(t, e, i);
    case Ne.INT32:
      return new Int32Array(t, e, i);
    case Ne.UINT32:
      return new Uint32Array(t, e, i);
    case Ne.FLOAT32:
      return new Float32Array(t, e, i);
    case Ne.FLOAT64:
      return new Float64Array(t, e, i);
    default:
      throw new Error(`Unsupported component type: ${s}`);
  }
}
function ix(s) {
  if (H(s._unpackedValues))
    return !1;
  const t = s._classProperty, e = t.type, i = t.valueType;
  return e === Be.STRING || i === Ne.INT64 && !sx() || i === Ne.UINT64 && !ox();
}
function Wz(s, t, e) {
  if (ix(s))
    return !0;
  const i = s._arrayOffsets;
  if (H(i)) {
    const n = i.get(t + 1) - i.get(t), o = e.length;
    if (n !== o)
      return !0;
  }
  return !1;
}
function nx(s) {
  s._unpackedValues = Zz(s), s._arrayOffsets = void 0, s._stringOffsets = void 0, s._values = void 0;
}
function Zz(s) {
  const t = s._count, e = new Array(t), i = s._classProperty, n = i.isArray, o = i.type, r = Be.getComponentCount(o);
  if (!n && r === 1) {
    for (let a = 0; a < t; ++a)
      e[a] = s._getValue(a);
    return e;
  }
  for (let a = 0; a < t; a++)
    e[a] = tx(s, i, a);
  return e;
}
function Uz(s, t) {
  const i = s._classProperty.isVariableLengthArray;
  return !s._hasValueTransform || i ? t : To.valueTransformInPlace(
    t,
    s._offset,
    s._scale,
    Ne.applyValueTransform
  );
}
function Oz(s, t) {
  const i = s._classProperty.isVariableLengthArray;
  return !s._hasValueTransform || i ? t : To.valueTransformInPlace(
    t,
    s._offset,
    s._scale,
    Ne.unapplyValueTransform
  );
}
function j0() {
  return typeof BigInt < "u";
}
function sx() {
  return typeof BigInt64Array < "u";
}
function ox() {
  return typeof BigUint64Array < "u";
}
class Qz {
  constructor(t = {}) {
    t = W(t, W.EMPTY_OBJECT);
    const { count: e, properties: i, class: n, bufferViews: o } = t;
    if (this._count = e, this._class = n, this._properties = {}, this._byteLength = 0, H(i)) {
      for (const r in i)
        if (i.hasOwnProperty(r)) {
          const a = new Rz({
            count: e,
            property: i[r],
            classProperty: n.properties[r],
            bufferViews: o
          });
          this._properties[r] = a, this._byteLength += a.byteLength;
        }
    }
  }
  get count() {
    return this._count;
  }
  get class() {
    return this._class;
  }
  get byteLength() {
    return this._byteLength;
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, this._class);
  }
  hasPropertyBySemantic(t) {
    return ke.hasPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  getPropertyIds(t = []) {
    return ke.getPropertyIds(this._properties, this._class, t);
  }
  getProperty(t, e) {
    const i = this._properties[e];
    let n;
    return H(i) ? n = i.get(t) : n = Yz(this._class, e), n;
  }
  setProperty(t, e, i) {
    const n = this._properties[e];
    return H(n) ? (n.set(t, i), !0) : !1;
  }
  getPropertyBySemantic(t, e) {
    let i;
    const n = this._class.propertiesBySemantic;
    if (H(n) && (i = n[e]), H(i))
      return this.getProperty(t, i.id);
  }
  setPropertyBySemantic(t, e, i) {
    let n;
    const o = this._class.propertiesBySemantic;
    return H(o) && (n = o[e]), H(n) ? this.setProperty(t, n.id, i) : !1;
  }
  getPropertyTypedArray(t) {
    const e = this._properties[t];
    if (H(e))
      return e.getTypedArray();
  }
  getPropertyTypedArrayBySemantic(t) {
    let e;
    const i = this._class.propertiesBySemantic;
    if (H(i) && (e = i[t]), H(e))
      return this.getPropertyTypedArray(e.id);
  }
}
function Yz(s, t) {
  const e = s.properties;
  if (!H(e))
    return;
  const i = e[t];
  if (H(i) && H(i.default)) {
    let n = i.default;
    return i.isArray && (n = dt(n, !0)), n = i.normalize(n), i.unpackVectorAndMatrixTypes(n);
  }
}
const J0 = {};
class jz {
  constructor(t) {
    this._count = t.count, this._properties = dt(t.properties, !0);
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, J0);
  }
  getPropertyIds(t = []) {
    return ke.getPropertyIds(this._properties, J0, t);
  }
  getProperty(t, e) {
    const i = this._properties[e];
    if (H(i))
      return dt(i[t], !0);
  }
  setProperty(t, e, i) {
    let n = this._properties[e];
    H(n) || (n = new Array(this._count), this._properties[e] = n), n[t] = dt(i, !0);
  }
}
const Xu = [];
class Jz {
  constructor(t = W.EMPTY_OBJECT) {
    this._name = t.name, this._id = t.id, this._count = t.count, this._extras = t.extras, this._extensions = t.extensions, this._metadataTable = t.metadataTable, this._jsonMetadataTable = t.jsonMetadataTable, this._batchTableHierarchy = t.batchTableHierarchy;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get count() {
    return this._count;
  }
  get class() {
    return this._metadataTable ? this._metadataTable.class : void 0;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  get byteLength() {
    let t = 0;
    return this._metadataTable && (t += this._metadataTable.byteLength), this._batchTableHierarchy && (t += this._batchTableHierarchy.byteLength), t;
  }
  hasProperty(t, e) {
    return !!(this._metadataTable && this._metadataTable.hasProperty(e) || this._batchTableHierarchy && this._batchTableHierarchy.hasProperty(t, e) || this._jsonMetadataTable && this._jsonMetadataTable.hasProperty(e));
  }
  hasPropertyBySemantic(t, e) {
    return this._metadataTable ? this._metadataTable.hasPropertyBySemantic(e) : !1;
  }
  propertyExists(t) {
    return !!(this._metadataTable && this._metadataTable.hasProperty(t) || this._batchTableHierarchy && this._batchTableHierarchy.propertyExists(t) || this._jsonMetadataTable && this._jsonMetadataTable.hasProperty(t));
  }
  propertyExistsBySemantic(t) {
    return this._metadataTable ? this._metadataTable.hasPropertyBySemantic(t) : !1;
  }
  getPropertyIds(t, e = []) {
    return e.length = 0, this._metadataTable && e.push(...this._metadataTable.getPropertyIds(Xu)), this._batchTableHierarchy && e.push(...this._batchTableHierarchy.getPropertyIds(t, Xu)), this._jsonMetadataTable && e.push(...this._jsonMetadataTable.getPropertyIds(Xu)), e;
  }
  getProperty(t, e) {
    let i;
    if (this._metadataTable && (i = this._metadataTable.getProperty(t, e), i) || this._batchTableHierarchy && (i = this._batchTableHierarchy.getProperty(t, e), i) || this._jsonMetadataTable && (i = this._jsonMetadataTable.getProperty(t, e), i))
      return i;
  }
  setProperty(t, e, i) {
    this._metadataTable && this._metadataTable.setProperty(t, e, i) || this._batchTableHierarchy && this._batchTableHierarchy.setProperty(t, e, i) || (this._jsonMetadataTable || (this._jsonMetadataTable = new jz({
      count: this._count,
      properties: {}
    })), this._jsonMetadataTable.setProperty(t, e, i));
  }
  getPropertyBySemantic(t, e) {
    return this._metadataTable ? this._metadataTable.getPropertyBySemantic(t, e) : void 0;
  }
  setPropertyBySemantic(t, e, i) {
    return this._metadataTable ? this._metadataTable.setPropertyBySemantic(t, e, i) : !1;
  }
  getPropertyTypedArray(t) {
    return this._metadataTable ? this._metadataTable.getPropertyTypedArray(t) : void 0;
  }
  getPropertyTypedArrayBySemantic(t) {
    return this._metadataTable ? this._metadataTable.getPropertyTypedArrayBySemantic(t) : void 0;
  }
  isClass(t, e) {
    return this._batchTableHierarchy ? this._batchTableHierarchy.isClass(t, e) : !1;
  }
  isExactClass(t, e) {
    return this.getExactClassName(t) === e;
  }
  getExactClassName(t) {
    return this._batchTableHierarchy ? this._batchTableHierarchy.getClassName(t) : void 0;
  }
}
class qz {
  constructor(t) {
    t = W(t, W.EMPTY_OBJECT);
    const e = t.property, i = t.classProperty, n = t.textures, o = H(e.channels) ? e.channels : [0], r = e;
    this._textureInfo = r, this._channels = $z(o), this._texture = n[r.index], this._min = e.min, this._max = e.max;
    let a = e.offset, g = e.scale;
    const c = i.hasValueTransform || H(a) || H(g);
    a = W(a, i.offset), g = W(g, i.scale), a = i.unpackVectorAndMatrixTypes(a), g = i.unpackVectorAndMatrixTypes(g), this._offset = a, this._scale = g, this._hasValueTransform = c, this._classProperty = i, this._extras = e.extras, this._extensions = e.extensions;
  }
  get texture() {
    return this._texture;
  }
  get channels() {
    return this._channels;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get extra() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  get classProperty() {
    return this._classProperty;
  }
  get textureInfo() {
    return this._textureInfo;
  }
}
function $z(s) {
  return s.map(function(t) {
    return "rgba".charAt(t);
  }).join("");
}
class eX {
  constructor(t) {
    t = W(t, W.EMPTY_OBJECT);
    const e = t.propertyTexture, i = t.class, n = t.textures, o = e.extensions, r = e.extras, a = {};
    if (H(e.properties))
      for (const g in e.properties)
        e.properties.hasOwnProperty(g) && (a[g] = new qz({
          property: e.properties[g],
          classProperty: i.properties[g],
          textures: n
        }));
    this._name = t.name, this._id = t.id, this._class = i, this._properties = a, this._extras = r, this._extensions = o;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get class() {
    return this._class;
  }
  get properties() {
    return this._properties;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  getProperty(t) {
    return this._properties[t];
  }
}
class tX {
  constructor(t) {
    t = W(t, W.EMPTY_OBJECT);
    const e = t.property, i = t.classProperty;
    this._attribute = e.attribute, this._classProperty = i, this._min = e.min, this._max = e.max;
    let n = e.offset, o = e.scale;
    const r = i.hasValueTransform || H(n) || H(o);
    n = W(n, i.offset), o = W(o, i.scale), n = i.unpackVectorAndMatrixTypes(n), o = i.unpackVectorAndMatrixTypes(o), this._offset = n, this._scale = o, this._hasValueTransform = r, this._extras = e.extras, this._extensions = e.extensions;
  }
  get attribute() {
    return this._attribute;
  }
  get hasValueTransform() {
    return this._hasValueTransform;
  }
  get offset() {
    return this._offset;
  }
  get scale() {
    return this._scale;
  }
  get classProperty() {
    return this._classProperty;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class iX {
  constructor(t) {
    t = W(t, W.EMPTY_OBJECT);
    const e = t.propertyAttribute, i = t.class, n = {};
    if (H(e.properties))
      for (const o in e.properties)
        e.properties.hasOwnProperty(o) && (n[o] = new tX({
          property: e.properties[o],
          classProperty: i.properties[o]
        }));
    this._name = t.name, this._id = t.id, this._class = i, this._properties = n, this._extras = e.extras, this._extensions = e.extensions;
  }
  get name() {
    return this._name;
  }
  get id() {
    return this._id;
  }
  get class() {
    return this._class;
  }
  get properties() {
    return this._properties;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  getProperty(t) {
    return this._properties[t];
  }
}
function nX(s) {
  s = W(s, W.EMPTY_OBJECT);
  const t = s.extension, e = s.schema, i = [];
  if (H(t.propertyTables))
    for (let r = 0; r < t.propertyTables.length; r++) {
      const a = t.propertyTables[r], g = e.classes[a.class], c = new Qz({
        count: a.count,
        properties: a.properties,
        class: g,
        bufferViews: s.bufferViews
      });
      i.push(
        new Jz({
          id: r,
          name: a.name,
          count: a.count,
          metadataTable: c,
          extras: a.extras,
          extensions: a.extensions
        })
      );
    }
  const n = [];
  if (H(t.propertyTextures))
    for (let r = 0; r < t.propertyTextures.length; r++) {
      const a = t.propertyTextures[r];
      n.push(
        new eX({
          id: r,
          name: a.name,
          propertyTexture: a,
          class: e.classes[a.class],
          textures: s.textures
        })
      );
    }
  const o = [];
  if (H(t.propertyAttributes))
    for (let r = 0; r < t.propertyAttributes.length; r++) {
      const a = t.propertyAttributes[r];
      o.push(
        new iX({
          id: r,
          name: a.name,
          class: e.classes[a.class],
          propertyAttribute: a
        })
      );
    }
  return new J_({
    schema: e,
    propertyTables: i,
    propertyTextures: n,
    propertyAttributes: o,
    statistics: t.statistics,
    extras: t.extras,
    extensions: t.extensions
  });
}
function sX(s, t) {
  let e = [], i = [];
  if (t) {
    if (t.propertyTextures) {
      const o = s.propertyTextures;
      e = t.propertyTextures.map((r) => o[r]);
    }
    if (t.propertyAttributes) {
      const o = s.propertyAttributes;
      i = t.propertyAttributes.map((r) => o[r]);
    }
  }
  return new J_({
    schema: s.schema,
    propertyTables: s.propertyTables,
    propertyTextures: e,
    propertyAttributes: i,
    extras: s.extras,
    extensions: s.extensions
  });
}
const ig = "EXT_structural_metadata";
function oX(s, t = []) {
  var n;
  const e = ((n = s.json.textures) == null ? void 0 : n.length) || 0, i = new Array(e).fill(null);
  return t.forEach(({ properties: o }) => {
    for (const r in o)
      if (o.hasOwnProperty(r)) {
        const { index: a } = o[r];
        i[a] === null && (i[a] = s.loadTexture(a));
      }
  }), Promise.all(i);
}
function rX(s, t = []) {
  var n;
  const e = ((n = s.json.bufferViews) == null ? void 0 : n.length) || 0, i = new Array(e).fill(null);
  return t.forEach(({ properties: o }) => {
    for (const r in o)
      if (o.hasOwnProperty(r)) {
        const { values: a, arrayOffsets: g, stringOffsets: c } = o[r];
        i[a] === null && (i[a] = s.loadBufferView(a)), i[g] === null && (i[g] = s.loadBufferView(g)), i[c] === null && (i[c] = s.loadBufferView(c));
      }
  }), Promise.all(i);
}
class aX {
  constructor(t) {
    this.parser = t, this.name = ig;
  }
  async afterRoot({ scene: t, parser: e }) {
    const i = e.json.extensionsUsed;
    if (!i || !i.includes(ig))
      return;
    let n = null, o = e.json.extensions[ig];
    if (o.schemaUri) {
      const { manager: h, path: d, requestHeader: C, crossOrigin: p } = e.options, m = new URL(o.schemaUri, d).toString(), b = new rs(h);
      b.setCrossOrigin(p), b.setResponseType("json"), b.setRequestHeader(C), n = b.loadAsync(m).then((S) => {
        o = { ...o, schema: S };
      });
    }
    const [r, a] = await Promise.all([
      oX(e, o.propertyTextures),
      rX(e, o.propertyTables),
      n
    ]), g = a.map((h) => {
      if (h)
        return new Uint8Array(h);
    }), c = ec.fromJson(o.schema), l = nX({
      extension: o,
      schema: c,
      bufferViews: g,
      textures: r
    });
    t.userData.structuralMetadata = l, t.traverse((h) => {
      if (e.associations.has(h)) {
        const { meshes: d, primitives: C } = e.associations.get(h);
        if (H(d) && H(C)) {
          const p = e.json.meshes[d].primitives[C];
          if (p && p.extensions && p.extensions[ig]) {
            const m = p.extensions[ig];
            h.userData.structuralMetadata = sX(
              l,
              m
            );
          } else
            h.userData.structuralMetadata = l;
        }
      }
    });
  }
}
class gX extends Fh {
  constructor(t) {
    super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.forceUnlit = !1, this.pluginCallbacks = [], this.register(function(e) {
      return new dX(e);
    }), this.register(function(e) {
      return new Wu(e);
    }), this.register(function(e) {
      return new yX(e);
    }), this.register(function(e) {
      return new SX(e);
    }), this.register(function(e) {
      return new IX(e);
    }), this.register(function(e) {
      return new AX(e);
    }), this.register(function(e) {
      return new CX(e);
    }), this.register(function(e) {
      return new fX(e);
    }), this.register(function(e) {
      return new hX(e);
    }), this.register(function(e) {
      return new pX(e);
    }), this.register(function(e) {
      return new uX(e);
    }), this.register(function(e) {
      return new mX(e);
    }), this.register(function(e) {
      return new lX(e);
    }), this.register(function(e) {
      return new bX(e);
    }), this.register(function(e) {
      return new BX(e);
    }), this.register(function(e) {
      return new mz(e);
    }), this.register(function(e) {
      return new aX(e);
    });
  }
  load(t, e, i, n) {
    const o = this;
    let r;
    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = ma.extractUrlBase(t), this.manager.itemStart(t);
    const a = function(c) {
      n ? n(c) : console.error(c), o.manager.itemError(t), o.manager.itemEnd(t);
    }, g = new rs(this.manager);
    g.setPath(this.path), g.setResponseType("arraybuffer"), g.setRequestHeader(this.requestHeader), g.setWithCredentials(this.withCredentials), g.load(t, function(c) {
      try {
        o.parse(c, r, function(l) {
          e(l), o.manager.itemEnd(t);
        }, a);
      } catch (l) {
        a(l);
      }
    }, i, a);
  }
  setForceUnlit(t) {
    return this.forceUnlit = t, this;
  }
  setDRACOLoader(t) {
    return this.dracoLoader = t, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(t) {
    return this.ktx2Loader = t, this;
  }
  setMeshoptDecoder(t) {
    return this.meshoptDecoder = t, this;
  }
  register(t) {
    return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
  }
  unregister(t) {
    return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
  }
  parse(t, e, i, n) {
    let o;
    const r = {}, a = {}, g = new TextDecoder();
    if (typeof t == "string")
      o = JSON.parse(t);
    else if (t instanceof ArrayBuffer) {
      const l = g.decode(new Uint8Array(t, 0, 4));
      if (l === ax || l === rx) {
        try {
          r[je.KHR_BINARY_GLTF] = new wX(t);
        } catch (h) {
          n && n(h);
          return;
        }
        o = JSON.parse(r[je.KHR_BINARY_GLTF].content);
      } else
        o = JSON.parse(g.decode(t));
    } else
      o = t;
    if (o.asset === void 0 || o.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new PX(o, {
      path: e || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
      forceUnlit: this.forceUnlit
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let l = 0; l < this.pluginCallbacks.length; l++) {
      const h = this.pluginCallbacks[l](c);
      a[h.name] = h, r[h.name] = !0;
    }
    if (o.extensionsUsed)
      for (let l = 0; l < o.extensionsUsed.length; ++l) {
        const h = o.extensionsUsed[l], d = o.extensionsRequired || [];
        switch (h) {
          case je.KHR_MATERIALS_UNLIT:
            r[h] = new q0();
            break;
          case je.KHR_DRACO_MESH_COMPRESSION:
            r[h] = new _X(o, this.dracoLoader);
            break;
          case je.KHR_TEXTURE_TRANSFORM:
            r[h] = new xX();
            break;
          case je.KHR_MESH_QUANTIZATION:
            r[h] = new vX();
            break;
          case je.KHR_TEXTURE_BASISU:
            r[h] = new Wu(c);
            break;
          default:
            d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    if (o.textures)
      for (let l = 0, h = o.textures.length; l < h; l++) {
        const d = o.textures[l];
        d.extensions && d.extensions.KHR_texture_basisu && typeof d.extensions.KHR_texture_basisu.source == "number" && (d.source = d.source || d.extensions.KHR_texture_basisu.source), o.images[d.source].mimeType === "image/ktx2" && (r.KHR_texture_basisu = new Wu(
          c
        ), o.textures[l].extensions = {
          KHR_texture_basisu: d
        });
      }
    this.forceUnlit && (r.KHR_materials_unlit = new q0()), c.setExtensions(r), c.setPlugins(a), c.parse(i, n);
  }
  parseAsync(t, e) {
    const i = this;
    return new Promise(function(n, o) {
      i.parse(t, e, n, o);
    });
  }
}
function cX() {
  let s = {};
  return {
    get: function(t) {
      return s[t];
    },
    add: function(t, e) {
      s[t] = e;
    },
    remove: function(t) {
      delete s[t];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const je = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class lX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const t = this.parser, e = this.parser.json.nodes || [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      o.extensions && o.extensions[this.name] && o.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, o.extensions[this.name].light);
    }
  }
  _loadLight(t) {
    const e = this.parser, i = "light:" + t;
    let n = e.cache.get(i);
    if (n)
      return n;
    const o = e.json, g = ((o.extensions && o.extensions[this.name] || {}).lights || [])[t];
    let c;
    const l = new Ce(16777215);
    g.color !== void 0 && l.fromArray(g.color);
    const h = g.range !== void 0 ? g.range : 0;
    switch (g.type) {
      case "directional":
        c = new Ph(l), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Ib(l), c.distance = h;
        break;
      case "spot":
        c = new ub(l), c.distance = h, g.spot = g.spot || {}, g.spot.innerConeAngle = g.spot.innerConeAngle !== void 0 ? g.spot.innerConeAngle : 0, g.spot.outerConeAngle = g.spot.outerConeAngle !== void 0 ? g.spot.outerConeAngle : Math.PI / 4, c.angle = g.spot.outerConeAngle, c.penumbra = 1 - g.spot.innerConeAngle / g.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + g.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, yo(c, g), g.intensity !== void 0 && (c.intensity = g.intensity), c.name = e.createUniqueName(g.name || "light_" + t), n = Promise.resolve(c), e.cache.add(i, n), n;
  }
  getDependency(t, e) {
    if (t === "light")
      return this._loadLight(e);
  }
  createNodeAttachment(t) {
    const e = this, i = this.parser, o = i.json.nodes[t], a = (o.extensions && o.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(g) {
      return i._getNodeRef(e.cache, a, g);
    });
  }
}
class q0 {
  constructor() {
    this.name = je.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return _t;
  }
  extendParams(t, e, i) {
    const n = [];
    t.color = new Ce(1, 1, 1), t.opacity = 1;
    const o = e.pbrMetallicRoughness;
    if (o) {
      if (Array.isArray(o.baseColorFactor)) {
        const r = o.baseColorFactor;
        t.color.fromArray(r), t.opacity = r[3];
      }
      o.baseColorTexture !== void 0 && n.push(i.assignTexture(t, "map", o.baseColorTexture, gt));
    }
    return Promise.all(n);
  }
}
class hX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = n.extensions[this.name].emissiveStrength;
    return o !== void 0 && (e.emissiveIntensity = o), Promise.resolve();
  }
}
class dX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (e.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && o.push(i.assignTexture(e, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && o.push(i.assignTexture(e, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (o.push(i.assignTexture(e, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const a = r.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new Z(a, a);
    }
    return Promise.all(o);
  }
}
class uX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (e.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && o.push(i.assignTexture(e, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (e.iridescenceIOR = r.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && o.push(i.assignTexture(e, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(o);
  }
}
class IX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [];
    e.sheenColor = new Ce(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
    const r = n.extensions[this.name];
    return r.sheenColorFactor !== void 0 && e.sheenColor.fromArray(r.sheenColorFactor), r.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && o.push(i.assignTexture(e, "sheenColorMap", r.sheenColorTexture, gt)), r.sheenRoughnessTexture !== void 0 && o.push(i.assignTexture(e, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(o);
  }
}
class AX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    return r.transmissionFactor !== void 0 && (e.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && o.push(i.assignTexture(e, "transmissionMap", r.transmissionTexture)), Promise.all(o);
  }
}
class CX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    e.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && o.push(i.assignTexture(e, "thicknessMap", r.thicknessTexture)), e.attenuationDistance = r.attenuationDistance || 1 / 0;
    const a = r.attenuationColor || [1, 1, 1];
    return e.attenuationColor = new Ce(a[0], a[1], a[2]), Promise.all(o);
  }
}
class fX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_IOR;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = n.extensions[this.name];
    return e.ior = o.ior !== void 0 ? o.ior : 1.5, Promise.resolve();
  }
}
class pX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    e.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && o.push(i.assignTexture(e, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return e.specularColor = new Ce(a[0], a[1], a[2]), r.specularColorTexture !== void 0 && o.push(i.assignTexture(e, "specularColorMap", r.specularColorTexture, gt)), Promise.all(o);
  }
}
class mX {
  constructor(t) {
    this.parser = t, this.name = je.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    return r.anisotropyStrength !== void 0 && (e.anisotropy = r.anisotropyStrength), r.anisotropyRotation !== void 0 && (e.anisotropyRotation = r.anisotropyRotation), r.anisotropyTexture !== void 0 && o.push(i.assignTexture(e, "anisotropyMap", r.anisotropyTexture)), Promise.all(o);
  }
}
class Wu {
  constructor(t) {
    this.parser = t, this.name = je.KHR_TEXTURE_BASISU;
  }
  loadTexture(t) {
    const e = this.parser, i = e.json, n = i.textures[t];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const o = n.extensions[this.name], r = e.options.ktx2Loader;
    if (!r) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e.loadTextureImage(t, o.source, r);
  }
}
class yX {
  constructor(t) {
    this.parser = t, this.name = je.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(t) {
    const e = this.name, i = this.parser, n = i.json, o = n.textures[t];
    if (!o.extensions || !o.extensions[e])
      return null;
    const r = o.extensions[e], a = n.images[r.source];
    let g = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (g = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return i.loadTextureImage(t, r.source, g);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(t);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t) {
      const e = new Image();
      e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
        t(e.height === 1);
      };
    })), this.isSupported;
  }
}
class SX {
  constructor(t) {
    this.parser = t, this.name = je.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(t) {
    const e = this.name, i = this.parser, n = i.json, o = n.textures[t];
    if (!o.extensions || !o.extensions[e])
      return null;
    const r = o.extensions[e], a = n.images[r.source];
    let g = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (g = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return i.loadTextureImage(t, r.source, g);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return i.loadTexture(t);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t) {
      const e = new Image();
      e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
        t(e.height === 1);
      };
    })), this.isSupported;
  }
}
class bX {
  constructor(t) {
    this.name = je.EXT_MESHOPT_COMPRESSION, this.parser = t;
  }
  loadBufferView(t) {
    const e = this.parser.json, i = e.bufferViews[t];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name], o = this.parser.getDependency("buffer", n.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return o.then(function(a) {
        const g = n.byteOffset || 0, c = n.byteLength || 0, l = n.count, h = n.byteStride, d = new Uint8Array(a, g, c);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(l, h, d, n.mode, n.filter).then(function(C) {
          return C.buffer;
        }) : r.ready.then(function() {
          const C = new ArrayBuffer(l * h);
          return r.decodeGltfBuffer(new Uint8Array(C), l, h, d, n.mode, n.filter), C;
        });
      });
    }
    return null;
  }
}
class BX {
  constructor(t) {
    this.name = je.EXT_MESH_GPU_INSTANCING, this.parser = t;
  }
  createNodeMesh(t) {
    const e = this.parser.json, i = e.nodes[t];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const n = e.meshes[i.mesh];
    for (const c of n.primitives)
      if (c.mode !== fn.TRIANGLES && c.mode !== fn.TRIANGLE_STRIP && c.mode !== fn.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const r = i.extensions[this.name].attributes, a = [], g = {};
    for (const c in r)
      a.push(this.parser.getDependency("accessor", r[c]).then((l) => (g[c] = l, g[c])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(t)), Promise.all(a).then((c) => {
      const l = c.pop(), h = l.isGroup ? l.children : [l], d = c[0].count, C = [];
      for (const p of h) {
        const m = new J(), b = new B(), S = new Ye(), A = new B(1, 1, 1), u = new kh(p.geometry, p.material, d);
        for (let y = 0; y < d; y++)
          g.TRANSLATION && b.fromBufferAttribute(g.TRANSLATION, y), g.ROTATION && S.fromBufferAttribute(g.ROTATION, y), g.SCALE && A.fromBufferAttribute(g.SCALE, y), u.setMatrixAt(y, m.compose(b, S, A));
        for (const y in g)
          y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && p.geometry.setAttribute(y, g[y]);
        Wt.prototype.copy.call(u, p), this.parser.assignFinalMaterial(u), C.push(u);
      }
      return l.isGroup ? (l.clear(), l.add(...C), l) : C[0];
    }));
  }
}
const rx = "embf", ax = "glTF", ng = 12, $0 = { JSON: 1313821514, BIN: 5130562 };
class wX {
  constructor(t) {
    this.name = je.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e = new TextDecoder();
    let i = 0;
    if (e.decode(new Uint8Array(t.slice(0, 4))) === rx && new Uint8Array(t, 4, 1)[0] === 1) {
      const l = new Uint8Array(t, 5, 1)[0];
      i = 4 + 1 + 1 + l;
    }
    const o = new DataView(t, i, ng);
    if (this.header = {
      magic: e.decode(new Uint8Array(t.slice(i, i + 4))),
      version: o.getUint32(4, !0),
      length: o.getUint32(8, !0)
    }, this.header.magic !== ax)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - ng + i, a = new DataView(t, ng);
    let g = i;
    for (; g < r; ) {
      const c = a.getUint32(g, !0);
      g += 4;
      const l = a.getUint32(g, !0);
      if (g += 4, l === $0.JSON) {
        const h = new Uint8Array(t, ng + g, c);
        this.content = e.decode(h);
      } else if (l === $0.BIN) {
        const h = ng + g;
        this.body = t.slice(h, h + c);
      }
      g += c;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class _X {
  constructor(t, e) {
    if (!e)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = je.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
  }
  decodePrimitive(t, e) {
    const i = this.json, n = this.dracoLoader, o = t.extensions[this.name].bufferView, r = t.extensions[this.name].attributes, a = {}, g = {}, c = {};
    for (const l in r) {
      const h = yA[l] || l.toLowerCase();
      a[h] = r[l];
    }
    for (const l in t.attributes) {
      const h = yA[l] || l.toLowerCase();
      if (r[l] !== void 0) {
        const d = i.accessors[t.attributes[l]], C = Aa[d.componentType];
        c[h] = C.name, g[h] = d.normalized === !0;
      }
    }
    return e.getDependency("bufferView", o).then(function(l) {
      return new Promise(function(h) {
        n.decodeDracoFile(l, function(d) {
          for (const C in d.attributes) {
            const p = d.attributes[C], m = g[C];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, a, c);
      });
    });
  }
}
class xX {
  constructor() {
    this.name = je.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(t, e) {
    return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t;
  }
}
class vX {
  constructor() {
    this.name = je.KHR_MESH_QUANTIZATION;
  }
}
class gx extends Tb {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
  copySampleValue_(t) {
    const e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, o = t * n * 3 + n;
    for (let r = 0; r !== n; r++)
      e[r] = i[o + r];
    return e;
  }
  interpolate_(t, e, i, n) {
    const o = this.resultBuffer, r = this.sampleValues, a = this.valueSize, g = a * 2, c = a * 3, l = n - e, h = (i - e) / l, d = h * h, C = d * h, p = t * c, m = p - c, b = -2 * C + 3 * d, S = C - d, A = 1 - b, u = S - d + h;
    for (let y = 0; y !== a; y++) {
      const I = r[m + y + a], M = r[m + y + g] * l, G = r[p + y + a], x = r[p + y] * l;
      o[y] = A * I + u * M + b * G + S * x;
    }
    return o;
  }
}
const TX = new Ye();
class LX extends gx {
  interpolate_(t, e, i, n) {
    const o = super.interpolate_(t, e, i, n);
    return TX.fromArray(o).normalize().toArray(o), o;
  }
}
const fn = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Aa = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, ey = {
  9728: cs,
  9729: Gt,
  9984: bb,
  9985: Bb,
  9986: wb,
  9987: wr
}, ty = {
  33071: hs,
  33648: _b,
  10497: ii
}, Zu = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, yA = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, ao = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, GX = {
  CUBICSPLINE: void 0,
  LINEAR: zh,
  STEP: xb
}, Uu = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function MX(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Vh({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: vb
  })), s.DefaultMaterial;
}
function er(s, t, e) {
  for (const i in e.extensions)
    s[i] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = e.extensions[i]);
}
function yo(s, t) {
  t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(s.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
}
function EX(s, t, e) {
  let i = !1, n = !1, o = !1;
  for (let c = 0, l = t.length; c < l; c++) {
    const h = t[c];
    if (h.POSITION !== void 0 && (i = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (o = !0), i && n && o)
      break;
  }
  if (!i && !n && !o)
    return Promise.resolve(s);
  const r = [], a = [], g = [];
  for (let c = 0, l = t.length; c < l; c++) {
    const h = t[c];
    if (i) {
      const d = h.POSITION !== void 0 ? e.getDependency("accessor", h.POSITION) : s.attributes.position;
      r.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? e.getDependency("accessor", h.NORMAL) : s.attributes.normal;
      a.push(d);
    }
    if (o) {
      const d = h.COLOR_0 !== void 0 ? e.getDependency("accessor", h.COLOR_0) : s.attributes.color;
      g.push(d);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(a),
    Promise.all(g)
  ]).then(function(c) {
    const l = c[0], h = c[1], d = c[2];
    return i && (s.morphAttributes.position = l), n && (s.morphAttributes.normal = h), o && (s.morphAttributes.color = d), s.morphTargetsRelative = !0, s;
  });
}
function RX(s, t) {
  if (s.updateMorphTargets(), t.weights !== void 0)
    for (let e = 0, i = t.weights.length; e < i; e++)
      s.morphTargetInfluences[e] = t.weights[e];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const e = t.extras.targetNames;
    if (s.morphTargetInfluences.length === e.length) {
      s.morphTargetDictionary = {};
      for (let i = 0, n = e.length; i < n; i++)
        s.morphTargetDictionary[e[i]] = i;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function DX(s) {
  let t;
  const e = s.extensions && s.extensions[je.KHR_DRACO_MESH_COMPRESSION];
  if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + Ou(e.attributes) : t = s.indices + ":" + Ou(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let i = 0, n = s.targets.length; i < n; i++)
      t += ":" + Ou(s.targets[i]);
  return t;
}
function Ou(s) {
  let t = "";
  const e = Object.keys(s).sort();
  for (let i = 0, n = e.length; i < n; i++)
    t += e[i] + ":" + s[e[i]] + ";";
  return t;
}
function SA(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function KX(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const HX = new J();
class PX {
  constructor(t = {}, e = {}) {
    this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new cX(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i = !1, n = !1, o = -1;
    typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, o = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || i || n && o < 98 ? this.textureLoader = new Ot(this.options.manager) : this.textureLoader = new Ab(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new rs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(t) {
    this.extensions = t;
  }
  setPlugins(t) {
    this.plugins = t;
  }
  parse(t, e) {
    const i = this, n = this.json, o = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(this._invokeAll(function(r) {
      return r.beforeRoot && r.beforeRoot();
    })).then(function() {
      return Promise.all([
        i.getDependencies("scene"),
        i.getDependencies("animation"),
        i.getDependencies("camera")
      ]);
    }).then(function(r) {
      const a = {
        scene: r[0][n.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: n.asset,
        parser: i,
        userData: {}
      };
      er(o, a, n), yo(a, n), Promise.all(i._invokeAll(function(g) {
        return g.afterRoot && g.afterRoot(a);
      })).then(function() {
        t(a);
      });
    }).catch(e);
  }
  _markDefs() {
    const t = this.json.nodes || [], e = this.json.skins || [], i = this.json.meshes || [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n].joints;
      for (let a = 0, g = r.length; a < g; a++)
        t[r[a]].isBone = !0;
    }
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (i[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  _addNodeRef(t, e) {
    e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
  }
  _getNodeRef(t, e, i) {
    if (t.refs[e] <= 1)
      return i;
    const n = i.clone(), o = (r, a) => {
      const g = this.associations.get(r);
      g != null && this.associations.set(a, g);
      for (const [c, l] of r.children.entries())
        o(l, a.children[c]);
    };
    return o(i, n), n.name += "_instance_" + t.uses[e]++, n;
  }
  _invokeOne(t) {
    const e = Object.values(this.plugins);
    e.push(this);
    for (let i = 0; i < e.length; i++) {
      const n = t(e[i]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(t) {
    const e = Object.values(this.plugins);
    e.unshift(this);
    const i = [];
    for (let n = 0; n < e.length; n++) {
      const o = t(e[n]);
      o && i.push(o);
    }
    return i;
  }
  getDependency(t, e) {
    const i = t + ":" + e;
    let n = this.cache.get(i);
    if (!n) {
      switch (t) {
        case "scene":
          n = this.loadScene(e);
          break;
        case "node":
          n = this._invokeOne(function(o) {
            return o.loadNode && o.loadNode(e);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(o) {
            return o.loadMesh && o.loadMesh(e);
          });
          break;
        case "accessor":
          n = this.loadAccessor(e);
          break;
        case "bufferView":
          n = this._invokeOne(function(o) {
            return o.loadBufferView && o.loadBufferView(e);
          });
          break;
        case "buffer":
          n = this.loadBuffer(e);
          break;
        case "material":
          n = this._invokeOne(function(o) {
            return o.loadMaterial && o.loadMaterial(e);
          });
          break;
        case "texture":
          n = this._invokeOne(function(o) {
            return o.loadTexture && o.loadTexture(e);
          });
          break;
        case "skin":
          n = this.loadSkin(e);
          break;
        case "animation":
          n = this._invokeOne(function(o) {
            return o.loadAnimation && o.loadAnimation(e);
          });
          break;
        case "camera":
          n = this.loadCamera(e);
          break;
        default:
          if (n = this._invokeOne(function(o) {
            return o != this && o.getDependency && o.getDependency(t, e);
          }), !n)
            throw new Error("Unknown type: " + t);
          break;
      }
      this.cache.add(i, n);
    }
    return n;
  }
  getDependencies(t) {
    let e = this.cache.get(t);
    if (!e) {
      const i = this, n = this.json[t + (t === "mesh" ? "es" : "s")] || [];
      e = Promise.all(n.map(function(o, r) {
        return i.getDependency(t, r);
      })), this.cache.add(t, e);
    }
    return e;
  }
  loadBuffer(t) {
    const e = this.json.buffers[t], i = this.fileLoader;
    if (e.type && e.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
    if (e.uri === void 0 && t === 0)
      return Promise.resolve(this.extensions[je.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(o, r) {
      i.load(ma.resolveURL(e.uri, n.path), o, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
      });
    });
  }
  loadBufferView(t) {
    const e = this.json.bufferViews[t];
    return this.getDependency("buffer", e.buffer).then(function(i) {
      const n = e.byteLength || 0, o = e.byteOffset || 0;
      return i.slice(o, o + n);
    });
  }
  loadAccessor(t) {
    const e = this, i = this.json, n = this.json.accessors[t];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const r = Zu[n.type], a = Aa[n.componentType], g = n.normalized === !0, c = new a(n.count * r);
      return Promise.resolve(new Fe(c, r, g));
    }
    const o = [];
    return n.bufferView !== void 0 ? o.push(this.getDependency("bufferView", n.bufferView)) : o.push(null), n.sparse !== void 0 && (o.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(o).then(function(r) {
      const a = r[0], g = Zu[n.type], c = Aa[n.componentType], l = c.BYTES_PER_ELEMENT, h = l * g, d = n.byteOffset || 0, C = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, b;
      if (C && C !== h) {
        const S = Math.floor(d / C), A = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + S + ":" + n.count;
        let u = e.cache.get(A);
        u || (m = new c(a, S * C, n.count * C / l), u = new Ai(m, C / l), e.cache.add(A, u)), b = new ve(u, g, d % C / l, p);
      } else
        a === null ? m = new c(n.count * g) : m = new c(a, d, n.count * g), b = new Fe(m, g, p);
      if (n.sparse !== void 0) {
        const S = Zu.SCALAR, A = Aa[n.sparse.indices.componentType], u = n.sparse.indices.byteOffset || 0, y = n.sparse.values.byteOffset || 0, I = new A(r[1], u, n.sparse.count * S), M = new c(r[2], y, n.sparse.count * g);
        a !== null && (b = new Fe(b.array.slice(), b.itemSize, b.normalized));
        for (let G = 0, x = I.length; G < x; G++) {
          const L = I[G];
          if (b.setX(L, M[G * g]), g >= 2 && b.setY(L, M[G * g + 1]), g >= 3 && b.setZ(L, M[G * g + 2]), g >= 4 && b.setW(L, M[G * g + 3]), g >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return b;
    });
  }
  loadTexture(t) {
    const e = this.json, i = this.options, o = e.textures[t].source, r = e.images[o], a = this.extensions;
    let g = this.textureLoader;
    if (r.mimeType === "image/ktx2" && a[je.KHR_TEXTURE_BASISU])
      return a[je.KHR_TEXTURE_BASISU].loadTexture(
        t
      );
    if (r.uri) {
      const c = i.manager.getHandler(r.uri);
      c !== null && (g = c);
    }
    return this.loadTextureImage(t, o, g);
  }
  loadTextureImage(t, e, i) {
    const n = this, o = this.json, r = o.textures[t], a = o.images[e], g = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[g])
      return this.textureCache[g];
    const c = this.loadImageSource(e, i).then(function(l) {
      l.flipY = !1, l.name = r.name || a.name || "", l.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (l.name = a.uri);
      const d = (o.samplers || {})[r.sampler] || {};
      return l.magFilter = ey[d.magFilter] || Gt, l.minFilter = ey[d.minFilter] || wr, l.wrapS = ty[d.wrapS] || ii, l.wrapT = ty[d.wrapT] || ii, n.associations.set(l, { textures: t }), l;
    }).catch(function() {
      return null;
    });
    return this.textureCache[g] = c, c;
  }
  loadImageSource(t, e) {
    const i = this, n = this.json, o = this.options;
    if (this.sourceCache[t] !== void 0)
      return this.sourceCache[t].then((h) => h.clone());
    const r = n.images[t], a = self.URL || self.webkitURL;
    let g = r.uri || "", c = !1;
    if (r.bufferView !== void 0)
      g = i.getDependency("bufferView", r.bufferView).then(function(h) {
        c = !0;
        const d = new Blob([h], { type: r.mimeType });
        return g = a.createObjectURL(d), g;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
    const l = Promise.resolve(g).then(function(h) {
      return new Promise(function(d, C) {
        let p = d;
        e.isImageBitmapLoader === !0 && (p = function(m) {
          const b = new pa(m);
          b.needsUpdate = !0, d(b);
        }), e.load(ma.resolveURL(h, o.path), p, void 0, C);
      });
    }).then(function(h) {
      return c === !0 && a.revokeObjectURL(g), h.userData.mimeType = r.mimeType || KX(r.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", g), h;
    });
    return this.sourceCache[t] = l, l;
  }
  assignTexture(t, e, i, n) {
    const o = this;
    return this.getDependency("texture", i.index).then(function(r) {
      if (!r)
        return null;
      if (i.texCoord !== void 0 && i.texCoord > 0 && (r = r.clone(), r.channel = i.texCoord), o.extensions[je.KHR_TEXTURE_TRANSFORM]) {
        const a = i.extensions !== void 0 ? i.extensions[je.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const g = o.associations.get(r);
          r = o.extensions[je.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), o.associations.set(r, g);
        }
      }
      return n !== void 0 && (r.colorSpace = n), t[e] = r, r;
    });
  }
  assignFinalMaterial(t) {
    const e = t.geometry;
    let i = t.material;
    const n = e.attributes.tangent === void 0, o = e.attributes.color !== void 0, r = e.attributes.normal === void 0;
    if (t.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let g = this.cache.get(a);
      g || (g = new ZA(), ks.prototype.copy.call(g, i), g.color.copy(i.color), g.map = i.map, g.sizeAttenuation = !1, this.cache.add(a, g)), i = g;
    } else if (t.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let g = this.cache.get(a);
      g || (g = new _r(), ks.prototype.copy.call(g, i), g.color.copy(i.color), g.map = i.map, this.cache.add(a, g)), i = g;
    }
    if (n || o || r) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      n && (a += "derivative-tangents:"), o && (a += "vertex-colors:"), r && (a += "flat-shading:");
      let g = this.cache.get(a);
      g || (g = i.clone(), o && (g.vertexColors = !0), r && (g.flatShading = !0), n && (g.normalScale && (g.normalScale.y *= -1), g.clearcoatNormalScale && (g.clearcoatNormalScale.y *= -1)), this.cache.add(a, g), this.associations.set(g, this.associations.get(i))), i = g;
    }
    t.material = i;
  }
  getMaterialType() {
    return Vh;
  }
  loadMaterial(t) {
    const e = this, i = this.json, n = this.extensions, o = i.materials[t];
    let r;
    const a = {}, g = o.extensions || {}, c = [];
    if (g[je.KHR_MATERIALS_UNLIT] || e.options.forceUnlit) {
      const h = n[je.KHR_MATERIALS_UNLIT];
      r = h.getMaterialType(), c.push(h.extendParams(a, o, e));
    } else {
      const h = o.pbrMetallicRoughness || {};
      if (a.color = new Ce(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        a.color.fromArray(d), a.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && c.push(e.assignTexture(a, "map", h.baseColorTexture, gt)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(e.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(e.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), r = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(t);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(t, a);
      })));
    }
    o.doubleSided === !0 && (a.side = xr);
    const l = o.alphaMode || Uu.OPAQUE;
    if (l === Uu.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, l === Uu.MASK && (a.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : 0.5)), o.normalTexture !== void 0 && r !== _t && (c.push(e.assignTexture(a, "normalMap", o.normalTexture)), a.normalScale = new Z(1, 1), o.normalTexture.scale !== void 0)) {
      const h = o.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    return o.occlusionTexture !== void 0 && r !== _t && (c.push(e.assignTexture(a, "aoMap", o.occlusionTexture)), o.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = o.occlusionTexture.strength)), o.emissiveFactor !== void 0 && r !== _t && (a.emissive = new Ce().fromArray(o.emissiveFactor)), o.emissiveTexture !== void 0 && r !== _t && c.push(e.assignTexture(a, "emissiveMap", o.emissiveTexture, gt)), Promise.all(c).then(function() {
      const h = new r(a);
      return o.name && (h.name = o.name), yo(h, o), e.associations.set(h, { materials: t }), o.extensions && er(n, h, o), h;
    });
  }
  createUniqueName(t) {
    const e = Cb.sanitizeNodeName(t || "");
    return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
  }
  loadGeometries(t) {
    const e = this, i = this.extensions, n = this.primitiveCache;
    function o(a) {
      return i[je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, e).then(function(g) {
        return iy(g, a, e);
      });
    }
    const r = [];
    for (let a = 0, g = t.length; a < g; a++) {
      const c = t[a], l = DX(c), h = n[l];
      if (h)
        r.push(h.promise);
      else {
        let d;
        c.extensions && c.extensions[je.KHR_DRACO_MESH_COMPRESSION] ? d = o(c) : d = iy(new Qe(), c, e), n[l] = { primitive: c, promise: d }, r.push(d);
      }
    }
    return Promise.all(r);
  }
  loadMesh(t) {
    const e = this, i = this.json, n = this.extensions, o = i.meshes[t], r = o.primitives, a = [];
    for (let g = 0, c = r.length; g < c; g++) {
      const l = r[g].material === void 0 ? MX(this.cache) : this.getDependency("material", r[g].material);
      a.push(l);
    }
    return a.push(e.loadGeometries(r)), Promise.all(a).then(function(g) {
      const c = g.slice(0, g.length - 1), l = g[g.length - 1], h = [];
      for (let C = 0, p = l.length; C < p; C++) {
        const m = l[C], b = r[C];
        let S;
        const A = c[C];
        if (b.mode === fn.TRIANGLES || b.mode === fn.TRIANGLE_STRIP || b.mode === fn.TRIANGLE_FAN || b.mode === void 0)
          S = o.isSkinnedMesh === !0 ? new fb(m, A) : new le(m, A), S.isSkinnedMesh === !0 && S.normalizeSkinWeights(), b.mode === fn.TRIANGLE_STRIP ? S.geometry = yh(S.geometry, WA) : b.mode === fn.TRIANGLE_FAN && (S.geometry = yh(S.geometry, eh));
        else if (b.mode === fn.LINES)
          S = new Ma(m, A);
        else if (b.mode === fn.LINE_STRIP)
          S = new es(m, A);
        else if (b.mode === fn.LINE_LOOP)
          S = new pb(m, A);
        else if (b.mode === fn.POINTS)
          S = new Ug(m, A);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + b.mode);
        Object.keys(S.geometry.morphAttributes).length > 0 && RX(S, o), S.name = e.createUniqueName(o.name || "mesh_" + t), yo(S, o), b.extensions && er(n, S, b), e.assignFinalMaterial(S), h.push(S);
      }
      for (let C = 0, p = h.length; C < p; C++)
        e.associations.set(h[C], {
          meshes: t,
          primitives: C
        });
      if (h.length === 1)
        return o.extensions && er(n, h[0], o), h[0];
      const d = new mt();
      o.extensions && er(n, d, o), e.associations.set(d, { meshes: t });
      for (let C = 0, p = h.length; C < p; C++)
        d.add(h[C]);
      return d;
    });
  }
  loadCamera(t) {
    let e;
    const i = this.json.cameras[t], n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return i.type === "perspective" ? e = new Ys(ce.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (e = new Zg(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (e.name = this.createUniqueName(i.name)), yo(e, i), Promise.resolve(e);
  }
  loadSkin(t) {
    const e = this.json.skins[t], i = [];
    for (let n = 0, o = e.joints.length; n < o; n++)
      i.push(this._loadNodeShallow(e.joints[n]));
    return e.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", e.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
      const o = n.pop(), r = n, a = [], g = [];
      for (let c = 0, l = r.length; c < l; c++) {
        const h = r[c];
        if (h) {
          a.push(h);
          const d = new J();
          o !== null && d.fromArray(o.array, c * 16), g.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[c]);
      }
      return new mb(a, g);
    });
  }
  loadAnimation(t) {
    const i = this.json.animations[t], n = i.name ? i.name : "animation_" + t, o = [], r = [], a = [], g = [], c = [];
    for (let l = 0, h = i.channels.length; l < h; l++) {
      const d = i.channels[l], C = i.samplers[d.sampler], p = d.target, m = p.node, b = i.parameters !== void 0 ? i.parameters[C.input] : C.input, S = i.parameters !== void 0 ? i.parameters[C.output] : C.output;
      p.node !== void 0 && (o.push(this.getDependency("node", m)), r.push(this.getDependency("accessor", b)), a.push(this.getDependency("accessor", S)), g.push(C), c.push(p));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(r),
      Promise.all(a),
      Promise.all(g),
      Promise.all(c)
    ]).then(function(l) {
      const h = l[0], d = l[1], C = l[2], p = l[3], m = l[4], b = [];
      for (let S = 0, A = h.length; S < A; S++) {
        const u = h[S], y = d[S], I = C[S], M = p[S], G = m[S];
        if (u === void 0)
          continue;
        u.updateMatrix();
        let x;
        switch (ao[G.path]) {
          case ao.weights:
            x = ZI;
            break;
          case ao.rotation:
            x = th;
            break;
          case ao.position:
          case ao.scale:
          default:
            x = WI;
            break;
        }
        const L = u.name ? u.name : u.uuid, E = M.interpolation !== void 0 ? GX[M.interpolation] : zh, T = [];
        ao[G.path] === ao.weights ? u.traverse(function(w) {
          w.morphTargetInfluences && T.push(w.name ? w.name : w.uuid);
        }) : T.push(L);
        let R = I.array;
        if (I.normalized) {
          const w = SA(R.constructor), v = new Float32Array(R.length);
          for (let D = 0, K = R.length; D < K; D++)
            v[D] = R[D] * w;
          R = v;
        }
        for (let w = 0, v = T.length; w < v; w++) {
          const D = new x(
            T[w] + "." + ao[G.path],
            y.array,
            R,
            E
          );
          M.interpolation === "CUBICSPLINE" && (D.createInterpolant = function(P) {
            const k = this instanceof th ? LX : gx;
            return new k(this.times, this.values, this.getValueSize() / 3, P);
          }, D.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), b.push(D);
        }
      }
      return new yb(n, void 0, b);
    });
  }
  createNodeMesh(t) {
    const e = this.json, i = this, n = e.nodes[t];
    return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(o) {
      const r = i._getNodeRef(i.meshCache, n.mesh, o);
      return n.weights !== void 0 && r.traverse(function(a) {
        if (!!a.isMesh)
          for (let g = 0, c = n.weights.length; g < c; g++)
            a.morphTargetInfluences[g] = n.weights[g];
      }), r;
    });
  }
  loadNode(t) {
    const e = this.json, i = this, n = e.nodes[t], o = i._loadNodeShallow(t), r = [], a = n.children || [];
    for (let c = 0, l = a.length; c < l; c++)
      r.push(i.getDependency("node", a[c]));
    const g = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
    return Promise.all([
      o,
      Promise.all(r),
      g
    ]).then(function(c) {
      const l = c[0], h = c[1], d = c[2];
      d !== null && l.traverse(function(C) {
        !C.isSkinnedMesh || C.bind(d, HX);
      });
      for (let C = 0, p = h.length; C < p; C++)
        l.add(h[C]);
      return l;
    });
  }
  _loadNodeShallow(t) {
    const e = this.json, i = this.extensions, n = this;
    if (this.nodeCache[t] !== void 0)
      return this.nodeCache[t];
    const o = e.nodes[t], r = o.name ? n.createUniqueName(o.name) : "", a = [], g = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(t);
    });
    return g && a.push(g), o.camera !== void 0 && a.push(n.getDependency("camera", o.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, o.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(t);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[t] = Promise.all(a).then(function(c) {
      let l;
      if (o.isBone === !0 ? l = new Sb() : c.length > 1 ? l = new mt() : c.length === 1 ? l = c[0] : l = new Wt(), l !== c[0])
        for (let h = 0, d = c.length; h < d; h++)
          l.add(c[h]);
      if (o.name && (l.userData.name = o.name, l.name = r), yo(l, o), o.extensions && er(i, l, o), o.matrix !== void 0) {
        const h = new J();
        h.fromArray(o.matrix), l.applyMatrix4(h);
      } else
        o.translation !== void 0 && l.position.fromArray(o.translation), o.rotation !== void 0 && l.quaternion.fromArray(o.rotation), o.scale !== void 0 && l.scale.fromArray(o.scale);
      return n.associations.has(l) || n.associations.set(l, {}), n.associations.get(l).nodes = t, l;
    }), this.nodeCache[t];
  }
  loadScene(t) {
    const e = this.extensions, i = this.json.scenes[t], n = this, o = new mt();
    i.name && (o.name = n.createUniqueName(i.name)), yo(o, i), i.extensions && er(e, o, i);
    const r = i.nodes || [], a = [];
    for (let g = 0, c = r.length; g < c; g++)
      a.push(n.getDependency("node", r[g]));
    return Promise.all(a).then(function(g) {
      for (let l = 0, h = g.length; l < h; l++)
        o.add(g[l]);
      const c = (l) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, C] of n.associations)
          (d instanceof ks || d instanceof pa) && h.set(d, C);
        return l.traverse((d) => {
          const C = n.associations.get(d);
          C != null && h.set(d, C);
        }), h;
      };
      return n.associations = c(o), o;
    });
  }
}
function NX(s, t, e) {
  const i = t.attributes, n = new Ue();
  if (i.POSITION !== void 0) {
    const a = e.json.accessors[i.POSITION], g = a.min, c = a.max;
    if (g !== void 0 && c !== void 0) {
      if (n.set(
        new B(g[0], g[1], g[2]),
        new B(c[0], c[1], c[2])
      ), a.normalized) {
        const l = SA(Aa[a.componentType]);
        n.min.multiplyScalar(l), n.max.multiplyScalar(l);
      }
    } else {
      $i("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const o = t.targets;
  if (o !== void 0) {
    const a = new B(), g = new B();
    for (let c = 0, l = o.length; c < l; c++) {
      const h = o[c];
      if (h.POSITION !== void 0) {
        const d = e.json.accessors[h.POSITION], C = d.min, p = d.max;
        if (C !== void 0 && p !== void 0) {
          if (g.setX(Math.max(Math.abs(C[0]), Math.abs(p[0]))), g.setY(Math.max(Math.abs(C[1]), Math.abs(p[1]))), g.setZ(Math.max(Math.abs(C[2]), Math.abs(p[2]))), d.normalized) {
            const m = SA(Aa[d.componentType]);
            g.multiplyScalar(m);
          }
          a.max(g);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(a);
  }
  s.boundingBox = n;
  const r = new Bn();
  n.getCenter(r.center), r.radius = n.min.distanceTo(n.max) / 2, s.boundingSphere = r;
}
function iy(s, t, e) {
  const i = t.attributes, n = [];
  function o(r, a) {
    return e.getDependency("accessor", r).then(function(g) {
      s.setAttribute(a, g);
    });
  }
  for (const r in i) {
    const a = yA[r] || r.toLowerCase();
    a in s.attributes || n.push(o(i[r], a));
  }
  if (t.indices !== void 0 && !s.index) {
    const r = e.getDependency("accessor", t.indices).then(function(a) {
      s.setIndex(a);
    });
    n.push(r);
  }
  return yo(s, t), NX(s, t, e), Promise.all(n).then(function() {
    return t.targets !== void 0 ? EX(s, t.targets, e) : s;
  });
}
var FX = function() {
  var s = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", t = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), i = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  var n = WebAssembly.validate(e) ? t : s, o, r = WebAssembly.instantiate(a(n), {}).then(function(S) {
    o = S.instance, o.exports.__wasm_call_ctors();
  });
  function a(S) {
    for (var A = new Uint8Array(S.length), u = 0; u < S.length; ++u) {
      var y = S.charCodeAt(u);
      A[u] = y > 96 ? y - 97 : y > 64 ? y - 39 : y + 4;
    }
    for (var I = 0, u = 0; u < S.length; ++u)
      A[I++] = A[u] < 60 ? i[A[u]] : (A[u] - 60) * 64 + A[++u];
    return A.buffer.slice(0, I);
  }
  function g(S, A, u, y, I, M) {
    var G = o.exports.sbrk, x = u + 3 & -4, L = G(x * y), E = G(I.length), T = new Uint8Array(o.exports.memory.buffer);
    T.set(I, E);
    var R = S(L, u, y, E, I.length);
    if (R == 0 && M && M(L, x, y), A.set(T.subarray(L, L + u * y)), G(L - G(0)), R != 0)
      throw new Error("Malformed buffer data: " + R);
  }
  var c = {
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, l = {
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  }, h = [], d = 0;
  function C(S) {
    var A = {
      object: new Worker(S),
      pending: 0,
      requests: {}
    };
    return A.object.onmessage = function(u) {
      var y = u.data;
      A.pending -= y.count, A.requests[y.id][y.action](y.value), delete A.requests[y.id];
    }, A;
  }
  function p(S) {
    for (var A = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(a(n)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + g.toString() + b.toString(), u = new Blob([A], { type: "text/javascript" }), y = URL.createObjectURL(u), I = 0; I < S; ++I)
      h[I] = C(y);
    URL.revokeObjectURL(y);
  }
  function m(S, A, u, y, I) {
    for (var M = h[0], G = 1; G < h.length; ++G)
      h[G].pending < M.pending && (M = h[G]);
    return new Promise(function(x, L) {
      var E = new Uint8Array(u), T = d++;
      M.pending += S, M.requests[T] = { resolve: x, reject: L }, M.object.postMessage({ id: T, count: S, size: A, source: E, mode: y, filter: I }, [E.buffer]);
    });
  }
  function b(S) {
    r.then(function() {
      var A = S.data;
      try {
        var u = new Uint8Array(A.count * A.size);
        g(o.exports[A.mode], u, A.count, A.size, A.source, o.exports[A.filter]), self.postMessage({ id: A.id, count: A.count, action: "resolve", value: u }, [u.buffer]);
      } catch (y) {
        self.postMessage({ id: A.id, count: A.count, action: "reject", value: y });
      }
    });
  }
  return {
    ready: r,
    supported: !0,
    useWorkers: function(S) {
      p(S);
    },
    decodeVertexBuffer: function(S, A, u, y, I) {
      g(o.exports.meshopt_decodeVertexBuffer, S, A, u, y, o.exports[c[I]]);
    },
    decodeIndexBuffer: function(S, A, u, y) {
      g(o.exports.meshopt_decodeIndexBuffer, S, A, u, y);
    },
    decodeIndexSequence: function(S, A, u, y) {
      g(o.exports.meshopt_decodeIndexSequence, S, A, u, y);
    },
    decodeGltfBuffer: function(S, A, u, y, I, M) {
      g(o.exports[l[I]], S, A, u, y, o.exports[c[M]]);
    },
    decodeGltfBufferAsync: function(S, A, u, y, I) {
      return h.length > 0 ? m(S, A, u, l[y], c[I]) : r.then(function() {
        var M = new Uint8Array(S * A);
        return g(o.exports[l[y]], M, S, A, u, o.exports[c[I]]), M;
      });
    }
  };
}();
const Qu = /* @__PURE__ */ new WeakMap();
class kX extends Fh {
  constructor(t) {
    super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(t) {
    return this.decoderPath = t, this;
  }
  setDecoderConfig(t) {
    return this.decoderConfig = t, this;
  }
  setWorkerLimit(t) {
    return this.workerLimit = t, this;
  }
  load(t, e, i, n) {
    const o = new rs(this.manager);
    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, (r) => {
      this.parse(r, e, n);
    }, i, n);
  }
  parse(t, e, i) {
    this.decodeDracoFile(t, e, null, null, gt).catch(i);
  }
  decodeDracoFile(t, e, i, n, o = Vi) {
    const r = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
      vertexColorSpace: o
    };
    return this.decodeGeometry(t, r).then(e);
  }
  decodeGeometry(t, e) {
    const i = JSON.stringify(e);
    if (Qu.has(t)) {
      const g = Qu.get(t);
      if (g.key === i)
        return g.promise;
      if (t.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const o = this.workerNextTaskID++, r = t.byteLength, a = this._getWorker(o, r).then((g) => (n = g, new Promise((c, l) => {
      n._callbacks[o] = { resolve: c, reject: l }, n.postMessage({ type: "decode", id: o, taskConfig: e, buffer: t }, [t]);
    }))).then((g) => this._createGeometry(g.geometry));
    return a.catch(() => !0).then(() => {
      n && o && this._releaseTask(n, o);
    }), Qu.set(t, {
      key: i,
      promise: a
    }), a;
  }
  _createGeometry(t) {
    const e = new Qe();
    t.index && e.setIndex(new Fe(t.index.array, 1));
    for (let i = 0; i < t.attributes.length; i++) {
      const n = t.attributes[i], o = n.name, r = n.array, a = n.itemSize, g = new Fe(r, a);
      o === "color" && (this._assignVertexColorSpace(g, n.vertexColorSpace), g.normalized = !(r instanceof Float32Array)), e.setAttribute(o, g);
    }
    return e;
  }
  _assignVertexColorSpace(t, e) {
    if (e !== gt)
      return;
    const i = new Ce();
    for (let n = 0, o = t.count; n < o; n++)
      i.fromBufferAttribute(t, n).convertSRGBToLinear(), t.setXYZ(n, i.r, i.g, i.b);
  }
  _loadLibrary(t, e) {
    const i = new rs(this.manager);
    return i.setPath(this.decoderPath), i.setResponseType(e), i.setWithCredentials(this.withCredentials), new Promise((n, o) => {
      i.load(t, n, void 0, o);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const t = typeof WebAssembly != "object" || this.decoderConfig.type === "js", e = [];
    return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then((i) => {
      const n = i[0];
      t || (this.decoderConfig.wasmBinary = i[1]);
      const o = VX.toString(), r = [
        "/* draco decoder */",
        n,
        "",
        "/* worker */",
        o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([r]));
    }), this.decoderPending;
  }
  _getWorker(t, e) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const n = new Worker(this.workerSourceURL);
        n._callbacks = {}, n._taskCosts = {}, n._taskLoad = 0, n.postMessage({ type: "init", decoderConfig: this.decoderConfig }), n.onmessage = function(o) {
          const r = o.data;
          switch (r.type) {
            case "decode":
              n._callbacks[r.id].resolve(r);
              break;
            case "error":
              n._callbacks[r.id].reject(r);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
          }
        }, this.workerPool.push(n);
      } else
        this.workerPool.sort(function(n, o) {
          return n._taskLoad > o._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return i._taskCosts[t] = e, i._taskLoad += e, i;
    });
  }
  _releaseTask(t, e) {
    t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e];
  }
  debug() {
    console.log("Task load: ", this.workerPool.map((t) => t._taskLoad));
  }
  dispose() {
    for (let t = 0; t < this.workerPool.length; ++t)
      this.workerPool[t].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function VX() {
  let s, t;
  onmessage = function(r) {
    const a = r.data;
    switch (a.type) {
      case "init":
        s = a.decoderConfig, t = new Promise(function(l) {
          s.onModuleLoaded = function(h) {
            l({ draco: h });
          }, DracoDecoderModule(s);
        });
        break;
      case "decode":
        const g = a.buffer, c = a.taskConfig;
        t.then((l) => {
          const h = l.draco, d = new h.Decoder();
          try {
            const C = e(h, d, new Int8Array(g), c), p = C.attributes.map((m) => m.array.buffer);
            C.index && p.push(C.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: C }, p);
          } catch (C) {
            console.error(C), self.postMessage({ type: "error", id: a.id, error: C.message });
          } finally {
            h.destroy(d);
          }
        });
        break;
    }
  };
  function e(r, a, g, c) {
    const l = c.attributeIDs, h = c.attributeTypes;
    let d, C;
    const p = a.GetEncodedGeometryType(g);
    if (p === r.TRIANGULAR_MESH)
      d = new r.Mesh(), C = a.DecodeArrayToMesh(g, g.byteLength, d);
    else if (p === r.POINT_CLOUD)
      d = new r.PointCloud(), C = a.DecodeArrayToPointCloud(g, g.byteLength, d);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!C.ok() || d.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + C.error_msg());
    const m = { index: null, attributes: [] };
    for (const b in l) {
      const S = self[h[b]];
      let A, u;
      if (c.useUniqueIDs)
        u = l[b], A = a.GetAttributeByUniqueId(d, u);
      else {
        if (u = a.GetAttributeId(d, r[l[b]]), u === -1)
          continue;
        A = a.GetAttribute(d, u);
      }
      const y = n(r, a, d, b, S, A);
      b === "color" && (y.vertexColorSpace = c.vertexColorSpace), m.attributes.push(y);
    }
    return p === r.TRIANGULAR_MESH && (m.index = i(r, a, d)), r.destroy(d), m;
  }
  function i(r, a, g) {
    const l = g.num_faces() * 3, h = l * 4, d = r._malloc(h);
    a.GetTrianglesUInt32Array(g, h, d);
    const C = new Uint32Array(r.HEAPF32.buffer, d, l).slice();
    return r._free(d), { array: C, itemSize: 1 };
  }
  function n(r, a, g, c, l, h) {
    const d = h.num_components(), p = g.num_points() * d, m = p * l.BYTES_PER_ELEMENT, b = o(r, l), S = r._malloc(m);
    a.GetAttributeDataArrayForAllPoints(g, h, b, m, S);
    const A = new l(r.HEAPF32.buffer, S, p).slice();
    return r._free(S), {
      name: c,
      array: A,
      itemSize: d
    };
  }
  function o(r, a) {
    switch (a) {
      case Float32Array:
        return r.DT_FLOAT32;
      case Int8Array:
        return r.DT_INT8;
      case Int16Array:
        return r.DT_INT16;
      case Int32Array:
        return r.DT_INT32;
      case Uint8Array:
        return r.DT_UINT8;
      case Uint16Array:
        return r.DT_UINT16;
      case Uint32Array:
        return r.DT_UINT32;
    }
  }
}
class zX {
  constructor(t = 4) {
    this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
  }
  _initWorker(t) {
    if (!this.workers[t]) {
      const e = this.workerCreator();
      e.addEventListener("message", this._onMessage.bind(this, t)), this.workers[t] = e;
    }
  }
  _getIdleWorker() {
    for (let t = 0; t < this.pool; t++)
      if (!(this.workerStatus & 1 << t))
        return t;
    return -1;
  }
  _onMessage(t, e) {
    const i = this.workersResolve[t];
    if (i && i(e), this.queue.length) {
      const { resolve: n, msg: o, transfer: r } = this.queue.shift();
      this.workersResolve[t] = n, this.workers[t].postMessage(o, r);
    } else
      this.workerStatus ^= 1 << t;
  }
  setWorkerCreator(t) {
    this.workerCreator = t;
  }
  setWorkerLimit(t) {
    this.pool = t;
  }
  postMessage(t, e) {
    return new Promise((i) => {
      const n = this._getIdleWorker();
      n !== -1 ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = i, this.workers[n].postMessage(t, e)) : this.queue.push({ resolve: i, msg: t, transfer: e });
    });
  }
  dispose() {
    this.workers.forEach((t) => t.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
  }
}
const XX = 0, ny = 2, WX = 1, sy = 2, ZX = 0, UX = 1, OX = 10, QX = 0, cx = 9, lx = 15, hx = 16, dx = 22, ux = 37, Ix = 43, Ax = 76, Cx = 83, fx = 97, px = 100, mx = 103, yx = 109, Sx = 165, bx = 166;
class YX {
  constructor() {
    this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: 0, descriptorBlockSize: 0, versionNumber: 2, colorModel: 0, colorPrimaries: 1, transferFunction: 2, flags: 0, texelBlockDimension: [0, 0, 0, 0], bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0], samples: [] }], this.keyValue = {}, this.globalData = null;
  }
}
class sg {
  constructor(t, e, i, n) {
    this._dataView = new DataView(t.buffer, t.byteOffset + e, i), this._littleEndian = n, this._offset = 0;
  }
  _nextUint8() {
    const t = this._dataView.getUint8(this._offset);
    return this._offset += 1, t;
  }
  _nextUint16() {
    const t = this._dataView.getUint16(this._offset, this._littleEndian);
    return this._offset += 2, t;
  }
  _nextUint32() {
    const t = this._dataView.getUint32(this._offset, this._littleEndian);
    return this._offset += 4, t;
  }
  _nextUint64() {
    const t = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return this._offset += 8, t;
  }
  _nextInt32() {
    const t = this._dataView.getInt32(this._offset, this._littleEndian);
    return this._offset += 4, t;
  }
  _skip(t) {
    return this._offset += t, this;
  }
  _scan(t, e = 0) {
    const i = this._offset;
    let n = 0;
    for (; this._dataView.getUint8(this._offset) !== e && n < t; )
      n++, this._offset++;
    return n < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n);
  }
}
const Li = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function oy(s) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(s) : Buffer.from(s).toString("utf8");
}
function jX(s) {
  const t = new Uint8Array(s.buffer, s.byteOffset, Li.length);
  if (t[0] !== Li[0] || t[1] !== Li[1] || t[2] !== Li[2] || t[3] !== Li[3] || t[4] !== Li[4] || t[5] !== Li[5] || t[6] !== Li[6] || t[7] !== Li[7] || t[8] !== Li[8] || t[9] !== Li[9] || t[10] !== Li[10] || t[11] !== Li[11])
    throw new Error("Missing KTX 2.0 identifier.");
  const e = new YX(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, n = new sg(s, Li.length, i, !0);
  e.vkFormat = n._nextUint32(), e.typeSize = n._nextUint32(), e.pixelWidth = n._nextUint32(), e.pixelHeight = n._nextUint32(), e.pixelDepth = n._nextUint32(), e.layerCount = n._nextUint32(), e.faceCount = n._nextUint32();
  const o = n._nextUint32();
  e.supercompressionScheme = n._nextUint32();
  const r = n._nextUint32(), a = n._nextUint32(), g = n._nextUint32(), c = n._nextUint32(), l = n._nextUint64(), h = n._nextUint64(), d = new sg(s, Li.length + i, 3 * o * 8, !0);
  for (let P = 0; P < o; P++)
    e.levels.push({ levelData: new Uint8Array(s.buffer, s.byteOffset + d._nextUint64(), d._nextUint64()), uncompressedByteLength: d._nextUint64() });
  const C = new sg(s, r, a, !0), p = { vendorId: C._skip(4)._nextUint16(), descriptorType: C._nextUint16(), versionNumber: C._nextUint16(), descriptorBlockSize: C._nextUint16(), colorModel: C._nextUint8(), colorPrimaries: C._nextUint8(), transferFunction: C._nextUint8(), flags: C._nextUint8(), texelBlockDimension: [C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8()], bytesPlane: [C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8()], samples: [] }, m = (p.descriptorBlockSize / 4 - 6) / 4;
  for (let P = 0; P < m; P++) {
    const k = { bitOffset: C._nextUint16(), bitLength: C._nextUint8(), channelType: C._nextUint8(), samplePosition: [C._nextUint8(), C._nextUint8(), C._nextUint8(), C._nextUint8()], sampleLower: -1 / 0, sampleUpper: 1 / 0 };
    64 & k.channelType ? (k.sampleLower = C._nextInt32(), k.sampleUpper = C._nextInt32()) : (k.sampleLower = C._nextUint32(), k.sampleUpper = C._nextUint32()), p.samples[P] = k;
  }
  e.dataFormatDescriptor.length = 0, e.dataFormatDescriptor.push(p);
  const b = new sg(s, g, c, !0);
  for (; b._offset < c; ) {
    const P = b._nextUint32(), k = b._scan(P), V = oy(k), N = b._scan(P - k.byteLength);
    e.keyValue[V] = V.match(/^ktx/i) ? oy(N) : N, b._offset % 4 && b._skip(4 - b._offset % 4);
  }
  if (h <= 0)
    return e;
  const S = new sg(s, l, h, !0), A = S._nextUint16(), u = S._nextUint16(), y = S._nextUint32(), I = S._nextUint32(), M = S._nextUint32(), G = S._nextUint32(), x = [];
  for (let P = 0; P < o; P++)
    x.push({ imageFlags: S._nextUint32(), rgbSliceByteOffset: S._nextUint32(), rgbSliceByteLength: S._nextUint32(), alphaSliceByteOffset: S._nextUint32(), alphaSliceByteLength: S._nextUint32() });
  const L = l + S._offset, E = L + y, T = E + I, R = T + M, w = new Uint8Array(s.buffer, s.byteOffset + L, y), v = new Uint8Array(s.buffer, s.byteOffset + E, I), D = new Uint8Array(s.buffer, s.byteOffset + T, M), K = new Uint8Array(s.buffer, s.byteOffset + R, G);
  return e.globalData = { endpointCount: A, selectorCount: u, imageDescs: x, endpointsData: w, selectorsData: v, tablesData: D, extendedData: K }, e;
}
let Yu, Rs, bA;
const ju = { env: { emscripten_notify_memory_growth: function(s) {
  bA = new Uint8Array(Rs.exports.memory.buffer);
} } };
class JX {
  init() {
    return Yu || (Yu = typeof fetch < "u" ? fetch("data:application/wasm;base64," + ry).then((t) => t.arrayBuffer()).then((t) => WebAssembly.instantiate(t, ju)).then(this._init) : WebAssembly.instantiate(Buffer.from(ry, "base64"), ju).then(this._init), Yu);
  }
  _init(t) {
    Rs = t.instance, ju.env.emscripten_notify_memory_growth(0);
  }
  decode(t, e = 0) {
    if (!Rs)
      throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const i = t.byteLength, n = Rs.exports.malloc(i);
    bA.set(t, n), e = e || Number(Rs.exports.ZSTD_findDecompressedSize(n, i));
    const o = Rs.exports.malloc(e), r = Rs.exports.ZSTD_decompress(o, e, n, i), a = bA.slice(o, o + r);
    return Rs.exports.free(n), Rs.exports.free(o), a;
  }
}
const ry = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", Ju = /* @__PURE__ */ new WeakMap();
let qu = 0, $u;
class os extends Fh {
  constructor(t) {
    super(t), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new zX(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn(
      'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
    );
  }
  setTranscoderPath(t) {
    return this.transcoderPath = t, this;
  }
  setWorkerLimit(t) {
    return this.workerPool.setWorkerLimit(t), this;
  }
  detectSupport(t) {
    return t.isWebGPURenderer === !0 ? this.workerConfig = {
      astcSupported: t.hasFeature("texture-compression-astc"),
      etc1Supported: !1,
      etc2Supported: t.hasFeature("texture-compression-etc2"),
      dxtSupported: t.hasFeature("texture-compression-bc"),
      bptcSupported: !1,
      pvrtcSupported: !1
    } : (this.workerConfig = {
      astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
      etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
      etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
      dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
      bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
      pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
    }, t.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)), this;
  }
  init() {
    if (!this.transcoderPending) {
      const t = new rs(this.manager);
      t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials);
      const e = t.loadAsync("basis_transcoder.js"), i = new rs(this.manager);
      i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
      const n = i.loadAsync("basis_transcoder.wasm");
      this.transcoderPending = Promise.all([e, n]).then(([o, r]) => {
        const a = os.BasisWorker.toString(), g = [
          "/* constants */",
          "let _EngineFormat = " + JSON.stringify(os.EngineFormat),
          "let _TranscoderFormat = " + JSON.stringify(os.TranscoderFormat),
          "let _BasisFormat = " + JSON.stringify(os.BasisFormat),
          "/* basis_transcoder.js */",
          o,
          "/* worker */",
          a.substring(a.indexOf("{") + 1, a.lastIndexOf("}"))
        ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([g])), this.transcoderBinary = r, this.workerPool.setWorkerCreator(() => {
          const c = new Worker(this.workerSourceURL), l = this.transcoderBinary.slice(0);
          return c.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: l }, [l]), c;
        });
      }), qu > 0 && console.warn(
        "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
      ), qu++;
    }
    return this.transcoderPending;
  }
  load(t, e, i, n) {
    if (this.workerConfig === null)
      throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
    const o = new rs(this.manager);
    o.setResponseType("arraybuffer"), o.setWithCredentials(this.withCredentials), o.load(t, (r) => {
      if (Ju.has(r))
        return Ju.get(r).promise.then(e).catch(n);
      this._createTexture(r).then((a) => e ? e(a) : null).catch(n);
    }, i, n);
  }
  _createTextureFrom(t, e) {
    const { faces: i, width: n, height: o, format: r, type: a, error: g, dfdFlags: c } = t;
    if (a === "error")
      return Promise.reject(g);
    let l;
    if (e.faceCount === 6)
      l = new cT(i, r, Pi);
    else {
      const h = i[0].mipmaps;
      l = e.layerCount > 1 ? new lT(h, n, o, e.layerCount, r, Pi) : new Lb(h, n, o, r, Pi);
    }
    return l.minFilter = i[0].mipmaps.length === 1 ? Gt : wr, l.magFilter = Gt, l.generateMipmaps = !1, l.needsUpdate = !0, l.colorSpace = Bx(e), l.premultiplyAlpha = !!(c & WX), l;
  }
  async _createTexture(t, e = {}) {
    const i = jX(new Uint8Array(t));
    if (i.vkFormat !== QX)
      return $X(i);
    const n = e, o = this.init().then(() => this.workerPool.postMessage({ type: "transcode", buffer: t, taskConfig: n }, [t])).then((r) => this._createTextureFrom(r.data, i));
    return Ju.set(t, { promise: o }), o;
  }
  dispose() {
    return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), qu--, this;
  }
}
os.BasisFormat = {
  ETC1S: 0,
  UASTC_4x4: 1
};
os.TranscoderFormat = {
  ETC1: 0,
  ETC2: 1,
  BC1: 2,
  BC3: 3,
  BC4: 4,
  BC5: 5,
  BC7_M6_OPAQUE_ONLY: 6,
  BC7_M5: 7,
  PVRTC1_4_RGB: 8,
  PVRTC1_4_RGBA: 9,
  ASTC_4x4: 10,
  ATC_RGB: 11,
  ATC_RGBA_INTERPOLATED_ALPHA: 12,
  RGBA32: 13,
  RGB565: 14,
  BGR565: 15,
  RGBA4444: 16
};
os.EngineFormat = {
  RGBAFormat: Hs,
  RGBA_ASTC_4x4_Format: Gb,
  RGBA_BPTC_Format: Mb,
  RGBA_ETC2_EAC_Format: Eb,
  RGBA_PVRTC_4BPPV1_Format: Rb,
  RGBA_S3TC_DXT5_Format: Db,
  RGB_ETC1_Format: Kb,
  RGB_ETC2_Format: Hb,
  RGB_PVRTC_4BPPV1_Format: Pb,
  RGB_S3TC_DXT1_Format: Nb
};
os.BasisWorker = function() {
  let s, t, e;
  const i = _EngineFormat, n = _TranscoderFormat, o = _BasisFormat;
  self.addEventListener("message", function(p) {
    const m = p.data;
    switch (m.type) {
      case "init":
        s = m.config, r(m.transcoderBinary);
        break;
      case "transcode":
        t.then(() => {
          try {
            const { faces: b, buffers: S, width: A, height: u, hasAlpha: y, format: I, dfdFlags: M } = a(m.buffer);
            self.postMessage({ type: "transcode", id: m.id, faces: b, width: A, height: u, hasAlpha: y, format: I, dfdFlags: M }, S);
          } catch (b) {
            console.error(b), self.postMessage({ type: "error", id: m.id, error: b.message });
          }
        });
        break;
    }
  });
  function r(p) {
    t = new Promise((m) => {
      e = { wasmBinary: p, onRuntimeInitialized: m }, BASIS(e);
    }).then(() => {
      e.initializeBasis(), e.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
    });
  }
  function a(p) {
    const m = new e.KTX2File(new Uint8Array(p));
    function b() {
      m.close(), m.delete();
    }
    if (!m.isValid())
      throw b(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
    const S = m.isUASTC() ? o.UASTC_4x4 : o.ETC1S, A = m.getWidth(), u = m.getHeight(), y = m.getLayers() || 1, I = m.getLevels(), M = m.getFaces(), G = m.getHasAlpha(), x = m.getDFDFlags(), { transcoderFormat: L, engineFormat: E } = h(S, A, u, G);
    if (!A || !u || !I)
      throw b(), new Error("THREE.KTX2Loader:	Invalid texture");
    if (!m.startTranscoding())
      throw b(), new Error("THREE.KTX2Loader: .startTranscoding failed");
    const T = [], R = [];
    for (let w = 0; w < M; w++) {
      const v = [];
      for (let D = 0; D < I; D++) {
        const K = [];
        let P, k;
        for (let N = 0; N < y; N++) {
          const z = m.getImageLevelInfo(D, N, w);
          w === 0 && D === 0 && N === 0 && (z.origWidth % 4 !== 0 || z.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), I > 1 ? (P = z.origWidth, k = z.origHeight) : (P = z.width, k = z.height);
          const O = new Uint8Array(m.getImageTranscodedSizeInBytes(D, N, 0, L));
          if (!m.transcodeImage(O, D, N, w, L, 0, -1, -1))
            throw b(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
          K.push(O);
        }
        const V = C(K);
        v.push({ data: V, width: P, height: k }), R.push(V.buffer);
      }
      T.push({ mipmaps: v, width: A, height: u, format: E });
    }
    return b(), { faces: T, buffers: R, width: A, height: u, hasAlpha: G, format: E, dfdFlags: x };
  }
  const g = [
    {
      if: "astcSupported",
      basisFormat: [o.UASTC_4x4],
      transcoderFormat: [n.ASTC_4x4, n.ASTC_4x4],
      engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
      priorityETC1S: 1 / 0,
      priorityUASTC: 1,
      needsPowerOfTwo: !1
    },
    {
      if: "bptcSupported",
      basisFormat: [o.ETC1S, o.UASTC_4x4],
      transcoderFormat: [n.BC7_M5, n.BC7_M5],
      engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
      priorityETC1S: 3,
      priorityUASTC: 2,
      needsPowerOfTwo: !1
    },
    {
      if: "dxtSupported",
      basisFormat: [o.ETC1S, o.UASTC_4x4],
      transcoderFormat: [n.BC1, n.BC3],
      engineFormat: [i.RGB_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
      priorityETC1S: 4,
      priorityUASTC: 5,
      needsPowerOfTwo: !1
    },
    {
      if: "etc2Supported",
      basisFormat: [o.ETC1S, o.UASTC_4x4],
      transcoderFormat: [n.ETC1, n.ETC2],
      engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
      priorityETC1S: 1,
      priorityUASTC: 3,
      needsPowerOfTwo: !1
    },
    {
      if: "etc1Supported",
      basisFormat: [o.ETC1S, o.UASTC_4x4],
      transcoderFormat: [n.ETC1],
      engineFormat: [i.RGB_ETC1_Format],
      priorityETC1S: 2,
      priorityUASTC: 4,
      needsPowerOfTwo: !1
    },
    {
      if: "pvrtcSupported",
      basisFormat: [o.ETC1S, o.UASTC_4x4],
      transcoderFormat: [n.PVRTC1_4_RGB, n.PVRTC1_4_RGBA],
      engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
      priorityETC1S: 5,
      priorityUASTC: 6,
      needsPowerOfTwo: !0
    }
  ], c = g.sort(function(p, m) {
    return p.priorityETC1S - m.priorityETC1S;
  }), l = g.sort(function(p, m) {
    return p.priorityUASTC - m.priorityUASTC;
  });
  function h(p, m, b, S) {
    let A, u;
    const y = p === o.ETC1S ? c : l;
    for (let I = 0; I < y.length; I++) {
      const M = y[I];
      if (!!s[M.if] && !!M.basisFormat.includes(p) && !(S && M.transcoderFormat.length < 2) && !(M.needsPowerOfTwo && !(d(m) && d(b))))
        return A = M.transcoderFormat[S ? 1 : 0], u = M.engineFormat[S ? 1 : 0], { transcoderFormat: A, engineFormat: u };
    }
    return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), A = n.RGBA32, u = i.RGBAFormat, { transcoderFormat: A, engineFormat: u };
  }
  function d(p) {
    return p <= 2 ? !0 : (p & p - 1) === 0 && p !== 0;
  }
  function C(p) {
    if (p.length === 1)
      return p[0];
    let m = 0;
    for (let A = 0; A < p.length; A++) {
      const u = p[A];
      m += u.byteLength;
    }
    const b = new Uint8Array(m);
    let S = 0;
    for (let A = 0; A < p.length; A++) {
      const u = p[A];
      b.set(u, S), S += u.byteLength;
    }
    return b;
  }
};
const qX = /* @__PURE__ */ new Set([Hs, aa, Ps]), eI = {
  [yx]: Hs,
  [fx]: Hs,
  [ux]: Hs,
  [Ix]: Hs,
  [mx]: aa,
  [Cx]: aa,
  [hx]: aa,
  [dx]: aa,
  [px]: Ps,
  [Ax]: Ps,
  [lx]: Ps,
  [cx]: Ps,
  [bx]: UI,
  [Sx]: UI
}, tI = {
  [yx]: ur,
  [fx]: xi,
  [ux]: Pi,
  [Ix]: Pi,
  [mx]: ur,
  [Cx]: xi,
  [hx]: Pi,
  [dx]: Pi,
  [px]: ur,
  [Ax]: xi,
  [lx]: Pi,
  [cx]: Pi,
  [bx]: Pi,
  [Sx]: Pi
};
async function $X(s) {
  const { vkFormat: t } = s;
  if (eI[t] === void 0)
    throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
  let e;
  s.supercompressionScheme === ny && ($u || ($u = new Promise(async (o) => {
    const r = new JX();
    await r.init(), o(r);
  })), e = await $u);
  const i = [];
  for (let o = 0; o < s.levels.length; o++) {
    const r = Math.max(1, s.pixelWidth >> o), a = Math.max(1, s.pixelHeight >> o), g = s.pixelDepth ? Math.max(1, s.pixelDepth >> o) : 0, c = s.levels[o];
    let l;
    if (s.supercompressionScheme === XX)
      l = c.levelData;
    else if (s.supercompressionScheme === ny)
      l = e.decode(c.levelData, c.uncompressedByteLength);
    else
      throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
    let h;
    tI[t] === ur ? h = new Float32Array(
      l.buffer,
      l.byteOffset,
      l.byteLength / Float32Array.BYTES_PER_ELEMENT
    ) : tI[t] === xi ? h = new Uint16Array(
      l.buffer,
      l.byteOffset,
      l.byteLength / Uint16Array.BYTES_PER_ELEMENT
    ) : h = l, i.push({
      data: h,
      width: r,
      height: a,
      depth: g
    });
  }
  let n;
  if (qX.has(eI[t]))
    n = s.pixelDepth === 0 ? new Ga(i[0].data, s.pixelWidth, s.pixelHeight) : new hT(i[0].data, s.pixelWidth, s.pixelHeight, s.pixelDepth);
  else {
    if (s.pixelDepth > 0)
      throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
    n = new Lb(i, s.pixelWidth, s.pixelHeight);
  }
  return n.mipmaps = i, n.type = tI[t], n.format = eI[t], n.colorSpace = Bx(s), n.needsUpdate = !0, Promise.resolve(n);
}
function Bx(s) {
  const t = s.dataFormatDescriptor[0];
  return t.colorPrimaries === UX ? t.transferFunction === sy ? gt : Vi : t.colorPrimaries === OX ? t.transferFunction === sy ? dT : uT : t.colorPrimaries === ZX ? Yl : (console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`), Yl);
}
const od = new os(), e5 = new VA();
od.detectSupport(e5);
od.setWorkerLimit = 4;
od.setTranscoderPath(pt("assets/libs/basis/"));
const tf = new kX();
tf.setDecoderPath(pt("assets/libs/draco/gltf/"));
tf.setDecoderConfig({ type: "js" });
function wx() {
  const s = new gX();
  return s.setMeshoptDecoder(FX), s.setDRACOLoader(tf), s.setKTX2Loader(od), s;
}
let nf = wx();
function t5(s) {
  const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), i = s.clone();
  return _x(s, i, function(n, o) {
    t.set(o, n), e.set(n, o);
  }), i.traverse(function(n) {
    if (!n.isSkinnedMesh)
      return;
    const o = n, r = t.get(n), a = r.skeleton.bones;
    o.skeleton = r.skeleton.clone(), o.bindMatrix.copy(r.bindMatrix), o.skeleton.bones = a.map(function(g) {
      return e.get(g);
    }), o.bind(o.skeleton, o.bindMatrix);
  }), i;
}
function _x(s, t, e) {
  e(s, t);
  for (let i = 0; i < s.children.length; i++)
    _x(s.children[i], t.children[i], e);
}
const xx = new sd();
xx.generate = async (s) => new Promise((t, e) => {
  nf.load(s, (i) => {
    t(i);
  }, null, e);
});
const iI = new B(), Or = new B(), Ln = new pr();
new J();
class EY extends Wt {
  constructor(e) {
    super(e);
    f(this, "_autoYUpToZUp", !0);
    this._parameters = e, this._name = e.name || "", this._object = e.object || e.url, e.autoYUpToZUp !== void 0 && (this._autoYUpToZUp = e.autoYUpToZUp);
  }
  afterAddToEngine(e) {
    this._engine = e, this.setTransform({
      point: this._parameters.point || [0, 0, 0],
      scale: this._parameters.scale || [1, 1, 1],
      rotation: this._parameters.rotation || [0, 0, 0]
    }), this._initModel();
  }
  beforeRemoveFromEngine() {
    this.dispose();
  }
  async _initModel() {
    if (!this._object) {
      console.error("object of SimpleModel is required");
      return;
    }
    let e = null;
    if (typeof this._object == "string") {
      const i = await xx.get(this._object);
      i.animations && i.animations.length > 0 ? e = t5(i.scene) : e = i.scene.clone(), this._updateData(i, e), this.dispatchEvent({
        type: "loaded",
        value: this
      }), this._autoYUpToZUp && e.rotateX(Math.PI / 2);
    } else
      this._object.isObject3D && (e = this._object);
    this.add(e);
  }
  dispose() {
  }
  setTransform(e = {}) {
    if (e.point) {
      e.point instanceof B ? iI.copy(e.point) : e.point instanceof Array && iI.set(e.point[0], e.point[1], e.point[2] || 0);
      const i = this._engine.map.projectCoordinate(iI);
      this.position.copy(i);
    }
    if (e.rotation) {
      if (e.rotation instanceof pr ? Ln.copy(e.rotation) : e.rotation instanceof B ? Ln.setFromVector3(e.rotation, "XYZ") : e.rotation instanceof Array && Ln.set(e.rotation[0], e.rotation[1], e.rotation[2], "XYZ"), this._engine.map.isGlobe) {
        const i = {
          heading: Ln.z,
          pitch: Ln.y,
          roll: Ln.x
        }, n = Ze.headingPitchRollToFixedFrame(this.position, i);
        Ln.setFromRotationMatrix(n);
      }
      this.rotation.set(Ln.x, Ln.y, Ln.z, Ln.order);
    }
    e.scale && (e.scale instanceof B ? Or.copy(e.scale) : typeof e.scale == "number" ? Or.set(e.scale, e.scale, e.scale) : e.scale instanceof Array && Or.set(e.scale[0], e.scale[1], e.scale[2]), this.scale.set(Or.x, Or.y, Or.z));
  }
  set point(e) {
    !e || this.setTransform({ point: e });
  }
  get autoYUpToZUp() {
    return this._autoYUpToZUp;
  }
  _updateData() {
  }
}
const nI = new wa({
  max: 100,
  onRemove(s) {
    s.destroyModel();
  }
});
class RY extends Wt {
  constructor(e) {
    super(e);
    f(this, "_hysteresis", 0.1);
    f(this, "_levels", []);
    f(this, "_currentLevel");
    f(this, "_currentModel");
    f(this, "_loader", nf);
    f(this, "_generateModelMesh", async (e) => new Promise((i, n) => {
      this._loader.load(e, (o) => {
        i(o.scene);
      }, null, n);
    }));
    f(this, "update", async () => {
      if (!this.visible)
        return;
      const e = this._engine.camera, i = this.levels, n = this.position, o = i.length;
      if (o > 0) {
        const r = e.position.distanceTo(n), a = i[o - 1].hysteresis || this.hysteresis;
        if (r > i[o - 1].distance * (1 + a)) {
          this._modelMeshSingleton.keys.forEach(async (l) => {
            let h = await this._modelMeshSingleton.get(l);
            h.visible = !1;
          }), !nI.cache[this.uuid] && this.isInit && nI.set(this.uuid, this), this._currentLevel = void 0, this._currentModel = void 0;
          return;
        }
        nI.remove(this.uuid);
        let g, c;
        for (let l = 0; l < o; l++) {
          const h = i[l];
          let d = h.distance;
          if (h.init && (await this._modelMeshSingleton.get(h.file)).visible === !0) {
            let p = h.hysteresis || this.hysteresis;
            d += d * p;
          }
          if (g === void 0 && r <= d) {
            g = l;
            continue;
          }
          if (h.init) {
            let C = await this._modelMeshSingleton.get(h.file);
            C.visible = !1;
          }
        }
        if (g >= 0) {
          let l = i[g], h = await this._modelMeshSingleton.get(l.file);
          l.init ? h.visible = !0 : (this.add(h), l.init = !0, this.handleLoaded(h)), c = h;
        }
        this._currentLevel = g, this._currentModel = c;
      }
    });
    e.hysteresis && (this.hysteresis = e.hysteresis), e.levels && (this.levels = e.levels);
  }
  afterAddToEngine(e) {
    this._engine = e, this._modelMeshSingleton = new sd(), this._modelMeshSingleton.generate = this._generateModelMesh, this._engine.rendering.addPrepareRenderListener(this.update);
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  addLevel(e, i = 0, n = 0) {
    i = Math.abs(i);
    const o = this.levels;
    let r;
    for (r = 0; r < o.length && !(i < o[r].distance); r++)
      ;
    return o.splice(r, 0, { distance: i, hysteresis: n, file: e, init: !1 }), this;
  }
  removeLevel(e) {
    for (let i = 0; i < this.levels.length; i++) {
      const n = this.levels[i];
      if (e === n.file) {
        this.levels.splice(i, 1);
        break;
      }
    }
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getCurrentModel() {
    return this._currentModel;
  }
  async getModel(e) {
    let i = this.levels[e];
    if (!!i)
      return await this._modelMeshSingleton.get(i.file);
  }
  handleLoaded(e) {
    this.dispatchEvent({
      type: "loaded",
      value: e
    }), this.levels.every((n) => n.init) && this.dispatchEvent({
      type: "complete",
      value: this
    });
  }
  dispose() {
    this._loaded && (this._engine.rendering.removePrepareRenderListener(this.update), this.destroyModel());
  }
  get isInit() {
    return this.levels.findIndex((i) => i.init) >= 0;
  }
  destroyModel() {
    this._modelMeshSingleton.keys.forEach(async (e) => {
      let i = await this._modelMeshSingleton.get(e);
      this.remove(i), i.traverse((n) => {
        if (n.isMesh) {
          n.geometry.dispose(), n.material.dispose();
          const o = n.material.map;
          o && (o.image instanceof ImageBitmap && o.image.close(), o.dispose());
        }
      });
    });
    for (let e = 0; e < this.levels.length; e++) {
      const i = this.levels[e];
      i.init = !1;
    }
    this._modelMeshSingleton.clear();
  }
  get transform() {
    return {
      translate: this.position,
      rotation: this.rotation,
      scale: this.scale
    };
  }
  set transform(e) {
    e.translate && (e.translate instanceof B ? this.position.copy(e.translate) : this.position.set(...e.translate)), e.rotation && (e.rotation instanceof B ? this.rotation.copy(e.rotation) : this.rotation.set(...e.rotation)), e.scale && (e.scale instanceof B ? this.scale.copy(e.scale) : typeof e.scale == "number" ? this.scale.setScalar(e.scale) : this.scale.set(...e.scale));
  }
  get levels() {
    return this._levels;
  }
  set levels(e) {
    this._levels = e.map((i) => (i.init = !1, i));
  }
  get hysteresis() {
    return this._hysteresis;
  }
  set hysteresis(e) {
    this._hysteresis = e;
  }
}
const i5 = {
  UNLOADED: 0,
  LOADING: 1,
  PROCESSING: 2,
  READY: 3,
  EXPIRED: 4,
  FAILED: 5
}, li = Object.freeze(i5);
function sI(s, t, e) {
  const i = s[t];
  s[t] = s[e], s[e] = i;
}
class n5 {
  constructor(t) {
    this._comparator = t.comparator, this._array = [], this._length = 0, this._maximumLength = void 0;
  }
  reserve(t) {
    t = W(t, this._length), this._array.length = t;
  }
  heapify(t) {
    t = W(t, 0);
    const e = this._length, i = this._comparator, n = this._array;
    let o = -1, r = !0;
    for (; r; ) {
      const a = 2 * (t + 1), g = a - 1;
      g < e && i(n[g], n[t]) < 0 ? o = g : o = t, a < e && i(n[a], n[o]) < 0 && (o = a), o !== t ? (sI(n, o, t), t = o) : r = !1;
    }
  }
  resort() {
    const t = this._length;
    for (let e = Math.ceil(t / 2); e >= 0; --e)
      this.heapify(e);
  }
  insert(t) {
    const e = this._array, i = this._comparator, n = this._maximumLength;
    let o = this._length++;
    for (o < e.length ? e[o] = t : e.push(t); o !== 0; ) {
      const a = Math.floor((o - 1) / 2);
      if (i(e[o], e[a]) < 0)
        sI(e, o, a), o = a;
      else
        break;
    }
    let r;
    return H(n) && this._length > n && (r = e[n], this._length = n), r;
  }
  pop(t) {
    if (t = W(t, 0), this._length === 0)
      return;
    const e = this._array, i = e[t];
    return sI(e, t, --this._length), this.heapify(t), e[this._length] = void 0, i;
  }
  get length() {
    return this._length;
  }
  get internalArray() {
    return this._array;
  }
  get maximumLength() {
    return this._maximumLength;
  }
  set maximumLength(t) {
    const e = this._length;
    if (t < e) {
      const i = this._array;
      for (let n = t; n < e; ++n)
        i[n] = void 0;
      this._length = t, i.length = t;
    }
    this._maximumLength = t;
  }
  get comparator() {
    return this._comparator;
  }
}
const s5 = /^data:/i;
function o5(s) {
  return s5.test(s);
}
const r5 = /^blob:/i;
function a5(s) {
  return r5.test(s);
}
function g5(s, t) {
  return s.priority - t.priority;
}
const as = {
  numberOfAttemptedRequests: 0,
  numberOfActiveRequests: 0,
  numberOfCancelledRequests: 0,
  numberOfCancelledActiveRequests: 0,
  numberOfFailedRequests: 0,
  numberOfActiveRequestsEver: 0,
  lastNumberOfActiveRequests: 0
};
let ca = 20;
const Qi = new n5({
  comparator: g5
});
Qi.maximumLength = ca;
Qi.reserve(ca);
const c5 = typeof document < "u" ? new Zs(document.location.href) : new Zs(), ar = [];
let fr = {};
const wo = class {
  static get statistics() {
    return as;
  }
  static get priorityHeapLength() {
    return ca;
  }
  static set priorityHeapLength(t) {
    if (t < ca)
      for (; Qi.length > t; ) {
        const e = Qi.pop();
        og(e);
      }
    ca = t, Qi.maximumLength = t, Qi.reserve(t);
  }
  static update() {
    let t, e, i = 0;
    const n = ar.length;
    for (t = 0; t < n; t++) {
      if (e = ar[t], e.cancelled && og(e), e.state !== Et.ACTIVE) {
        ++i;
        continue;
      }
      i > 0 && (ar[t - i] = e);
    }
    ar.length -= i;
    const o = Qi.internalArray, r = Qi.length;
    for (t = 0; t < r; ++t)
      ay(o[t]);
    Qi.resort();
    const a = Math.max(
      wo.maximumRequests - ar.length,
      0
    );
    let g = 0;
    for (; g < a && Qi.length > 0; ) {
      if (e = Qi.pop(), e.cancelled) {
        og(e);
        continue;
      }
      if (e.throttleByServer && !wo.serverHasOpenSlots(e.serverKey)) {
        og(e);
        continue;
      }
      gy(e), ++g;
    }
  }
  static request(t) {
    if (o5(t.url) || a5(t.url))
      return t.state = Et.RECEIVED, t.requestFunction();
    if (++as.numberOfAttemptedRequests, H(t.serverKey) || (t.serverKey = wo.getServerKey(t.url)), !t.throttle)
      return gy(t);
    if (ar.length >= wo.maximumRequests)
      return;
    ay(t);
    const e = Qi.insert(t);
    if (H(e)) {
      if (e === t)
        return;
      og(e);
    }
    return vx(t);
  }
};
let Bi = wo;
f(Bi, "maximumRequests", 50), f(Bi, "maximumRequestsPerServer", 18), f(Bi, "requestsByServer", {}), f(Bi, "throttleRequests", !0), f(Bi, "debugShowStatistics", !1), f(Bi, "getServerKey", function(t) {
  let e = new Zs(t);
  e.scheme() === "" && (e = e.absoluteTo(c5), e.normalize());
  let i = e.authority();
  /:/.test(i) || (i = `${i}:${e.scheme() === "https" ? "443" : "80"}`);
  const n = fr[i];
  return H(n) || (fr[i] = 0), i;
}), f(Bi, "serverHasOpenSlots", function(t, e) {
  e = W(e, 1);
  const i = W(
    wo.requestsByServer[t],
    wo.maximumRequestsPerServer
  );
  return fr[t] + e <= i;
}), f(Bi, "heapHasOpenSlots", function(t) {
  return Qi.length + t <= ca;
});
function og(s) {
  const t = s.state === Et.ACTIVE;
  if (s.state = Et.CANCELLED, ++as.numberOfCancelledRequests, H(s.deferred)) {
    const e = s.deferred;
    s.deferred = void 0, e.reject();
  }
  t && (--as.numberOfActiveRequests, --fr[s.serverKey], ++as.numberOfCancelledActiveRequests), H(s.cancelFunction) && s.cancelFunction();
}
function ay(s) {
  H(s.priorityFunction) && (s.priority = s.priorityFunction());
}
function vx(s) {
  return s.state === Et.UNISSUED && (s.state = Et.ISSUED, s.deferred = YC()), s.deferred.promise;
}
function l5(s) {
  return function(t) {
    if (s.state === Et.CANCELLED)
      return;
    const e = s.deferred;
    --as.numberOfActiveRequests, --fr[s.serverKey], s.state = Et.RECEIVED, s.deferred = void 0, e.resolve(t);
  };
}
function h5(s) {
  return function(t) {
    s.state !== Et.CANCELLED && (++as.numberOfFailedRequests, --as.numberOfActiveRequests, --fr[s.serverKey], s.state = Et.FAILED, s.deferred.reject(t));
  };
}
function gy(s) {
  const t = vx(s);
  return s.state = Et.ACTIVE, ar.push(s), ++as.numberOfActiveRequests, ++as.numberOfActiveRequestsEver, ++fr[s.serverKey], s.requestFunction().then(l5(s)).catch(h5(s)), t;
}
class d5 {
  constructor(t, e, i) {
    this.item = t, this.previous = e, this.next = i;
  }
}
function cy(s, t) {
  H(t.previous) && H(t.next) ? (t.previous.next = t.next, t.next.previous = t.previous) : H(t.previous) ? (t.previous.next = void 0, s.tail = t.previous) : H(t.next) ? (t.next.previous = void 0, s.head = t.next) : (s.head = void 0, s.tail = void 0), t.next = void 0, t.previous = void 0;
}
class u5 {
  constructor() {
    this.head = void 0, this.tail = void 0, this._length = 0;
  }
  add(t) {
    const e = new d5(t, this.tail, void 0);
    return H(this.tail) ? (this.tail.next = e, this.tail = e) : (this.head = e, this.tail = e), ++this._length, e;
  }
  remove(t) {
    !H(t) || (cy(this, t), --this._length);
  }
  splice(t, e) {
    if (t === e)
      return;
    cy(this, e);
    const i = t.next;
    t.next = e, this.tail === t ? this.tail = e : i.previous = e, e.next = i, e.previous = t;
  }
  get length() {
    return this._length;
  }
}
class I5 {
  constructor() {
    this._list = new u5(), this._sentinel = this._list.add(), this.trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(t) {
    const e = t.cacheNode;
    H(e) && this._list.splice(this._sentinel, e);
  }
  add(t) {
    H(t.cachedNode) || (t.cacheNode = this._list.add(t));
  }
  unloadTile(t, e, i) {
    const n = e.cacheNode;
    !H(n) || (this._list.remove(n), e.cacheNode = void 0, i(t, e));
  }
  unloadTiles(t, e) {
    const i = this._trimTiles;
    this._trimTiles = !1;
    const n = this._list, o = this._sentinel;
    let r = n.head;
    for (; r !== o && (t.totalMemoryUsageInBytes > t.cacheBytes || i); ) {
      const a = r.item;
      r = r.next, this.unloadTile(t, a, e);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
class ly {
  constructor() {
    this.selected = 0, this.visited = 0, this.numberOfAttemptedRequests = 0, this.numberOfPendingRequests = 0, this.numberOfTilesProcessing = 0, this.numberOfTilesWithContentReady = 0, this.numberOfTilesTotal = 0, this.numberOfLoadedTilesTotal = 0, this.numberOfTilesCulledWithChildrenUnion = 0, this.totalByteLength = 0;
  }
  clear() {
    this.selected = 0, this.visited = 0, this.numberOfAttemptedRequests = 0, this.numberOfTilesCulledWithChildrenUnion = 0;
  }
  incrementSelectionCounts() {
    Zl(this, this.content, !1, !1);
  }
  incrementLoadCounts(t) {
    Zl(this, t, !1, !0);
  }
  decrementLoadCounts(t) {
    Zl(this, t, !0, !0);
  }
}
function Zl(s, t, e, i) {
  const n = t.innerContents;
  t.pointsLength, t.trianglesLength, t.featuresLength;
  const o = t.byteSize;
  if (i && (s.totalByteLength += e ? -o : o), H(n)) {
    const r = n.length;
    for (let a = 0; a < r; ++a)
      Zl(s, n[a], e, i);
  }
}
function A5(s) {
  if (!H(s))
    throw new Error("obj is required.");
  let t = "";
  for (const e in s)
    if (s.hasOwnProperty(e)) {
      const i = s[e], n = `${encodeURIComponent(e)}=`;
      if (Array.isArray(i))
        for (let o = 0, r = i.length; o < r; ++o)
          t += `${n + encodeURIComponent(i[o])}&`;
      else
        t += `${n + encodeURIComponent(i)}&`;
    }
  return t = t.slice(0, -1), t;
}
function C5(s) {
  if (s.state === Et.ISSUED || s.state === Et.ACTIVE)
    throw new Error("The Resource is already being fetched.");
  s.state = Et.UNISSUED, s.deferred = void 0;
}
function f5(s) {
  const t = Object.keys(s);
  return t.length === 0 ? "" : t.length === 1 && !H(s[t[0]]) ? `?${t[0]}` : `?${A5(s)}`;
}
function p5(s) {
  const t = {};
  if (s === "")
    return t;
  const e = s.replace(/\+/g, "%20").split(/[&;]/);
  for (let i = 0, n = e.length; i < n; ++i) {
    const o = e[i].split("="), r = decodeURIComponent(o[0]);
    let a = o[1];
    H(a) ? a = decodeURIComponent(a) : a = "";
    const g = t[r];
    typeof g == "string" ? t[r] = [g, a] : Array.isArray(g) ? g.push(a) : t[r] = a;
  }
  return t;
}
function la(s, t, e) {
  e = W(e, !1);
  const i = {}, n = H(s), o = H(t);
  let r, a, g;
  if (n)
    for (r in s)
      s.hasOwnProperty(r) && (a = s[r], o && e && typeof a == "object" && t.hasOwnProperty(r) ? (g = t[r], typeof g == "object" ? i[r] = la(a, g, e) : i[r] = a) : i[r] = a);
  if (o)
    for (r in t)
      t.hasOwnProperty(r) && !i.hasOwnProperty(r) && (g = t[r], i[r] = g);
  return i;
}
function Gg(s, t) {
  if (s === null || typeof s != "object")
    return s;
  t = W(t, !1);
  const e = new s.constructor();
  for (const i in s)
    if (s.hasOwnProperty(i)) {
      let n = s[i];
      t && (n = Gg(n, t)), e[i] = n;
    }
  return e;
}
function oI(s, t, e) {
  if (!e)
    return la(s, t);
  const i = Gg(s, !0);
  for (const n in t)
    if (t.hasOwnProperty(n)) {
      let o = i[n];
      const r = t[n];
      H(o) ? (Array.isArray(o) || (o = i[n] = [o]), i[n] = o.concat(r)) : i[n] = Array.isArray(r) ? r.slice() : r;
    }
  return i;
}
function m5(s) {
  return s.length === 0 ? {} : s.indexOf("=") === -1 ? { [s]: void 0 } : p5(s);
}
class Lt {
  constructor(t) {
    t = W(t, {}), typeof t == "string" && (t = {
      url: t
    }), this._url = void 0, this._templateValues = W(t.templateValues, {}), this._queryParameters = W(t.queryParameters, {}), this.headers = W(t.headers, {}), this.request = W(t.request, new tc()), this.proxy = t.proxy, this.retryCallback = t.retryCallback, this.retryAttempts = W(t.retryAttempts, 0), this._retryCount = 0, W(t.parseUrl, !0) ? this.parseUrl(t.url, !0, !0) : this._url = t.url;
  }
  parseUrl(t, e, i, n) {
    let o = new Zs(t);
    const r = m5(o.query());
    this._queryParameters = e ? oI(r, this.queryParameters, i) : r, o.search(""), o.fragment(""), H(n) && o.scheme() === "" && (o = o.absoluteTo(AC(n))), this._url = o.toString();
  }
  clone(t) {
    return H(t) ? (t._url = this._url, t._queryParameters = Gg(this._queryParameters), t._templateValues = Gg(this._templateValues), t.headers = Gg(this.headers), t.proxy = this.proxy, t.retryCallback = this.retryCallback, t.retryAttempts = this.retryAttempts, t._retryCount = 0, t.request = this.request.clone(), t) : new Lt({
      url: this._url,
      queryParameters: this.queryParameters,
      templateValues: this.templateValues,
      headers: this.headers,
      proxy: this.proxy,
      retryCallback: this.retryCallback,
      retryAttempts: this.retryAttempts,
      request: this.request.clone(),
      parseUrl: !1,
      credits: H(this.credits) ? this.credits.slice() : void 0
    });
  }
  setQueryParameters(t, e) {
    e ? this._queryParameters = oI(
      this._queryParameters,
      t,
      !1
    ) : this._queryParameters = oI(
      t,
      this._queryParameters,
      !1
    );
  }
  getDerivedResource(t) {
    const e = this.clone();
    if (e._retryCount = 0, H(t.url)) {
      const i = W(t.preserveQueryParameters, !1);
      e.parseUrl(t.url, !0, i, this._url);
    }
    return H(t.queryParameters) && (e._queryParameters = la(
      t.queryParameters,
      e.queryParameters
    )), H(t.templateValues) && (e._templateValues = la(
      t.templateValues,
      e.templateValues
    )), H(t.headers) && (e.headers = la(t.headers, e.headers)), H(t.proxy) && (e.proxy = t.proxy), H(t.request) && (e.request = t.request), H(t.retryCallback) && (e.retryCallback = t.retryCallback), H(t.retryAttempts) && (e.retryAttempts = t.retryAttempts), e;
  }
  fetchJson() {
    const t = this.fetch({
      responseType: "text",
      headers: {
        Accept: "application/json,*/*;q=0.01"
      }
    });
    if (!!H(t))
      return t.then(function(e) {
        if (!!H(e))
          return JSON.parse(e);
      });
  }
  fetchArrayBuffer() {
    return this.fetch({
      responseType: "arraybuffer"
    });
  }
  fetch(t) {
    return t = W(t, {}), t.method = "GET", this._makeRequest(t);
  }
  retryOnError(t) {
    const e = this.retryCallback;
    if (typeof e != "function" || this._retryCount >= this.retryAttempts)
      return Promise.resolve(!1);
    const i = this;
    return Promise.resolve(e(this, t)).then(function(n) {
      return ++i._retryCount, n;
    });
  }
  _makeRequest(t) {
    const e = this;
    C5(e.request);
    const i = e.request, n = e.url;
    i.url = n, i.requestFunction = function() {
      const r = t.responseType, a = la(t.headers, e.headers), g = t.overrideMimeType, c = t.method, l = t.data, h = YC(), d = Lt._Implementations.loadWithXhr(
        n,
        r,
        c,
        l,
        a,
        h,
        g
      );
      return H(d) && H(d.abort) && (i.cancelFunction = function() {
        d.abort();
      }), h.promise;
    };
    const o = Bi.request(i);
    if (!!H(o))
      return o.then(function(r) {
        return i.cancelFunction = void 0, r;
      }).catch(function(r) {
        return i.cancelFunction = void 0, i.state !== Et.FAILED ? Promise.reject(r) : e.retryOnError(r).then(function(a) {
          return a ? (i.state = Et.UNISSUED, i.deferred = void 0, e.fetch(t)) : Promise.reject(r);
        });
      });
  }
  getUrlComponent(t, e) {
    if (this.isDataUri)
      return this._url;
    let i = this._url;
    t && (i = `${i}${f5(this.queryParameters || {})}`), i = i.replace(/%7B/g, "{").replace(/%7D/g, "}");
    const n = this._templateValues;
    return Object.keys(n).length > 0 && (i = i.replace(/{(.*?)}/g, function(o, r) {
      const a = n[r];
      return H(a) ? encodeURIComponent(a) : o;
    })), e && H(this.proxy) && (i = this.proxy.getURL(i)), i;
  }
  getBaseUri(t) {
    return ew(this.getUrlComponent(t), t);
  }
  static createIfNeeded(t) {
    return t instanceof Lt ? t.getDerivedResource({
      request: t.request
    }) : typeof t != "string" ? t : new Lt({
      url: t
    });
  }
  static fetchArrayBuffer(t) {
    return new Lt(t).fetchArrayBuffer();
  }
  get url() {
    return this.getUrlComponent(!0, !0);
  }
  set url(t) {
    this.parseUrl(t, !1, !1);
  }
  get queryParameters() {
    return this._queryParameters;
  }
  get extension() {
    return $B(this._url);
  }
}
const y5 = /^data:(.*?)(;base64)?,(.*)$/;
function Ul(s, t) {
  const e = decodeURIComponent(t);
  return s ? atob(e) : e;
}
function hy(s, t) {
  const e = Ul(s, t), i = new ArrayBuffer(e.length), n = new Uint8Array(i);
  for (let o = 0; o < e.length; o++)
    n[o] = e.charCodeAt(o);
  return i;
}
function S5(s, t) {
  t = W(t, "");
  const e = s[1], i = !!s[2], n = s[3];
  let o, r;
  switch (t) {
    case "":
    case "text":
      return Ul(i, n);
    case "arraybuffer":
      return hy(i, n);
    case "blob":
      return o = hy(i, n), new Blob([o], {
        type: e
      });
    case "document":
      return r = new DOMParser(), r.parseFromString(
        Ul(i, n),
        e
      );
    case "json":
      return JSON.parse(Ul(i, n));
    default:
      throw new Error(`Unhandled responseType: ${t}`);
  }
}
const b5 = typeof XMLHttpRequest > "u";
function B5(s, t, e, i, n, o, r) {
  fetch(s, {
    method: e,
    headers: n
  }).then(async (a) => {
    if (!a.ok) {
      a.headers.forEach((g, c) => {
      }), o.reject();
      return;
    }
    switch (t) {
      case "text":
        o.resolve(a.text());
        break;
      case "json":
        o.resolve(a.json());
        break;
      default:
        o.resolve(new Uint8Array(await a.arrayBuffer()).buffer);
        break;
    }
  }).catch(() => {
  });
}
Lt._Implementations = {};
Lt._Implementations.loadWithXhr = function(s, t, e, i, n, o, r) {
  const a = y5.exec(s);
  if (a !== null) {
    o.resolve(S5(a, t));
    return;
  }
  if (b5) {
    B5(
      s,
      t,
      e,
      i,
      n,
      o
    );
    return;
  }
  const g = new XMLHttpRequest();
  if (g.open(e, s, !0), H(r) && H(g.overrideMimeType) && g.overrideMimeType(r), H(n))
    for (const l in n)
      n.hasOwnProperty(l) && g.setRequestHeader(l, n[l]);
  H(t) && (g.responseType = t);
  let c = !1;
  return typeof s == "string" && (c = s.indexOf("file://") === 0 || typeof window < "u" && window.location.origin === "file://"), g.onload = function() {
    if ((g.status < 200 || g.status >= 300) && !(c && g.status === 0)) {
      o.reject();
      return;
    }
    const l = g.response, h = g.responseType;
    if (e === "HEAD" || e === "OPTIONS") {
      const C = g.getAllResponseHeaders().trim().split(/[\r\n]+/), p = {};
      C.forEach(function(m) {
        const b = m.split(": "), S = b.shift();
        p[S] = b.join(": ");
      }), o.resolve(p);
      return;
    }
    if (g.status === 204)
      o.resolve(void 0);
    else if (H(l) && (!H(t) || h === t))
      o.resolve(l);
    else if (t === "json" && typeof l == "string")
      try {
        o.resolve(JSON.parse(l));
      } catch (d) {
        o.reject(d);
      }
    else
      (h === "" || h === "document") && H(g.responseXML) && g.responseXML.hasChildNodes() ? o.resolve(g.responseXML) : (h === "" || h === "text") && H(g.responseText) ? o.resolve(g.responseText) : o.reject(
        new Error("Invalid XMLHttpRequest response type.")
      );
  }, g.onerror = function(l) {
  }, g.send(i), g;
};
const Tx = {}, w5 = new B(), ha = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};
function dy(s) {
  const t = s.boundingVolume;
  let e;
  return t.obb ? e = t.obb : t.regionObb && (e = t.regionObb), e;
}
Tx.checkChildrenWithinParent = function(s) {
  const t = s.children, e = t.length, i = dy(s);
  if (i) {
    s._optimChildrenWithinParent = ha.USE_OPTIMIZATION;
    for (let n = 0; n < e; ++n) {
      const o = t[n], r = dy(o);
      if (!r) {
        s._optimChildrenWithinParent = ha.SKIP_OPTIMIZATION;
        break;
      }
      const a = w5.subVectors(
        r.center,
        i.center
      ), g = a.length();
      a.divideScalar(g);
      const c = i.halfAxes, l = Math.abs(c[0] * a.x) + Math.abs(c[1] * a.y) + Math.abs(c[2] * a.z) + Math.abs(c[3] * a.x) + Math.abs(c[4] * a.y) + Math.abs(c[5] * a.z) + Math.abs(c[6] * a.x) + Math.abs(c[7] * a.y) + Math.abs(c[8] * a.z), h = r.halfAxes, d = Math.abs(h[0] * a.x) + Math.abs(h[1] * a.y) + Math.abs(h[2] * a.z) + Math.abs(h[3] * a.x) + Math.abs(h[4] * a.y) + Math.abs(h[5] * a.z) + Math.abs(h[6] * a.x) + Math.abs(h[7] * a.y) + Math.abs(h[8] * a.z);
      if (l <= d + g) {
        s._optimChildrenWithinParent = ha.SKIP_OPTIMIZATION;
        break;
      }
    }
  }
  return s._optimChildrenWithinParent === ha.USE_OPTIMIZATION;
};
const _5 = new qe();
function x5(s, t, e, i) {
  const n = _5.set(
    s.normal.x,
    s.normal.y,
    s.normal.z,
    t.normal.x,
    t.normal.y,
    t.normal.z,
    e.normal.x,
    e.normal.y,
    e.normal.z
  );
  return i.set(-s.constant, -t.constant, -e.constant), i.applyMatrix3(n.invert()), i;
}
class v5 extends Nh {
  constructor() {
    super(), this.points = Array(8).fill().map(() => new B());
  }
  setFromProjectionMatrix(t, e) {
    super.setFromProjectionMatrix(t, e), this.calculateFrustumPoints();
  }
  calculateFrustumPoints() {
    const { planes: t, points: e } = this;
    [
      [t[0], t[3], t[4]],
      [t[1], t[3], t[4]],
      [t[0], t[2], t[4]],
      [t[1], t[2], t[4]],
      [t[0], t[3], t[5]],
      [t[1], t[3], t[5]],
      [t[0], t[2], t[5]],
      [t[1], t[2], t[5]]
    ].forEach((n, o) => {
      x5(n[0], n[1], n[2], e[o]);
    });
  }
}
function Fn(s, t) {
  this._tileset = s, this._tile = t, this.featurePropertiesDirty = !1;
}
Object.defineProperties(Fn.prototype, {
  featuresLength: {
    get: function() {
      return 0;
    }
  },
  pointsLength: {
    get: function() {
      return 0;
    }
  },
  trianglesLength: {
    get: function() {
      return 0;
    }
  },
  geometryByteLength: {
    get: function() {
      return 0;
    }
  },
  texturesByteLength: {
    get: function() {
      return 0;
    }
  },
  batchTableByteLength: {
    get: function() {
      return 0;
    }
  },
  innerContents: {
    get: function() {
    }
  },
  ready: {
    get: function() {
      return !0;
    }
  },
  tileset: {
    get: function() {
      return this._tileset;
    }
  },
  tile: {
    get: function() {
      return this._tile;
    }
  },
  url: {
    get: function() {
    }
  },
  metadata: {
    get: function() {
    },
    set: function(s) {
      throw new Error(
        "Empty3DTileContent cannot have content metadata"
      );
    }
  },
  batchTable: {
    get: function() {
    }
  },
  group: {
    get: function() {
    },
    set: function(s) {
      throw new Error("Empty3DTileContent cannot have group metadata");
    }
  }
});
Fn.prototype.hasProperty = function(s, t) {
  return !1;
};
Fn.prototype.getFeature = function(s) {
};
Fn.prototype.applyDebugSettings = function(s, t) {
};
Fn.prototype.applyStyle = function(s) {
};
Fn.prototype.update = function(s, t) {
};
Fn.prototype.pick = function(s, t, e) {
};
Fn.prototype.isDestroyed = function() {
  return !1;
};
Fn.prototype.destroy = function() {
  return ko(this);
};
const Rn = {
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  VECTOR: "vctr",
  GEOMETRY: "geom",
  GLTF: "gltf",
  GLTF_BINARY: "glb",
  IMPLICIT_SUBTREE: "subt",
  IMPLICIT_SUBTREE_JSON: "subtreeJson",
  EXTERNAL_TILESET: "externalTileset",
  MULTIPLE_CONTENT: "multipleContent",
  GEOJSON: "geoJson",
  VOXEL_BINARY: "voxl",
  VOXEL_JSON: "voxelJson"
};
Rn.isBinaryFormat = function(s) {
  switch (s) {
    case Rn.BATCHED_3D_MODEL:
    case Rn.INSTANCED_3D_MODEL:
    case Rn.COMPOSITE:
    case Rn.POINT_CLOUD:
    case Rn.VECTOR:
    case Rn.GEOMETRY:
    case Rn.IMPLICIT_SUBTREE:
    case Rn.VOXEL_BINARY:
    case Rn.GLTF_BINARY:
      return !0;
    default:
      return !1;
  }
};
const kt = Object.freeze(Rn);
class sf {
  constructor(t, e, i) {
    this.isTileset3DTileContent = !0, this._tileset = t, this._tile = e, this._resource = i, this.featurePropertiesDirty = null, this._metadata = void 0, this._group = void 0, this._ready = !1;
  }
  static fromJson(t, e, i, n) {
    const o = new sf(t, e, i);
    return o._tileset.loadTileset(o._resource, n, o._tile), o._ready = !0, o;
  }
  hasProperty(t, e) {
    return !1;
  }
  getFeature(t) {
  }
  applyDebugSettings() {
  }
  applyStyle(t) {
  }
  update(t, e) {
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return ko(this);
  }
  get featuresLength() {
    return 0;
  }
  get pointsLength() {
    return 0;
  }
  get trianglesLength() {
    return 0;
  }
  get geometryByteLength() {
    return 0;
  }
  get texturesByteLength() {
    return 0;
  }
  get batchTableByteLength() {
    return 0;
  }
  get innerContents() {
  }
  get ready() {
    return this._ready;
  }
  get tileset() {
    return this._tileset;
  }
  get tile() {
    return this._tile;
  }
  get url() {
    return this._resource.getUrlComponent(!0);
  }
  get batchTable() {
  }
  get metadata() {
    return this._metadata;
  }
  set metadata(t) {
    this._metadata = t;
  }
  get group() {
    return this._group;
  }
  set group(t) {
    this._group = t;
  }
}
const T5 = new TextDecoder();
function Lx(s) {
  return T5.decode(s);
}
function Gx(s, t, e, i, n, o) {
  let r;
  switch (i) {
    case "SCALAR":
      r = 1;
      break;
    case "VEC2":
      r = 2;
      break;
    case "VEC3":
      r = 3;
      break;
    case "VEC4":
      r = 4;
      break;
    default:
      throw new Error(`FeatureTable : Feature type not provided for "${o}".`);
  }
  let a;
  const g = e * r;
  switch (n) {
    case "BYTE":
      a = new Int8Array(s, t, g);
      break;
    case "UNSIGNED_BYTE":
      a = new Uint8Array(s, t, g);
      break;
    case "SHORT":
      a = new Int16Array(s, t, g);
      break;
    case "UNSIGNED_SHORT":
      a = new Uint16Array(s, t, g);
      break;
    case "INT":
      a = new Int32Array(s, t, g);
      break;
    case "UNSIGNED_INT":
      a = new Uint32Array(s, t, g);
      break;
    case "FLOAT":
      a = new Float32Array(s, t, g);
      break;
    case "DOUBLE":
      a = new Float64Array(s, t, g);
      break;
    default:
      throw new Error(`FeatureTable : Feature component type not provided for "${o}".`);
  }
  return a;
}
class rd {
  constructor(t, e, i, n) {
    this.buffer = t, this.binOffset = e + i, this.binLength = n;
    let o = null;
    if (i !== 0) {
      const r = new Uint8Array(t, e, i);
      o = JSON.parse(Lx(r));
    } else
      o = {};
    this.header = o;
  }
  getKeys() {
    return Object.keys(this.header);
  }
  getData(t, e, i = null, n = null) {
    const o = this.header;
    if (!(t in o))
      return null;
    const r = o[t];
    if (r instanceof Object) {
      if (Array.isArray(r))
        return r;
    } else
      return r;
    const { buffer: a, binOffset: g, binLength: c } = this, l = r.byteOffset || 0, h = r.type || n, d = r.componentType || i;
    if ("type" in r && n && r.type !== n)
      throw new Error("FeatureTable: Specified type does not match expected type.");
    const C = g + l, p = Gx(a, C, e, h, d, t);
    if (C + p.byteLength > g + c)
      throw new Error("FeatureTable: Feature data read outside binary body length.");
    return p;
  }
  getBuffer(t, e) {
    const { buffer: i, binOffset: n } = this;
    return i.slice(n + t, n + t + e);
  }
}
class L5 {
  constructor(t) {
    var n;
    this.batchTable = t;
    const e = t.header.extensions["3DTILES_batch_table_hierarchy"];
    this.classes = e.classes;
    for (const o of this.classes) {
      const r = o.instances;
      for (const a in r)
        r.hasOwnProperty(a) && (o.instances[a] = this._parseProperty(r[a], o.length, a));
    }
    if (this.instancesLength = e.instancesLength, this.classIds = this._parseProperty(e.classIds, this.instancesLength, "classIds"), e.parentCounts ? this.parentCounts = this._parseProperty(e.parentCounts, this.instancesLength, "parentCounts") : this.parentCounts = new Array(this.instancesLength).fill(1), e.parentIds) {
      const o = this.parentCounts.reduce((r, a) => r + a, 0);
      this.parentIds = this._parseProperty(e.parentIds, o, "parentIds");
    } else
      this.parentIds = null;
    this.instancesIds = [];
    const i = {};
    for (const o of this.classIds)
      i[o] = (n = i[o]) != null ? n : 0, this.instancesIds.push(i[o]), i[o]++;
  }
  _parseProperty(t, e, i) {
    if (Array.isArray(t))
      return t;
    const { buffer: n, binOffset: o } = this.batchTable, r = t.byteOffset, a = t.componentType || "UNSIGNED_SHORT", g = o + r;
    return Gx(n, g, e, "SCALAR", a, i);
  }
  getDataFromId(t, e = {}) {
    const i = this.parentCounts[t];
    if (this.parentIds && i > 0) {
      let g = 0;
      for (let c = 0; c < t; c++)
        g += this.parentCounts[c];
      for (let c = 0; c < i; c++) {
        const l = this.parentIds[g + c];
        l !== t && this.getDataFromId(l, e);
      }
    }
    const n = this.classIds[t], o = this.classes[n].instances, r = this.classes[n].name, a = this.instancesIds[t];
    for (const g in o)
      o.hasOwnProperty(g) && (e[r] = e[r] || {}, e[r][g] = o[g][a]);
    return e;
  }
}
class of extends rd {
  constructor(t, e, i, n, o) {
    super(t, i, n, o), this.batchSize = e, this.extensions = {};
    const r = this.header.extensions;
    r && r["3DTILES_batch_table_hierarchy"] && (this.extensions["3DTILES_batch_table_hierarchy"] = new L5(this));
  }
  getData(t, e = null, i = null) {
    return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId instead."), super.getData(t, this.batchSize, e, i);
  }
  getDataFromId(t, e = {}) {
    if (t < 0 || t >= this.batchSize)
      throw new Error(`BatchTable: id value "${t}" out of bounds for "${this.batchSize}" features number.`);
    for (const i of this.getKeys())
      i !== "extensions" && (e[i] = super.getData(i, this.batchSize)[t]);
    for (const i in this.extensions)
      if (this.extensions.hasOwnProperty(i)) {
        const n = this.extensions[i];
        n.getDataFromId instanceof Function && (e[i] = e[i] || {}, n.getDataFromId(t, e[i]));
      }
    return e;
  }
}
class ic {
  constructor() {
    this.fetchOptions = {}, this.workingPath = "";
  }
  load(t) {
    return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'), this.loadAsync(t);
  }
  loadAsync(t) {
    return fetch(t, this.fetchOptions).then((e) => {
      if (!e.ok)
        throw new Error(`Failed to load file "${t}" with status ${e.status} : ${e.statusText}`);
      return e.arrayBuffer();
    }).then((e) => (this.workingPath === "" && (this.workingPath = this.workingPathForURL(t)), this.parse(e)));
  }
  resolveExternalURL(t) {
    return /^[^\\/]/.test(t) ? this.workingPath + "/" + t : t;
  }
  workingPathForURL(t) {
    const e = t.split(/[\\/]/g);
    return e.pop(), e.join("/") + "/";
  }
  parse(t) {
    throw new Error("LoaderBase: Parse not implemented.");
  }
}
class G5 extends ic {
  parse(t) {
    const e = new DataView(t), i = e.getUint32(4, !0);
    console.assert(i === 1);
    const n = e.getUint32(8, !0);
    console.assert(n === t.byteLength);
    const o = e.getUint32(12, !0), r = e.getUint32(16, !0), a = e.getUint32(20, !0), g = e.getUint32(24, !0), c = 28, l = t.slice(
      c,
      c + o + r
    ), h = new rd(
      l,
      0,
      o,
      r
    ), d = c + o + r, C = t.slice(
      d,
      d + a + g
    ), p = new of(
      C,
      h.getData("BATCH_LENGTH"),
      0,
      a,
      g
    ), m = d + a + g, b = new Uint8Array(t, m, n - m);
    return {
      version: i,
      featureTable: h,
      batchTable: p,
      glbBytes: b
    };
  }
}
class rf extends Fh {
  constructor(t) {
    super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e) {
      return new K5(e);
    }), this.register(function(e) {
      return new X5(e);
    }), this.register(function(e) {
      return new W5(e);
    }), this.register(function(e) {
      return new Z5(e);
    }), this.register(function(e) {
      return new P5(e);
    }), this.register(function(e) {
      return new N5(e);
    }), this.register(function(e) {
      return new F5(e);
    }), this.register(function(e) {
      return new k5(e);
    }), this.register(function(e) {
      return new D5(e);
    }), this.register(function(e) {
      return new V5(e);
    }), this.register(function(e) {
      return new H5(e);
    }), this.register(function(e) {
      return new z5(e);
    }), this.register(function(e) {
      return new E5(e);
    }), this.register(function(e) {
      return new U5(e);
    }), this.register(function(e) {
      return new O5(e);
    });
  }
  load(t, e, i, n) {
    const o = this;
    let r;
    this.resourcePath !== "" ? r = this.resourcePath : this.path !== "" ? r = this.path : r = ma.extractUrlBase(t), this.manager.itemStart(t);
    const a = function(c) {
      n ? n(c) : console.error(c), o.manager.itemError(t), o.manager.itemEnd(t);
    }, g = new rs(this.manager);
    g.setPath(this.path), g.setResponseType("arraybuffer"), g.setRequestHeader(this.requestHeader), g.setWithCredentials(this.withCredentials), g.load(t, function(c) {
      try {
        o.parse(c, r, function(l) {
          e(l), o.manager.itemEnd(t);
        }, a);
      } catch (l) {
        a(l);
      }
    }, i, a);
  }
  setDRACOLoader(t) {
    return this.dracoLoader = t, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(t) {
    return this.ktx2Loader = t, this;
  }
  setMeshoptDecoder(t) {
    return this.meshoptDecoder = t, this;
  }
  register(t) {
    return this.pluginCallbacks.indexOf(t) === -1 && this.pluginCallbacks.push(t), this;
  }
  unregister(t) {
    return this.pluginCallbacks.indexOf(t) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
  }
  parse(t, e, i, n) {
    let o;
    const r = {}, a = {}, g = new TextDecoder();
    if (typeof t == "string")
      o = JSON.parse(t);
    else if (t instanceof ArrayBuffer)
      if (g.decode(new Uint8Array(t, 0, 4)) === Mx) {
        try {
          r[tt.KHR_BINARY_GLTF] = new Q5(t);
        } catch (h) {
          n && n(h);
          return;
        }
        o = JSON.parse(r[tt.KHR_BINARY_GLTF].content);
      } else
        o = JSON.parse(g.decode(t));
    else
      o = t;
    if (o.asset === void 0 || o.asset.version[0] < 2) {
      n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new aW(o, {
      path: e || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let l = 0; l < this.pluginCallbacks.length; l++) {
      const h = this.pluginCallbacks[l](c);
      h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[h.name] = h, r[h.name] = !0;
    }
    if (o.extensionsUsed)
      for (let l = 0; l < o.extensionsUsed.length; ++l) {
        const h = o.extensionsUsed[l], d = o.extensionsRequired || [];
        switch (h) {
          case tt.KHR_MATERIALS_UNLIT:
            r[h] = new R5();
            break;
          case tt.KHR_DRACO_MESH_COMPRESSION:
            r[h] = new Y5(o, this.dracoLoader);
            break;
          case tt.KHR_TEXTURE_TRANSFORM:
            r[h] = new j5();
            break;
          case tt.KHR_MESH_QUANTIZATION:
            r[h] = new J5();
            break;
          default:
            d.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    c.setExtensions(r), c.setPlugins(a), c.parse(i, n);
  }
  parseAsync(t, e) {
    const i = this;
    return new Promise(function(n, o) {
      i.parse(t, e, n, o);
    });
  }
}
function M5() {
  let s = {};
  return {
    get: function(t) {
      return s[t];
    },
    add: function(t, e) {
      s[t] = e;
    },
    remove: function(t) {
      delete s[t];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const tt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class E5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const t = this.parser, e = this.parser.json.nodes || [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      o.extensions && o.extensions[this.name] && o.extensions[this.name].light !== void 0 && t._addNodeRef(this.cache, o.extensions[this.name].light);
    }
  }
  _loadLight(t) {
    const e = this.parser, i = "light:" + t;
    let n = e.cache.get(i);
    if (n)
      return n;
    const o = e.json, g = ((o.extensions && o.extensions[this.name] || {}).lights || [])[t];
    let c;
    const l = new Ce(16777215);
    g.color !== void 0 && l.setRGB(g.color[0], g.color[1], g.color[2], Vi);
    const h = g.range !== void 0 ? g.range : 0;
    switch (g.type) {
      case "directional":
        c = new Ph(l), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new Ib(l), c.distance = h;
        break;
      case "spot":
        c = new ub(l), c.distance = h, g.spot = g.spot || {}, g.spot.innerConeAngle = g.spot.innerConeAngle !== void 0 ? g.spot.innerConeAngle : 0, g.spot.outerConeAngle = g.spot.outerConeAngle !== void 0 ? g.spot.outerConeAngle : Math.PI / 4, c.angle = g.spot.outerConeAngle, c.penumbra = 1 - g.spot.innerConeAngle / g.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + g.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, So(c, g), g.intensity !== void 0 && (c.intensity = g.intensity), c.name = e.createUniqueName(g.name || "light_" + t), n = Promise.resolve(c), e.cache.add(i, n), n;
  }
  getDependency(t, e) {
    if (t === "light")
      return this._loadLight(e);
  }
  createNodeAttachment(t) {
    const e = this, i = this.parser, o = i.json.nodes[t], a = (o.extensions && o.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(g) {
      return i._getNodeRef(e.cache, a, g);
    });
  }
}
class R5 {
  constructor() {
    this.name = tt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return _t;
  }
  extendParams(t, e, i) {
    const n = [];
    t.color = new Ce(1, 1, 1), t.opacity = 1;
    const o = e.pbrMetallicRoughness;
    if (o) {
      if (Array.isArray(o.baseColorFactor)) {
        const r = o.baseColorFactor;
        t.color.setRGB(r[0], r[1], r[2], Vi), t.opacity = r[3];
      }
      o.baseColorTexture !== void 0 && n.push(i.assignTexture(t, "map", o.baseColorTexture, gt));
    }
    return Promise.all(n);
  }
}
class D5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = n.extensions[this.name].emissiveStrength;
    return o !== void 0 && (e.emissiveIntensity = o), Promise.resolve();
  }
}
class K5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (e.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && o.push(i.assignTexture(e, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (e.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && o.push(i.assignTexture(e, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (o.push(i.assignTexture(e, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const a = r.clearcoatNormalTexture.scale;
      e.clearcoatNormalScale = new Z(a, a);
    }
    return Promise.all(o);
  }
}
class H5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (e.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && o.push(i.assignTexture(e, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (e.iridescenceIOR = r.iridescenceIor), e.iridescenceThicknessRange === void 0 && (e.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (e.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (e.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && o.push(i.assignTexture(e, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(o);
  }
}
class P5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [];
    e.sheenColor = new Ce(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
    const r = n.extensions[this.name];
    if (r.sheenColorFactor !== void 0) {
      const a = r.sheenColorFactor;
      e.sheenColor.setRGB(a[0], a[1], a[2], Vi);
    }
    return r.sheenRoughnessFactor !== void 0 && (e.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && o.push(i.assignTexture(e, "sheenColorMap", r.sheenColorTexture, gt)), r.sheenRoughnessTexture !== void 0 && o.push(i.assignTexture(e, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(o);
  }
}
class N5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    return r.transmissionFactor !== void 0 && (e.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && o.push(i.assignTexture(e, "transmissionMap", r.transmissionTexture)), Promise.all(o);
  }
}
class F5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    e.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && o.push(i.assignTexture(e, "thicknessMap", r.thicknessTexture)), e.attenuationDistance = r.attenuationDistance || 1 / 0;
    const a = r.attenuationColor || [1, 1, 1];
    return e.attenuationColor = new Ce().setRGB(a[0], a[1], a[2], Vi), Promise.all(o);
  }
}
class k5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_IOR;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const n = this.parser.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = n.extensions[this.name];
    return e.ior = o.ior !== void 0 ? o.ior : 1.5, Promise.resolve();
  }
}
class V5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    e.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && o.push(i.assignTexture(e, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return e.specularColor = new Ce().setRGB(a[0], a[1], a[2], Vi), r.specularColorTexture !== void 0 && o.push(i.assignTexture(e, "specularColorMap", r.specularColorTexture, gt)), Promise.all(o);
  }
}
class z5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(t) {
    const i = this.parser.json.materials[t];
    return !i.extensions || !i.extensions[this.name] ? null : Ti;
  }
  extendMaterialParams(t, e) {
    const i = this.parser, n = i.json.materials[t];
    if (!n.extensions || !n.extensions[this.name])
      return Promise.resolve();
    const o = [], r = n.extensions[this.name];
    return r.anisotropyStrength !== void 0 && (e.anisotropy = r.anisotropyStrength), r.anisotropyRotation !== void 0 && (e.anisotropyRotation = r.anisotropyRotation), r.anisotropyTexture !== void 0 && o.push(i.assignTexture(e, "anisotropyMap", r.anisotropyTexture)), Promise.all(o);
  }
}
class X5 {
  constructor(t) {
    this.parser = t, this.name = tt.KHR_TEXTURE_BASISU;
  }
  loadTexture(t) {
    const e = this.parser, i = e.json, n = i.textures[t];
    if (!n.extensions || !n.extensions[this.name])
      return null;
    const o = n.extensions[this.name], r = e.options.ktx2Loader;
    if (!r) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return e.loadTextureImage(t, o.source, r);
  }
}
class W5 {
  constructor(t) {
    this.parser = t, this.name = tt.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(t) {
    const e = this.name, i = this.parser, n = i.json, o = n.textures[t];
    if (!o.extensions || !o.extensions[e])
      return null;
    const r = o.extensions[e], a = n.images[r.source];
    let g = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (g = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return i.loadTextureImage(t, r.source, g);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return i.loadTexture(t);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t) {
      const e = new Image();
      e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e.onload = e.onerror = function() {
        t(e.height === 1);
      };
    })), this.isSupported;
  }
}
class Z5 {
  constructor(t) {
    this.parser = t, this.name = tt.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(t) {
    const e = this.name, i = this.parser, n = i.json, o = n.textures[t];
    if (!o.extensions || !o.extensions[e])
      return null;
    const r = o.extensions[e], a = n.images[r.source];
    let g = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (g = c);
    }
    return this.detectSupport().then(function(c) {
      if (c)
        return i.loadTextureImage(t, r.source, g);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return i.loadTexture(t);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(t) {
      const e = new Image();
      e.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", e.onload = e.onerror = function() {
        t(e.height === 1);
      };
    })), this.isSupported;
  }
}
class U5 {
  constructor(t) {
    this.name = tt.EXT_MESHOPT_COMPRESSION, this.parser = t;
  }
  loadBufferView(t) {
    const e = this.parser.json, i = e.bufferViews[t];
    if (i.extensions && i.extensions[this.name]) {
      const n = i.extensions[this.name], o = this.parser.getDependency("buffer", n.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return o.then(function(a) {
        const g = n.byteOffset || 0, c = n.byteLength || 0, l = n.count, h = n.byteStride, d = new Uint8Array(a, g, c);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(l, h, d, n.mode, n.filter).then(function(C) {
          return C.buffer;
        }) : r.ready.then(function() {
          const C = new ArrayBuffer(l * h);
          return r.decodeGltfBuffer(new Uint8Array(C), l, h, d, n.mode, n.filter), C;
        });
      });
    } else
      return null;
  }
}
class O5 {
  constructor(t) {
    this.name = tt.EXT_MESH_GPU_INSTANCING, this.parser = t;
  }
  createNodeMesh(t) {
    const e = this.parser.json, i = e.nodes[t];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const n = e.meshes[i.mesh];
    for (const c of n.primitives)
      if (c.mode !== pn.TRIANGLES && c.mode !== pn.TRIANGLE_STRIP && c.mode !== pn.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const r = i.extensions[this.name].attributes, a = [], g = {};
    for (const c in r)
      a.push(this.parser.getDependency("accessor", r[c]).then((l) => (g[c] = l, g[c])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(t)), Promise.all(a).then((c) => {
      const l = c.pop(), h = l.isGroup ? l.children : [l], d = c[0].count, C = [];
      for (const p of h) {
        const m = new J(), b = new B(), S = new Ye(), A = new B(1, 1, 1), u = new kh(p.geometry, p.material, d);
        for (let y = 0; y < d; y++)
          g.TRANSLATION && b.fromBufferAttribute(g.TRANSLATION, y), g.ROTATION && S.fromBufferAttribute(g.ROTATION, y), g.SCALE && A.fromBufferAttribute(g.SCALE, y), u.setMatrixAt(y, m.compose(b, S, A));
        for (const y in g)
          if (y === "_COLOR_0") {
            const I = g[y];
            u.instanceColor = new Ni(I.array, I.itemSize, I.normalized);
          } else
            y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && p.geometry.setAttribute(y, g[y]);
        Wt.prototype.copy.call(u, p), this.parser.assignFinalMaterial(u), C.push(u);
      }
      return l.isGroup ? (l.clear(), l.add(...C), l) : C[0];
    }));
  }
}
const Mx = "glTF", rg = 12, uy = { JSON: 1313821514, BIN: 5130562 };
class Q5 {
  constructor(t) {
    this.name = tt.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const e = new DataView(t, 0, rg), i = new TextDecoder();
    if (this.header = {
      magic: i.decode(new Uint8Array(t.slice(0, 4))),
      version: e.getUint32(4, !0),
      length: e.getUint32(8, !0)
    }, this.header.magic !== Mx)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - rg, o = new DataView(t, rg);
    let r = 0;
    for (; r < n; ) {
      const a = o.getUint32(r, !0);
      r += 4;
      const g = o.getUint32(r, !0);
      if (r += 4, g === uy.JSON) {
        const c = new Uint8Array(t, rg + r, a);
        this.content = i.decode(c);
      } else if (g === uy.BIN) {
        const c = rg + r;
        this.body = t.slice(c, c + a);
      }
      r += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Y5 {
  constructor(t, e) {
    if (!e)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = tt.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload();
  }
  decodePrimitive(t, e) {
    const i = this.json, n = this.dracoLoader, o = t.extensions[this.name].bufferView, r = t.extensions[this.name].attributes, a = {}, g = {}, c = {};
    for (const l in r) {
      const h = BA[l] || l.toLowerCase();
      a[h] = r[l];
    }
    for (const l in t.attributes) {
      const h = BA[l] || l.toLowerCase();
      if (r[l] !== void 0) {
        const d = i.accessors[t.attributes[l]], C = Ca[d.componentType];
        c[h] = C.name, g[h] = d.normalized === !0;
      }
    }
    return e.getDependency("bufferView", o).then(function(l) {
      return new Promise(function(h) {
        n.decodeDracoFile(l, function(d) {
          for (const C in d.attributes) {
            const p = d.attributes[C], m = g[C];
            m !== void 0 && (p.normalized = m);
          }
          h(d);
        }, a, c);
      });
    });
  }
}
class j5 {
  constructor() {
    this.name = tt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(t, e) {
    return (e.texCoord === void 0 || e.texCoord === t.channel) && e.offset === void 0 && e.rotation === void 0 && e.scale === void 0 || (t = t.clone(), e.texCoord !== void 0 && (t.channel = e.texCoord), e.offset !== void 0 && t.offset.fromArray(e.offset), e.rotation !== void 0 && (t.rotation = e.rotation), e.scale !== void 0 && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t;
  }
}
class J5 {
  constructor() {
    this.name = tt.KHR_MESH_QUANTIZATION;
  }
}
class Ex extends Tb {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
  copySampleValue_(t) {
    const e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, o = t * n * 3 + n;
    for (let r = 0; r !== n; r++)
      e[r] = i[o + r];
    return e;
  }
  interpolate_(t, e, i, n) {
    const o = this.resultBuffer, r = this.sampleValues, a = this.valueSize, g = a * 2, c = a * 3, l = n - e, h = (i - e) / l, d = h * h, C = d * h, p = t * c, m = p - c, b = -2 * C + 3 * d, S = C - d, A = 1 - b, u = S - d + h;
    for (let y = 0; y !== a; y++) {
      const I = r[m + y + a], M = r[m + y + g] * l, G = r[p + y + a], x = r[p + y] * l;
      o[y] = A * I + u * M + b * G + S * x;
    }
    return o;
  }
}
const q5 = new Ye();
class $5 extends Ex {
  interpolate_(t, e, i, n) {
    const o = super.interpolate_(t, e, i, n);
    return q5.fromArray(o).normalize().toArray(o), o;
  }
}
const pn = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Ca = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Iy = {
  9728: cs,
  9729: Gt,
  9984: bb,
  9985: Bb,
  9986: wb,
  9987: wr
}, Ay = {
  33071: hs,
  33648: _b,
  10497: ii
}, rI = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, BA = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, go = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, eW = {
  CUBICSPLINE: void 0,
  LINEAR: zh,
  STEP: xb
}, aI = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function tW(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Vh({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: vb
  })), s.DefaultMaterial;
}
function tr(s, t, e) {
  for (const i in e.extensions)
    s[i] === void 0 && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = e.extensions[i]);
}
function So(s, t) {
  t.extras !== void 0 && (typeof t.extras == "object" ? Object.assign(s.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras));
}
function iW(s, t, e) {
  let i = !1, n = !1, o = !1;
  for (let c = 0, l = t.length; c < l; c++) {
    const h = t[c];
    if (h.POSITION !== void 0 && (i = !0), h.NORMAL !== void 0 && (n = !0), h.COLOR_0 !== void 0 && (o = !0), i && n && o)
      break;
  }
  if (!i && !n && !o)
    return Promise.resolve(s);
  const r = [], a = [], g = [];
  for (let c = 0, l = t.length; c < l; c++) {
    const h = t[c];
    if (i) {
      const d = h.POSITION !== void 0 ? e.getDependency("accessor", h.POSITION) : s.attributes.position;
      r.push(d);
    }
    if (n) {
      const d = h.NORMAL !== void 0 ? e.getDependency("accessor", h.NORMAL) : s.attributes.normal;
      a.push(d);
    }
    if (o) {
      const d = h.COLOR_0 !== void 0 ? e.getDependency("accessor", h.COLOR_0) : s.attributes.color;
      g.push(d);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(a),
    Promise.all(g)
  ]).then(function(c) {
    const l = c[0], h = c[1], d = c[2];
    return i && (s.morphAttributes.position = l), n && (s.morphAttributes.normal = h), o && (s.morphAttributes.color = d), s.morphTargetsRelative = !0, s;
  });
}
function nW(s, t) {
  if (s.updateMorphTargets(), t.weights !== void 0)
    for (let e = 0, i = t.weights.length; e < i; e++)
      s.morphTargetInfluences[e] = t.weights[e];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const e = t.extras.targetNames;
    if (s.morphTargetInfluences.length === e.length) {
      s.morphTargetDictionary = {};
      for (let i = 0, n = e.length; i < n; i++)
        s.morphTargetDictionary[e[i]] = i;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function sW(s) {
  let t;
  const e = s.extensions && s.extensions[tt.KHR_DRACO_MESH_COMPRESSION];
  if (e ? t = "draco:" + e.bufferView + ":" + e.indices + ":" + gI(e.attributes) : t = s.indices + ":" + gI(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let i = 0, n = s.targets.length; i < n; i++)
      t += ":" + gI(s.targets[i]);
  return t;
}
function gI(s) {
  let t = "";
  const e = Object.keys(s).sort();
  for (let i = 0, n = e.length; i < n; i++)
    t += e[i] + ":" + s[e[i]] + ";";
  return t;
}
function wA(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function oW(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const rW = new J();
class aW {
  constructor(t = {}, e = {}) {
    this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new M5(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let i = !1, n = !1, o = -1;
    typeof navigator < "u" && (i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, n = navigator.userAgent.indexOf("Firefox") > -1, o = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || i || n && o < 98 ? this.textureLoader = new Ot(this.options.manager) : this.textureLoader = new Ab(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new rs(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(t) {
    this.extensions = t;
  }
  setPlugins(t) {
    this.plugins = t;
  }
  parse(t, e) {
    const i = this, n = this.json, o = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(this._invokeAll(function(r) {
      return r.beforeRoot && r.beforeRoot();
    })).then(function() {
      return Promise.all([
        i.getDependencies("scene"),
        i.getDependencies("animation"),
        i.getDependencies("camera")
      ]);
    }).then(function(r) {
      const a = {
        scene: r[0][n.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: n.asset,
        parser: i,
        userData: {}
      };
      return tr(o, a, n), So(a, n), Promise.all(i._invokeAll(function(g) {
        return g.afterRoot && g.afterRoot(a);
      })).then(function() {
        t(a);
      });
    }).catch(e);
  }
  _markDefs() {
    const t = this.json.nodes || [], e = this.json.skins || [], i = this.json.meshes || [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n].joints;
      for (let a = 0, g = r.length; a < g; a++)
        t[r[a]].isBone = !0;
    }
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (i[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  _addNodeRef(t, e) {
    e !== void 0 && (t.refs[e] === void 0 && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
  }
  _getNodeRef(t, e, i) {
    if (t.refs[e] <= 1)
      return i;
    const n = i.clone(), o = (r, a) => {
      const g = this.associations.get(r);
      g != null && this.associations.set(a, g);
      for (const [c, l] of r.children.entries())
        o(l, a.children[c]);
    };
    return o(i, n), n.name += "_instance_" + t.uses[e]++, n;
  }
  _invokeOne(t) {
    const e = Object.values(this.plugins);
    e.push(this);
    for (let i = 0; i < e.length; i++) {
      const n = t(e[i]);
      if (n)
        return n;
    }
    return null;
  }
  _invokeAll(t) {
    const e = Object.values(this.plugins);
    e.unshift(this);
    const i = [];
    for (let n = 0; n < e.length; n++) {
      const o = t(e[n]);
      o && i.push(o);
    }
    return i;
  }
  getDependency(t, e) {
    const i = t + ":" + e;
    let n = this.cache.get(i);
    if (!n) {
      switch (t) {
        case "scene":
          n = this.loadScene(e);
          break;
        case "node":
          n = this._invokeOne(function(o) {
            return o.loadNode && o.loadNode(e);
          });
          break;
        case "mesh":
          n = this._invokeOne(function(o) {
            return o.loadMesh && o.loadMesh(e);
          });
          break;
        case "accessor":
          n = this.loadAccessor(e);
          break;
        case "bufferView":
          n = this._invokeOne(function(o) {
            return o.loadBufferView && o.loadBufferView(e);
          });
          break;
        case "buffer":
          n = this.loadBuffer(e);
          break;
        case "material":
          n = this._invokeOne(function(o) {
            return o.loadMaterial && o.loadMaterial(e);
          });
          break;
        case "texture":
          n = this._invokeOne(function(o) {
            return o.loadTexture && o.loadTexture(e);
          });
          break;
        case "skin":
          n = this.loadSkin(e);
          break;
        case "animation":
          n = this._invokeOne(function(o) {
            return o.loadAnimation && o.loadAnimation(e);
          });
          break;
        case "camera":
          n = this.loadCamera(e);
          break;
        default:
          if (n = this._invokeOne(function(o) {
            return o != this && o.getDependency && o.getDependency(t, e);
          }), !n)
            throw new Error("Unknown type: " + t);
          break;
      }
      this.cache.add(i, n);
    }
    return n;
  }
  getDependencies(t) {
    let e = this.cache.get(t);
    if (!e) {
      const i = this, n = this.json[t + (t === "mesh" ? "es" : "s")] || [];
      e = Promise.all(n.map(function(o, r) {
        return i.getDependency(t, r);
      })), this.cache.add(t, e);
    }
    return e;
  }
  loadBuffer(t) {
    const e = this.json.buffers[t], i = this.fileLoader;
    if (e.type && e.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
    if (e.uri === void 0 && t === 0)
      return Promise.resolve(this.extensions[tt.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function(o, r) {
      i.load(ma.resolveURL(e.uri, n.path), o, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
      });
    });
  }
  loadBufferView(t) {
    const e = this.json.bufferViews[t];
    return this.getDependency("buffer", e.buffer).then(function(i) {
      const n = e.byteLength || 0, o = e.byteOffset || 0;
      return i.slice(o, o + n);
    });
  }
  loadAccessor(t) {
    const e = this, i = this.json, n = this.json.accessors[t];
    if (n.bufferView === void 0 && n.sparse === void 0) {
      const r = rI[n.type], a = Ca[n.componentType], g = n.normalized === !0, c = new a(n.count * r);
      return Promise.resolve(new Fe(c, r, g));
    }
    const o = [];
    return n.bufferView !== void 0 ? o.push(this.getDependency("bufferView", n.bufferView)) : o.push(null), n.sparse !== void 0 && (o.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), o.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(o).then(function(r) {
      const a = r[0], g = rI[n.type], c = Ca[n.componentType], l = c.BYTES_PER_ELEMENT, h = l * g, d = n.byteOffset || 0, C = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === !0;
      let m, b;
      if (C && C !== h) {
        const S = Math.floor(d / C), A = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + S + ":" + n.count;
        let u = e.cache.get(A);
        u || (m = new c(a, S * C, n.count * C / l), u = new Ai(m, C / l), e.cache.add(A, u)), b = new ve(u, g, d % C / l, p);
      } else
        a === null ? m = new c(n.count * g) : m = new c(a, d, n.count * g), b = new Fe(m, g, p);
      if (n.sparse !== void 0) {
        const S = rI.SCALAR, A = Ca[n.sparse.indices.componentType], u = n.sparse.indices.byteOffset || 0, y = n.sparse.values.byteOffset || 0, I = new A(r[1], u, n.sparse.count * S), M = new c(r[2], y, n.sparse.count * g);
        a !== null && (b = new Fe(b.array.slice(), b.itemSize, b.normalized));
        for (let G = 0, x = I.length; G < x; G++) {
          const L = I[G];
          if (b.setX(L, M[G * g]), g >= 2 && b.setY(L, M[G * g + 1]), g >= 3 && b.setZ(L, M[G * g + 2]), g >= 4 && b.setW(L, M[G * g + 3]), g >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return b;
    });
  }
  loadTexture(t) {
    const e = this.json, i = this.options, o = e.textures[t].source, r = e.images[o];
    let a = this.textureLoader;
    if (r.uri) {
      const g = i.manager.getHandler(r.uri);
      g !== null && (a = g);
    }
    return this.loadTextureImage(t, o, a);
  }
  loadTextureImage(t, e, i) {
    const n = this, o = this.json, r = o.textures[t], a = o.images[e], g = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[g])
      return this.textureCache[g];
    const c = this.loadImageSource(e, i).then(function(l) {
      l.flipY = !1, l.name = r.name || a.name || "", l.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (l.name = a.uri);
      const d = (o.samplers || {})[r.sampler] || {};
      return l.magFilter = Iy[d.magFilter] || Gt, l.minFilter = Iy[d.minFilter] || wr, l.wrapS = Ay[d.wrapS] || ii, l.wrapT = Ay[d.wrapT] || ii, n.associations.set(l, { textures: t }), l;
    }).catch(function() {
      return null;
    });
    return this.textureCache[g] = c, c;
  }
  loadImageSource(t, e) {
    const i = this, n = this.json, o = this.options;
    if (this.sourceCache[t] !== void 0)
      return this.sourceCache[t].then((h) => h.clone());
    const r = n.images[t], a = self.URL || self.webkitURL;
    let g = r.uri || "", c = !1;
    if (r.bufferView !== void 0)
      g = i.getDependency("bufferView", r.bufferView).then(function(h) {
        c = !0;
        const d = new Blob([h], { type: r.mimeType });
        return g = a.createObjectURL(d), g;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
    const l = Promise.resolve(g).then(function(h) {
      return new Promise(function(d, C) {
        let p = d;
        e.isImageBitmapLoader === !0 && (p = function(m) {
          const b = new pa(m);
          b.needsUpdate = !0, d(b);
        }), e.load(ma.resolveURL(h, o.path), p, void 0, C);
      });
    }).then(function(h) {
      return c === !0 && a.revokeObjectURL(g), h.userData.mimeType = r.mimeType || oW(r.uri), h;
    }).catch(function(h) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", g), h;
    });
    return this.sourceCache[t] = l, l;
  }
  assignTexture(t, e, i, n) {
    const o = this;
    return this.getDependency("texture", i.index).then(function(r) {
      if (!r)
        return null;
      if (i.texCoord !== void 0 && i.texCoord > 0 && (r = r.clone(), r.channel = i.texCoord), o.extensions[tt.KHR_TEXTURE_TRANSFORM]) {
        const a = i.extensions !== void 0 ? i.extensions[tt.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const g = o.associations.get(r);
          r = o.extensions[tt.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), o.associations.set(r, g);
        }
      }
      return n !== void 0 && (r.colorSpace = n), t[e] = r, r;
    });
  }
  assignFinalMaterial(t) {
    const e = t.geometry;
    let i = t.material;
    const n = e.attributes.tangent === void 0, o = e.attributes.color !== void 0, r = e.attributes.normal === void 0;
    if (t.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let g = this.cache.get(a);
      g || (g = new ZA(), ks.prototype.copy.call(g, i), g.color.copy(i.color), g.map = i.map, g.sizeAttenuation = !1, this.cache.add(a, g)), i = g;
    } else if (t.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let g = this.cache.get(a);
      g || (g = new _r(), ks.prototype.copy.call(g, i), g.color.copy(i.color), g.map = i.map, this.cache.add(a, g)), i = g;
    }
    if (n || o || r) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      n && (a += "derivative-tangents:"), o && (a += "vertex-colors:"), r && (a += "flat-shading:");
      let g = this.cache.get(a);
      g || (g = i.clone(), o && (g.vertexColors = !0), r && (g.flatShading = !0), n && (g.normalScale && (g.normalScale.y *= -1), g.clearcoatNormalScale && (g.clearcoatNormalScale.y *= -1)), this.cache.add(a, g), this.associations.set(g, this.associations.get(i))), i = g;
    }
    t.material = i;
  }
  getMaterialType() {
    return Vh;
  }
  loadMaterial(t) {
    const e = this, i = this.json, n = this.extensions, o = i.materials[t];
    let r;
    const a = {}, g = o.extensions || {}, c = [];
    if (g[tt.KHR_MATERIALS_UNLIT]) {
      const h = n[tt.KHR_MATERIALS_UNLIT];
      r = h.getMaterialType(), c.push(h.extendParams(a, o, e));
    } else {
      const h = o.pbrMetallicRoughness || {};
      if (a.color = new Ce(1, 1, 1), a.opacity = 1, Array.isArray(h.baseColorFactor)) {
        const d = h.baseColorFactor;
        a.color.setRGB(d[0], d[1], d[2], Vi), a.opacity = d[3];
      }
      h.baseColorTexture !== void 0 && c.push(e.assignTexture(a, "map", h.baseColorTexture, gt)), a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(e.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture)), c.push(e.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture))), r = this._invokeOne(function(d) {
        return d.getMaterialType && d.getMaterialType(t);
      }), c.push(Promise.all(this._invokeAll(function(d) {
        return d.extendMaterialParams && d.extendMaterialParams(t, a);
      })));
    }
    o.doubleSided === !0 && (a.side = xr);
    const l = o.alphaMode || aI.OPAQUE;
    if (l === aI.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, l === aI.MASK && (a.alphaTest = o.alphaCutoff !== void 0 ? o.alphaCutoff : 0.5)), o.normalTexture !== void 0 && r !== _t && (c.push(e.assignTexture(a, "normalMap", o.normalTexture)), a.normalScale = new Z(1, 1), o.normalTexture.scale !== void 0)) {
      const h = o.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    if (o.occlusionTexture !== void 0 && r !== _t && (c.push(e.assignTexture(a, "aoMap", o.occlusionTexture)), o.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = o.occlusionTexture.strength)), o.emissiveFactor !== void 0 && r !== _t) {
      const h = o.emissiveFactor;
      a.emissive = new Ce().setRGB(h[0], h[1], h[2], Vi);
    }
    return o.emissiveTexture !== void 0 && r !== _t && c.push(e.assignTexture(a, "emissiveMap", o.emissiveTexture, gt)), Promise.all(c).then(function() {
      const h = new r(a);
      return o.name && (h.name = o.name), So(h, o), e.associations.set(h, { materials: t }), o.extensions && tr(n, h, o), h;
    });
  }
  createUniqueName(t) {
    const e = Cb.sanitizeNodeName(t || "");
    return e in this.nodeNamesUsed ? e + "_" + ++this.nodeNamesUsed[e] : (this.nodeNamesUsed[e] = 0, e);
  }
  loadGeometries(t) {
    const e = this, i = this.extensions, n = this.primitiveCache;
    function o(a) {
      return i[tt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, e).then(function(g) {
        return Cy(g, a, e);
      });
    }
    const r = [];
    for (let a = 0, g = t.length; a < g; a++) {
      const c = t[a], l = sW(c), h = n[l];
      if (h)
        r.push(h.promise);
      else {
        let d;
        c.extensions && c.extensions[tt.KHR_DRACO_MESH_COMPRESSION] ? d = o(c) : d = Cy(new Qe(), c, e), n[l] = { primitive: c, promise: d }, r.push(d);
      }
    }
    return Promise.all(r);
  }
  loadMesh(t) {
    const e = this, i = this.json, n = this.extensions, o = i.meshes[t], r = o.primitives, a = [];
    for (let g = 0, c = r.length; g < c; g++) {
      const l = r[g].material === void 0 ? tW(this.cache) : this.getDependency("material", r[g].material);
      a.push(l);
    }
    return a.push(e.loadGeometries(r)), Promise.all(a).then(function(g) {
      const c = g.slice(0, g.length - 1), l = g[g.length - 1], h = [];
      for (let C = 0, p = l.length; C < p; C++) {
        const m = l[C], b = r[C];
        let S;
        const A = c[C];
        if (b.mode === pn.TRIANGLES || b.mode === pn.TRIANGLE_STRIP || b.mode === pn.TRIANGLE_FAN || b.mode === void 0)
          S = o.isSkinnedMesh === !0 ? new fb(m, A) : new le(m, A), S.isSkinnedMesh === !0 && S.normalizeSkinWeights(), b.mode === pn.TRIANGLE_STRIP ? S.geometry = yh(S.geometry, WA) : b.mode === pn.TRIANGLE_FAN && (S.geometry = yh(S.geometry, eh));
        else if (b.mode === pn.LINES)
          S = new Ma(m, A);
        else if (b.mode === pn.LINE_STRIP)
          S = new es(m, A);
        else if (b.mode === pn.LINE_LOOP)
          S = new pb(m, A);
        else if (b.mode === pn.POINTS)
          S = new Ug(m, A);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + b.mode);
        Object.keys(S.geometry.morphAttributes).length > 0 && nW(S, o), S.name = e.createUniqueName(o.name || "mesh_" + t), So(S, o), b.extensions && tr(n, S, b), e.assignFinalMaterial(S), h.push(S);
      }
      for (let C = 0, p = h.length; C < p; C++)
        e.associations.set(h[C], {
          meshes: t,
          primitives: C
        });
      if (h.length === 1)
        return o.extensions && tr(n, h[0], o), h[0];
      const d = new mt();
      o.extensions && tr(n, d, o), e.associations.set(d, { meshes: t });
      for (let C = 0, p = h.length; C < p; C++)
        d.add(h[C]);
      return d;
    });
  }
  loadCamera(t) {
    let e;
    const i = this.json.cameras[t], n = i[i.type];
    if (!n) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return i.type === "perspective" ? e = new Ys(ce.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (e = new Zg(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (e.name = this.createUniqueName(i.name)), So(e, i), Promise.resolve(e);
  }
  loadSkin(t) {
    const e = this.json.skins[t], i = [];
    for (let n = 0, o = e.joints.length; n < o; n++)
      i.push(this._loadNodeShallow(e.joints[n]));
    return e.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", e.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
      const o = n.pop(), r = n, a = [], g = [];
      for (let c = 0, l = r.length; c < l; c++) {
        const h = r[c];
        if (h) {
          a.push(h);
          const d = new J();
          o !== null && d.fromArray(o.array, c * 16), g.push(d);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[c]);
      }
      return new mb(a, g);
    });
  }
  loadAnimation(t) {
    const e = this.json, i = this, n = e.animations[t], o = n.name ? n.name : "animation_" + t, r = [], a = [], g = [], c = [], l = [];
    for (let h = 0, d = n.channels.length; h < d; h++) {
      const C = n.channels[h], p = n.samplers[C.sampler], m = C.target, b = m.node, S = n.parameters !== void 0 ? n.parameters[p.input] : p.input, A = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      m.node !== void 0 && (r.push(this.getDependency("node", b)), a.push(this.getDependency("accessor", S)), g.push(this.getDependency("accessor", A)), c.push(p), l.push(m));
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(g),
      Promise.all(c),
      Promise.all(l)
    ]).then(function(h) {
      const d = h[0], C = h[1], p = h[2], m = h[3], b = h[4], S = [];
      for (let A = 0, u = d.length; A < u; A++) {
        const y = d[A], I = C[A], M = p[A], G = m[A], x = b[A];
        if (y === void 0)
          continue;
        y.updateMatrix && y.updateMatrix();
        const L = i._createAnimationTracks(y, I, M, G, x);
        if (L)
          for (let E = 0; E < L.length; E++)
            S.push(L[E]);
      }
      return new yb(o, void 0, S);
    });
  }
  createNodeMesh(t) {
    const e = this.json, i = this, n = e.nodes[t];
    return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(o) {
      const r = i._getNodeRef(i.meshCache, n.mesh, o);
      return n.weights !== void 0 && r.traverse(function(a) {
        if (!!a.isMesh)
          for (let g = 0, c = n.weights.length; g < c; g++)
            a.morphTargetInfluences[g] = n.weights[g];
      }), r;
    });
  }
  loadNode(t) {
    const e = this.json, i = this, n = e.nodes[t], o = i._loadNodeShallow(t), r = [], a = n.children || [];
    for (let c = 0, l = a.length; c < l; c++)
      r.push(i.getDependency("node", a[c]));
    const g = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
    return Promise.all([
      o,
      Promise.all(r),
      g
    ]).then(function(c) {
      const l = c[0], h = c[1], d = c[2];
      d !== null && l.traverse(function(C) {
        !C.isSkinnedMesh || C.bind(d, rW);
      });
      for (let C = 0, p = h.length; C < p; C++)
        l.add(h[C]);
      return l;
    });
  }
  _loadNodeShallow(t) {
    const e = this.json, i = this.extensions, n = this;
    if (this.nodeCache[t] !== void 0)
      return this.nodeCache[t];
    const o = e.nodes[t], r = o.name ? n.createUniqueName(o.name) : "", a = [], g = n._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(t);
    });
    return g && a.push(g), o.camera !== void 0 && a.push(n.getDependency("camera", o.camera).then(function(c) {
      return n._getNodeRef(n.cameraCache, o.camera, c);
    })), n._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(t);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[t] = Promise.all(a).then(function(c) {
      let l;
      if (o.isBone === !0 ? l = new Sb() : c.length > 1 ? l = new mt() : c.length === 1 ? l = c[0] : l = new Wt(), l !== c[0])
        for (let h = 0, d = c.length; h < d; h++)
          l.add(c[h]);
      if (o.name && (l.userData.name = o.name, l.name = r), So(l, o), o.extensions && tr(i, l, o), o.matrix !== void 0) {
        const h = new J();
        h.fromArray(o.matrix), l.applyMatrix4(h);
      } else
        o.translation !== void 0 && l.position.fromArray(o.translation), o.rotation !== void 0 && l.quaternion.fromArray(o.rotation), o.scale !== void 0 && l.scale.fromArray(o.scale);
      return n.associations.has(l) || n.associations.set(l, {}), n.associations.get(l).nodes = t, l;
    }), this.nodeCache[t];
  }
  loadScene(t) {
    const e = this.extensions, i = this.json.scenes[t], n = this, o = new mt();
    i.name && (o.name = n.createUniqueName(i.name)), So(o, i), i.extensions && tr(e, o, i);
    const r = i.nodes || [], a = [];
    for (let g = 0, c = r.length; g < c; g++)
      a.push(n.getDependency("node", r[g]));
    return Promise.all(a).then(function(g) {
      for (let l = 0, h = g.length; l < h; l++)
        o.add(g[l]);
      const c = (l) => {
        const h = /* @__PURE__ */ new Map();
        for (const [d, C] of n.associations)
          (d instanceof ks || d instanceof pa) && h.set(d, C);
        return l.traverse((d) => {
          const C = n.associations.get(d);
          C != null && h.set(d, C);
        }), h;
      };
      return n.associations = c(o), o;
    });
  }
  _createAnimationTracks(t, e, i, n, o) {
    const r = [], a = t.name ? t.name : t.uuid, g = [];
    go[o.path] === go.weights ? t.traverse(function(d) {
      d.morphTargetInfluences && g.push(d.name ? d.name : d.uuid);
    }) : g.push(a);
    let c;
    switch (go[o.path]) {
      case go.weights:
        c = ZI;
        break;
      case go.rotation:
        c = th;
        break;
      case go.position:
      case go.scale:
        c = WI;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            c = ZI;
            break;
          case 2:
          case 3:
          default:
            c = WI;
            break;
        }
        break;
    }
    const l = n.interpolation !== void 0 ? eW[n.interpolation] : zh, h = this._getArrayFromAccessor(i);
    for (let d = 0, C = g.length; d < C; d++) {
      const p = new c(
        g[d] + "." + go[o.path],
        e.array,
        h,
        l
      );
      n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), r.push(p);
    }
    return r;
  }
  _getArrayFromAccessor(t) {
    let e = t.array;
    if (t.normalized) {
      const i = wA(e.constructor), n = new Float32Array(e.length);
      for (let o = 0, r = e.length; o < r; o++)
        n[o] = e[o] * i;
      e = n;
    }
    return e;
  }
  _createCubicSplineTrackInterpolant(t) {
    t.createInterpolant = function(i) {
      const n = this instanceof th ? $5 : Ex;
      return new n(this.times, this.values, this.getValueSize() / 3, i);
    }, t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function gW(s, t, e) {
  const i = t.attributes, n = new Ue();
  if (i.POSITION !== void 0) {
    const a = e.json.accessors[i.POSITION], g = a.min, c = a.max;
    if (g !== void 0 && c !== void 0) {
      if (n.set(
        new B(g[0], g[1], g[2]),
        new B(c[0], c[1], c[2])
      ), a.normalized) {
        const l = wA(Ca[a.componentType]);
        n.min.multiplyScalar(l), n.max.multiplyScalar(l);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const o = t.targets;
  if (o !== void 0) {
    const a = new B(), g = new B();
    for (let c = 0, l = o.length; c < l; c++) {
      const h = o[c];
      if (h.POSITION !== void 0) {
        const d = e.json.accessors[h.POSITION], C = d.min, p = d.max;
        if (C !== void 0 && p !== void 0) {
          if (g.setX(Math.max(Math.abs(C[0]), Math.abs(p[0]))), g.setY(Math.max(Math.abs(C[1]), Math.abs(p[1]))), g.setZ(Math.max(Math.abs(C[2]), Math.abs(p[2]))), d.normalized) {
            const m = wA(Ca[d.componentType]);
            g.multiplyScalar(m);
          }
          a.max(g);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    n.expandByVector(a);
  }
  s.boundingBox = n;
  const r = new Bn();
  n.getCenter(r.center), r.radius = n.min.distanceTo(n.max) / 2, s.boundingSphere = r;
}
function Cy(s, t, e) {
  const i = t.attributes, n = [];
  function o(r, a) {
    return e.getDependency("accessor", r).then(function(g) {
      s.setAttribute(a, g);
    });
  }
  for (const r in i) {
    const a = BA[r] || r.toLowerCase();
    a in s.attributes || n.push(o(i[r], a));
  }
  if (t.indices !== void 0 && !s.index) {
    const r = e.getDependency("accessor", t.indices).then(function(a) {
      s.setIndex(a);
    });
    n.push(r);
  }
  return Jl.workingColorSpace !== Vi && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Jl.workingColorSpace}" not supported.`), So(s, t), gW(s, t, e), Promise.all(n).then(function() {
    return t.targets !== void 0 ? iW(s, t.targets, e) : s;
  });
}
class Rx extends G5 {
  constructor(t = Qg) {
    super(), this.manager = t, this.adjustmentTransform = new J();
  }
  parse(t) {
    const e = super.parse(t), i = e.glbBytes.slice().buffer;
    return new Promise((n, o) => {
      const r = this.manager, a = this.fetchOptions, g = r.getHandler("path.gltf") || new rf(r);
      a.credentials === "include" && a.mode === "cors" && g.setCrossOrigin("use-credentials"), "credentials" in a && g.setWithCredentials(a.credentials === "include"), a.headers && g.setRequestHeader(a.headers);
      let c = this.workingPath;
      !/[\\/]$/.test(c) && c.length && (c += "/");
      const l = this.adjustmentTransform;
      g.parse(i, c, (h) => {
        const { batchTable: d, featureTable: C } = e, { scene: p } = h, m = C.getData("RTC_CENTER");
        m && (p.position.x += m[0], p.position.y += m[1], p.position.z += m[2]), h.scene.updateMatrix(), h.scene.matrix.multiply(l), h.scene.matrix.decompose(h.scene.position, h.scene.quaternion, h.scene.scale), h.batchTable = d, h.featureTable = C, p.batchTable = d, p.featureTable = C, n(h);
      }, o);
    });
  }
}
class cW extends ic {
  parse(t) {
    const e = new DataView(t), i = e.getUint32(4, !0);
    console.assert(i === 1);
    const n = e.getUint32(8, !0);
    console.assert(n === t.byteLength);
    const o = e.getUint32(12, !0), r = e.getUint32(16, !0), a = e.getUint32(20, !0), g = e.getUint32(24, !0), c = e.getUint32(28, !0), l = 32, h = t.slice(
      l,
      l + o + r
    ), d = new rd(
      h,
      0,
      o,
      r
    ), C = l + o + r, p = t.slice(
      C,
      C + a + g
    ), m = new of(
      p,
      d.getData("INSTANCES_LENGTH"),
      0,
      a,
      g
    ), b = C + a + g, S = new Uint8Array(t, b, n - b);
    let A = null, u = null;
    if (c)
      A = S, u = Promise.resolve();
    else {
      const y = this.resolveExternalURL(Lx(S));
      u = fetch(y, this.fetchOptions).then((I) => {
        if (!I.ok)
          throw new Error(`I3DMLoaderBase : Failed to load file "${y}" with status ${I.status} : ${I.statusText}`);
        return I.arrayBuffer();
      }).then((I) => {
        A = new Uint8Array(I);
      });
    }
    return u.then(() => ({
      version: i,
      featureTable: d,
      batchTable: m,
      glbBytes: A
    }));
  }
}
const fy = new B(), cI = new B(), lI = new B(), py = new B(), hI = new Ye(), el = new B(), tl = new J();
class Dx extends cW {
  constructor(t = Qg) {
    super(), this.manager = t, this.adjustmentTransform = new J();
  }
  resolveExternalURL(t) {
    return this.manager.resolveURL(super.resolveExternalURL(t));
  }
  parse(t) {
    return super.parse(t).then((e) => {
      const { featureTable: i, batchTable: n } = e, o = e.glbBytes.slice().buffer;
      return new Promise((r, a) => {
        const g = this.fetchOptions, c = this.manager, l = c.getHandler("path.gltf") || new rf(c);
        g.credentials === "include" && g.mode === "cors" && l.setCrossOrigin("use-credentials"), "credentials" in g && l.setWithCredentials(g.credentials === "include"), g.headers && l.setRequestHeader(g.headers);
        let h = this.workingPath;
        /[\\/]$/.test(h) || (h += "/");
        const d = this.adjustmentTransform;
        l.parse(o, h, (C) => {
          const p = i.getData("INSTANCES_LENGTH"), m = i.getData("POSITION", p, "FLOAT", "VEC3"), b = i.getData("NORMAL_UP", p, "FLOAT", "VEC3"), S = i.getData("NORMAL_RIGHT", p, "FLOAT", "VEC3"), A = i.getData("SCALE_NON_UNIFORM", p, "FLOAT", "VEC3"), u = i.getData("SCALE", p, "FLOAT", "SCALAR");
          [
            "RTC_CENTER",
            "QUANTIZED_VOLUME_OFFSET",
            "QUANTIZED_VOLUME_SCALE",
            "EAST_NORTH_UP",
            "POSITION_QUANTIZED",
            "NORMAL_UP_OCT32P",
            "NORMAL_RIGHT_OCT32P"
          ].forEach((G) => {
            G in i.header && console.warn(`I3DMLoader: Unsupported FeatureTable feature "${G}" detected.`);
          });
          const y = /* @__PURE__ */ new Map(), I = [];
          C.scene.traverse((G) => {
            if (G.isMesh) {
              const { geometry: x, material: L } = G, E = new kh(x, L, p);
              E.position.copy(G.position), E.rotation.copy(G.rotation), E.scale.copy(G.scale), I.push(E), y.set(G, E);
            }
          });
          const M = new B();
          for (let G = 0; G < p; G++)
            M.x += m[G * 3 + 0] / p, M.y += m[G * 3 + 1] / p, M.z += m[G * 3 + 2] / p;
          y.forEach((G, x) => {
            const L = x.parent;
            L && (L.remove(x), L.add(G), G.updateMatrixWorld(), G.position.copy(M).applyMatrix4(G.matrixWorld));
          });
          for (let G = 0; G < p; G++) {
            py.set(
              m[G * 3 + 0] - M.x,
              m[G * 3 + 1] - M.y,
              m[G * 3 + 2] - M.z
            ), b ? (cI.set(
              b[G * 3 + 0],
              b[G * 3 + 1],
              b[G * 3 + 2]
            ), lI.set(
              S[G * 3 + 0],
              S[G * 3 + 1],
              S[G * 3 + 2]
            ), fy.crossVectors(lI, cI).normalize(), tl.makeBasis(
              lI,
              cI,
              fy
            ), hI.setFromRotationMatrix(tl)) : hI.set(0, 0, 0, 1), u ? el.setScalar(u[G]) : A ? el.set(
              A[G * 3 + 0],
              A[G * 3 + 1],
              A[G * 3 + 2]
            ) : el.set(1, 1, 1), tl.compose(py, hI, el).multiply(d);
            for (let x = 0, L = I.length; x < L; x++)
              I[x].setMatrixAt(G, tl);
          }
          C.batchTable = n, C.featureTable = i, C.scene.batchTable = n, C.scene.featureTable = i, r(C);
        }, a);
      });
    });
  }
}
class lW extends ic {
  parse(t) {
    const e = new DataView(t), i = e.getUint32(4, !0);
    console.assert(i === 1);
    const n = e.getUint32(8, !0);
    console.assert(n === t.byteLength);
    const o = e.getUint32(12, !0), r = e.getUint32(16, !0), a = e.getUint32(20, !0), g = e.getUint32(24, !0), c = 28, l = t.slice(
      c,
      c + o + r
    ), h = new rd(
      l,
      0,
      o,
      r
    ), d = c + o + r, C = t.slice(
      d,
      d + a + g
    ), p = new of(
      C,
      h.getData("BATCH_LENGTH") || h.getData("POINTS_LENGTH"),
      0,
      a,
      g
    );
    return Promise.resolve({
      version: i,
      featureTable: h,
      batchTable: p
    });
  }
}
const my = {
  RGB: "color",
  POSITION: "position"
};
class Kx extends lW {
  constructor(t = Qg) {
    super(), this.manager = t;
  }
  parse(t) {
    return super.parse(t).then(async (e) => {
      const { featureTable: i, batchTable: n } = e, o = new ZA(), r = i.header.extensions, a = new B();
      let g;
      if (r && r["3DTILES_draco_point_compression"]) {
        const { byteOffset: h, byteLength: d, properties: C } = r["3DTILES_draco_point_compression"], p = this.manager.getHandler("draco.drc");
        if (p == null)
          throw new Error("PNTSLoader: dracoLoader not available.");
        const m = {};
        for (const A in C)
          if (A in my && A in C) {
            const u = my[A];
            m[u] = C[A];
          }
        const b = {
          attributeIDs: m,
          attributeTypes: {
            position: "Float32Array",
            color: "Uint8Array"
          },
          useUniqueIDs: !0
        }, S = i.getBuffer(h, d);
        g = await p.decodeGeometry(S, b), g.attributes.color && (o.vertexColors = !0);
      } else {
        const h = i.getData("POINTS_LENGTH"), d = i.getData("POSITION", h, "FLOAT", "VEC3"), C = i.getData("RGB", h, "UNSIGNED_BYTE", "VEC3"), p = i.getData("RGBA", h, "UNSIGNED_BYTE", "VEC4"), m = i.getData("RGB565", h, "UNSIGNED_SHORT", "SCALAR"), b = i.getData("CONSTANT_RGBA", h, "UNSIGNED_BYTE", "VEC4"), S = i.getData("POSITION_QUANTIZED", h, "UNSIGNED_SHORT", "VEC3"), A = i.getData("QUANTIZED_VOLUME_SCALE", h, "FLOAT", "VEC3"), u = i.getData("QUANTIZED_VOLUME_OFFSET", h, "FLOAT", "VEC3");
        if (g = new Qe(), S) {
          const y = new Float32Array(h * 3);
          for (let I = 0; I < h; I++)
            for (let M = 0; M < 3; M++) {
              const G = 3 * I + M;
              y[G] = S[G] / 65535 * A[M];
            }
          a.x = u[0], a.y = u[1], a.z = u[2], g.setAttribute("position", new Fe(y, 3, !1));
        } else
          g.setAttribute("position", new Fe(d, 3, !1));
        if (p !== null)
          g.setAttribute("color", new Fe(p, 4, !0)), o.vertexColors = !0, o.transparent = !0, o.depthWrite = !1;
        else if (C !== null)
          g.setAttribute("color", new Fe(C, 3, !0)), o.vertexColors = !0;
        else if (m !== null) {
          const y = new Uint8Array(h * 3);
          for (let I = 0; I < h; I++) {
            const M = Bw(m[I]);
            for (let G = 0; G < 3; G++) {
              const x = 3 * I + G;
              y[x] = M[G];
            }
          }
          g.setAttribute("color", new Fe(y, 3, !0)), o.vertexColors = !0;
        } else if (b !== null) {
          const y = new Ce(b[0], b[1], b[2]);
          o.color = y;
          const I = b[3] / 255;
          I < 1 && (o.opacity = I, o.transparent = !0, o.depthWrite = !1);
        }
      }
      [
        "BATCH_LENGTH",
        "NORMAL",
        "NORMAL_OCT16P"
      ].forEach((h) => {
        h in i.header && console.warn(
          `PNTSLoader: Unsupported FeatureTable feature "${h}" detected.`
        );
      });
      const c = new Ug(g, o);
      c.position.copy(a), e.scene = c, e.scene.featureTable = i, e.scene.batchTable = n;
      const l = i.getData("RTC_CENTER");
      return l && (e.scene.position.x += l[0], e.scene.position.y += l[1], e.scene.position.z += l[2]), e;
    });
  }
}
function yy(s) {
  let t;
  if (s instanceof DataView ? t = s : t = new DataView(s), String.fromCharCode(t.getUint8(0)) === "{")
    return null;
  let e = "";
  for (let i = 0; i < 4; i++)
    e += String.fromCharCode(t.getUint8(i));
  return e;
}
class hW extends ic {
  parse(t) {
    const e = new DataView(t), i = yy(e);
    console.assert(i === "cmpt", 'CMPTLoader: The magic bytes equal "cmpt".');
    const n = e.getUint32(4, !0);
    console.assert(n === 1, 'CMPTLoader: The version listed in the header is "1".');
    const o = e.getUint32(8, !0);
    console.assert(
      o === t.byteLength,
      "CMPTLoader: The contents buffer length listed in the header matches the file."
    );
    const r = e.getUint32(12, !0), a = [];
    let g = 16;
    for (let c = 0; c < r; c++) {
      const l = new DataView(t, g, 12), h = yy(l), d = l.getUint32(4, !0), C = l.getUint32(8, !0), p = new Uint8Array(t, g, C);
      a.push({
        type: h,
        buffer: p,
        version: d
      }), g += C;
    }
    return {
      version: n,
      tiles: a
    };
  }
}
class dW extends hW {
  constructor(t = Qg) {
    super(), this.manager = t, this.adjustmentTransform = new J();
  }
  parse(t) {
    const e = super.parse(t), i = this.manager, n = this.adjustmentTransform, o = [];
    for (const r in e.tiles)
      if (e.tiles.hasOwnProperty(r)) {
        const { type: a, buffer: g } = e.tiles[r];
        switch (a) {
          case "b3dm": {
            const c = g.slice(), l = new Rx(i);
            l.workingPath = this.workingPath, l.fetchOptions = this.fetchOptions, l.adjustmentTransform.copy(n);
            const h = l.parse(c.buffer);
            o.push(h);
            break;
          }
          case "pnts": {
            const c = g.slice(), l = new Kx(i);
            l.workingPath = this.workingPath, l.fetchOptions = this.fetchOptions;
            const h = l.parse(c.buffer);
            o.push(h);
            break;
          }
          case "i3dm": {
            const c = g.slice(), l = new Dx(i);
            l.workingPath = this.workingPath, l.fetchOptions = this.fetchOptions, l.adjustmentTransform.copy(n);
            const h = l.parse(c.buffer);
            o.push(h);
            break;
          }
        }
      }
    return Promise.all(o).then((r) => {
      const a = new mt();
      return r.forEach((g) => {
        a.add(g.scene);
      }), {
        tiles: r,
        scene: a
      };
    });
  }
}
class Sy extends ic {
  constructor(t = Qg) {
    super(), this.manager = t;
  }
  parse(t) {
    return new Promise((e, i) => {
      const n = this.manager, o = this.fetchOptions;
      let r = n.getHandler("path.gltf") || n.getHandler("path.glb");
      r || (r = new rf(n)), o.credentials === "include" && o.mode === "cors" && r.setCrossOrigin("use-credentials"), "credentials" in o && r.setWithCredentials(o.credentials === "include"), o.headers && r.setRequestHeader(o.headers);
      let a = r.resourcePath || r.path || this.workingPath;
      !/[\\/]$/.test(a) && a.length && (a += "/"), r.parse(t, a, (g) => {
        e(g);
      }, i);
    });
  }
}
const qt = {
  QUADTREE: "QUADTREE",
  OCTREE: "OCTREE"
};
qt.getBranchingFactor = function(s) {
  switch (s) {
    case qt.OCTREE:
      return 8;
    case qt.QUADTREE:
      return 4;
    default:
      throw new Error("subdivisionScheme is not a valid value.");
  }
};
class by {
  constructor(t) {
    const e = t.lengthBits;
    let i = t.availableCount;
    const n = t.constant, o = t.bitstream;
    if (H(n))
      i = e;
    else {
      const r = Math.ceil(e / 8);
      if (o.length !== r)
        throw new Error(
          `Availability bitstream must be exactly ${r} bytes long to store ${e} bits.
                    Actual bitstream was ${o.length} bytes long.`
        );
      const a = W(
        t.computeAvailableCountEnabled,
        !1
      );
      !H(i) && a && (i = uW(o, e));
    }
    this._lengthBits = e, this._availableCount = i, this._constant = n, this._bitstream = o;
  }
  getBit(t) {
    if (H(this._constant))
      return this._constant;
    const e = t >> 3, i = t % 8;
    return (this._bitstream[e] >> i & 1) === 1;
  }
  get lengthBits() {
    return this._lengthBits;
  }
  get availableCount() {
    return this._availableCount;
  }
}
function uW(s, t) {
  let e = 0;
  for (let i = 0; i < t; i++) {
    const n = i >> 3, o = i % 8;
    e += s[n] >> o & 1;
  }
  return e;
}
class IW {
  constructor(t) {
    t = W(t, {});
    const e = t.subtreeMetadata, i = t.class, n = H(e) ? e.properties : {};
    this._class = i, this._properties = n, this._extras = e.extras, this._extensions = e.extensions;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, this._class);
  }
  hasPropertyBySemantic(t) {
    return ke.hasPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  getPropertyIds(t) {
    return ke.getPropertyIds(this._properties, this._class, t);
  }
  getProperty(t) {
    return ke.getProperty(t, this._properties, this._class);
  }
  setProperty(t, e) {
    return ke.setProperty(
      t,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(t) {
    return ke.getPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(t, e) {
    return ke.setPropertyBySemantic(
      t,
      e,
      this._properties,
      this._class
    );
  }
}
function AW(s) {
  return AC(s.url);
}
class By {
  static getSchemaCacheKey(t) {
    const { schema: e, resource: i } = t;
    return H(e) ? `embedded-schema:${JSON.stringify(e)}` : `external-schema:${AW(i)}`;
  }
}
class Hx {
  unload() {
  }
  process() {
    return !1;
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return this.unload(), ko(this);
  }
}
const CW = {
  UNLOADED: 0,
  LOADING: 1,
  LOADED: 2,
  PROCESSING: 3,
  READY: 4,
  FAILED: 5
}, Lo = Object.freeze(CW);
class fW extends Hx {
  constructor(t) {
    super(t), t = W(t, {});
    const e = t.schema, i = t.resource, n = t.cacheKey;
    this._schema = H(e) ? ec.fromJson(e) : void 0, this._resource = i, this._cacheKey = n, this._state = Lo.UNLOADED, this._promise = void 0;
  }
  load() {
    return H(this._promise) ? this._promise : H(this._schema) ? (this._promise = Promise.resolve(this), this._promise) : (this._promise = pW(this), this._promise);
  }
  unload() {
    this._schema = void 0;
  }
  get cacheKey() {
    return this._cacheKey;
  }
  get schema() {
    return this._schema;
  }
}
async function pW(s) {
  const t = s._resource;
  s._state = Lo.LOADING;
  try {
    const e = await t.fetchJson();
    return s.isDestroyed() ? void 0 : (s._schema = ec.fromJson(e), s._state = Lo.READY, s);
  } catch (e) {
    if (s.isDestroyed())
      return;
    s._state = Lo.FAILED;
    const i = `Failed to load schema: ${t.url}`;
    throw s.getError(i, e);
  }
}
class af extends Hx {
  constructor(t) {
    super(), t = W(t, {});
    const e = t.typedArray, i = t.resource, n = t.cacheKey;
    this._typedArray = e, this._resource = i, this._cacheKey = n, this._state = Lo.UNLOADED, this._promise = void 0;
  }
  get cacheKey() {
    return this._cacheKey;
  }
  get typedArray() {
    return this._typedArray;
  }
  async load() {
    return H(this._promise) ? this._promise : H(this._typedArray) ? (this._promise = Promise.resolve(this), this._promise) : (this._promise = this.loadExternalBuffer(), this._promise);
  }
  unload() {
    this._typedArray = void 0;
  }
  async loadExternalBuffer() {
    const t = this._resource;
    this._state = Lo.LOADING;
    try {
      const e = await af._fetchArrayBuffer(t);
      return this.isDestroyed() ? void 0 : (this._typedArray = new Uint8Array(e), this._state = Lo.READY, this);
    } catch (e) {
      if (this.isDestroyed())
        return;
      this._state = Lo.FAILED;
      const i = `Failed to load external buffer: ${t.url}`;
      throw this.getError(i, e);
    }
  }
  static _fetchArrayBuffer(t) {
    return t.fetchArrayBuffer();
  }
}
function mW(s) {
  this.referenceCount = 1, this.resourceLoader = s, this._statisticsPromise = void 0;
}
const is = class {
  static get(t) {
    const e = is.cacheEntries[t];
    if (H(e))
      return ++e.referenceCount, e.resourceLoader;
  }
  static add(t) {
    const e = t.cacheKey;
    return is.cacheEntries[e] = new mW(t), t;
  }
  static unload(t) {
    const e = t.cacheKey, i = is.cacheEntries[e];
    --i.referenceCount, i.referenceCount === 0 && (t.destroy(), delete is.cacheEntries[e]);
  }
  static getSchemaLoader(t) {
    t = W(t, {});
    const { schema: e, resource: i } = t, n = By.getSchemaCacheKey({
      schema: e,
      resource: i
    });
    let o = is.get(n);
    return H(o) ? o : (o = new fW({
      schema: e,
      resource: i,
      cacheKey: n
    }), is.add(o));
  }
  static getExternalBufferLoader(t) {
    t = W(t, {});
    const { resource: e } = t, i = By.getExternalBufferCacheKey({
      resource: e
    });
    let n = is.get(i);
    return H(n) ? n : (n = new af({
      resource: e,
      cacheKey: i
    }), is.add(n));
  }
};
let Ro = is;
f(Ro, "cacheEntries", {});
class wy {
  constructor(t) {
    t = W(t, {});
    const e = t.metadataTable, i = t.class, n = t.entityId, o = t.propertyTableJson;
    this._class = i, this._metadataTable = e, this._entityId = n, this._extensions = o.extensions, this._extras = o.extras;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(t) {
    return this._metadataTable.hasProperty(t);
  }
  hasPropertyBySemantic(t) {
    return this._metadataTable.hasPropertyBySemantic(t);
  }
  getPropertyIds(t) {
    return this._metadataTable.getPropertyIds(t);
  }
  getProperty(t) {
    return this._metadataTable.getProperty(this._entityId, t);
  }
  setProperty(t, e) {
    return this._metadataTable.setProperty(this._entityId, t, e);
  }
  getPropertyBySemantic(t) {
    return this._metadataTable.getPropertyBySemantic(this._entityId, t);
  }
  setPropertyBySemantic(t, e) {
    return this._metadataTable.setPropertyBySemantic(
      this._entityId,
      t,
      e
    );
  }
}
class gf {
  constructor(t, e, i) {
    this._resource = t, this._subtreeJson = void 0, this._bufferLoader = void 0, this._tileAvailability = void 0, this._contentAvailabilityBitstreams = [], this._childSubtreeAvailability = void 0, this._implicitCoordinates = i, this._subtreeLevels = e.subtreeLevels, this._subdivisionScheme = e.subdivisionScheme, this._branchingFactor = e.branchingFactor, this._metadata = void 0, this._tileMetadataTable = void 0, this._tilePropertyTableJson = void 0, this._contentMetadataTables = [], this._contentPropertyTableJsons = [], this._tileJumpBuffer = void 0, this._contentJumpBuffers = [], this._ready = !1;
  }
  get ready() {
    return this._ready;
  }
  get metadata() {
    return this._metadata;
  }
  get tileMetadataTable() {
    return this._tileMetadataTable;
  }
  get tilePropertyTableJson() {
    return this._tilePropertyTableJson;
  }
  get contentMetadataTables() {
    return this._contentMetadataTables;
  }
  get contentPropertyTableJsons() {
    return this._contentPropertyTableJsons;
  }
  get implicitCoordinates() {
    return this._implicitCoordinates;
  }
  tileIsAvailableAtIndex(t) {
    return this._tileAvailability.getBit(t);
  }
  tileIsAvailableAtCoordinates(t) {
    const e = this.getTileIndex(t);
    return this.tileIsAvailableAtIndex(e);
  }
  contentIsAvailableAtIndex(t, e) {
    return e = W(e, 0), this._contentAvailabilityBitstreams[e].getBit(t);
  }
  contentIsAvailableAtCoordinates(t, e) {
    const i = this.getTileIndex(t);
    return this.contentIsAvailableAtIndex(i, e);
  }
  childSubtreeIsAvailableAtIndex(t) {
    return this._childSubtreeAvailability.getBit(t);
  }
  childSubtreeIsAvailableAtCoordinates(t) {
    const e = this.getChildSubtreeIndex(t);
    return this.childSubtreeIsAvailableAtIndex(e);
  }
  getLevelOffset(t) {
    const e = this._branchingFactor;
    return (Math.pow(e, t) - 1) / (e - 1);
  }
  getParentMortonIndex(t) {
    let e = 2;
    return this._subdivisionScheme === qt.OCTREE && (e = 3), t >> e;
  }
  getTileIndex(t) {
    const e = t.level - this._implicitCoordinates.level;
    if (e < 0 || this._subtreeLevels <= e)
      throw new Error("level is out of bounds for this subtree");
    return t.getSubtreeCoordinates().getOffsetCoordinates(
      t
    ).tileIndex;
  }
  getChildSubtreeIndex(t) {
    if (t.level - this._implicitCoordinates.level !== this._implicitCoordinates.subtreeLevels)
      throw new Error("level is out of bounds for this subtree");
    return t.getParentSubtreeCoordinates().getOffsetCoordinates(
      t
    ).mortonIndex;
  }
  getTileMetadataView(t) {
    const e = EW(this, t);
    if (!H(e))
      return;
    const i = this._tileMetadataTable;
    return new wy({
      class: i.class,
      metadataTable: i,
      entityId: e,
      propertyTableJson: this._tilePropertyTableJson
    });
  }
  getContentMetadataView(t, e) {
    const i = RW(this, t, e);
    if (!H(i))
      return;
    const n = this._contentMetadataTables[e], o = this._contentPropertyTableJsons[e];
    return new wy({
      class: n.class,
      metadataTable: n,
      entityId: i,
      contentIndex: e,
      propertyTableJson: o
    });
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return H(this._bufferLoader) && Ro.unload(this._bufferLoader), ko(this);
  }
  static async fromSubtreeJson(t, e, i, n, o) {
    const r = new gf(
      t,
      n,
      o
    );
    let a;
    H(e) ? a = {
      json: e,
      binary: void 0
    } : a = yW(i);
    const g = a.json;
    r._subtreeJson = g;
    let c;
    if (Ei(g, "3DTILES_metadata"))
      c = g.extensions["3DTILES_metadata"];
    else if (H(g.tileMetadata)) {
      const u = g.tileMetadata;
      c = g.propertyTables[u];
    }
    const l = [];
    if (H(g.contentMetadata)) {
      const u = g.contentMetadata.length;
      for (let y = 0; y < u; y++) {
        const I = g.contentMetadata[y];
        l.push(
          g.propertyTables[I]
        );
      }
    }
    let h;
    const d = n.metadataSchema, C = g.subtreeMetadata;
    if (H(C)) {
      const u = C.class, y = d.classes[u];
      h = new IW({
        subtreeMetadata: C,
        class: y
      });
    }
    r._metadata = h, r._tilePropertyTableJson = c, r._contentPropertyTableJsons = l;
    const p = {
      constant: 0
    };
    g.contentAvailabilityHeaders = [], Ei(g, "3DTILES_multiple_contents") ? g.contentAvailabilityHeaders = g.extensions["3DTILES_multiple_contents"].contentAvailability : Array.isArray(g.contentAvailability) ? g.contentAvailabilityHeaders = g.contentAvailability : g.contentAvailabilityHeaders.push(
      W(g.contentAvailability, p)
    );
    const m = SW(g.buffers), b = bW(
      g.bufferViews,
      m
    );
    BW(g, b), H(c) && _y(c, b);
    for (let u = 0; u < l.length; u++) {
      const y = l[u];
      _y(y, b);
    }
    const S = await wW(
      r,
      m,
      a.binary
    ), A = xW(b, S);
    return vW(r, g, n, A), H(c) && (TW(r, n), GW(r)), LW(r, n), MW(r), r._ready = !0, r;
  }
}
function yW(s) {
  const e = new DataView(
    s.buffer,
    s.byteOffset
  );
  let i = 8;
  const n = e.getUint32(i, !0);
  i += 8;
  const o = e.getUint32(i, !0);
  i += 8;
  const r = Ez(
    s,
    i,
    n
  );
  i += n;
  const a = s.subarray(
    i,
    i + o
  );
  return {
    json: r,
    binary: a
  };
}
function SW(s) {
  s = H(s) ? s : [];
  for (let t = 0; t < s.length; t++) {
    const e = s[t];
    e.isExternal = H(e.uri), e.isActive = !1;
  }
  return s;
}
function bW(s, t) {
  s = H(s) ? s : [];
  for (let e = 0; e < s.length; e++) {
    const i = s[e], n = t[i.buffer];
    i.bufferHeader = n, i.isActive = !1;
  }
  return s;
}
function BW(s, t) {
  let e;
  const i = s.tileAvailability;
  H(i.bitstream) ? e = t[i.bitstream] : H(i.bufferView) && (e = t[i.bufferView]), H(e) && (e.isActive = !0, e.bufferHeader.isActive = !0);
  const n = s.contentAvailabilityHeaders;
  for (let r = 0; r < n.length; r++)
    e = void 0, H(n[r].bitstream) ? e = t[n[r].bitstream] : H(n[r].bufferView) && (e = t[n[r].bufferView]), H(e) && (e.isActive = !0, e.bufferHeader.isActive = !0);
  e = void 0;
  const o = s.childSubtreeAvailability;
  H(o.bitstream) ? e = t[o.bitstream] : H(o.bufferView) && (e = t[o.bufferView]), H(e) && (e.isActive = !0, e.bufferHeader.isActive = !0);
}
function _y(s, t) {
  const e = s.properties;
  let i;
  for (const n in e)
    if (e.hasOwnProperty(n)) {
      const o = e[n], r = W(
        o.values,
        o.bufferView
      );
      i = t[r], i.isActive = !0, i.bufferHeader.isActive = !0;
      const a = W(
        o.stringOffsets,
        o.stringOffsetBufferView
      );
      H(a) && (i = t[a], i.isActive = !0, i.bufferHeader.isActive = !0);
      const g = W(
        o.arrayOffsets,
        o.arrayOffsetBufferView
      );
      H(g) && (i = t[g], i.isActive = !0, i.bufferHeader.isActive = !0);
    }
}
function wW(s, t, e) {
  const i = [];
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    if (!o.isActive)
      i.push(Promise.resolve(void 0));
    else if (o.isExternal) {
      const r = _W(s, o);
      i.push(r);
    } else
      i.push(Promise.resolve(e));
  }
  return Promise.all(i).then(function(n) {
    const o = {};
    for (let r = 0; r < n.length; r++) {
      const a = n[r];
      H(a) && (o[r] = a);
    }
    return o;
  });
}
async function _W(s, t) {
  const i = s._resource.getDerivedResource({
    url: t.uri
  }), n = Ro.getExternalBufferLoader({
    resource: i
  });
  s._bufferLoader = n;
  try {
    await n.load();
  } catch (o) {
    if (n.isDestroyed())
      return;
    throw o;
  }
  return n.typedArray;
}
function xW(s, t) {
  const e = {};
  for (let i = 0; i < s.length; i++) {
    const n = s[i];
    if (!n.isActive)
      continue;
    const o = n.byteOffset, r = o + n.byteLength, g = t[n.buffer].subarray(o, r);
    e[i] = g;
  }
  return e;
}
function vW(s, t, e, i) {
  const n = e.branchingFactor, o = e.subtreeLevels, r = (Math.pow(n, o) - 1) / (n - 1), a = Math.pow(n, o), g = Ei(t, "3DTILES_metadata"), c = H(s._tilePropertyTableJson);
  let l = g || c;
  s._tileAvailability = dI(
    t.tileAvailability,
    i,
    r,
    l
  );
  const h = s._contentPropertyTableJsons.length > 0;
  l = l || h;
  for (let d = 0; d < t.contentAvailabilityHeaders.length; d++) {
    const C = dI(
      t.contentAvailabilityHeaders[d],
      i,
      r,
      l
    );
    s._contentAvailabilityBitstreams.push(C);
  }
  s._childSubtreeAvailability = dI(
    t.childSubtreeAvailability,
    i,
    a
  );
}
function dI(s, t, e, i) {
  if (H(s.constant))
    return new by({
      constant: Boolean(s.constant),
      lengthBits: e,
      availableCount: s.availableCount
    });
  let n;
  return H(s.bitstream) ? n = t[s.bitstream] : H(s.bufferView) && (n = t[s.bufferView]), new by({
    bitstream: n,
    lengthBits: e,
    availableCount: s.availableCount,
    computeAvailableCountEnabled: i
  });
}
function TW(s, t, e) {
  const i = s._tilePropertyTableJson;
  s._tileAvailability.availableCount;
  const n = t.metadataSchema, o = i.class;
  n.classes[o];
}
function LW(s, t, e) {
  const i = s._contentPropertyTableJsons, n = s._contentAvailabilityBitstreams, o = t.metadataSchema;
  s._contentMetadataTables;
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    n[r].availableCount;
    const c = a.class;
    o.classes[c];
  }
}
function Px(s) {
  let t = 0;
  const e = s.lengthBits, i = s.availableCount;
  let n;
  i < 256 ? n = new Uint8Array(e) : i < 65536 ? n = new Uint16Array(e) : n = new Uint32Array(e);
  for (let o = 0; o < s.lengthBits; o++)
    s.getBit(o) && (n[o] = t, t++);
  return n;
}
function GW(s) {
  const t = Px(s._tileAvailability);
  s._tileJumpBuffer = t;
}
function MW(s) {
  const t = s._contentJumpBuffers, e = s._contentAvailabilityBitstreams;
  for (let i = 0; i < e.length; i++) {
    const n = e[i], o = Px(n);
    t.push(o);
  }
}
function EW(s, t) {
  if (!H(s._tileMetadataTable))
    return;
  const e = s.getTileIndex(t);
  if (s._tileAvailability.getBit(e))
    return s._tileJumpBuffer[e];
}
function RW(s, t, e) {
  const i = s._contentMetadataTables;
  if (!H(i))
    return;
  const n = i[e];
  if (!H(n))
    return;
  const o = s._contentAvailabilityBitstreams[e], r = s.getTileIndex(t);
  if (o.getBit(r))
    return s._contentJumpBuffers[e][r];
}
const DW = {
  ID: "ID",
  NAME: "NAME",
  DESCRIPTION: "DESCRIPTION",
  TILESET_TILE_COUNT: "TILESET_TILE_COUNT",
  TILE_BOUNDING_BOX: "TILE_BOUNDING_BOX",
  TILE_BOUNDING_REGION: "TILE_BOUNDING_REGION",
  TILE_BOUNDING_SPHERE: "TILE_BOUNDING_SPHERE",
  TILE_MINIMUM_HEIGHT: "TILE_MINIMUM_HEIGHT",
  TILE_MAXIMUM_HEIGHT: "TILE_MAXIMUM_HEIGHT",
  TILE_HORIZON_OCCLUSION_POINT: "TILE_HORIZON_OCCLUSION_POINT",
  TILE_GEOMETRIC_ERROR: "TILE_GEOMETRIC_ERROR",
  CONTENT_BOUNDING_BOX: "CONTENT_BOUNDING_BOX",
  CONTENT_BOUNDING_REGION: "CONTENT_BOUNDING_REGION",
  CONTENT_BOUNDING_SPHERE: "CONTENT_BOUNDING_SPHERE",
  CONTENT_MINIMUM_HEIGHT: "CONTENT_MINIMUM_HEIGHT",
  CONTENT_MAXIMUM_HEIGHT: "CONTENT_MAXIMUM_HEIGHT",
  CONTENT_HORIZON_OCCLUSION_POINT: "CONTENT_HORIZON_OCCLUSION_POINT"
}, KW = Object.freeze(DW);
class Bh {
  constructor(t, e, i) {
    const n = e.implicitTileset, o = e.implicitCoordinates;
    this._implicitTileset = n, this._implicitCoordinates = o, this._implicitSubtree = void 0, this._tileset = t, this._tile = e, this._resource = i, this._metadata = void 0, this.featurePropertiesDirty = !1, this._group = void 0;
    const r = o.getTemplateValues(), a = n.subtreeUriTemplate.getDerivedResource(
      {
        templateValues: r
      }
    );
    this._url = a.getUrlComponent(!0), this._ready = !1;
  }
  hasProperty(t, e) {
    return !1;
  }
  getFeature(t) {
  }
  applyDebugSettings(t, e) {
  }
  update(t, e) {
  }
  pick(t, e, i) {
  }
  isDestroyed() {
    return !1;
  }
  destroy() {
    return this._implicitSubtree = this._implicitSubtree && this._implicitSubtree.destroy(), ko(this);
  }
  get featuresLength() {
    return 0;
  }
  get pointsLength() {
    return 0;
  }
  get trianglesLength() {
    return 0;
  }
  get geometryByteLength() {
    return 0;
  }
  get texturesByteLength() {
    return 0;
  }
  get batchTableByteLength() {
    return 0;
  }
  get innerContents() {
  }
  get ready() {
    return this._ready;
  }
  get tileset() {
    return this._tileset;
  }
  get tile() {
    return this._tile;
  }
  get url() {
    return this._url;
  }
  get metadata() {
  }
  get batchTable() {
  }
  get group() {
    return this._group;
  }
  set group(t) {
    this._group = t;
  }
  static async fromSubtreeJson(t, e, i, n, o, r) {
    r = W(r, 0);
    let a;
    H(o) && (a = new Uint8Array(o, r));
    const g = e.implicitTileset, c = e.implicitCoordinates, l = await gf.fromSubtreeJson(
      i,
      n,
      a,
      g,
      c
    ), h = new Bh(t, e, i);
    return h._implicitSubtree = l, HW(h, l), h._ready = !0, h;
  }
}
function HW(s, t) {
  const e = s._tile, i = s._implicitCoordinates.childIndex, n = NW(
    s,
    t,
    e,
    i
  ), o = s._tileset.statistics;
  e.children.push(n.rootTile), o.numberOfTilesTotal++;
  const r = PW(s, t, n.bottomRow);
  for (let a = 0; a < r.length; a++) {
    const g = r[a], c = g.tile, l = YW(
      s,
      c,
      g.childIndex
    );
    c.children.push(l), o.numberOfTilesTotal++;
  }
}
function PW(s, t, e) {
  const i = [], n = s._implicitTileset.branchingFactor;
  for (let o = 0; o < e.length; o++) {
    const r = e[o];
    if (!!H(r))
      for (let a = 0; a < n; a++) {
        const g = o * n + a;
        t.childSubtreeIsAvailableAtIndex(g) && i.push({
          tile: r,
          childIndex: a
        });
      }
  }
  return i;
}
function NW(s, t, e, i) {
  const r = xy(
    s,
    t,
    e,
    i,
    0,
    !0
  ), a = s._tileset.statistics;
  let g = [r], c = [];
  const l = s._implicitTileset;
  for (let h = 1; h < l.subtreeLevels; h++) {
    const d = t.getLevelOffset(h), C = l.branchingFactor * g.length;
    for (let p = 0; p < C; p++) {
      const m = d + p;
      if (!t.tileIsAvailableAtIndex(m)) {
        c.push(void 0);
        continue;
      }
      const b = t.getParentMortonIndex(p), S = g[b], A = p % l.branchingFactor, u = xy(
        s,
        t,
        S,
        A,
        m
      );
      S.children.push(u), a.numberOfTilesTotal++, c.push(u);
    }
    g = c, c = [];
  }
  return {
    rootTile: r,
    bottomRow: g
  };
}
function Nx(s, t, e) {
  const i = KW.TILE_GEOMETRIC_ERROR;
  return H(s) && s.hasPropertyBySemantic(i) ? s.getPropertyBySemantic(i) : t.geometricError / Math.pow(2, e.level);
}
function xy(s, t, e, i, n, o) {
  const r = s._implicitTileset;
  let a;
  W(o, !1) ? a = e.implicitCoordinates : a = e.implicitCoordinates.getChildCoordinates(
    i
  );
  let g, c, l;
  H(t.tilePropertyTableJson) && (g = t.getTileMetadataView(a));
  const d = t.contentPropertyTableJsons.length;
  let C = !1;
  for (let M = 0; M < d; M++)
    if (t.contentIsAvailableAtCoordinates(a, M)) {
      C = !0;
      break;
    }
  const p = VW(
    r,
    a,
    i,
    o,
    e,
    c
  ), m = [];
  for (let M = 0; M < r.contentCount; M++) {
    if (!t.contentIsAvailableAtIndex(n, M))
      continue;
    const L = {
      uri: r.contentUriTemplates[M].getDerivedResource({
        templateValues: a.getTemplateValues()
      }).url
    }, E = zW(
      p,
      l
    );
    H(E) && (L.boundingVolume = E), m.push(ah(L, r.contentHeaders[M]));
  }
  const b = Nx(
    g,
    r,
    a
  ), S = {
    boundingVolume: p,
    geometricError: b,
    refine: r.refine,
    contents: m
  }, A = !0, u = dt(r.tileHeader, A);
  delete u.boundingVolume, delete u.transform, delete u.metadata;
  const y = ah(S, u, A), I = kx(
    s,
    r.baseResource,
    y,
    e
  );
  return I.implicitCoordinates = a, I.implicitSubtree = t, I.metadata = g, I.hasImplicitContentMetadata = C, I;
}
function wh(s, t) {
  return H(s) && H(t) && (H(t.minimumHeight) || H(t.maximumHeight)) && (Ei(s, "3DTILES_bounding_volume_S2") || H(s.region));
}
function _A(s, t) {
  !H(t) || (Ei(s, "3DTILES_bounding_volume_S2") ? kW(
    s.extensions["3DTILES_bounding_volume_S2"],
    t.minimumHeight,
    t.maximumHeight
  ) : H(s.region) && FW(
    s.region,
    t.minimumHeight,
    t.maximumHeight
  ));
}
function FW(s, t, e) {
  H(t) && (s[4] = t), H(e) && (s[5] = e);
}
function kW(s, t, e) {
  H(t) && (s.minimumHeight = t), H(e) && (s.maximumHeight = e);
}
function VW(s, t, e, i, n, o) {
  let r;
  return !H(o) || !H(o.boundingVolume) || !wh(o.boundingVolume, o) && wh(s.boundingVolume, o) ? r = Fx(
    s,
    t,
    e,
    W(i, !1),
    n
  ) : r = o.boundingVolume, _A(r, o), r;
}
function zW(s, t) {
  let e;
  return H(t) && (e = t.boundingVolume), wh(e, t) ? _A(e, t) : wh(s, t) && (e = dt(s, !0), _A(e, t)), e;
}
function Fx(s, t, e, i, n) {
  const o = s.boundingVolume;
  return Ei(o, "3DTILES_bounding_volume_S2") ? (t.level, t.x, t.y, t.z, void 0) : H(o.region) ? {
    region: QW(
      o.region,
      t.level,
      t.x,
      t.y,
      t.z
    )
  } : {
    box: UW(
      o.box,
      t.level,
      t.x,
      t.y,
      t.z
    )
  };
}
const XW = new B(), WW = new B(), uI = new B(), ZW = new qe();
function UW(s, t, e, i, n) {
  if (t === 0)
    return s;
  const o = WW.fromArray(s, 0), r = ZW.fromArray(s, 3), a = Math.pow(2, -t), g = -1 + (2 * e + 1) * a, c = -1 + (2 * i + 1) * a;
  let l = 0;
  const h = XW.set(a, a, 1);
  H(n) && (l = -1 + (2 * n + 1) * a, h.z = a);
  let d = uI.set(g, c, l);
  d = uI.applyMatrix3(r), d = uI.addVectors(d, o);
  let C = new qe().copy(r);
  Ae.multiplyByScale(C, h, C);
  const p = new Array(12);
  return d.toArray(p), C.toArray(p, 3), p;
}
const OW = new Oe();
function QW(s, t, e, i, n) {
  if (t === 0)
    return s.slice();
  const o = Oe.unpack(s, 0, OW), r = s[4], a = s[5], g = Math.pow(2, -t), c = g * o.width, l = X.negativePiToPi(o.west + e * c), h = X.negativePiToPi(l + c), d = g * o.height, C = X.negativePiToPi(o.south + i * d), p = X.negativePiToPi(C + d);
  let m = r, b = a;
  if (H(n)) {
    const S = g * (a - r);
    m += n * S, b = m + S;
  }
  return [l, C, h, p, m, b];
}
function YW(s, t, e) {
  const i = s._implicitTileset, n = t.implicitCoordinates.getChildCoordinates(
    e
  ), o = Fx(
    i,
    n,
    e,
    !1,
    t
  ), r = Nx(
    void 0,
    i,
    n
  ), a = i.subtreeUriTemplate.getDerivedResource(
    {
      templateValues: n.getTemplateValues()
    }
  ).url, g = {
    boundingVolume: o,
    geometricError: r,
    refine: i.refine,
    contents: [
      {
        uri: a
      }
    ]
  }, c = kx(
    s,
    i.baseResource,
    g,
    t
  );
  return c.implicitTileset = i, c.implicitCoordinates = n, c;
}
function kx(s, t, e, i) {
  const n = s._tile.constructor;
  return new n(s._tileset, t, e, i);
}
const Vx = Symbol("INITIAL_FRUSTUM_CULLED");
function jW(s, t) {
  s.traverse((e) => {
    e.frustumCulled = e[Vx] && t;
  });
}
class bo {
  constructor(t) {
    f(this, "byteSize", 0);
    this.scene = t.scene, this.asset = W(t.asset, {}), this.parser = t.parser, this.animations = W(t.animations, []), this.batchTable = W(t.batchTable, {}), this.featureTable = W(t.featureTable, {}), this.userData = W(t.userData, {}), this.metadata = W(t.metadata, {}), this.group = W(t.group, {}), this.type = W(t.type, "gltf");
  }
  static fromJson(t) {
    return t = W(t, {}), new bo(t);
  }
  traverse(t) {
    const e = this.scene;
    e && e.traverse(t);
  }
  dispose() {
    const t = this.scene;
    if (t) {
      const e = [], i = [], n = [];
      this.traverse((o) => {
        if (o.geometry && i.push(o.geometry), o.material) {
          const r = o.material;
          e.push(o.material);
          for (const a in r)
            if (r.hasOwnProperty(a)) {
              const g = r[a];
              g && g.isTexture && n.push(g);
            }
        }
        o.userData.meshFeatures && o.userData.meshFeatures.dispose(), o.userData.structuralMetadata && o.userData.structuralMetadata.dispose();
      });
      for (let o = 0, r = i.length; o < r; o++)
        i[o].dispose();
      for (let o = 0, r = e.length; o < r; o++)
        e[o].dispose();
      for (let o = 0, r = n.length; o < r; o++) {
        const a = n[o];
        a.image instanceof ImageBitmap && a.image.close(), a.dispose();
      }
      t.removeFromParent();
    }
  }
  update(t) {
    const e = t.tileset, i = this.scene, n = e.gltfUpMatrix;
    e.optimizeRaycast, i.updateMatrix(), (this.type === "gltf" || this.type === "glb") && i.matrix.multiply(n), i.matrix.premultiply(t.computedTransform), i.matrix.decompose(i.position, i.quaternion, i.scale), i.traverse((o) => {
      o[Vx] = o.frustumCulled, o.isMesh && (o.content = this, o.tile = t);
    }), jW(i, !1);
  }
}
const zx = {
  externalTileset: function(s, t, e, i) {
    return sf.fromJson(s, t, e, i);
  },
  b3dm: async function(s, t, e, i) {
    const n = s._manager, r = e.url.split(/[\\/]/g);
    r.pop();
    const a = r.join("/"), g = new Rx(n), c = s.gltfUpMatrix;
    g.adjustmentTransform.copy(c), g.workingPath = a;
    const h = await g.parse(i);
    return h.type = "b3dm", bo.fromJson(h);
  },
  pnts: async function(s, t, e, i) {
    const n = s._manager, r = e.url.split(/[\\/]/g);
    r.pop();
    const a = r.join("/"), g = new Kx(n);
    g.workingPath = a;
    const l = await g.parse(i);
    return l.type = "pnts", bo.fromJson(l);
  },
  i3dm: async function(s, t, e, i) {
    const n = s._manager, r = e.url.split(/[\\/]/g);
    r.pop();
    const a = r.join("/"), g = new Dx(n), c = s.gltfUpMatrix;
    g.adjustmentTransform.copy(c), g.workingPath = a;
    const h = await g.parse(i);
    return h.type = "i3dm", bo.fromJson(h);
  },
  cmpt: async function(s, t, e, i) {
    const n = s._manager, r = e.url.split(/[\\/]/g);
    r.pop();
    const a = r.join("/"), g = new dW(n), c = s.gltfUpMatrix;
    g.adjustmentTransform.copy(c), g.workingPath = a;
    const h = await g.parse(i);
    return h.type = "cmpt", bo.fromJson(h);
  },
  gltf: async function(s, t, e, i) {
    const n = s._manager, r = e.url.split(/[\\/]/g);
    r.pop();
    const a = r.join("/"), g = new Sy(n);
    g.workingPath = a;
    const l = await g.parse(i);
    return l.type = "gltf", bo.fromJson(l);
  },
  glb: async function(s, t, e, i) {
    const n = s._manager, r = e.url.split(/[\\/]/g);
    r.pop();
    const a = r.join("/"), g = new Sy(n);
    g.workingPath = a;
    const l = await g.parse(i);
    return l.type = "glb", bo.fromJson(l);
  },
  subt: function(s, t, e, i, n) {
    return Bh.fromSubtreeJson(
      s,
      t,
      e,
      void 0,
      i,
      n
    );
  },
  subtreeJson: function(s, t, e, i) {
    return Bh.fromSubtreeJson(s, t, e, i);
  }
}, il = new B(), nl = new B(), un = new B(), sl = new yt();
class vy {
  constructor(t = new Ue(), e = new J()) {
    this.box = t.clone(), this.absoluteBox = t.clone(), this.transform = e.clone(), this.inverseTransform = new J(), this.points = new Array(8).fill().map(() => new B()), this.planes = new Array(6).fill().map(() => new Zt());
  }
  clampPoint(t, e) {
    return e.copy(t).applyMatrix4(this.inverseTransform).clamp(this.box.min, this.box.max).applyMatrix4(this.transform);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, un).distanceTo(t);
  }
  containsPoint(t) {
    return un.copy(t).applyMatrix4(this.inverseTransform), this.box.containsPoint(un);
  }
  intersectsRay(t) {
    return sl.copy(t).applyMatrix4(this.inverseTransform), sl.intersectsBox(this.box);
  }
  intersectRay(t, e) {
    return sl.copy(t).applyMatrix4(this.inverseTransform), sl.intersectBox(this.box, e) ? (e.applyMatrix4(this.transform), e) : null;
  }
  update() {
    const { points: t, inverseTransform: e, transform: i, box: n } = this;
    e.copy(i).invert();
    const { min: o, max: r } = n;
    let a = 0;
    for (let g = -1; g <= 1; g += 2)
      for (let c = -1; c <= 1; c += 2)
        for (let l = -1; l <= 1; l += 2)
          t[a].set(
            g < 0 ? o.x : r.x,
            c < 0 ? o.y : r.y,
            l < 0 ? o.z : r.z
          ).applyMatrix4(i), a++;
    this.updatePlanes();
  }
  updatePlanes() {
    il.copy(this.box.min).applyMatrix4(this.transform), nl.copy(this.box.max).applyMatrix4(this.transform), un.set(0, 0, 1).transformDirection(this.transform), this.planes[0].setFromNormalAndCoplanarPoint(un, il), this.planes[1].setFromNormalAndCoplanarPoint(un, nl).negate(), un.set(0, 1, 0).transformDirection(this.transform), this.planes[2].setFromNormalAndCoplanarPoint(un, il), this.planes[3].setFromNormalAndCoplanarPoint(un, nl).negate(), un.set(1, 0, 0).transformDirection(this.transform), this.planes[4].setFromNormalAndCoplanarPoint(un, il), this.planes[5].setFromNormalAndCoplanarPoint(un, nl).negate();
  }
  intersectsFrustum(t) {
    const { points: e } = this, { planes: i } = t;
    for (let n = 0; n < 6; n++) {
      const o = i[n];
      let r = -1 / 0;
      for (let a = 0; a < 8; a++) {
        const g = e[a], c = o.distanceToPoint(g);
        r = r < c ? c : r;
      }
      if (r < 0)
        return !1;
    }
    for (let n = 0; n < 6; n++) {
      const o = this.planes[n];
      let r = -1 / 0;
      for (let a = 0; a < 8; a++) {
        const g = t.points[a], c = o.distanceToPoint(g);
        r = r < c ? c : r;
      }
      if (r < 0)
        return !1;
    }
    return !0;
  }
}
const Co = Math.PI, ol = Co / 2, Ty = new B(), Ly = new B(), Gy = new B(), My = new J(), JW = new B(), II = new B();
new J();
let _g = 0;
const AI = [];
function qW(s = !1) {
  return s ? (AI[_g] || (AI[_g] = new B()), _g++, AI[_g - 1]) : new B();
}
function Ey() {
  _g = 0;
}
class Xx extends De {
  constructor(t, e, i, n = -ol, o = ol, r = 0, a = 2 * Co, g = 0, c = 0) {
    super(t, e, i), this.latStart = n, this.latEnd = o, this.lonStart = r, this.lonEnd = a, this.heightStart = g, this.heightEnd = c;
  }
  _getPoints(t = !1) {
    const {
      latStart: e,
      latEnd: i,
      lonStart: n,
      lonEnd: o,
      heightStart: r,
      heightEnd: a
    } = this, g = ce.mapLinear(0.5, 0, 1, e, i), c = ce.mapLinear(0.5, 0, 1, n, o), l = Math.floor(n / ol) * ol, h = [
      [-Co / 2, 0],
      [Co / 2, 0],
      [0, l],
      [0, l + Co / 2],
      [0, l + Co],
      [0, l + 3 * Co / 2],
      [e, o],
      [i, o],
      [e, n],
      [i, n],
      [0, n],
      [0, o],
      [g, c],
      [e, c],
      [i, c],
      [g, n],
      [g, o]
    ], d = [], C = h.length;
    for (let p = 0; p <= 1; p++) {
      const m = ce.mapLinear(p, 0, 1, r, a);
      for (let b = 0, S = C; b < S; b++) {
        const [A, u] = h[b];
        if (A >= e && A <= i && u >= n && u <= o) {
          const y = qW(t);
          d.push(y), this.cartographicToCartesian(II.set(u, A, m), y);
        }
      }
    }
    return d;
  }
  getBoundingBox(t, e) {
    Ey();
    const {
      latStart: i,
      latEnd: n,
      lonStart: o,
      lonEnd: r
    } = this;
    if (n - i < Co / 2) {
      const c = ce.mapLinear(0.5, 0, 1, i, n), l = ce.mapLinear(0.5, 0, 1, o, r);
      this.cartographicToCartesian(JW.set(l, c, 0), II);
      const h = Ze.eastNorthUpToFixedFrame(II);
      e.copy(h);
    } else
      Ty.set(1, 0, 0), Ly.set(0, 1, 0), Gy.set(0, 0, 1), e.makeBasis(Ty, Ly, Gy);
    const g = this._getPoints(!0);
    t.makeEmpty(), t.setFromPoints(g), My.copy(e).invert();
    for (let c = 0, l = g.length; c < l; c++)
      g[c].applyMatrix4(My);
    t.makeEmpty(), t.setFromPoints(g);
  }
  getBoundingSphere(t, e) {
    Ey();
    const i = this._getPoints(!0);
    t.makeEmpty(), t.setFromPoints(i, e);
  }
}
const ws = new B(), _s = new B(), xs = new B(), Ry = new B(), Dy = new B();
new qe();
const Ky = new qe(), $W = new B(), eZ = new B(), tZ = new B(), _h = 6378137, iZ = 1 / 298.257223563, nZ = -(iZ * _h - _h);
class sZ {
  constructor() {
    this.sphere = null, this.obb = null, this.region = null, this.regionObb = null;
  }
  intersectsRay(t) {
    const e = this.sphere, i = this.obb || this.regionObb;
    return !(e && !t.intersectsSphere(e) || i && !i.intersectsRay(t));
  }
  intersectRay(t, e = null) {
    const i = this.sphere, n = this.obb || this.regionObb;
    let o = -1 / 0, r = -1 / 0;
    i && t.intersectSphere(i, Ry) && (o = i.containsPoint(t.origin) ? 0 : t.origin.distanceToSquared(Ry)), n && n.intersectRay(t, Dy) && (r = n.containsPoint(t.origin) ? 0 : t.origin.distanceToSquared(Dy));
    const a = Math.max(o, r);
    return a === -1 / 0 ? null : (t.at(Math.sqrt(a), e), e);
  }
  distanceToPoint(t) {
    const e = this.sphere, i = this.obb || this.regionObb;
    let n = -1 / 0, o = -1 / 0;
    return e && (n = Math.max(e.distanceToPoint(t), 0)), i && (o = i.distanceToPoint(t)), n > o ? n : o;
  }
  intersectsFrustum(t, e) {
    const i = this.obb || this.regionObb, n = this.sphere;
    return n && !t.intersectsSphere(n) || i && !i.intersectsFrustum(t) ? !1 : Boolean(n || i);
  }
  getOBB(t, e) {
    const i = this.obb || this.regionObb;
    i ? (t.copy(i.box), e.copy(i.transform)) : (this.getAABB(t), e.identity());
  }
  getAABB(t) {
    if (this.sphere)
      this.sphere.getBoundingBox(t);
    else {
      const e = this.obb || this.regionObb;
      t.copy(e.box).applyMatrix4(e.transform);
    }
  }
  getSphere(t) {
    if (this.sphere)
      t.copy(this.sphere);
    else if (this.region)
      this.region.getBoundingSphere(t);
    else {
      const e = this.obb || this.regionObb;
      e.box.getBoundingSphere(t), t.applyMatrix4(e.transform);
    }
  }
  setObbData(t, e) {
    const i = new vy();
    ws.set(t[3], t[4], t[5]), _s.set(t[6], t[7], t[8]), xs.set(t[9], t[10], t[11]);
    const n = ws.length(), o = _s.length(), r = xs.length();
    ws.normalize(), _s.normalize(), xs.normalize(), n === 0 && ws.crossVectors(_s, xs), o === 0 && _s.crossVectors(ws, xs), r === 0 && xs.crossVectors(ws, _s), i.transform.set(
      ws.x,
      _s.x,
      xs.x,
      t[0],
      ws.y,
      _s.y,
      xs.y,
      t[1],
      ws.z,
      _s.z,
      xs.z,
      t[2],
      0,
      0,
      0,
      1
    ).premultiply(e);
    const a = new B().setFromMatrixColumn(i.transform, 3);
    i.center = a, Ky.fromArray(t, 3);
    const g = new qe().setFromMatrix4(e);
    i.halfAxes = g.multiply(Ky), i.box.min.set(-n, -o, -r), i.box.max.set(n, o, r), i.update(), i.absoluteBox.copy(i.box).applyMatrix4(i.transform), this.obb = i;
  }
  setSphereData(t, e, i, n, o) {
    const r = new Bn();
    r.center.set(t, e, i), r.radius = n, r.applyMatrix4(o), this.sphere = r;
  }
  setRegionData(t, e, i, n, o, r) {
    const a = new Xx(
      _h,
      _h,
      nZ,
      e,
      n,
      t,
      i,
      o,
      r
    ), g = new vy();
    a.getBoundingBox(g.box, g.transform), g.update();
    const c = ce.mapLinear(0.5, 0, 1, e, n), l = ce.mapLinear(0.5, 0, 1, t, i), { min: h, max: d } = g.box, C = new qe().setFromMatrix4(g.transform);
    let p = eZ;
    p.x = (h.x + d.x) / 2, p.y = (h.y + d.y) / 2, p.z = (h.z + d.z) / 2;
    const m = tZ;
    m.x = (d.x - h.x) / 2, m.y = (d.y - h.y) / 2, m.z = (d.z - h.z) / 2;
    const b = a.cartographicToCartesian($W.set(l, c, 0));
    p.applyMatrix3(C), g.center = b.add(p), Ae.multiplyByScale(C, m, C), g.halfAxes = C, g.absoluteBox.copy(g.box).applyMatrix4(g.transform), this.region = a, this.regionObb = g;
  }
}
function oZ(s, t, e) {
  return JSON.parse(
    Sn(s, t, e)
  );
}
function rZ(s) {
  let t;
  try {
    t = oZ(s);
  } catch {
    throw new Error("Invalid tile content.");
  }
  return t;
}
function aZ(s) {
  const t = new Uint8Array(s);
  let e = ex(t);
  if (e === "glTF" && (e = "glb"), kt.isBinaryFormat(e))
    return {
      contentType: e,
      binaryPayload: t
    };
  const i = rZ(t);
  if (H(i.root))
    return {
      contentType: kt.EXTERNAL_TILESET,
      jsonPayload: i
    };
  if (H(i.root))
    return {
      contentType: kt.EXTERNAL_TILESET,
      jsonPayload: i
    };
  if (H(i.asset))
    return {
      contentType: kt.GLTF,
      jsonPayload: i
    };
  if (H(i.tileAvailability))
    return {
      contentType: kt.IMPLICIT_SUBTREE_JSON,
      jsonPayload: i
    };
  if (H(i.type))
    return {
      contentType: kt.GEOJSON,
      jsonPayload: i
    };
  if (H(i.voxelTable))
    return {
      contentType: kt.VOXEL_JSON,
      jsonPayload: i
    };
  throw new Error("Invalid tile content.");
}
class gZ {
  constructor(t) {
    t = W(t, {});
    const e = t.tile, i = t.class;
    this._class = i, this._properties = e.properties, this._extensions = e.extensions, this._extras = e.extras;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, this._class);
  }
  hasPropertyBySemantic(t) {
    return ke.hasPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  getPropertyIds(t) {
    return ke.getPropertyIds(this._properties, this._class, t);
  }
  getProperty(t) {
    return ke.getProperty(t, this._properties, this._class);
  }
  setProperty(t, e) {
    return ke.setProperty(
      t,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(t) {
    return ke.getPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(t, e) {
    return ke.setPropertyBySemantic(
      t,
      e,
      this._properties,
      this._class
    );
  }
}
class cZ {
  constructor(t) {
    t = W(t, {});
    const e = t.content, i = t.class;
    this._class = i, this._properties = e.properties, this._extensions = e.extensions, this._extras = e.extras;
  }
  get class() {
    return this._class;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, this._class);
  }
  hasPropertyBySemantic(t) {
    return ke.hasPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  getPropertyIds(t) {
    return ke.getPropertyIds(this._properties, this._class, t);
  }
  getProperty(t) {
    return ke.getProperty(t, this._properties, this._class);
  }
  setProperty(t, e) {
    return ke.setProperty(
      t,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(t) {
    return ke.getPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(t, e) {
    return ke.setPropertyBySemantic(
      t,
      e,
      this._properties,
      this._class
    );
  }
}
function lZ(s, t) {
  const e = Ei(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"] : t.metadata;
  if (!H(e))
    return;
  if (!H(s.schema)) {
    $i("Could not find a metadata schema for tile metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.");
    return;
  }
  const i = W(
    s.schema.classes,
    {}
  );
  if (H(e.class)) {
    const n = i[e.class];
    return new gZ({
      tile: e,
      class: n
    });
  }
}
function Wx(s, t) {
  const e = s.metadataExtension;
  if (!H(e))
    return;
  const i = e.groups, n = Ei(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"].group : t.group;
  if (typeof n == "number")
    return i[n];
  const o = e.groupIds.findIndex(function(r) {
    return r === n;
  });
  return o >= 0 ? i[o] : void 0;
}
function Zx(s, t) {
  const e = Ei(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"] : t.metadata;
  if (!H(e))
    return;
  if (!H(s.schema)) {
    $i("Could not find a metadata schema for content metadata. For tilesets that contain external tilesets, make sure the schema is added to the root tileset.json.");
    return;
  }
  const i = W(
    s.schema.classes,
    {}
  );
  if (H(e.class)) {
    const n = i[e.class];
    return new cZ({
      content: e,
      class: n
    });
  }
}
class Ux {
  constructor(t) {
    t = W(t, {}), this._metadata = t.metadata;
  }
  get metadata() {
    return this._metadata;
  }
}
function hZ(s, t) {
  const e = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return e > t ? (s.repeat.x = 1, s.repeat.y = e / t, s.offset.x = 0, s.offset.y = (1 - s.repeat.y) / 2) : (s.repeat.x = t / e, s.repeat.y = 1, s.offset.x = (1 - s.repeat.x) / 2, s.offset.y = 0), s;
}
function dZ(s, t) {
  const e = s.image && s.image.width ? s.image.width / s.image.height : 1;
  return e > t ? (s.repeat.x = t / e, s.repeat.y = 1, s.offset.x = (1 - s.repeat.x) / 2, s.offset.y = 0) : (s.repeat.x = 1, s.repeat.y = e / t, s.offset.x = 0, s.offset.y = (1 - s.repeat.y) / 2), s;
}
function uZ(s) {
  return s.repeat.x = 1, s.repeat.y = 1, s.offset.x = 0, s.offset.y = 0, s;
}
function IZ(s, t, e, i) {
  const n = AZ(i);
  switch (e) {
    case kT:
      return s * t;
    case db:
      return s * t;
    case FT:
      return s * t * 2;
    case Ps:
      return s * t / n.components * n.byteLength;
    case NT:
      return s * t / n.components * n.byteLength;
    case aa:
      return s * t * 2 / n.components * n.byteLength;
    case PT:
      return s * t * 2 / n.components * n.byteLength;
    case Hs:
      return s * t * 4 / n.components * n.byteLength;
    case HT:
      return s * t * 4 / n.components * n.byteLength;
    case Nb:
    case KT:
      return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case DT:
    case Db:
      return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case RT:
    case ET:
      return Math.max(s, 16) * Math.max(t, 8) / 4;
    case Pb:
    case Rb:
      return Math.max(s, 8) * Math.max(t, 8) / 2;
    case Kb:
    case Hb:
      return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 8;
    case Eb:
      return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case Gb:
      return Math.floor((s + 3) / 4) * Math.floor((t + 3) / 4) * 16;
    case MT:
      return Math.floor((s + 4) / 5) * Math.floor((t + 3) / 4) * 16;
    case GT:
      return Math.floor((s + 4) / 5) * Math.floor((t + 4) / 5) * 16;
    case LT:
      return Math.floor((s + 5) / 6) * Math.floor((t + 4) / 5) * 16;
    case UI:
      return Math.floor((s + 5) / 6) * Math.floor((t + 5) / 6) * 16;
    case TT:
      return Math.floor((s + 7) / 8) * Math.floor((t + 4) / 5) * 16;
    case vT:
      return Math.floor((s + 7) / 8) * Math.floor((t + 5) / 6) * 16;
    case xT:
      return Math.floor((s + 7) / 8) * Math.floor((t + 7) / 8) * 16;
    case _T:
      return Math.floor((s + 9) / 10) * Math.floor((t + 4) / 5) * 16;
    case wT:
      return Math.floor((s + 9) / 10) * Math.floor((t + 5) / 6) * 16;
    case BT:
      return Math.floor((s + 9) / 10) * Math.floor((t + 7) / 8) * 16;
    case bT:
      return Math.floor((s + 9) / 10) * Math.floor((t + 9) / 10) * 16;
    case ST:
      return Math.floor((s + 11) / 12) * Math.floor((t + 9) / 10) * 16;
    case yT:
      return Math.floor((s + 11) / 12) * Math.floor((t + 11) / 12) * 16;
    case Mb:
    case mT:
    case pT:
      return Math.ceil(s / 4) * Math.ceil(t / 4) * 16;
    case fT:
    case CT:
      return Math.ceil(s / 4) * Math.ceil(t / 4) * 8;
    case AT:
    case IT:
      return Math.ceil(s / 4) * Math.ceil(t / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${e} format.`
  );
}
function AZ(s) {
  switch (s) {
    case Pi:
    case OT:
      return { byteLength: 1, components: 1 };
    case UT:
    case ZT:
    case xi:
      return { byteLength: 2, components: 1 };
    case WT:
    case XT:
      return { byteLength: 2, components: 4 };
    case zT:
    case VT:
    case ur:
      return { byteLength: 4, components: 1 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
const Hy = {
  contain: hZ,
  cover: dZ,
  fill: uZ,
  getByteLength: IZ
};
function Ox(s) {
  if (!Hy)
    return 0;
  const t = /* @__PURE__ */ new Set();
  let e = 0;
  return s.traverse((i) => {
    if (i.geometry && !t.has(i.geometry) && (e += hz(i.geometry), t.add(i.geometry)), i.material) {
      const n = i.material;
      for (const o in n)
        if (n.hasOwnProperty(o)) {
          const r = n[o];
          if (r && r.isTexture && !t.has(r)) {
            const { format: a, type: g, image: c } = r, { width: l, height: h } = c, d = Hy.getByteLength(l, h, a, g);
            e += r.generateMipmaps ? d * 4 / 3 : d, t.add(r);
          }
        }
    }
  }), e;
}
function CZ(s) {
  const t = {};
  for (let e = 0; e < s.length; e++) {
    const i = s[e];
    H(t[i]) ? t[i]++ : t[i] = 1;
  }
  for (let e in t)
    if (t.hasOwnProperty(e) && !Bi.serverHasOpenSlots(e, t[e]))
      return !1;
  return Bi.heapHasOpenSlots(s.length);
}
function Py(s, t) {
  s._cancelCount++, s._tile._contentState = t;
  const e = s.tileset.statistics;
  e.numberOfPendingRequests -= s._requestsInFlight, e.numberOfAttemptedRequests += s._requestsInFlight, s._requestsInFlight = 0;
  const i = s._innerContentHeaders.length;
  s._arrayFetchPromises = new Array(i);
}
function fZ(s, t, e, i) {
  const n = s._innerContentResources[t].clone(), o = s.tile, r = function() {
    return o._priority;
  }, a = s._serverKeys[t], g = new tc({
    throttle: !0,
    throttleByServer: !0,
    priorityFunction: r,
    serverKey: a
  });
  n.request = g, s._requests[t] = g;
  const c = n.fetchArrayBuffer();
  if (!!H(c))
    return c.then(function(l) {
      if (!(e < s._cancelCount)) {
        if (n.request.cancelled || n.request.state === Et.CANCELLED) {
          Py(s, i);
          return;
        }
        return xA(s, -1), l;
      }
    }).catch(function(l) {
      if (!(e < s._cancelCount)) {
        if (n.request.cancelled || n.request.state === Et.CANCELLED) {
          Py(s, i);
          return;
        }
        xA(s, -1), Qx(s, t, l);
      }
    });
}
function xA(s, t) {
  s._requestsInFlight += t, s.tileset.statistics.numberOfPendingRequests += t;
}
async function pZ(s) {
  const t = s._cancelCount, e = await Promise.all(s._arrayFetchPromises);
  if (t < s._cancelCount)
    return;
  const i = e.map((o, r) => mZ(s, o, r)), n = await Promise.all(i);
  return s._contentCreated = !0, s._contents = n.filter(H), n;
}
function Qx(s, t, e) {
  s._tileset, s._innerContentResources[t].url, H(e.message) ? e.message : e.toString();
}
async function mZ(s, t, e) {
  if (!!H(t))
    try {
      const i = aZ(t);
      if (i.contentType === kt.EXTERNAL_TILESET)
        throw new Error("External tilesets are disabllowed inside multiple contents");
      const n = s._tileset, o = s._innerContentResources[e], r = s._tile;
      let a;
      const g = zx[i.contentType];
      H(i.binaryPayload) ? a = await g(
        n,
        r,
        r._contentResource,
        i.binaryPayload.buffer,
        0
      ) : a = await Promise.resolve(
        g(
          n,
          r,
          o,
          i.binaryPayload.buffer
        )
      );
      const c = s._innerContentHeaders[e];
      if (r.hasImplicitContentMetadata) {
        const h = r.implicitSubtree, d = r.implicitCoordinates;
        a.metadata = h.getContentMetadataView(d, e);
      } else
        r.hasImplicitContent || (a.metadata = Zx(n, c));
      const l = Wx(n, c);
      if (H(l) && (a.group = new Ux({
        metadata: l
      })), !r.hasTilesetContent && !r.hasImplicitContent) {
        const h = a.scene;
        H(h) && (a.byteSize = Ox(a.scene));
      }
      return a;
    } catch (i) {
      Qx(s, e, i);
    }
}
class yZ {
  constructor(t, e, i, n) {
    f(this, "isMultiple3DTileContents", !0);
    this._tileset = t, this._tile = e, this._tilesetResource = i;
    const o = H(n.contents) ? n.contents : n.content;
    this._innerContentHeaders = o, this._requestsInFlight = 0, this._cancelCount = 0;
    const r = this._innerContentHeaders.length;
    this._arrayFetchPromises = new Array(r), this._requests = new Array(r), this._ready = !1, this._innerContentResources = new Array(r), this._serverKeys = new Array(r);
    for (let a = 0; a < r; a++) {
      const g = i.getDerivedResource({
        url: o[a].uri
      }), c = Bi.getServerKey(
        g.getUrlComponent()
      );
      this._innerContentResources[a] = g, this._serverKeys[a] = c;
    }
  }
  updatePendingRequests(t) {
  }
  requestInnerContents() {
    if (!CZ(this._serverKeys)) {
      this.tileset.statistics.numberOfAttemptedRequests += this._serverKeys.length;
      return;
    }
    const t = this._innerContentHeaders;
    xA(this, t.length);
    const e = this._cancelCount;
    for (let i = 0; i < t.length; i++)
      this._arrayFetchPromises[i] = fZ(
        this,
        i,
        e,
        this._tileset._contentState
      );
    return pZ(this);
  }
  cancelRequests() {
    for (let t = 0; t < this._requests.length; t++) {
      const e = this._requests[t];
      H(e) && e.cancel();
    }
  }
  traverse(t) {
    const e = this._contents;
    if (e && e.length > 0)
      for (let i = 0; i < e.length; i++) {
        const o = e[i].scene;
        o && o.traverse(t);
      }
  }
  dispose() {
    const t = this._contents;
    if (t && t.length > 0)
      for (let e = 0; e < t.length; e++)
        t[e].dispose();
  }
  update(t) {
    const e = this._contents;
    e && e.length > 0 && e.forEach((i) => {
      i.update(t);
    });
  }
  get tileset() {
    return this._tileset;
  }
  get tile() {
    return this._tile;
  }
}
const rl = new Bn(), SZ = new B(), bZ = new B(), Qr = new B();
function BZ(s, t, e) {
  const i = s * Math.pow(10, t);
  return parseInt(i, 10) * Math.pow(10, e);
}
function Yx(s, t) {
  return H(s) && H(s.extensions) && H(s.extensions[t]);
}
function wZ(s) {
  let t = s._content;
  const e = s._tileset;
  if (!H(t)) {
    const n = Yx(s.content, "3DTILES_multiple_contents") ? s._header.extensions["3DTILES_multiple_contents"] : s._header;
    t = new yZ(
      e,
      s,
      s._contentResource.clone(),
      n
    ), s._content = t;
  }
  const i = t.requestInnerContents();
  if (!!H(i))
    return s._contentState = li.LOADING, i.then((n) => {
      if (!s.isDestroyed() && !!H(n))
        return s._contentState = li.PROCESSING, t;
    }).catch((n) => {
      if (!s.isDestroyed())
        return s._contentState = li.FAILED, n;
    });
}
function _Z(s) {
  return function() {
    return s._priority;
  };
}
function xZ(s) {
  const t = s._contentResource.clone(), e = new tc({
    throttle: !0,
    throttleByServer: !0,
    priorityFunction: _Z(s),
    serverKey: s._serverKey
  });
  s._request = e, t.request = e;
  const i = s._tileset, n = t.fetchArrayBuffer();
  if (!H(n)) {
    ++i.statistics.numberOfAttemptedRequests;
    return;
  }
  return RZ(s, i, e, !1, n);
}
function vZ(s, t) {
  const e = s * t;
  return 1 - Math.exp(-(e * e));
}
function TZ(s, t, e) {
  return JSON.parse(
    Sn(s, t, e)
  );
}
function LZ(s) {
  let t;
  try {
    t = TZ(s);
  } catch {
    throw new Error("Invalid tile content.");
  }
  return t;
}
function CI(s, t, e) {
  return Math.max(
    X.normalize(s, t, e) - X.EPSILON7,
    0
  );
}
function GZ(s, t) {
  const { tileset: e, boundingVolume: i } = s;
  i.getSphere(rl);
  const o = t._rendering.camera, r = rl.center, a = rl.radius, g = e._cameraInfo, c = bZ.copy(g.directionWC).multiplyScalar(s._centerZDepth), l = Qr.addVectors(
    g.position,
    c
  ), h = Qr.subVectors(l, r);
  if (h.length() > rl.radius) {
    const I = Qr.copy(h).normalize().multiplyScalar(a), M = Qr.addVectors(r, I);
    Qr.subVectors(M, g.position);
    const G = Qr.normalize();
    s._foveatedFactor = 1 - Math.abs(g.directionWC.dot(G));
  } else
    s._foveatedFactor = 0;
  const p = 1 - Math.cos(o.fov * 0.5), m = e.foveatedConeSize * p;
  if (s._foveatedFactor <= m)
    return !1;
  const b = p - m, S = X.clamp(
    (s._foveatedFactor - m) / b,
    0,
    1
  ), A = e.foveatedInterpolationCallback(
    e.foveatedMinimumScreenSpaceErrorRelaxation,
    e.screenSpaceError,
    S
  ), u = s._screenSpaceError === 0 && H(s.parent) ? s.parent._screenSpaceError * 0.5 : s._screenSpaceError;
  return e.screenSpaceError - A <= u * 4;
}
function MZ(s) {
  const t = new Uint8Array(s);
  let e = ex(t);
  if (e === "glTF" && (e = "glb"), kt.isBinaryFormat(e))
    return {
      contentType: e,
      binaryPayload: t
    };
  const i = LZ(t);
  if (H(i.root))
    return {
      contentType: kt.EXTERNAL_TILESET,
      jsonPayload: i
    };
  if (H(i.root))
    return {
      contentType: kt.EXTERNAL_TILESET,
      jsonPayload: i
    };
  if (H(i.asset))
    return {
      contentType: kt.GLTF,
      jsonPayload: i
    };
  if (H(i.tileAvailability))
    return {
      contentType: kt.IMPLICIT_SUBTREE_JSON,
      jsonPayload: i
    };
  if (H(i.type))
    return {
      contentType: kt.GEOJSON,
      jsonPayload: i
    };
  if (H(i.voxelTable))
    return {
      contentType: kt.VOXEL_JSON,
      jsonPayload: i
    };
  throw new Error("Invalid tile content.");
}
async function EZ(s, t) {
  const e = MZ(t), i = s._tileset;
  i._disableSkipLevelOfDetail = i._disableSkipLevelOfDetail || e.contentType === kt.GEOMETRY || e.contentType === kt.VECTOR, (e.contentType === kt.IMPLICIT_SUBTREE || e.contentType === kt.IMPLICIT_SUBTREE_JSON) && (s.hasImplicitContent = !0), e.contentType === kt.EXTERNAL_TILESET && (s.hasTilesetContent = !0);
  let n;
  const o = zx[e.contentType];
  if (s.isDestroyed())
    return;
  H(e.binaryPayload) ? n = await o(
    i,
    s,
    s._contentResource,
    e.binaryPayload.buffer,
    0
  ) : n = await Promise.resolve(
    o(
      i,
      s,
      s._contentResource,
      e.jsonPayload
    )
  );
  const r = s._contentHeader;
  if (s.hasImplicitContentMetadata) {
    const g = s.implicitSubtree, c = s.implicitCoordinates;
    n.metadata = g.getContentMetadataView(c, 0);
  } else
    s.hasImplicitContent || (n.metadata = Zx(i, r));
  const a = Wx(i, r);
  if (H(a) && (n.group = new Ux({
    metadata: a
  })), !s.hasTilesetContent && !s.hasImplicitContent) {
    const g = n.scene;
    H(g) && (n.byteSize = Ox(g));
  }
  return n;
}
async function RZ(s, t, e, i, n) {
  const o = s._contentState;
  s._contentState = li.LOADING, ++t.statistics.numberOfPendingRequests;
  let r;
  try {
    r = await n;
  } catch {
    if (--t.statistics.numberOfPendingRequests, s.isDestroyed())
      return;
    if (e.cancelled || e.state === Et.CANCELLED) {
      s._contentState = o, ++t.statistics.numberOfAttemptedRequests;
      return;
    }
    s._contentState = li.FAILED;
  }
  if (s.isDestroyed()) {
    --t.statistics.numberOfPendingRequests;
    return;
  }
  if (e.cancelled || e.state === Et.CANCELLED) {
    s._contentState = o, --t.statistics.numberOfPendingRequests, ++t.statistics.numberOfAttemptedRequests;
    return;
  }
  try {
    const a = await EZ(s, r);
    return --t.statistics.numberOfPendingRequests, s.isDestroyed() ? void 0 : (s._content = a, s._contentState = li.PROCESSING, a);
  } catch (a) {
    if (--t.statistics.numberOfPendingRequests, s.isDestroyed())
      return;
    throw s._contentState = li.FAILED, a;
  }
}
function DZ(s, t) {
  if (s.progressiveResolutionHeightFraction <= 0 || s.progressiveResolutionHeightFraction > 0.5)
    return !1;
  const e = s.screenSpaceError;
  let i = t._screenSpaceErrorProgressiveResolution > e;
  t._priorityProgressiveResolutionScreenSpaceErrorLeaf = !1;
  const n = t.parent, o = t._screenSpaceErrorProgressiveResolution <= e, r = H(n) && n._screenSpaceErrorProgressiveResolution > e;
  return o && r && (t._priorityProgressiveResolutionScreenSpaceErrorLeaf = !0, i = !0), i;
}
class Ny {
  constructor(t, e, i, n) {
    this._tileset = t, this._header = i, this.hasTilesetContent = !1, this.hasImplicitContent = !1, this.hasImplicitContentMetadata = !1, this._updatedVisibilityFrame = 0;
    const o = H(i.contents), r = o && i.contents.length > 1 || Yx(i, "3DTILES_multiple_contents"), a = o && !r ? i.contents[0] : i.content;
    this._contentHeader = a, this.transform = H(i.transform) ? new J().fromArray(i.transform) : new J();
    const g = H(n) ? n.computedTransform : t.modelMatrix, c = new J().copy(g).multiply(this.transform);
    this.computedTransform = c, this.metadata = lZ(t, i), this.geometricError = i.geometricError, this._geometricError = i.geometricError, H(this._geometricError) || (this._geometricError = H(n) ? n._geometricError : t._geometricError);
    let l;
    H(i.refine) ? l = i.refine.toUpperCase() === "REPLACE" ? gs.REPLACE : gs.ADD : H(n) ? l = n.refine : l = gs.REPLACE, this._parent = n;
    let h, d = !1, C, p;
    if (e = Lt.createIfNeeded(e), r)
      C = li.UNLOADED, p = e.clone();
    else if (H(a)) {
      let b = a.uri;
      H(a.url) && (console.warn(
        'This tileset JSON uses the "content.url" property which has been deprecated. Use "content.uri" instead.'
      ), b = a.url), b === "" ? (h = new Fn(t, this), d = !0, C = li.READY) : (C = li.UNLOADED, p = e.getDerivedResource({
        url: b
      }), Bi.getServerKey(
        p.getUrlComponent()
      ));
    } else
      h = new Fn(t, this), d = !0, C = li.READY;
    this._content = h, this._contentResource = p, this._contentState = C, this.hasEmptyContent = d, this.hasMultipleContents = r, this.refine = l, this.children = [], this.parent = n, this._screenSpaceError = 0, this._depthToCamera = 0, this._centerZDepth = 0, this._depth = 0, this._refines = !1, this.priorityDeferred = !1, this._visible = !1, this._inRequestVolume = !0, this.contentExpired = !1, this._isInRequestVolume = !0, this._priority = 0, this._priorityHolder = this, this._foveatedFactor = 0;
    const m = new sZ();
    "sphere" in i.boundingVolume && m.setSphereData(...i.boundingVolume.sphere, this.computedTransform), "box" in i.boundingVolume && m.setObbData(i.boundingVolume.box, this.computedTransform), "region" in i.boundingVolume && m.setRegionData(...i.boundingVolume.region), this.boundingVolume = m;
  }
  updatePriority() {
    const t = this.tileset, e = t.preferLeaves, i = t._minimumPriority, n = t._maximumPriority, o = 4, r = 1, a = 0, g = o, h = a + g + o, d = r, C = Math.pow(
      10,
      h
    ), p = h + d, m = Math.pow(10, p);
    let b = CI(
      this._depth,
      i.depth,
      n.depth
    );
    b = e ? 1 - b : b;
    const S = CI(
      this._priorityHolder._distanceToCamera,
      i.distance,
      n.distance
    ), A = BZ(
      S,
      g,
      a
    ), u = this._priorityProgressiveResolution ? 0 : C;
    CI(
      this._priorityHolder._foveatedFactor,
      i.foveatedFactor,
      n.foveatedFactor
    ), this.priorityDeferred;
    const y = this.isVisible ? 0 : Math.pow(10, 10);
    this._priority = b + A + y + u;
  }
  updateContent(t) {
    const e = this.tileset;
    t.update(this), e.dispatchEvent({
      type: "loaded",
      tile: this
    });
  }
  process(t) {
    this.contentReady || (this._selectedFrame = 0, this.lastStyleTime = 0, this._contentState = li.READY, !this.hasTilesetContent && !this.hasImplicitContent && (t._statistics.incrementLoadCounts(this.content), ++t._statistics.numberOfTilesWithContentReady, ++t._statistics.numberOfLoadedTilesTotal, t._cache.add(this)));
    try {
      const e = this._content;
      e.isTileset3DTileContent ? e.update(t) : this.updateContent(e);
    } catch {
      this._contentState = li.FAILED;
    }
  }
  update(t) {
  }
  cancelRequests() {
    this.hasMultipleContents ? this._content.cancelRequests() : this._request.cancel();
  }
  unloadContent() {
    if (!this.hasRenderableContent)
      return;
    const t = this._content;
    t && (t.dispose(), this.tileset.dispatchEvent({
      type: "dispose",
      tile: this
    }), this._content = null), this._contentState = li.UNLOADED;
  }
  requestContent() {
    if (!this.hasEmptyContent)
      return this.hasMultipleContents ? wZ(this) : xZ(this);
  }
  visibility() {
    const t = this.boundingVolume, n = this._tileset._cameraInfo.frustum;
    t.intersectsFrustum(n, !0) ? this._visible = !0 : this._visible = !1;
  }
  computeVisibility(t, e) {
    const o = this.tileset.getCamera().frustum;
    return this.intersectBoundingVolume(t, o);
  }
  intersectBoundingVolume(t, e) {
  }
  updateVisibility(t) {
    const { tileset: e } = this;
    this._updatedVisibilityFrame !== e._updatedVisibilityFrame && (this.updateTransform(), this._distanceToCamera = this.distanceToTile(), this._centerZDepth = this.distanceToTileCenter(t), this._screenSpaceError = this.getScreenSpaceError(), this._screenSpaceErrorProgressiveResolution = this.getScreenSpaceError(
      !1,
      this.tileset.progressiveResolutionHeightFraction
    ), this._priorityProgressiveResolution = DZ(e, this), this.priorityDeferred = GZ(this, t), this.visibility(), this._updatedVisibilityFrame = e._updatedVisibilityFrame);
  }
  updateTransform() {
    this.geometricError = this._geometricError;
  }
  distanceToTile() {
    const t = this.boundingVolume, e = this.tileset._cameraInfo;
    return t.distanceToPoint(e.position);
  }
  distanceToTileCenter(t) {
    this.boundingVolume;
    const i = this._tileset._cameraInfo, n = this.boundingVolumeCenter;
    return SZ.subVectors(
      n,
      i.position
    ).dot(i.directionWC);
  }
  getScreenSpaceError(t, e) {
    const i = this._tileset, n = W(e, 1), o = H(this.parent) ? this.parent.geometricError : i._scaledGeometricError, r = t ? o : this.geometricError;
    if (r === 0)
      return 0;
    const a = i._cameraInfo;
    this.boundingVolume;
    const g = a.invScale;
    let c;
    if (a.isOrthographic) {
      const l = a.pixelSize;
      c = r / (l * g);
    } else {
      const l = Math.max(this._distanceToCamera, 1e-7), h = l * g, d = a.sseDenominator;
      if (c = r * n / (h * d), i.dynamicScreenSpaceError) {
        const C = i._dynamicScreenSpaceErrorComputedDensity, p = i.dynamicScreenSpaceErrorFactor, m = vZ(l, C) * p;
        c -= m;
      }
    }
    return c;
  }
  getDistance() {
    return 100;
  }
  isDestroyed() {
    return !1;
  }
  get contentReady() {
    return this._contentState === li.READY;
  }
  get contentAvailable() {
    return this.contentReady && this.hasRenderableContent;
  }
  get hasRenderableContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent && !this.hasImplicitContent;
  }
  get isVisible() {
    return this._visible && this._inRequestVolume;
  }
  get tileset() {
    return this._tileset;
  }
  get hasUnloadedRenderableContent() {
    return this.hasRenderableContent && this.contentUnLoaded;
  }
  get contentUnLoaded() {
    return this._contentState === li.UNLOADED;
  }
  get content() {
    return this._content;
  }
  get cached() {
    return this._content;
  }
  get __visible() {
    const t = this._tileset;
    return this._selectedFrame === t._updatedVisibilityFrame;
  }
  get boundingVolumeCenter() {
    const t = this.boundingVolume.obb || this.boundingVolume.regionObb;
    return H(t) ? t.center : this.boundingVolume.sphere.center;
  }
}
class KZ {
}
const Fy = new Bn();
function HZ(s) {
  const { tileset: t } = s;
  if (!t._cullRequestsWhileMoving)
    return !0;
  const e = t._cameraInfo, {
    positionWCDeltaMagnitude: i,
    positionWCDeltaMagnitudeLastFrame: n
  } = e, o = i !== 0 ? i : n;
  s.boundingVolume.getSphere(Fy);
  const a = Math.max(Fy.radius * 2, 1);
  return t.cullRequestsWhileMovingMultiplier * o / a < 1;
}
class La {
  static selectTile(t, e) {
    t._wasSelectedLastFrame = !0;
    const { content: i, tileset: n } = t;
    t._selectedFrame = e.frameCount, n._selectedTiles.push(t);
  }
  static sortChildrenByDistanceToCamera(t, e) {
    return e._distanceToCamera === 0 && t._distanceToCamera === 0 ? e._centerZDepth - t._centerZDepth : e._distanceToCamera - t._distanceToCamera;
  }
  static canTraverse(t) {
    return t.children.length === 0 ? !1 : t.hasTilesetContent || t.hasImplicitContent ? !0 : t._screenSpaceError > t.tileset.screenSpaceError;
  }
  static visitTile(t, e) {
    ++t.tileset._statistics.visited, t._visitedFrame = e.frameCount;
  }
  static touchTile(t, e) {
    t._touchedFrame !== e.frameCount && (t.tileset._cache.touch(t), t._touchedFrame = e.frameCount);
  }
  static loadTile(t, e) {
    const { tileset: i } = t;
    t._requestedFrame === e.frameCount || !t.hasUnloadedRenderableContent || !HZ(t) || (t._requestedFrame = e.frameCount, i._requestedTiles.push(t));
  }
  static updateTile(t, e) {
    jx(t, e), t._wasMinPriorityChild = !1, t._priorityHolder = t, PZ(t), t._shouldSelect = !1, t._finalResolution = !0;
  }
}
function jx(s, t) {
  if (s.updateVisibility(t), !s.isVisible)
    return;
  const e = s.children.length > 0;
  if ((s.hasTilesetContent || s.hasImplicitContent) && e) {
    const o = s.children[0];
    jx(o, t), s._visible = o._visible;
    return;
  }
  if (FZ(s)) {
    s._visible = !1;
    return;
  }
  const i = s.refine === gs.REPLACE, n = s._optimChildrenWithinParent === ha.USE_OPTIMIZATION;
  if (i && n && e && !NZ(s, t)) {
    ++s.tileset._statistics.numberOfTilesCulledWithChildrenUnion, s._visible = !1;
    return;
  }
}
function PZ(s) {
  const t = s.tileset._minimumPriority, e = s.tileset._maximumPriority, i = s._priorityHolder;
  e.distance = Math.max(
    i._distanceToCamera,
    e.distance
  ), t.distance = Math.min(
    i._distanceToCamera,
    t.distance
  ), e.depth = Math.max(s._depth, e.depth), t.depth = Math.min(s._depth, t.depth), e.foveatedFactor = Math.max(
    i._foveatedFactor,
    e.foveatedFactor
  ), t.foveatedFactor = Math.min(
    i._foveatedFactor,
    t.foveatedFactor
  );
}
function NZ(s, t) {
  let e = !1;
  const i = s.children;
  for (let n = 0; n < i.length; ++n) {
    const o = i[n];
    o.updateVisibility(t), e = e || o.isVisible;
  }
  return e;
}
function FZ(s) {
  const { parent: t, tileset: e } = s;
  return !H(t) || t.hasTilesetContent || t.hasImplicitContent || t.refine !== gs.ADD ? !1 : s.getScreenSpaceError(!0) <= e.screenSpaceError;
}
class cf {
  constructor(t = 0) {
    t = W(t, 0), this._array = new Array(t), this._length = t;
  }
  get length() {
    return this._length;
  }
  set length(t) {
    const e = this._array, i = this._length;
    if (t < i)
      for (let n = t; n < i; ++n)
        e[n] = void 0;
    else
      t > e.length && (e.length = t);
    this._length = t;
  }
  get values() {
    return this._array;
  }
  get(t) {
    return this._array[t];
  }
  set(t, e) {
    t >= this._length && (this.length = t + 1), this._array[t] = e;
  }
  peek() {
    return this._array[this._length - 1];
  }
  push(t) {
    const e = this.length++;
    this._array[e] = t;
  }
  pop() {
    if (this._length === 0)
      return;
    const t = this._array[this._length - 1];
    return --this.length, t;
  }
  reserve(t) {
    t > this._array.length && (this._array.length = t);
  }
  resize(t) {
    this.length = t;
  }
  trim(t) {
    t = W(t, this._length), this._array.length = t;
  }
}
const Mg = {
  stack: new cf(),
  stackMaximumLength: 0
}, Eg = {
  stack: new cf(),
  stackMaximumLength: 0
}, kZ = {
  stack: new cf(),
  stackMaximumLength: 0
};
class VZ {
  static selectTiles(t, e) {
    t._requestedTiles.length = 0, t._selectedTiles.length = 0, t._selectedTilesToStyle.length = 0, t._emptyTiles.length = 0, t.hasMixedContent = !1;
    let i = t.root;
    if (La.updateTile(i, e), !i.isVisible || i.getScreenSpaceError(!0) < t.screenSpaceError)
      return;
    zZ(i, e), Mg.stack.trim(Mg.stackMaximumLength), Eg.stack.trim(Eg.stackMaximumLength);
    const n = t._requestedTiles;
    for (let o = 0; o < n.length; ++o)
      n[o].updatePriority();
  }
  static forEachLoadedTile(t, e) {
    const i = t.root;
    if (!H(i))
      return;
    const n = kZ.stack;
    for (n.push(i); n.length > 0; ) {
      const o = n.pop();
      o.children.forEach((g) => {
        n.push(g);
      });
      const a = o.content;
      if (o.hasRenderableContent && a) {
        const g = a.scene;
        e(g, o);
      }
    }
  }
}
function zZ(s, t) {
  const { tileset: e } = s, {
    canTraverse: i,
    loadTile: n,
    visitTile: o,
    touchTile: r
  } = La, a = Mg.stack;
  for (a.push(s); a.length > 0; ) {
    Mg.stackMaximumLength = Math.max(
      Mg.stackMaximumLength,
      a.length
    );
    const g = a.pop(), c = g.parent, l = !H(c) || c._refines;
    let h = !0;
    if (i(g)) {
      const p = XZ(g, a, t);
      h = p.anyChildrenVisible, g._refines = p.refines && l;
    } else
      g._refines = !1;
    const C = !g._refines && l;
    g.hasRenderableContent ? g.refine === gs.ADD ? (fI(g, t, h), n(g, t)) : g.refine === gs.REPLACE && (n(g, t), C && fI(g, t, h)) : (e._emptyTiles.push(g), n(g, t), C && fI(g, t, h)), o(g, t), r(g, t);
  }
}
function fI(s, t, e) {
  const i = s.refine === gs.REPLACE, n = s._optimChildrenWithinParent === ha.USE_OPTIMIZATION, o = s.children && s.children.length > 0, r = n && o && i;
  if (s.contentAvailable) {
    if (r && !e) {
      ++s.tileset._statistics.numberOfTilesCulledWithChildrenUnion;
      return;
    }
    La.selectTile(s, t);
  }
}
function XZ(s, t, e) {
  const i = s.refine === gs.REPLACE, { tileset: n, children: o } = s, { updateTile: r, loadTile: a, touchTile: g } = La;
  for (let p = 0; p < o.length; p++)
    r(o[p], e);
  o.sort(La.sortChildrenByDistanceToCamera);
  const c = i && s.hasRenderableContent;
  let l = !0, h = !1, d = -1, C = Number.MAX_VALUE;
  for (let p = 0; p < o.length; ++p) {
    const m = o[p];
    if (m.isVisible ? (t.push(m), m._foveatedFactor < C && (d = p, C = m._foveatedFactor), h = !0) : (c || n.loadSiblings) && (m._foveatedFactor < C && (d = p, C = m._foveatedFactor), a(m, e), g(m, e)), c) {
      let b;
      m._isInRequestVolume ? m.hasRenderableContent ? b = m.contentAvailable : b = WZ(m, e) : b = !1, l = l && !(m.isVisible && !b);
    }
  }
  if (h || (l = !1), d !== -1 && i) {
    const p = o[d];
    p._wasMinPriorityChild = !0;
    const m = (s._wasMinPriorityChild || s === n.root) && C <= s._priorityHolder._foveatedFactor ? s._priorityHolder : s;
    m._foveatedFactor = Math.min(
      p._foveatedFactor,
      m._foveatedFactor
    ), m._distanceToCamera = Math.min(
      p._distanceToCamera,
      m._distanceToCamera
    );
    for (let b = 0; b < o.length; ++b)
      o[b]._priorityHolder = m;
  }
  return {
    refines: l,
    anyChildrenVisible: h
  };
}
function WZ(s, t) {
  const {
    canTraverse: e,
    updateTile: i,
    loadTile: n,
    touchTile: o
  } = La;
  let r = !0;
  const a = Eg.stack;
  for (a.push(s); a.length > 0; ) {
    Eg.stackMaximumLength = Math.max(
      Eg.stackMaximumLength,
      a.length
    );
    const g = a.pop(), c = g.children, l = c.length, h = !g.hasRenderableContent && e(g);
    if (!h && !g.contentAvailable && (r = !1), i(g, t), g.isVisible || (n(g, t), o(g, t)), h)
      for (let d = 0; d < l; ++d) {
        const C = c[d];
        a.push(C);
      }
  }
  return s.hasEmptyContent || r;
}
class ZZ {
  constructor(t, e, i) {
    const n = Ei(e, "3DTILES_implicit_tiling") ? e.extensions["3DTILES_implicit_tiling"] : e.implicitTiling;
    this.baseResource = t, this.geometricError = e.geometricError, this.metadataSchema = i;
    const o = e.boundingVolume;
    if (!H(o.box) && !H(o.region) && !Ei(o, "3DTILES_bounding_volume_S2") && !Ei(o, "3DTILES_bounding_volume_cylinder"))
      throw new Error(
        "Only box, region, 3DTILES_bounding_volume_S2, and 3DTILES_bounding_volume_cylinder are supported for implicit tiling"
      );
    this.boundingVolume = o, this.refine = e.refine, this.subtreeUriTemplate = new Lt({ url: n.subtrees.uri }), this.contentUriTemplates = [], this.contentHeaders = [];
    const r = UZ(e);
    for (let a = 0; a < r.length; a++) {
      const g = r[a];
      this.contentHeaders.push(dt(g, !0));
      const c = new Lt({
        url: g.uri
      });
      this.contentUriTemplates.push(c);
    }
    this.contentCount = this.contentHeaders.length, this.tileHeader = OZ(e), this.subdivisionScheme = qt[n.subdivisionScheme], this.branchingFactor = qt.getBranchingFactor(this.subdivisionScheme), this.subtreeLevels = n.subtreeLevels, H(n.availableLevels) ? this.availableLevels = n.availableLevels : this.availableLevels = n.maximumLevel + 1;
  }
}
function UZ(s) {
  if (Ei(s, "3DTILES_multiple_contents")) {
    const t = s.extensions["3DTILES_multiple_contents"];
    return H(t.contents) ? t.contents : t.content;
  }
  return H(s.contents) ? s.contents : H(s.content) ? [s.content] : [];
}
function OZ(s) {
  const t = dt(s, !0);
  return H(t.extensions) && (delete t.extensions["3DTILES_implicit_tiling"], delete t.extensions["3DTILES_multiple_contents"], Object.keys(t.extensions).length === 0 && delete t.extensions), delete t.implicitTiling, delete t.contents, delete t.content, t;
}
const Go = {};
function ky(s) {
  return s = (s ^ s << 8) & 16711935, s = (s ^ s << 4) & 252645135, s = (s ^ s << 2) & 858993459, s = (s ^ s << 1) & 1431655765, s;
}
function pI(s) {
  return s = (s ^ s << 16) & 50331903, s = (s ^ s << 8) & 50393103, s = (s ^ s << 4) & 51130563, s = (s ^ s << 2) & 153391689, s;
}
function Vy(s) {
  return s &= 1431655765, s = (s ^ s >> 1) & 858993459, s = (s ^ s >> 2) & 252645135, s = (s ^ s >> 4) & 16711935, s = (s ^ s >> 8) & 65535, s;
}
function mI(s) {
  return s &= 153391689, s = (s ^ s >> 2) & 51130563, s = (s ^ s >> 4) & 50393103, s = (s ^ s >> 8) & 4278190335, s = (s ^ s >> 16) & 1023, s;
}
Go.encode2D = function(s, t) {
  return (ky(s) | ky(t) << 1) >>> 0;
};
Go.decode2D = function(s, t) {
  return H(t) || (t = new Array(2)), t[0] = Vy(s), t[1] = Vy(s >> 1), t;
};
Go.encode3D = function(s, t, e) {
  return pI(s) | pI(t) << 1 | pI(e) << 2;
};
Go.decode3D = function(s, t) {
  return H(t) || (t = new Array(3)), t[0] = mI(s), t[1] = mI(s >> 1), t[2] = mI(s >> 2), t;
};
const zy = [0, 0, 0];
class Yi {
  constructor(t) {
    this.subdivisionScheme = t.subdivisionScheme, this.subtreeLevels = t.subtreeLevels, this.level = t.level, this.x = t.x, this.y = t.y, this.z = void 0, t.subdivisionScheme === qt.OCTREE && (this.z = t.z);
  }
  getDescendantCoordinates(t) {
    const e = this.level + t.level, i = (this.x << t.level) + t.x, n = (this.y << t.level) + t.y;
    if (this.subdivisionScheme === qt.OCTREE) {
      const o = (this.z << t.level) + t.z;
      return new Yi({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: e,
        x: i,
        y: n,
        z: o
      });
    }
    return new Yi({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: e,
      x: i,
      y: n
    });
  }
  getAncestorCoordinates(t) {
    const e = 1 << t, i = this.level - t, n = Math.floor(this.x / e), o = Math.floor(this.y / e);
    if (this.subdivisionScheme === qt.OCTREE) {
      const r = Math.floor(this.z / e);
      return new Yi({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: i,
        x: n,
        y: o,
        z: r
      });
    }
    return new Yi({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: i,
      x: n,
      y: o
    });
  }
  getOffsetCoordinates(t) {
    const e = t.level - this.level, i = 1 << e, n = t.x % i, o = t.y % i;
    if (this.subdivisionScheme === qt.OCTREE) {
      const r = t.z % i;
      return new Yi({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: e,
        x: n,
        y: o,
        z: r
      });
    }
    return new Yi({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: e,
      x: n,
      y: o
    });
  }
  getChildCoordinates(t) {
    const e = this.level + 1, i = 2 * this.x + t % 2, n = 2 * this.y + Math.floor(t / 2) % 2;
    if (this.subdivisionScheme === qt.OCTREE) {
      const o = 2 * this.z + Math.floor(t / 4) % 2;
      return new Yi({
        subdivisionScheme: this.subdivisionScheme,
        subtreeLevels: this.subtreeLevels,
        level: e,
        x: i,
        y: n,
        z: o
      });
    }
    return new Yi({
      subdivisionScheme: this.subdivisionScheme,
      subtreeLevels: this.subtreeLevels,
      level: e,
      x: i,
      y: n
    });
  }
  getSubtreeCoordinates() {
    return this.getAncestorCoordinates(this.level % this.subtreeLevels);
  }
  getParentSubtreeCoordinates() {
    return this.getAncestorCoordinates(
      this.level % this.subtreeLevels + this.subtreeLevels
    );
  }
  isAncestor(t) {
    const e = t.level - this.level;
    if (e <= 0)
      return !1;
    const i = t.x >> e, n = t.y >> e, o = this.x === i, r = this.y === n;
    if (this.subdivisionScheme === qt.OCTREE) {
      const a = t.z >> e, g = this.z === a;
      return o && r && g;
    }
    return o && r;
  }
  isEqual(t) {
    return this.subdivisionScheme === t.subdivisionScheme && this.subtreeLevels === t.subtreeLevels && this.level === t.level && this.x === t.x && this.y === t.y && (this.subdivisionScheme === qt.OCTREE ? this.z === t.z : !0);
  }
  isImplicitTilesetRoot() {
    return this.level === 0;
  }
  isSubtreeRoot() {
    return this.level % this.subtreeLevels === 0;
  }
  isBottomOfSubtree() {
    return this.level % this.subtreeLevels === this.subtreeLevels - 1;
  }
  getTemplateValues() {
    const t = {
      level: this.level,
      x: this.x,
      y: this.y
    };
    return this.subdivisionScheme === qt.OCTREE && (t.z = this.z), t;
  }
  static fromMortonIndex(t, e, i, n) {
    let o;
    return t === qt.OCTREE ? (o = Go.decode3D(
      n,
      zy
    ), new Yi({
      subdivisionScheme: t,
      subtreeLevels: e,
      level: i,
      x: o[0],
      y: o[1],
      z: o[2]
    })) : (o = Go.decode2D(n, zy), new Yi({
      subdivisionScheme: t,
      subtreeLevels: e,
      level: i,
      x: o[0],
      y: o[1]
    }));
  }
  static fromTileIndex(t, e, i) {
    let n, o, r;
    return t === qt.OCTREE ? (n = Math.floor(Math.log2(7 * i + 1) / 3), o = ((1 << 3 * n) - 1) / 7, r = i - o) : (n = Math.floor(Math.log2(3 * i + 1) / 2), o = ((1 << 2 * n) - 1) / 3, r = i - o), Yi.fromMortonIndex(
      t,
      e,
      n,
      r
    );
  }
  get childIndex() {
    let t = 0;
    return t |= this.x & 1, t |= (this.y & 1) << 1, this.subdivisionScheme === qt.OCTREE && (t |= (this.z & 1) << 2), t;
  }
  get mortonIndex() {
    return this.subdivisionScheme === qt.OCTREE ? Go.encode3D(this.x, this.y, this.z) : Go.encode2D(this.x, this.y);
  }
  get tileIndex() {
    const t = this.subdivisionScheme === qt.OCTREE ? ((1 << 3 * this.level) - 1) / 7 : ((1 << 2 * this.level) - 1) / 3, e = this.mortonIndex;
    return t + e;
  }
}
const Xy = new B(), al = new B(), Wy = new B(), Jn = new B();
new B();
new B();
function QZ(s) {
  const {
    latStart: t = -Math.PI / 2,
    latEnd: e = Math.PI / 2,
    lonStart: i = 0,
    lonEnd: n = 2 * Math.PI,
    heightStart: o = 0,
    heightEnd: r = 0
  } = s, a = new Nt(1, 1, 1, 32, 32), { normal: g, position: c } = a.attributes, l = c.clone();
  for (let h = 0; h < c.count; ++h) {
    Jn.fromBufferAttribute(c, h);
    const d = ce.mapLinear(Jn.x, -0.5, 0.5, t, e), C = ce.mapLinear(Jn.y, -0.5, 0.5, i, n);
    let p = o;
    Jn.z < 0 && (p = r), s.cartographicToCartesian(Wy.set(C, d, p), Jn), c.setXYZ(h, ...Jn);
  }
  a.computeVertexNormals();
  for (let h = 0, d = l.count; h < d; h++) {
    Jn.fromBufferAttribute(l, h);
    const C = ce.mapLinear(Jn.x, -0.5, 0.5, t, e), p = ce.mapLinear(Jn.y, -0.5, 0.5, i, n);
    Xy.fromBufferAttribute(g, h), s.geodeticSurfaceNormalCartographic(Wy.set(p, C, 0), al), Math.abs(Xy.dot(al)) > 0.1 && (Jn.z > 0 && al.multiplyScalar(-1), g.setXYZ(h, ...al));
  }
  return a;
}
class YZ extends Ma {
  constructor(t = new Xx(), e = 16776960) {
    super(), this.ellipsoidRegion = t, this.material.color.set(e), this.update();
  }
  update() {
    const t = QZ(this.ellipsoidRegion);
    this.geometry.dispose(), this.geometry = new QT(t, 80);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const Gn = new B(), Zy = ["x", "y", "z"];
class jZ extends Ma {
  constructor(t, e = 16776960, i = 40) {
    const n = new Qe(), o = [];
    for (let r = 0; r < 3; r++) {
      const a = Zy[r], g = Zy[(r + 1) % 3];
      Gn.set(0, 0, 0);
      for (let c = 0; c < i; c++) {
        let l;
        l = 2 * Math.PI * c / (i - 1), Gn[a] = Math.sin(l), Gn[g] = Math.cos(l), o.push(Gn.x, Gn.y, Gn.z), l = 2 * Math.PI * (c + 1) / (i - 1), Gn[a] = Math.sin(l), Gn[g] = Math.cos(l), o.push(Gn.x, Gn.y, Gn.z);
      }
    }
    n.setAttribute("position", new Fe(new Float32Array(o), 3)), n.computeBoundingSphere(), super(n, new _r({ color: e, toneMapped: !1 })), this.sphere = t, this.type = "SphereHelper";
  }
  updateMatrixWorld(t) {
    const e = this.sphere;
    this.position.copy(e.center), this.scale.setScalar(e.radius), super.updateMatrixWorld(t);
  }
}
const JZ = Symbol("ORIGINAL_MATERIAL"), yI = () => {
}, SI = {};
function bI(s) {
  if (!SI[s]) {
    const t = Math.random(), e = 0.5 + Math.random() * 0.5, i = 0.375 + Math.random() * 0.25;
    SI[s] = new Ce().setHSL(t, e, i);
  }
  return SI[s];
}
const qZ = 0;
class $Z {
  constructor(t) {
    t = {
      displayBoxBounds: !1,
      displaySphereBounds: !1,
      displayRegionBounds: !0,
      colorMode: qZ,
      maxDebugDepth: -1,
      maxDebugDistance: -1,
      maxDebugError: -1,
      customColorCallback: null,
      ...t
    }, this.name = "DEBUG_TILES_PLUGIN", this.tiles = null, this.extremeDebugDepth = -1, this.extremeDebugError = -1, this.boxGroup = null, this.sphereGroup = null, this.regionGroup = null, this.displayBoxBounds = t.displayBoxBounds, this.displaySphereBounds = t.displaySphereBounds, this.displayRegionBounds = t.displayRegionBounds, this.colorMode = t.colorMode, this.maxDebugDepth = t.maxDebugDepth, this.maxDebugDistance = t.maxDebugDistance, this.maxDebugError = t.maxDebugError, this.customColorCallback = t.customColorCallback, this.getDebugColor = (e, i) => {
      i.setRGB(e, e, e);
    };
  }
  init(t) {
    this.tileset = t;
    const e = t.group;
    this.boxGroup = new mt(), this.boxGroup.name = "DebugTilesRenderer.boxGroup", e.add(this.boxGroup), this.boxGroup.updateMatrixWorld(), this.sphereGroup = new mt(), this.sphereGroup.name = "DebugTilesRenderer.sphereGroup", e.add(this.sphereGroup), this.sphereGroup.updateMatrixWorld(), this.regionGroup = new mt(), this.regionGroup.name = "DebugTilesRenderer.regionGroup", e.add(this.regionGroup), this.regionGroup.updateMatrixWorld(), this._onLoadTileSetCB = (i) => {
    }, this._onLoadTileCB = ({ scene: i, tile: n }) => {
      this._onLoadTile(n);
    }, this._onDisposeTileCB = ({ tile: i }) => {
      this._onDisposeTile(i);
    }, this._onUpdateAfterCB = () => {
      this._onUpdateAfter();
    }, this._onTileVisibilityChangeCB = ({ scene: i, tile: n, visible: o }) => {
      this._onTileVisibilityChange(n, o);
    }, t.addEventListener("loaded", this._onLoadTileCB), t.addEventListener("dispose", this._onDisposeTileCB), t.addEventListener("update-after", this._onUpdateAfterCB), t.addEventListener("visibilitychange", this._onTileVisibilityChangeCB), t.traversalLoadedTile((i, n) => {
      this._onLoadTile(n);
    }), t._selectedTiles.forEach((i) => {
      this._onTileVisibilityChange(i, !0);
    });
  }
  _onLoadTile(t) {
    const e = t.content, i = t.boundingVolume, { obb: n, sphere: o, region: r, regionObb: a } = i, g = t.tileset._selectedTiles;
    if (n) {
      const c = new mt();
      c.name = "DebugTilesRenderer.boxHelperGroup", c.matrix.copy(n.transform), c.matrixAutoUpdate = !1;
      const l = new $l(n.box, bI(t._depth));
      l.raycast = yI, c.add(l), e.boxHelperGroup = c, g.includes(t) && this.displayBoxBounds && (this.boxGroup.add(c), c.updateMatrixWorld());
    }
    if (o) {
      const c = new jZ(
        o,
        bI(t._depth)
      );
      c.raycast = yI, e.sphereHelper = c, g.includes(t) && this.displaySphereBounds && (this.boxGroup.add(c), c.updateMatrixWorld());
    }
    if (r) {
      const c = new YZ(r, bI(t._depth));
      c.raycast = yI;
      const l = a.center;
      c.position.copy(l);
      const h = l.clone().multiplyScalar(-1);
      c.geometry.translate(...h), e.regionHelper = c, g.includes(t) && this.displayRegionBounds && (this.regionGroup.add(c), c.updateMatrixWorld(!0));
    }
    e.traverse((c) => {
      const l = c.material;
      l && (c[JZ] = l);
    });
  }
  _onDisposeTile(t) {
    const e = t.content;
    e.boxHelperGroup && (e.boxHelperGroup.removeFromParent(), e.boxHelperGroup.children[0].geometry.dispose(), delete e.boxHelperGroup), e.sphereHelper && (e.sphereHelper.removeFromParent(), e.sphereHelper.geometry.dispose(), delete e.sphereHelper), e.regionHelper && (e.regionHelper.removeFromParent(), e.regionHelper.geometry.dispose(), delete e.regionHelper);
  }
  _initExtremes(t) {
  }
  _onUpdateAfter() {
    !this.tileset.root || (this.boxGroup.visible = this.displayBoxBounds, this.sphereGroup.visible = this.displaySphereBounds, this.regionGroup.visible = this.displayRegionBounds);
  }
  _onTileVisibilityChange(t, e) {
    const i = t.content, n = this.sphereGroup, o = this.boxGroup, r = this.regionGroup, a = i.boxHelperGroup, g = i.sphereHelper, c = i.regionHelper;
    e ? (a && (o.add(a), a.updateMatrixWorld(!0)), g && (n.add(g), g.updateMatrixWorld(!0)), c && (r.add(c), c.updateMatrixWorld(!0))) : (a && o.remove(a), g && n.remove(g), c && r.remove(c));
  }
  dispose() {
    const t = this.tileset;
    t.removeEventListener("loaded", this._onLoadTileCB), t.removeEventListener("dispose", this._onDisposeModelCB), t.removeEventListener("update-after", this._onUpdateAfterCB), t.removeEventListener("visibilitychange", this._onTileVisibilityChangeCB), t.traversalLoadedTile((e, i) => {
      this._onDisposeTile(i);
    }), this.boxGroup.removeFromParent(), this.sphereGroup.removeFromParent(), this.regionGroup.removeFromParent();
  }
}
const eU = parseInt(Hh, 10) < 165, xh = new J(), Jx = new yt(), BI = new B(), Ol = [];
function qx(s, t) {
  return s.distance - t.distance;
}
function vA(s, t, e) {
  eU ? (s.traverse((i) => {
    Object.getPrototypeOf(i).raycast.call(i, t, e);
  }), Ol.sort(qx)) : t.intersectObject(s, !0, e);
}
function tU(s, t) {
  vA(s, t, Ol);
  const e = Ol[0] || null;
  return Ol.length = 0, e;
}
function $x(s, t, e, i = null) {
  const { group: n } = s, o = t.content;
  i === null && (i = Jx, xh.copy(n.matrixWorld).invert(), i.copy(e.ray).applyMatrix4(xh));
  const r = [], a = t.children;
  for (let h = 0; h < a.length; h++) {
    const d = a[h];
    if (d._touchedFrame !== s._updatedVisibilityFrame)
      continue;
    d.boundingVolume.intersectRay(i, BI) !== null && (BI.applyMatrix4(n.matrixWorld), r.push({
      distance: BI.distanceToSquared(e.ray.origin),
      tile: d
    }));
  }
  r.sort(qx);
  let g = null, c = null;
  const l = !t.isVisible && t._touchedFrame === s._updatedVisibilityFrame;
  if ((t.__visible || l) && t.hasRenderableContent && o) {
    const h = o.scene, d = tU(h, e);
    d && (g = d, c = Math.pow(d.distance, 2));
  }
  for (let h = 0, d = r.length; h < d; h++) {
    const C = r[h], p = C.distance, m = C.tile;
    if (p > c)
      break;
    const b = $x(s, m, e, i);
    if (b) {
      const S = b.distance * b.distance;
      S < c && (g = b, c = S);
    }
  }
  return g;
}
function ev(s, t, e, i, n = null) {
  const { group: o } = s, { content: r, boundingVolume: a } = t;
  if (n === null && (n = Jx, xh.copy(o.matrixWorld).invert(), n.copy(e.ray).applyMatrix4(xh)), t._touchedFrame !== s._updatedVisibilityFrame || !a.intersectsRay(n))
    return;
  const g = !t.isVisible && t._touchedFrame === s._updatedVisibilityFrame;
  if ((t.__visible || g) && t.hasRenderableContent && r)
    if (r.isMultiple3DTileContents)
      r._contents.forEach((h) => {
        const d = h.scene;
        d && vA(d, e, i);
      });
    else {
      const l = r.scene;
      vA(l, e, i);
    }
  const c = t.children;
  for (let l = 0; l < c.length; l++)
    ev(s, c[l], e, i, n);
}
class iU {
  constructor(t) {
    f(this, "_tileMaxLevel", 19);
    f(this, "_subscribedMaxLodLevel", 1);
    f(this, "_elementHandlers", []);
    f(this, "_objectParent", null);
    f(this, "subscribedDataTypeMap", {});
    f(this, "_active", !1);
    f(this, "_configVersion", 0);
    f(this, "shouldIgnoreTile", (t) => t.__lodLevel > this._subscribedMaxLodLevel);
    f(this, "parseElements", (t) => {
      const e = t.cached.scene, i = e.batchTable && e.batchTable.header;
      if (!i || !i.id || !i.dataType)
        return;
      const n = i.id, o = i.dataType, r = {}, a = /* @__PURE__ */ new Map();
      let g = null, c = null, l = null;
      for (let h = 0, d = o.length; h < d; h++) {
        if (!this.subscribedDataTypeMap[o[h]])
          continue;
        g = o[h], c = this.subscribedDataTypeMap[g], l = n[h];
        const C = {
          id: l,
          dataType: g,
          position: [],
          uv: [],
          normal: [],
          index: []
        };
        r[h] = C;
        const p = a.get(c);
        p ? p.push(C) : a.set(c, [
          C
        ]);
      }
      for (const h of e.children)
        this.findElementInMesh(h, r, a);
      for (const h of a.keys()) {
        const d = a.get(h);
        h.addTileElementObjects(t, d);
      }
    });
    f(this, "getInterleavedBufferValue2", (t, e) => {
      const i = t.data.array, n = t.data.stride * e + t.offset;
      return [i[n], i[n + 1]];
    });
    f(this, "getInterleavedBufferValue3", (t, e) => {
      const i = t.data.array, n = t.data.stride * e + t.offset;
      return [i[n], i[n + 1], i[n + 2]];
    });
    f(this, "findElementInMesh", (t, e, i) => {
      if (!t || !t.geometry)
        return;
      const n = t.geometry.getAttribute("_batchid");
      if (!n)
        return;
      const o = t.geometry.getAttribute("normal");
      if (!o)
        return;
      const r = t.geometry.getAttribute("position"), a = t.geometry.getAttribute("uv"), g = n.data.count, c = {};
      let l = null;
      for (let d = 0; d < g; d++) {
        if (l = n.getX(d), !e[l])
          continue;
        let C = e[l], p = this.getInterleavedBufferValue3(r, d), m = this.getInterleavedBufferValue3(o, d), b = this.getInterleavedBufferValue2(a, d);
        C.position.push(p[0], p[1], p[2]), C.normal.push(m[0], m[1], m[2]), C.uv.push(b[0], b[1]), c[d] = {
          batchId: l,
          index: C.position.length / 3 - 1
        };
      }
      const h = t.geometry.index.array;
      for (let d = 0, C = h.length - 2; d < C; d += 3) {
        let p = h[d];
        if (c[p] === void 0)
          continue;
        let m = h[d + 1], b = h[d + 2], S = c[p], A = S.batchId, u = S.index, y = c[m] && c[m].index, I = c[b] && c[b].index;
        if (y === void 0 || I === void 0) {
          console.warn("one face includes more than one object");
          continue;
        }
        e[A].index.push(u, y, I);
      }
      for (const d of Object.keys(e)) {
        const C = e[d], p = new Qe();
        p.setAttribute("position", new Fe(new Float32Array(C.position), 3)), p.setAttribute("normal", new Fe(new Float32Array(C.normal), 3)), p.setAttribute("uv", new Fe(new Float32Array(C.uv), 2)), p.setIndex(C.index), C.geometry = p;
      }
    });
    f(this, "onTileLoad", (t, e) => {
      this.parseTileInfo(t), this.shouldIgnoreTile(t);
    });
    f(this, "onTileDispose", (t, e) => {
      if (!this.shouldIgnoreTile(t))
        for (const i of this._elementHandlers)
          i.disposeTileElementObjects(t);
    });
    f(this, "onTileShow", (t) => {
      !this._active || this.shouldIgnoreTile(t) || this.refreshTile(t);
    });
    f(this, "onTileHide", (t) => {
      if (!(!this._active || this.shouldIgnoreTile(t)))
        for (const e of this._elementHandlers)
          e.hideTileElementObjects(t);
    });
    f(this, "parseTileInfo", (t) => {
      const e = t._contentResource.url, i = e.substring(e.lastIndexOf("/") + 1).split(".")[0], n = i.split("-");
      t.__id = i, t.__level = parseInt(n[0], 10), t.__lodLevel = this._tileMaxLevel - t.__level;
    });
    f(this, "refreshTile", (t) => {
      if (t.__elementsConfigVersion !== this._configVersion) {
        for (const e of this._elementHandlers)
          e.disposeTileElementObjects(t);
        this.parseElements(t), t.__elementsConfigVersion = this._configVersion;
      }
      for (const e of this._elementHandlers)
        e.showTileElementObjects(t);
    });
    f(this, "refreshTiles", () => {
      this.tilesRenderer.forEachLoadedModel((t, e) => {
        !e.__visible || this.shouldIgnoreTile(e) || this.refreshTile(e);
      }), this.engine.requestRender();
    });
    this._objectParent = t;
  }
  registerElement(t) {
    t.parent = this._objectParent, t.engine = this.engine;
    for (const e of t.subscribedDataTypeIds)
      this.subscribedDataTypeMap[e] = t;
    return this._elementHandlers.push(t), this._configVersion++, this._active = !0, this.refreshTiles(), t;
  }
  unregisterElement(t) {
    for (let i of Object.keys(this.subscribedDataTypeMap))
      this.subscribedDataTypeMap[i] === t && delete this.subscribedDataTypeMap[i];
    let e = this._elementHandlers.indexOf(t);
    e > -1 && (t.dispose(), this._elementHandlers.splice(e, 1)), this._configVersion++, this._active = this._elementHandlers.length > 0, this.refreshTiles();
  }
  tick(t) {
    if (!!this._active)
      for (const e of this._elementHandlers)
        e.tick(t);
  }
  get subscribedMaxLodLevel() {
    return this._subscribedMaxLodLevel;
  }
  set subscribedMaxLodLevel(t) {
    this._subscribedMaxLodLevel = t;
  }
}
class nU {
  constructor(t) {
    t = W(t, {});
    const e = t.tileset, i = t.class, n = H(e.properties) ? e.properties : {};
    this._class = i, this._properties = n, this._extras = e.extras, this._extensions = e.extensions;
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, this._class);
  }
  hasPropertyBySemantic(t) {
    return ke.hasPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  getPropertyIds(t) {
    return ke.getPropertyIds(this._properties, this._class, t);
  }
  getProperty(t) {
    return ke.getProperty(t, this._properties, this._class);
  }
  setProperty(t, e) {
    return ke.setProperty(
      t,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(t) {
    return ke.getPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(t, e) {
    return ke.setPropertyBySemantic(
      t,
      e,
      this._properties,
      this._class
    );
  }
  get class() {
    return this._class;
  }
  get extra() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
class Uy {
  constructor(t = {}) {
    t = W(t, {});
    const { id: e, group: i, class: n } = t;
    this._id = e, this._class = n, this._properties = H(i.properties) ? i.properties : {}, this._extras = i.extras, this._extensions = i.extensions;
  }
  get class() {
    return this._class;
  }
  get id() {
    return this._id;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
  hasProperty(t) {
    return ke.hasProperty(t, this._properties, this._class);
  }
  hasPropertyBySemantic(t) {
    return ke.hasPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  getPropertyIds(t) {
    return ke.getPropertyIds(this._properties, this._class, t);
  }
  getProperty(t) {
    return ke.getProperty(t, this._properties, this._class);
  }
  setProperty(t, e) {
    return ke.setProperty(
      t,
      e,
      this._properties,
      this._class
    );
  }
  getPropertyBySemantic(t) {
    return ke.getPropertyBySemantic(
      t,
      this._properties,
      this._class
    );
  }
  setPropertyBySemantic(t, e) {
    return ke.setPropertyBySemantic(
      t,
      e,
      this._properties,
      this._class
    );
  }
}
class sU {
  constructor(t) {
    t = W(t, {});
    const e = t.metadataJson, i = t.schema, n = W(e.metadata, e.tileset);
    let o;
    H(n) && (o = new nU({
      tileset: n,
      class: i.classes[n.class]
    }));
    let r = [];
    const a = [], g = e.groups;
    if (Array.isArray(g)) {
      const c = g.length;
      for (let l = 0; l < c; l++) {
        const h = g[l];
        a.push(
          new Uy({
            group: h,
            class: i.classes[h.class]
          })
        );
      }
    } else if (H(g)) {
      r = Object.keys(g).sort();
      const c = r.length;
      for (let l = 0; l < c; l++) {
        const h = r[l];
        if (g.hasOwnProperty(h)) {
          const d = g[h];
          a.push(
            new Uy({
              id: h,
              group: g[h],
              class: i.classes[d.class]
            })
          );
        }
      }
    }
    this._schema = i, this._groups = a, this._groupIds = r, this._tileset = o, this._statistics = e.statistics, this._extras = e.extras, this._extensions = e.extensions;
  }
  get schema() {
    return this._schema;
  }
  get groups() {
    return this._groups;
  }
  get groupIds() {
    return this._groupIds;
  }
  get tileset() {
    return this._tileset;
  }
  get statistics() {
    return this._statistics;
  }
  get extras() {
    return this._extras;
  }
  get extensions() {
    return this._extensions;
  }
}
const oU = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZjJlYTllMy1kYWRiLTQwYjctOGZhOS02NGJkOTJhYTA1ODUiLCJpZCI6MjU5LCJpYXQiOjE3Mjc3OTI2NzB9.XbfI79d1v3T5OpMl4CznrcBuctSfW1lycPWlt8bq_1A", vh = {};
vh.defaultAccessToken = oU;
vh.defaultServer = new Lt({ url: "https://api.cesium.com/" });
function rU(s, t) {
  const e = W(s._ionRoot, s), i = e._ionEndpointResource, n = typeof Image < "u";
  return !H(t) || t.statusCode !== 401 && !(n && t.target instanceof Image) ? Promise.resolve(!1) : (H(e._pendingPromise) || (e._pendingPromise = i.fetchJson().then(function(o) {
    return e._ionEndpoint = o, o;
  }).finally(function(o) {
    return e._pendingPromise = void 0, o;
  })), e._pendingPromise.then(function(o) {
    return s._ionEndpoint = o, !0;
  }));
}
const Kg = class extends Lt {
  constructor(t, e) {
    let i;
    const n = t.externalType, o = H(n);
    if (!o)
      i = {
        url: t.url,
        retryAttempts: 1,
        retryCallback: rU
      };
    else if (n === "3DTILES" || n === "STK_TERRAIN_SERVER")
      i = { url: t.options.url };
    else
      throw new Error(
        "Ion.createResource does not support external imagery assets; use IonImageryProvider instead."
      );
    super(i), this._ionEndpoint = t, this._ionEndpointDomain = o ? void 0 : new Zs(t.url).authority(), this._ionEndpointResource = e, this._ionRoot = void 0, this._pendingPromise = void 0, this._credits = void 0, this._isExternal = o;
  }
  static fromAssetId(t, e) {
    const i = Kg._createEndpointResource(
      t,
      e
    );
    return i.fetchJson().then(function(n) {
      return new Kg(n, i);
    });
  }
  clone(t) {
    const e = W(this._ionRoot, this);
    return H(t) || (t = new Kg(
      e._ionEndpoint,
      e._ionEndpointResource
    )), t = Lt.prototype.clone.call(this, t), t._ionRoot = e, t._isExternal = this._isExternal, t;
  }
  fetchImage(t) {
    if (!this._isExternal) {
      const e = t;
      t = {
        preferBlob: !0
      }, H(e) && (t.flipY = e.flipY, t.preferImageBitmap = e.preferImageBitmap);
    }
    return Lt.prototype.fetchImage.call(this, t);
  }
  _makeRequest(t) {
    return this._isExternal || new Zs(this.url).authority() !== this._ionEndpointDomain ? Lt.prototype._makeRequest.call(this, t) : (H(t.headers) || (t.headers = {}), t.headers.Authorization = `Bearer ${this._ionEndpoint.accessToken}`, t.headers["X-Cesium-Client"] = "CesiumJS", typeof CESIUM_VERSION < "u" && (t.headers["X-Cesium-Client-Version"] = CESIUM_VERSION), Lt.prototype._makeRequest.call(this, t));
  }
};
let fa = Kg;
f(fa, "_createEndpointResource", function(t, e) {
  e = W(e, {});
  let i = W(e.server, vh.defaultServer);
  const n = W(e.accessToken, vh.defaultAccessToken);
  i = Lt.createIfNeeded(i);
  const o = {
    url: `v1/assets/${t}/endpoint`
  };
  return H(n) && (o.queryParameters = { access_token: n }), i.getDerivedResource(o);
});
let Oy = new Ue();
new J();
new yt();
let Qy = new Bn(), gl = new J(), cl = new J(), ir = new J();
const co = new J(), Yy = new J(), jy = new J();
let ag = new J(), ll = new le(), vs = [], nr = new B(), Yr = new Me();
new B();
const gg = new B(), aU = new J(), gU = new B();
class ad extends Os {
  constructor(e, i) {
    super();
    f(this, "type", "InstancedMesh");
    f(this, "isMesh", !0);
    f(this, "isInstancedMesh", !0);
    f(this, "frustumCulled", !1);
    f(this, "instanceColor", null);
    f(this, "count", 0);
    f(this, "instanceMatrix");
    f(this, "_enableInstanceColor", !1);
    f(this, "instanceMorphMatrix", new J());
    f(this, "isEventEntitySupported", !0);
    f(this, "boundingBox", null);
    f(this, "boundingSphere", null);
    f(this, "getInstanceLocalMatrix", (e, i, n, o) => null);
    f(this, "getEcefTransformMatrix", (e, i, n) => {
      const r = this.engine.map.isGlobe, a = new J();
      if (r) {
        const g = Ze.eastNorthUpToFixedFrame(gU.fromArray(e)), c = aU.extractRotation(g);
        a.multiply(c);
      }
      return a;
    });
    f(this, "addCustomAttributes", () => {
    });
    this.parameters = {}, this.geometry = e, this.material = i, this.instanceMatrix = new Ni(new Float32Array(0), 16);
  }
  set enableInstanceColor(e) {
    e !== this._enableInstanceColor && (this._enableInstanceColor = e, this.needsUpdate = !0);
  }
  get enableInstanceColor() {
    return this._enableInstanceColor;
  }
  collisionTest(e) {
    let i = this.material.keepSize ? this.size : 0;
    return {
      width: i,
      height: i
    };
  }
  _updateData() {
    const {
      visiblePropName: e = "visible",
      vertexVisible: i = !1
    } = this.parameters, n = this.engine.map.isGlobe;
    let o = [];
    this._enableCollision && this._collisionData ? o = this._collisionData : o = this.dataSource.userData;
    const r = [], a = [], g = [], c = [];
    let l = 1 / 0, h = 1 / 0, d = 1 / 0, C = -1 / 0, p = -1 / 0, m = -1 / 0;
    for (let S = 0; S < o.length; S++) {
      const A = o[S].position, [u, y, I = 0] = A;
      u < l && (l = u), u > C && (C = u), y < h && (h = y), y > p && (p = y), I < d && (d = I), I > m && (m = I);
    }
    let b = [(l + C) / 2, (h + p) / 2, (d + m) / 2 || 0];
    for (let S = 0; S < o.length; S++) {
      const A = o[S].position;
      o[S].index;
      const u = o[S][e];
      if (i && u === !1)
        continue;
      const y = this.dataSource.getDataItem(S), I = this.getInstanceLocalMatrix(A, y, S, o[S]);
      Yy.makeTranslation(
        A[0] - b[0],
        A[1] - b[1],
        (A[2] || 0) - b[2]
      );
      const M = this.getEcefTransformMatrix(A, y, S);
      co.identity(), this.constructor === ad && (jy.extractRotation(M), co.multiplyMatrices(co, jy)), I && co.multiplyMatrices(co, I), co.multiplyMatrices(Yy, co);
      const G = co.elements;
      if (r.push(
        G[0],
        G[1],
        G[2],
        G[3],
        G[4],
        G[5],
        G[6],
        G[7],
        G[8],
        G[9],
        G[10],
        G[11],
        G[12],
        G[13],
        G[14],
        G[15]
      ), n) {
        const x = M.elements;
        a.push(
          x[0],
          x[1],
          x[2],
          x[3],
          x[4],
          x[5],
          x[6],
          x[7],
          x[8],
          x[9],
          x[10],
          x[11],
          x[12],
          x[13],
          x[14],
          x[15]
        );
      }
      if (g.push(Math.random()), this._enableInstanceColor) {
        let x = pi(o[S].color);
        c.push(x[0], x[1], x[2]);
      }
    }
    n && this.geometry.setAttribute(
      "ecefMatrix",
      new Ni(new Float32Array(a), 16)
    ), this.geometry.setAttribute(
      "instancedRandomFactor",
      new Ni(new Float32Array(g), 1)
    ), this.addCustomAttributes(this.geometry, this.dataSource), this.geometry.computeBoundingSphere(), this.geometry.instanceCount = r.length / 16, this.instanceMatrix = new Ni(new Float32Array(r), 16), this._enableInstanceColor && (this.instanceColor = new Ni(new Float32Array(c), 3)), this.count = this.geometry.instanceCount, this.makeMeshPositionOffset(b), this.needsUpdate = !1;
  }
  setBufferData(e) {
    if (!e)
      return;
    const n = e.id.length;
    n !== 0 && (this.count = n, this.geometry.instanceCount = n, e.instanceMatrix ? this.instanceMatrix = new Ni(new Float32Array(e.instanceMatrix), 16) : this.computeTempMatrix(e));
  }
  computeTempMatrix(e) {
    const i = this.engine.map.isGlobe;
    e.id;
    const n = e.translation, o = e.scale, r = e.rotation, a = [], g = [];
    let c = new J(), l = new B(), h = new B(), d = new pr(), C = new Ye(), p = 1 / 0, m = 1 / 0, b = 1 / 0, S = -1 / 0, A = -1 / 0, u = -1 / 0;
    for (let I = 0; I < this.count; I++) {
      let M = I * 3;
      const G = n[M], x = n[M + 1], L = n[M + 2];
      G < p && (p = G), G > S && (S = G), x < m && (m = x), x > A && (A = x), L < b && (b = L), L > u && (u = L);
    }
    let y = [(p + S) / 2, (m + A) / 2, (b + u) / 2 || 0];
    for (let I = 0; I < this.count; I++) {
      let M = I * 3;
      o ? h.set(o[M], o[M + 1], o[M + 2]) : h.set(1, 1, 1), n ? l.set(
        n[M] - y[0],
        n[M + 1] - y[1],
        n[M + 2] - y[2]
      ) : l.set(0, 0, 0), gg.set(0, 0, 0), r && gg.set(r[M], r[M + 1], r[M + 2]);
      const G = [n[M], n[M + 1], n[M + 2]];
      if (i) {
        const E = this.getEcefTransformMatrix(G).elements;
        g.push(
          E[0],
          E[1],
          E[2],
          E[3],
          E[4],
          E[5],
          E[6],
          E[7],
          E[8],
          E[9],
          E[10],
          E[11],
          E[12],
          E[13],
          E[14],
          E[15]
        );
      }
      d.set(gg.x, gg.y, gg.z, "ZYX"), C.setFromEuler(d), c.compose(l, C, h), M = I * 16;
      const x = c.elements;
      for (let L = 0; L < 16; L++)
        a[M + L] = x[L];
    }
    i && this.geometry.setAttribute(
      "ecefMatrix",
      new Ni(new Float32Array(g), 16)
    ), this.geometry.computeBoundingSphere(), this.instanceMatrix = new Ni(new Float32Array(a), 16), this.makeMeshPositionOffset(y);
  }
  computeBoundingBox() {
    const e = this.geometry, i = this.count;
    this.boundingBox === null && (this.boundingBox = new Ue()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < i; n++)
      this.getMatrixAt(n, gl), Oy.copy(e.boundingBox).applyMatrix4(gl), this.boundingBox.union(Oy);
  }
  computeBoundingSphere() {
    const e = this.geometry, i = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Bn()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < i; n++)
      this.getMatrixAt(n, gl), Qy.copy(e.boundingSphere).applyMatrix4(gl), this.boundingSphere.union(Qy);
  }
  getMatrixAt(e, i) {
    i.fromArray(this.instanceMatrix.array, e * 16);
  }
  computeInstanceMorphMatrix() {
    const e = this.material;
    let i = e.height || 0, n = 1;
    if (e.keepSize && (n = e.zoomUnits || 1), e.isUseSize3) {
      const o = e.size3;
      nr.set(o[0] * n, o[1] * n, o[2] * n);
    } else if (e.isUseSize2) {
      const o = e.size2;
      nr.set(o[0] * n, o[1] * n, n);
    } else {
      let o = e.size || 1;
      nr.set(o * n, o * n, o * n);
    }
    this.instanceMorphMatrix.identity().scale(nr).premultiply(ag.identity().makeTranslation(0, 0, i * n));
  }
  getEntityByIndex(e) {
    const i = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const n = {
      index: e,
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e];
    return n;
  }
  raycast(e, i) {
    if (!this.visible)
      return;
    let n = this.geometry, o = this.material, r = this.matrixWorld;
    if (!o || !n)
      return;
    const a = this.instanceMatrix;
    if (!a)
      return;
    const g = a.array;
    this.computeInstanceMorphMatrix();
    const c = this.count;
    if (ll.geometry = this.geometry.getInstanceGeometry ? this.geometry.getInstanceGeometry() : this.geometry, ll.material = o, o.isInstancedBallonMaterial) {
      const l = e.camera, h = o.resolution, d = e.mouse, C = o.size / h[0], p = o.size / h[1], m = (o.height + o.size / 2) * 2 / h[1], b = d.x - C, S = d.x + C, A = d.y - p - m, u = d.y + p - m;
      ag.multiplyMatrices(l.matrixWorldInverse, r), ag.multiplyMatrices(l.projectionMatrix, ag);
      for (let y = 0; y < c; ++y)
        if (ir.fromArray(g, y * 16), Yr.set(0, 0, 0, 1).applyMatrix4(ir).applyMatrix4(ag).divideScalar(Yr.w), Yr.x >= b && Yr.y >= A && Yr.x <= S && Yr.y <= u) {
          nr.set(
            ir.elements[12],
            ir.elements[13],
            ir.elements[14]
          );
          const I = e.ray.origin.distanceTo(nr);
          I >= e.near && I <= e.far && (vs[0] = {
            distance: I,
            point: nr.clone(),
            itemIndex: y,
            object: this
          }, i.push(vs[0]), vs.length = 0);
        }
    } else
      for (let l = 0; l < c; ++l)
        ir.fromArray(g, l * 16), cl.multiplyMatrices(ir, this.instanceMorphMatrix), cl.multiplyMatrices(r, cl), ll.matrixWorld = cl, ll.raycast(e, vs), vs.length > 0 && (vs[0].instanceId = l, vs[0].object = this, i.push(vs[0]), vs.length = 0);
  }
}
class tv extends ad {
  constructor() {
    super(...arguments);
    f(this, "isInstancedPointMesh", !0);
  }
}
let Jy = new Ue(), qy = new B();
class iv extends Fb {
  constructor() {
    super(...arguments);
    f(this, "isCustomInstancedBufferGeometry", !0);
    f(this, "instanceGeometry", null);
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ue());
    const e = this.attributes.instancedPosition;
    e !== void 0 ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Bn());
    let e = this.attributes.instancedPosition;
    if (e) {
      let i = this.boundingSphere.center;
      Jy.setFromBufferAttribute(e), Jy.getCenter(i);
      let n = 0;
      for (let o = 0, r = e.count; o < r; o++)
        qy.fromBufferAttribute(e, o), n = Math.max(n, i.distanceToSquared(qy));
      this.boundingSphere.radius = Math.sqrt(n), e.count === 1 && (this.boundingSphere.radius = 1e5), isNaN(this.boundingSphere.radius) && console.error('CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.', this);
    }
  }
  getInstanceGeometry() {
    return this.instanceGeometry || (this.instanceGeometry = new Qe(), this.instanceGeometry.attributes = this.attributes, this.instanceGeometry.index = this.index), this.instanceGeometry;
  }
}
class cU extends iv {
  constructor() {
    super();
    f(this, "setModelData", () => {
      const e = [
        -0.5,
        0,
        0,
        -0.5,
        0,
        1,
        0.5,
        0,
        1,
        0.5,
        0,
        0
      ], i = [
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0
      ], n = [
        0,
        2,
        1,
        0,
        3,
        2
      ];
      this.setAttribute("position", new ae(e, 3)), this.setAttribute("uv", new ae(i, 2)), this.setIndex(n);
    });
    this.setModelData();
  }
}
const lU = `#define GLSLIFY 1
varying vec2 vUv;
varying vec3 vPosition;
// varying vec3 vNormal;
varying float vRadian;
varying float vCameraRotation;

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

#include <common>
#include <logdepthbuf_pars_vertex>
#include <normal_pars_vertex>

mat4 removeRotation(mat4 matrix) {
    // \u63D0\u53D6\u7F29\u653E\u90E8\u5206
    vec3 scale;
    scale.x = length(matrix[0].xyz);
    scale.y = length(matrix[1].xyz);
    scale.z = length(matrix[2].xyz);

    // \u6784\u5EFA\u65E0\u65CB\u8F6C\u4F46\u4FDD\u7559\u7F29\u653E\u7684\u77E9\u9635
    mat3 scaleMatrix = mat3(
        vec3(scale.x, 0.0, 0.0),
        vec3(0.0, scale.y, 0.0),
        vec3(0.0, 0.0, scale.z)
    );

    // \u6784\u5EFA\u65B0\u7684 matrix\uFF0C\u53BB\u6389\u65CB\u8F6C\u90E8\u5206
    mat4 newMatrix = mat4(
        vec4(scaleMatrix[0], 0.0),
        vec4(scaleMatrix[1], 0.0),
        vec4(scaleMatrix[2], 0.0),
        matrix[3] // \u4FDD\u6301\u539F\u6765\u7684\u5E73\u79FB\u90E8\u5206
    );

    return newMatrix;
}

void main() {
    vUv = uv;

    vec3 transformed = vec3(position);

    // \u8BA1\u7B97\u5E73\u9762\u7684\u4E2D\u5FC3\u70B9
    vec4 centerPosition = (modelMatrix * instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0));
    vPosition = centerPosition.xyz;

    // \u8BA1\u7B97\u9762\u5411\u76F8\u673A\u7684\u65CB\u8F6C\u77E9\u9635\uFF08\u4EC5\u7ED5Z\u8F74\u65CB\u8F6C\uFF09
    vec3 toCamera = normalize(centerPosition.xyz - cameraPosition);

    #ifdef IS_GLOBE
        mat4 ecefMatrixInverse = inverse(ecefMatrix);
        toCamera = (ecefMatrixInverse * vec4(toCamera, 0.0)).xyz;
    #endif

    // vNormal = toCamera;
    // vNormal = viewMatrix[2].xyz;
    // #include <beginnormal_vertex>
    // #include <defaultnormal_vertex>
    // #include <normal_vertex>

    float angleZ = atan(toCamera.x, toCamera.y);
    float cosAngle = cos(angleZ);
    float sinAngle = sin(angleZ);

    vCameraRotation = angleZ;

    mat4 faceCameraMatrix = mat4(
        vec4(cosAngle,-sinAngle, 0.0, 0.0),
        vec4(sinAngle, cosAngle, 0.0, 0.0),
        vec4(0.0, 0.0, 1.0, 0.0),
        vec4(0.0, 0.0, 0.0, 1.0)
    );

    mat4 currentInstanceMatrix = removeRotation(instanceMatrix);
    #ifdef IS_GLOBE
        currentInstanceMatrix = currentInstanceMatrix * ecefMatrix;
    #endif

    // \u9876\u70B9\u6570\u636E\u4E2D\u5E26\u7684\u989D\u5916\u65CB\u8F6C
    vRadian = atan(instanceMatrix[1][0], instanceMatrix[0][0]);

    gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * faceCameraMatrix * vec4(transformed, 1.0);

    #include <logdepthbuf_vertex>
}`, hU = `#define GLSLIFY 1
uniform sampler2D tDiffuse;
uniform sampler2D tNormal;

varying vec2 vUv;
varying vec3 vPosition;
varying float vRadian;
varying float vCameraRotation;

#include <common>
#include <packing>
#include <logdepthbuf_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>

vec2 getUVCoordinates(vec3 center) {
    const int NUM_ROWS = 5;
    const int NUM_COLS = 5;
    const int TOTAL_IMAGES = NUM_ROWS * NUM_COLS;

    // \u8BA1\u7B97\u9762\u5411\u76F8\u673A\u7684\u89D2\u5EA6\uFF08\u4EC5\u8003\u8651Z\u8F74\u65CB\u8F6C\uFF09
    float radian = vCameraRotation + vRadian;

    // \u8BA1\u7B97\u79BB\u6563\u89D2\u5EA6\u533A\u95F4\u7684\u7D22\u5F15
    float intervalSize = 2.0 * PI / float(TOTAL_IMAGES);
    int index = int(floor((radian + PI) / intervalSize));

    // \u786E\u4FDD\u7D22\u5F15\u5728 [0, TOTAL_IMAGES - 1] \u8303\u56F4\u5185
    index = (index % TOTAL_IMAGES + TOTAL_IMAGES) % TOTAL_IMAGES;

    // Calculate the grid coordinates
    int x = index % NUM_COLS;
    int y = index / NUM_COLS;

    // x\u8F74\u7FFB\u8F6C\uFF0C\u76F8\u673A\u987A\u65F6\u9488\u65CB\u8F6C\u65F6\uFF0C\u7EB9\u7406\u6309\u987A\u5E8F\u5207\u6362
    x = NUM_COLS - 1 - x;

    // Calculate the UV coordinates
    float u_min = float(x) / float(NUM_COLS);
    float u_max = float(x + 1) / float(NUM_COLS);
    float v_min = float(y) / float(NUM_ROWS);
    float v_max = float(y + 1) / float(NUM_ROWS);

    // Calculate the new UV coordinates
    vec2 newUV;
    newUV.x = clamp(mix(u_min, u_max, vUv.x), u_min, u_max);
    newUV.y = clamp(mix(v_min, v_max, vUv.y), v_min, v_max);

    return newUV;
}

void main() {
    vec2 uv = getUVCoordinates(vPosition);

    vec4 viewNormal = texture2D(tNormal, uv);
    vec3 normal = unpackRGBToNormal(viewNormal.xyz);

    vec4 diffuseColor = texture2D(tDiffuse, uv);
    if (diffuseColor.a < 0.3) {
        discard;
    }

    #if ( NUM_DIR_LIGHTS > 0 )
        float normalLightIntensity = dot(normal, directionalLights[0].direction);
        gl_FragColor = vec4(diffuseColor.rgb * normalLightIntensity, diffuseColor.a);
    #else 
        gl_FragColor = diffuseColor;
    #endif

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <logdepthbuf_fragment>
    #include <colorspace_fragment>
}
`, dU = we.merge([
  Xt.lights,
  {
    tDiffuse: { value: null },
    tNormal: { value: null }
  }
]);
class uU extends di {
  constructor(t = {}) {
    super(), this.name = "BillboardTreeMaterial", this.type = "BillboardTreeMaterial", this.isBillboardTreeMaterial = !0, this.side = xr, this.lights = !0, this.transparent = !1, this.vertexShader = lU, this.fragmentShader = hU, Object.assign(this.uniforms, we.clone(dU)), oi(this, [
      "tDiffuse",
      "tNormal"
    ]), ri(this, [
      ["isGlobe", "IS_GLOBE"]
    ]), this.setValues(t);
  }
}
const $y = new Ot();
let wI = null, eS = null;
class IU extends tv {
  constructor(e = {}) {
    super(e);
    f(this, "geometry");
    f(this, "material");
    f(this, "getInstanceLocalMatrix", (e, i, n, o) => {
      const r = new J(), a = new J(), g = o.rotation;
      typeof g == "number" ? a.makeRotationZ(g) : g instanceof Array ? a.makeRotationFromEuler(new pr(g[1], g[2], g[3])) : g instanceof B && a.makeRotationFromEuler(new pr(g.x, g.y, g.z));
      const c = new J(), l = o.scale;
      return typeof l == "number" ? c.makeScale(l, l, l) : l instanceof Array ? c.makeScale(l[0], l[1], l[2]) : l instanceof B && c.makeScale(l.x, l.y, l.z), r.multiplyMatrices(c, a), r;
    });
    this.parameters = e;
    let i = null, n = null;
    this.parameters.diffuseTexture && this.parameters.normalTexture ? (i = this.parameters.diffuseTexture, n = this.parameters.normalTexture) : (wI || (wI = $y.load(
      pt("assets/textures/tree/hill_tree_billboard.png")
    ), eS = $y.load(
      pt("assets/textures/tree/hill_tree_billboard_normal.png")
    )), i = wI, n = eS), i.colorSpace = gt, i.wrapS = i.wrapT = hs, i.minFilter = i.magFilter = Gt, this.geometry = new cU(), this.material = new uU(), this.geometry.scale(10, 10, 10), this.material.tDiffuse = i, this.material.tNormal = n;
  }
  initObject() {
    this.material.isGlobe = this.engine.map.isGlobe;
  }
}
const tS = new J(), hl = new J(), AU = new B(), lo = new B();
class CU extends Wt {
  constructor(e, i) {
    super();
    f(this, "isEventEntitySupported", !0);
    f(this, "_meshes", []);
    f(this, "_idIndexMap", {});
    f(this, "_indexIdMap", {});
    f(this, "_matrixAttribute", null);
    f(this, "_count", 0);
    f(this, "_rtc", null);
    f(this, "updateRenderingMesh", () => {
      this._cleanOldMesh();
      const e = this._meshes, i = e.length;
      for (let n = 0; n < i; ++n) {
        const o = e[n], r = new kh(o.geometry, o.material);
        r.__eventProxyByParent = !0, r.castShadow = o.castShadow, r.receiveShadow = o.receiveShadow, r.parent = this, r.name = o.name, this.add(r), o.isInstancedMesh && (r._isOriginalInstancedMesh = !0, r._rawInstanceMatrix = o.instanceMatrix, r._rawCount = o.count);
      }
    });
    f(this, "_cleanOldMesh", () => {
      const e = this.children;
      for (let i = e.length - 1; i >= 0; i--) {
        const n = e[i];
        this.remove(n), n.dispose();
      }
    });
    if (e)
      this._meshes = e;
    else {
      const n = this._defaultMesh = new le(new Nt(1, 1, 1), new _t({
        color: 16777215
      }));
      this._meshes = [n];
    }
    this.updateRenderingMesh(), this._matrixAttribute = new Ni(new Float32Array(i * 16), 16), this._initialized = !0;
  }
  afterAddToEngine(e) {
    this.engine = e;
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  getEntityByIndex(e) {
    const i = this._indexIdMap[e];
    if (i === void 0)
      return null;
    const n = {
      id: i,
      index: e
    };
    return n.matrix = this._matrixAttribute.array.slice(e * 16, (e + 1) * 16), n;
  }
  has(e) {
    return this._idIndexMap[e] !== void 0;
  }
  clear() {
    this._idIndexMap = {}, this._indexIdMap = {}, this._rtc = null;
  }
  setBufferData(e) {
    if (this.clear(), !e)
      return;
    const n = e.id.length;
    n !== 0 && (this.count = n, e.instanceMatrix ? this._matrixAttribute.array.set(e.instanceMatrix, 16 * this._count) : this.computeTempMatrix(e));
  }
  computeTempMatrix(e) {
    const i = e.id, n = e.translation, o = e.scale, r = e.rotation, a = this._matrixAttribute.array;
    let g = new J(), c = new B(), l = new B(), h = new pr(), d = new Ye(), C = null, p = null, m = this._rtc;
    m || (n ? (m = [n[0], n[1], n[2]], this._rtc = m, this.position.set(m[0], m[1], m[2])) : m = [0, 0, 0]);
    for (let b = 0; b < this._count; b++) {
      let S = b * 3;
      if (o ? l.set(o[S], o[S + 1], o[S + 2]) : l.set(1, 1, 1), n ? c.set(
        n[S] - m[0],
        n[S + 1] - m[1],
        n[S + 2] - m[2]
      ) : c.set(0, 0, 0), lo.set(0, 0, 0), r && lo.set(r[S], r[S + 1], r[S + 2]), this.engine && this.engine.map.isGlobe) {
        const u = {
          heading: -lo.z,
          pitch: -lo.y,
          roll: lo.x
        }, y = Ze.headingPitchRollToFixedFrame(
          AU.set(
            n[S],
            n[S + 1],
            n[S + 2]
          ),
          u
        );
        h.setFromRotationMatrix(y, "ZYX");
      } else
        h.set(lo.x, lo.y, lo.z, "ZYX");
      d.setFromEuler(h), g.compose(c, d, l), S = b * 16;
      const A = g.elements;
      for (let u = 0; u < 16; u++)
        a[S + u] = A[u];
      C = i[b], p = b, this._idIndexMap[C] = p, this._indexIdMap[p] = C;
    }
  }
  update() {
    if (!this._initialized)
      return;
    const e = this.children;
    this._matrixAttribute.needsUpdate = !0;
    for (const i of e) {
      if (i._isOriginalInstancedMesh) {
        const n = i._rawCount * this._count, o = new Float32Array(n * 16);
        for (let r = 0; r < this._count; r++) {
          tS.fromArray(this._matrixAttribute.array, r * 16);
          for (let a = 0; a < i._rawCount; a++)
            hl.fromArray(i._rawInstanceMatrix.array, a * 16), hl.multiplyMatrices(tS, hl), o.set(hl.elements, (r * i._rawCount + a) * 16);
        }
        i.instanceMatrix = new Ni(o, 16), i.count = n;
      } else
        i.instanceMatrix = this._matrixAttribute, i.count = this._count;
      i.frustumCulled = !1, i.computeBoundingSphere(), i.instanceMatrix.needsUpdate = !0;
    }
  }
  dispose() {
    this._cleanOldMesh(), this._defaultMesh && (this._defaultMesh.geometry.dispose(), this._defaultMesh.material.dispose());
  }
  raycast(e, i) {
    if (!this.visible) {
      this.traverse((n) => {
        n.isMesh && !n._originRaycast && (n._originRaycast = n.raycast, n.raycast = () => {
        });
      });
      return;
    }
    this.traverse((n) => {
      n.isMesh && n._originRaycast && (n.raycast = n._originRaycast, delete n._originRaycast);
    });
  }
  set needsUpdate(e) {
    e && this.update();
  }
  set count(e) {
    e !== this._count && (this._count = e, this._matrixAttribute = new Ni(new Float32Array(e * 16), 16));
  }
  get count() {
    return this._count;
  }
  set meshes(e) {
    !e || (Array.isArray(e) ? this._meshes = e : e.isMesh ? this._meshes = [e] : e.isGroup && (this._meshes = e.children), this.updateRenderingMesh(), this.update());
  }
  get meshes() {
    return this._meshes;
  }
}
const dl = new J(), fU = (s) => {
  const t = new Ue();
  t.setFromObject(s);
  const e = Math.max(t.max.x - t.min.x, t.max.y - t.min.y, t.max.z - t.min.z);
  s.scale.multiplyScalar(1 / e);
}, pU = (s) => {
  s.rotation.x = Math.PI / 2;
}, nv = (s) => {
  if (s.isInstancedMesh)
    for (let t = 0; t < s.count; t++)
      dl.fromArray(s.instanceMatrix.array, t * 16), dl.multiplyMatrices(s.matrixWorld, dl), s.instanceMatrix.array.set(dl.elements, t * 16);
  else if (s.isSkinnedMesh)
    s.skeleton.pose(), s.geometry.applyMatrix4(s.bindMatrixInverse), s.geometry.applyMatrix4(s.matrixWorld);
  else if (s.isMesh)
    s.geometry.applyMatrix4(s.matrixWorld);
  else if (s.isBone)
    s.matrixWorld.decompose(s.position, s.quaternion, s.scale);
  else if (s.children.length > 0)
    for (const t of s.children)
      nv(t);
  s.position.set(0, 0, 0), s.scale.set(1, 1, 1), s.quaternion.set(0, 0, 0, 1);
}, sv = (s, t) => {
  if (s.isMesh || s.isBone)
    t.push(s);
  else if (s.children.length > 0)
    for (const e of s.children)
      sv(e, t);
}, lf = (s, t, e) => {
  t && fU(s), e && pU(s), s.updateMatrixWorld(), nv(s), s.updateMatrixWorld();
  const i = [];
  return sv(s, i), i;
}, mU = (s, t, e) => {
  const i = [];
  for (const n of s) {
    const o = n.name;
    if (!o.startsWith("lod"))
      continue;
    const r = parseInt(o.substring(3), 10);
    if (isNaN(r))
      continue;
    const a = lf(n, t, e);
    i[r] = a;
  }
  return i;
}, DY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  parseLODModel: mU,
  parseScene: lf
}, Symbol.toStringTag, { value: "Module" }));
class yU {
  constructor() {
    f(this, "_lastUpdateTime", 0);
    f(this, "_updateDelayTimerHander", null);
    f(this, "_configVersion", 0);
    f(this, "_config", {
      tree: {
        enabled: !1,
        isFoliage: !0,
        isBox: !1,
        scaleByZ: !1,
        instances: [{
          subtype: 4,
          modelPath: pt("assets/models/tree/planar/tree18.glb"),
          itemScale: 1,
          zOffset: 0
        }, {
          subtype: 3,
          modelPath: pt("assets/models/tree/planar/tree22.glb"),
          itemScale: 1,
          zOffset: 0
        }, {
          subtype: 2,
          modelPath: pt("assets/models/tree/planar/tree21.glb"),
          itemScale: 1,
          zOffset: 0
        }, {
          subtype: 1,
          modelPath: pt("assets/models/tree/planar/tree20.glb"),
          itemScale: 1,
          zOffset: 0
        }, {
          subtype: 0,
          modelPath: pt("assets/models/tree/planar/tree19.glb"),
          itemScale: 1,
          zOffset: 0
        }]
      }
    });
    f(this, "_labelEnabled", !1);
    f(this, "_generateModelMesh", async (t) => new Promise((e, i) => {
      nf.load(t, (n) => {
        const o = lf(n.scene, !1, !0);
        e(o);
      }, null, i);
    }));
    f(this, "markNeedsUpdate", () => {
      this._updateDelayTimerHander || (this._updateDelayTimerHander = setTimeout(() => {
        this.engine.requestRender(), this._updateDelayTimerHander = null;
      }, 100));
    });
    f(this, "remapBatchValueToNumber", (t) => t ? isFinite(t) ? (t = Math.round(t % 100), t) : typeof t == "string" ? (t = t.charCodeAt(3) || 0, t % 100) : 0 : 0);
    f(this, "parseBatchTableAttribute", (t, e, i) => {
      const n = t.cached.scene, o = [], r = n.batchTable && n.batchTable.header;
      if (!r)
        return;
      const a = r[e];
      if (!!a) {
        n.traverse((g) => {
          g.isMesh && o.push(g);
        });
        for (const g of o) {
          if ("type" in g.geometry.userData && "subtype" in g.geometry.userData)
            continue;
          const c = g.geometry, l = c.getAttribute("_batchid");
          if (!l)
            continue;
          const h = l.data.count;
          let d = -1, C = 0;
          const p = [];
          for (let m = 0; m < h; m++)
            d = l.getX(m), C = this.remapBatchValueToNumber(a[d]), p.push(C);
          c.attributes[i] = new Fe(new Float32Array(p), 1);
        }
      }
    });
    f(this, "parseLabelData", (t, e) => {
      const i = t.geometry, n = e.__id, o = i.attributes.position, r = o.count;
      if (r === 0)
        return;
      const a = i.attributes.rotation, g = e.cached.scene, c = g.matrix, l = g.batchTable.header.text, h = g.batchTable.header.rank, d = [], C = new B();
      for (let p = 0; p < r; p++)
        C.set(o.getX(p), o.getY(p), o.getZ(p)), C.applyMatrix4(c), d.push({
          id: n + "-" + p,
          type: "text_flat",
          position: [C.x, C.y, C.z],
          text: l[p],
          rotateZ: a.getZ(p),
          rank: h && h[p] || 0
        });
      e.__labelData = d;
    });
    f(this, "onTileLoad", (t, e) => {
      this.refreshTile(t);
    });
    f(this, "onTileDispose", (t, e) => {
      this.resetTile(t);
    });
    f(this, "onTileShow", (t) => {
      if (t.__instanceInfo) {
        const e = t.__instanceInfo;
        Object.keys(e).forEach((i) => {
          const n = e[i];
          n.model && (n.model.visible = !0, this.markNeedsUpdate());
        });
      }
    });
    f(this, "onTileHide", (t) => {
      if (t.__instanceInfo) {
        const i = t.__instanceInfo;
        Object.keys(i).forEach((n) => {
          const o = i[n];
          o.model && (o.model.visible = !1, this.markNeedsUpdate());
        });
      }
      const e = t.__labelData;
      t.__hasAddLabelData && e && (this.engine.rendering.label.removeLabels(e), t.__hasAddLabelData = !1);
    });
    f(this, "resetTile", (t) => {
      if (t.__instanceConfigVersion = null, t.__instanceInfo && (Object.keys(t.__instanceInfo).forEach((e) => {
        const i = t.__instanceInfo[e];
        i.model && (this.group.remove(i.model), i.model.dispose());
      }), delete t.__instanceInfo), t.__labelData && t.__hasAddLabelData) {
        const e = t.__labelData;
        this.engine.rendering.label.removeLabels(e, t.__lodLevel), t.__hasAddLabelData = !1;
      }
    });
    f(this, "refreshTile", (t) => {
      const e = t.cached.scene, i = [];
      if (t.__instanceConfigVersion !== this._configVersion) {
        e.traverse((o) => {
          o.isMesh && i.push(o);
        });
        for (const o of i)
          if (o.isMesh && "type" in o.geometry.userData && "subtype" in o.geometry.userData) {
            o.visible = !1;
            const { type: r, subtype: a } = o.geometry.userData, g = this.getInstanceCollectionConfig(r);
            if (!g)
              continue;
            const c = this.getInstanceConfig(r, a);
            if (!c)
              continue;
            t.__instanceInfo || (t.__instanceInfo = {}), g.enabled && this.createInstanceComponent(o, t, g, c);
          } else
            o._rawMaterialName === "_label" && (o.visible = !1, this._labelEnabled && !t.__instanceLabelParsed && (this.parseLabelData(o, t), t.__instanceLabelParsed = !0));
        t.__instanceConfigVersion = this._configVersion;
      }
      const n = t.__labelData;
      n && (this._labelEnabled && !t.__hasAddLabelData && (this.engine.rendering.label.addLabels(n, t.__lodLevel), t.__hasAddLabelData = !0), !this._labelEnabled && t.__hasAddLabelData && (this.engine.rendering.label.removeLabels(n, t.__lodLevel), t.__hasAddLabelData = !1));
    });
    f(this, "refreshTiles", () => {
      this.tilesRenderer.forEachLoadedModel((t, e) => {
        !e.__visible || (this.resetTile(e), this.refreshTile(e));
      }), this.engine.requestRender();
    });
    this.group = new mt(), this._modelMeshSingleton = new sd(), this._modelMeshSingleton.generate = this._generateModelMesh;
  }
  async createInstanceComponent(t, e, i, n) {
    const o = t.geometry, r = e.__id, a = o.attributes.position, g = a.count;
    if (g === 0)
      return;
    const c = i.type, l = n.subtype, h = c + "-" + l, d = n.itemScale || 1, C = n.zOffset || 0;
    let p;
    if (c === "tree")
      p = new IU();
    else {
      const x = await this._modelMeshSingleton.get(n.modelPath);
      p = new CU(x, g);
    }
    p.afterAddToEngine && p.afterAddToEngine(this.engine);
    const m = [], b = o.attributes.scale, S = o.attributes.rotation, A = new Array(3 * g), u = new Float32Array(3 * g), y = new Float32Array(3 * g), I = e.cached.scene.matrix, M = new B();
    for (let x = 0; x < g; x++)
      M.set(a.getX(x), a.getY(x), a.getZ(x)), M.applyMatrix4(I), A[3 * x] = M.x, A[3 * x + 1] = M.y, A[3 * x + 2] = M.z + C, u[3 * x] = b.getX(x) * d, u[3 * x + 1] = b.getY(x) * d, u[3 * x + 2] = b.getZ(x) * d, y[3 * x] = S.getX(x), y[3 * x + 1] = -S.getY(x), y[3 * x + 2] = Math.PI / 2 - S.getZ(x), m.push(r + "-" + x);
    const G = {
      translation: A,
      scale: u,
      rotation: y,
      id: m
    };
    p.setBufferData(G), p.needsUpdate = !0, e.__instanceInfo[h] = {
      model: p,
      data: G
    }, this.group.add(p), p.visible = e.__visible;
  }
  getInstanceCollectionConfig(t) {
    if (H(this._config[t]))
      return {
        type: t,
        ...this._config[t]
      };
    $i("TileInstancedElementManager: no config for type " + t);
  }
  setInstanceCollectionConfig(t, e) {
    return this._config[t] ? this._config[t] = {
      ...this._config[t],
      ...e
    } : this._config[t] = e, this._configVersion++, this.refreshTiles(), this;
  }
  getInstanceConfig(t, e) {
    if (this._config[t]) {
      let i = this._config[t].instances;
      for (let n = 0; n < i.length; n++) {
        const o = i[n];
        if (String(o.subtype) === String(e))
          return o;
      }
      $i("TileInstancedElementManager: no config for type " + t + " subtype " + e);
    } else
      $i("TileInstancedElementManager: no config for type " + t);
  }
  setInstanceConfig(t, e, i) {
    if (this._config[t]) {
      let n = this._config[t].instances, o = !0;
      for (let r = 0; r < n.length; r++) {
        const a = n[r];
        if (String(a.subtype) === String(e)) {
          n[r] = {
            ...a,
            ...i
          }, o = !1;
          break;
        }
      }
      o && this._config[t].instances.push({
        ...i,
        subtype: e
      }), this._configVersion++, this.refreshTiles();
    }
    return this;
  }
  set config(t) {
    this._config = t, this._configVersion++, this.refreshTiles();
  }
  get config() {
    return this._config;
  }
  set labelEnabled(t) {
    this._labelEnabled = t, this._configVersion++, this.refreshTiles();
  }
  get labelEnabled() {
    return this._labelEnabled;
  }
}
class SU {
  constructor() {
    f(this, "_configVersion", 0);
    f(this, "_deletedIds", /* @__PURE__ */ new Set());
    f(this, "_needsRefreshAll", !1);
    f(this, "updateEditableAttribute", (t) => {
      const e = t.cached.scene;
      e.children;
      const i = e.batchTable && e.batchTable.header;
      if (!i)
        return;
      const n = i.id;
      if (!n)
        return;
      const o = "_tileEditableValue", r = this._deletedIds;
      e.traverse((a) => {
        if (a.geometry) {
          const g = a.geometry, c = g.getAttribute("_batchid");
          if (!c)
            return;
          const l = c.array.length;
          let h = -1, d = 0;
          const C = [];
          for (let p = 0; p < l; p++)
            h = c.getX(p), d = n[h] + "", r.has(d) || this.shouldBeHidden(i, h) ? C.push(1) : C.push(0);
          g.attributes[o] = new Fe(new Float32Array(C), 1);
        }
      });
    });
    f(this, "shouldBeHidden", (t, e) => !1);
    f(this, "onTileLoad", (t, e) => {
      t.__editableConfigVersion = 0;
    });
    f(this, "onTileDispose", (t, e) => {
    });
    f(this, "onTileShow", (t) => {
      this.refreshTile(t);
    });
    f(this, "onTileHide", (t) => {
    });
    f(this, "refreshTile", (t) => {
      t.__editableConfigVersion !== this._configVersion && (this.updateEditableAttribute(t), t.__editableConfigVersion = this._configVersion);
    });
    f(this, "refreshTiles", () => {
      !this._needsRefreshAll || this.tilesRenderer.forEachLoadedModel((t, e) => {
        !e.__visible || this.refreshTile(e);
      });
    });
  }
  addDeletedId(t) {
    t = t + "", this._deletedIds.add(t), this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  addDeletedIds(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e] + "";
      this._deletedIds.add(i);
    }
    this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  removeDeletedId(t) {
    t = t + "", this._deletedIds.delete(t), this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  removeDeletedIds(t) {
    for (let e = 0; e < t.length; e++) {
      const i = t[e] + "";
      this._deletedIds.delete(i);
    }
    this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
  hasDeletedId(t) {
    return this._deletedIds.has(t);
  }
  requestUpdate() {
    this._configVersion++, this._needsRefreshAll = !0, this.engine.requestRender();
  }
}
const iS = new B();
new J();
const bU = new B(), BU = new B(), wU = new B(1, 0, 0), _U = new B(0, 1, 0), xU = new B(), vU = new B(), nS = Symbol("PLUGIN_REGISTERED"), ts = {
  X: 0,
  Y: 1,
  Z: 2
};
ts.fromName = function(s) {
  return ts[s];
};
const TU = new B(), sS = new B(), LU = new B(), GU = new B(), MU = () => {
};
function EU(s, t, e) {
  let i, n, o, r, a;
  const g = s._root, c = g.boundingVolume, l = s.getCamera(), h = s._cameraInfo, d = e.map.isGlobe;
  if (H(g.boundingVolume.regionObb)) {
    d ? i = _.normalize(l.position, sS) : i = _.UNIT_Z, n = h.directionWC, o = h.positionCartographic.z;
    const u = g.boundingVolume.regionObb.box, { min: y, max: I } = u;
    r = y.z, a = I.z;
  } else {
    const u = g.computedTransform.clone().invert(), y = e.map.map._ellipsoid || De.WGS84, I = c.obb, M = g.boundingVolumeCenter, G = _e.multiplyByPoint(
      u,
      M,
      BU
    );
    if (_.magnitude(G) > y.minimumRadius && d) {
      const x = qi.fromCartesian(
        G,
        y,
        TU
      );
      i = _.normalize(l.position, sS), n = h.directionWC, o = h.positionCartographic.z, r = 0, a = x.z * 2;
    } else {
      iS.copy(l.position);
      const x = _e.multiplyByPoint(
        u,
        iS,
        LU
      );
      if (i = _.UNIT_Z, n = _e.multiplyByPointAsVector(
        u,
        h.directionWC,
        GU
      ), n = _.normalize(n, n), o = x.z, H(I)) {
        const T = Ae.getColumn(
          I.halfAxes,
          2,
          bU
        ).length();
        r = G.z - T, a = G.z + T;
      } else {
        const T = g.boundingVolume.sphere.radius;
        r = G.z - T, a = G.z + T;
      }
    }
  }
  const p = s.dynamicScreenSpaceErrorHeightFalloff, m = r + (a - r) * p, b = a * s.dynamicScreenSpaceHeightScale, S = ce.clamp(
    (o - m) / (b - m),
    0,
    1
  );
  let A = 1 - Math.abs(_.dot(n, i));
  A = A * (1 - S), s._dynamicScreenSpaceErrorComputedDensity = s.dynamicScreenSpaceErrorDensity * A;
}
async function oS(s, t) {
  const e = Ei(t, "3DTILES_metadata") ? t.extensions["3DTILES_metadata"] : t;
  let i;
  if (H(e.schemaUri))
    s = s.getDerivedResource({
      url: e.schemaUri
    }), i = Ro.getSchemaLoader({
      schema: e.schema
    });
  else if (H(e.schema))
    i = Ro.getSchemaLoader({
      schema: e.schema
    });
  else
    return;
  await i.load();
  const n = new sU({
    schema: i.schema,
    metadataJson: e
  });
  return Ro.unload(i), n;
}
const gs = {
  ADD: 0,
  REPLACE: 1
}, Cn = class extends Wt {
  constructor(e) {
    super();
    f(this, "isEventEntitySupported", !0);
    f(this, "is3DTiles", !0);
    f(this, "_needsRefreshAllLoadedTiles", !1);
    f(this, "_freezeUpdate", !1);
    f(this, "_forceUnlit", !1);
    f(this, "handleBeforeRender", (e) => {
      if (this._needsRefreshAllLoadedTiles && (this._needsRefreshAllLoadedTiles = !1, this.traversalLoadedTile((n, o) => {
        this._refreshTileInfo(o);
      })), this._freezeUpdate || !this.visible)
        return;
      const i = e.rendering.renderState;
      this._elementsManager && this._elementsManager.tick(i.time), this.prePassesUpdate(i), this.update(i), this.postPassesUpdate(i), this._editableElementManager.refreshTiles();
    });
    f(this, "parseBatchTableAttribute", (e, i) => {
      const o = e.scene.children, r = e.batchTable && e.batchTable.header;
      if (!r)
        return;
      const a = r[i];
      if (!(!a || !a.length))
        for (const g of o) {
          const c = g.geometry, l = c.getAttribute("_batchid");
          if (!l)
            continue;
          const h = l.data.count;
          let d = -1, C = 0;
          const p = [];
          for (let m = 0; m < h; m++)
            d = l.getX(m), C = a[d], p.push(C);
          c.attributes[i] = new Fe(new Float32Array(p), 1);
        }
    });
    f(this, "_refreshTileInfo", (e) => {
      var n;
      const i = e.content;
      ((n = this._asset) == null ? void 0 : n.tilesetVersion) === "2.0.0" && this.parseBatchTableAttribute(i, "typeId"), i.traverse((o) => {
        if (!o.isMesh || !o.material)
          return;
        o._rawMaterialName === void 0 && (o._rawMaterialName = o.material.name, o._originalMaterial = o.material);
        const r = o._rawMaterialName;
        if (this._materialManager) {
          const a = this._materialManager.getMaterialByKey(r, o);
          a && a.isMaterial ? o.material = a : o.material = o._originalMaterial;
        } else
          o.material = o._originalMaterial;
        o.receiveShadow = this._receiveShadow, i._raycastMethod !== this._raycastMethod && (this._raycastMethod === Cn.RAYCAST_NONE ? o.raycast = MU : o.raycast = this._overridenRaycast);
      }), i._raycastMethod = this._raycastMethod;
    });
    f(this, "traversalLoadedTile", (e) => {
      this.getTraversal().forEachLoadedTile(this, e);
    });
    e = W(e, {}), this.plugins = [], this.preferLeaves = W(e.preferLeaves, !1), this.dynamicScreenSpaceError = W(e.dynamicScreenSpaceError, !0), this._updatedVisibilityFrame = 0, this.dynamicScreenSpaceErrorDensity = W(
      e.dynamicScreenSpaceErrorDensity,
      278e-5
    ), this.dynamicScreenSpaceErrorFactor = W(
      e.dynamicScreenSpaceErrorFactor,
      40
    ), this.dynamicScreenSpaceErrorHeightFalloff = W(
      e.dynamicScreenSpaceErrorHeightFalloff,
      0.25
    ), this.foveatedScreenSpaceError = W(
      e.foveatedScreenSpaceError,
      !0
    ), this._foveatedConeSize = W(e.foveatedConeSize, 0.05), this._foveatedMinimumScreenSpaceErrorRelaxation = W(
      e.foveatedMinimumScreenSpaceErrorRelaxation,
      0
    ), this.foveatedInterpolationCallback = W(
      e.foveatedInterpolationCallback,
      ce.lerp
    ), this.loadSiblings = W(e.loadSiblings, !1), this.dynamicScreenSpaceHeightScale = e.dynamicScreenSpaceHeightScale || 6, this._dynamicScreenSpaceErrorComputedDensity = 0, this._cullWithChildrenBounds = W(
      e.cullWithChildrenBounds,
      !0
    ), this._url = void 0, this._basePath = void 0, this._root = void 0, this._cache = new I5(), this._processingQueue = [], this._selectedTiles = [], this._selectedTilesToStyle = [], this._emptyTiles = [], this._requestedTiles = [], this._requestedTilesInFlight = [], this._maximumScreenSpaceError = W(
      e.maximumScreenSpaceError,
      64
    ), this._screenSpaceError = this._maximumScreenSpaceError, this.cullRequestsWhileMoving = W(
      e.cullRequestsWhileMoving,
      !0
    ), this._cullRequestsWhileMoving = !1, this.cullRequestsWhileMovingMultiplier = W(
      e.cullRequestsWhileMovingMultiplier,
      60
    ), this.progressiveResolutionHeightFraction = ce.clamp(
      W(e.progressiveResolutionHeightFraction, 0.5),
      0,
      0.5
    ), this._cacheBytes = W(e.cacheBytes, 512 * 1024 * 1024), this._prevSelectedTiles = [];
    const i = W(
      e.maximumCacheOverflowBytes,
      512 * 1024 * 1024
    );
    this._maximumCacheOverflowBytes = i, this._statistics = new ly(), this._statisticsLast = new ly(), this._maximumPriority = {
      foveatedFactor: -Number.MAX_VALUE,
      depth: -Number.MAX_VALUE,
      distance: -Number.MAX_VALUE,
      reverseScreenSpaceError: -Number.MAX_VALUE
    }, this._minimumPriority = {
      foveatedFactor: Number.MAX_VALUE,
      depth: Number.MAX_VALUE,
      distance: Number.MAX_VALUE,
      reverseScreenSpaceError: Number.MAX_VALUE
    }, this._modelMatrix = H(e.modelMatrix) ? new J().copy(e.modelMatrix) : new J(), this.optimizeRaycast = W(e.optimizeRaycast, !0), this._raycastMethod = Cn.RAYCAST_DEFAULT;
    const n = this;
    this._overridenRaycast = function(g, c) {
      n.optimizeRaycast || Object.getPrototypeOf(this).raycast.call(this, g, c);
    }, this._camera = null, this._manager = new YT(), Array.isArray(e.loaders) ? this._loaders = e.loaders : (this._gltfLoader = wx(), this._loaders = [
      [/\.gltf$/, this._gltfLoader]
    ], e.forceUnlit && (this.forceUnlit = !0)), this.updateCustomLoaders(), this.group = new mt(), this.add(this.group);
    const o = this._elementsManager = new iU(this.group);
    o.tilesRenderer = this;
    const r = this._instancedElementManager = new yU();
    r.tilesRenderer = this, this.add(r.group);
    const a = this._editableElementManager = new SU();
    a.tilesRenderer = this, this._displayBoxBounds = W(e.displayBoxBounds, !1), this._displayRegionBounds = W(e.displayRegionBounds, !1), this.debug = W(e.debug, !1), this._initEventListener();
  }
  getBounds() {
    const e = new Ue(), i = this.getBoundingBox(e);
    return i && e.applyMatrix4(this.matrixWorld), i ? e : null;
  }
  isEntityVisible(e) {
    return e.id ? !this._editableElementManager.hasDeletedId(e.id) : !0;
  }
  _initEventListener() {
    this.addEventListener("jsonloaded", this.handleLoadTileset), this.addEventListener("loaded", this.handleLoadTile), this.addEventListener("dispose", this.handleDisposeTile), this.addEventListener("visibilitychange", this.handleTileVisibleChanged);
  }
  handleLoadTileset() {
    this._engine && this._engine.requestRender();
  }
  handleLoadTile(e) {
    const i = e.tile;
    this._refreshTileInfo(i);
    const o = i.content.scene;
    this._elementsManager.onTileLoad(i, o), this._instancedElementManager.onTileLoad(i, o), this._editableElementManager.onTileLoad(i, o), this._engine.requestRender();
  }
  handleDisposeTile(e) {
    const i = e.tile, o = i.content.scene;
    this._elementsManager.onTileDispose(i, o), this._instancedElementManager.onTileDispose(i, o), this._editableElementManager.onTileDispose(i, o);
  }
  handleTileVisibleChanged(e) {
    const {
      tile: i,
      visible: n
    } = e;
    n ? (this._instancedElementManager.onTileShow(i), this._elementsManager.onTileShow(i), this._editableElementManager.onTileShow(i)) : (this._instancedElementManager.onTileHide(i), this._elementsManager.onTileHide(i), this._editableElementManager.onTileHide(i));
  }
  updateCustomLoaders() {
    for (const e of this._loaders)
      this._manager.addHandler(e[0], e[1]);
  }
  afterAddToEngine(e) {
    this._engine = e, e.addPrepareRenderListener(this.handleBeforeRender), this._elementsManager.engine = e, this._instancedElementManager.engine = e, this._editableElementManager.engine = e;
  }
  setCamera(e) {
    this._camera = e;
  }
  hasCamera() {
    return H(this._camera);
  }
  deleteCamera() {
    this._camera = void 0;
  }
  getCamera() {
    return this.hasCamera() ? this._camera : this._engine && this._engine.camera;
  }
  getEntityByIntersection(e) {
    const i = e.object;
    if (!H(i))
      return null;
    const { face: n, faceIndex: o } = e, r = n && n.a, a = {}, g = i.content, c = i.tile;
    if (g && (a._content = g), c) {
      const d = c.tileset;
      a._tile = c, a._tileset = d;
    }
    a._face = n, a._faceIndex = o;
    const l = i.geometry ? i.geometry.getAttribute("_batchid") : void 0, h = g && g.batchTable;
    if (r !== void 0 && l) {
      const d = Math.round(l.getX(r));
      a._batchId = d;
      for (const C of Object.keys(h.header)) {
        const p = h.header[C];
        a[C] = p[d];
      }
    }
    return a;
  }
  updateInfo() {
    const e = this._engine, i = this.getCamera();
    this.dispatchEvent({ type: "update-before" });
    const n = e.renderer.getPixelRatio(), o = this._cameraInfo || {
      positionWCDeltaMagnitude: 0,
      positionCartographic: new B(),
      lastMovedTimestamp: Date.now(),
      positionWCDeltaMagnitudeLastFrame: 0,
      timeSinceMoved: 0,
      position: new B(),
      directionWC: new B(),
      oldPosition: null
    }, r = e.rendering.resolution;
    (r.x === 0 || r.y === 0) && console.warn("TilesRenderer: resolution for camera error calculation is not set.");
    const a = i.projectionMatrix.elements;
    if (o.isOrthographic = a[15] === 1, o.isOrthographic) {
      const C = 2 / a[0], p = 2 / a[5];
      o.pixelSize = Math.max(p / (r.height * n), C / (r.width * n));
    } else
      o.sseDenominator = 2 / a[5] / (r.y * n);
    o.invScale = 1, o.position = xU.copy(i.position), o.pixelRatio = e.rendering.pixelRatio;
    const g = o.position;
    o.oldPosition || (o.oldPosition = g.clone()), o.frustum || (o.frustum = new v5());
    const c = new J(), l = new J(), h = this.group;
    c.copy(h.matrixWorld), l.copy(c).invert(), c.premultiply(i.matrixWorldInverse), c.premultiply(i.projectionMatrix), o.frustum.setFromProjectionMatrix(c), g.set(0, 0, 0), g.applyMatrix4(i.matrixWorld), g.applyMatrix4(l), o.positionWCDeltaMagnitudeLastFrame = o.positionWCDeltaMagnitude;
    const d = vU.subVectors(g, o.oldPosition);
    o.positionWCDeltaMagnitude = d.length(), o.positionWCDeltaMagnitude > 0 ? (o.timeSinceMoved = 0, o.lastMovedTimestamp = Date.now()) : o.timeSinceMoved = Math.max(Date.now() - o.lastMovedTimestamp, 0) / 1e3, o.oldPosition.copy(g), i.getWorldDirection(o.directionWC), o.positionCartographic.fromArray(e.map.unprojectArrayCoordinate(i.position.toArray())), this._cameraInfo = o;
  }
  prePassesUpdate(e) {
    if (this.updateInfo(), !!H(this._root)) {
      if (XU(this), this.dynamicScreenSpaceError) {
        const i = this._engine;
        EU(this, e, i);
      }
      this._cache.reset();
    }
  }
  forEachLoadedModel(e) {
    this.traversalLoadedTile(e);
  }
  update(e) {
    HU(this, e);
  }
  trimLoadedTiles() {
    this._cache.trim();
  }
  postPassesUpdate(e) {
    !H(this._root) || (RU(this, e), this._cache.unloadTiles(this, gS), this._styleApplied = !1, Bi.update());
  }
  beforeRemoveFromEngine(e) {
    this._engine.removePrepareRenderListener(this.handleBeforeRender), this.dispose();
  }
  dispose() {
    this.resetQueue(), this.traversalLoadedTile((e, i) => {
      this._cache.unloadTile(this, i, gS);
    });
  }
  disposePlugins() {
    this.plugins.forEach((e) => {
      e.dispose && e.dispose();
    });
  }
  resetQueue() {
    this._prevSelectedTiles.length = 0, this._processingQueue.length = 0, this._requestedTiles.length = 0;
  }
  getTraversal() {
    return this.isSkippingLevelOfDetail ? KZ : VZ;
  }
  isDestroyed() {
    return !1;
  }
  async setTilesetProperties(e, i, n) {
    const o = await oS(
      i,
      e
    );
    this._metadataExtension = o, this._geometricError = e.geometricError, this._scaledGeometricError = e.geometricError;
    const r = e.asset;
    this._asset = r, this._extras = e.extras;
    const a = H(e.asset.gltfUpAxis) ? ts.fromName(e.asset.gltfUpAxis) : ts.Y, g = W(n.modelUpAxis, a), c = W(n.modelForwardAxis, ts.X);
    this._gltfUpMatrix = new J(), this._properties = e.properties, this._extensionsUsed = e.extensionsUsed, this._extensions = e.extensions, this._modelUpAxis = g, this._modelForwardAxis = c, this._root = this.loadTileset(i, e), queueMicrotask(() => {
      this.dispatchEvent({
        type: "rootloaded",
        tileset: e,
        url: i.url
      });
    });
  }
  static async fromAssetId(e, i) {
    const n = await fa.fromAssetId(e);
    return Cn.fromUrl(n, i);
  }
  static fromUrl(e, i) {
    i = W(i, {});
    const n = Lt.createIfNeeded(e);
    let o;
    n.extension === "json" ? o = n.getBaseUri(!0) : n.isDataUri && (o = "");
    const r = new Cn(i);
    return r._resource = n, r._url = e, r._basePath = o, Cn.loadJson(n).then(async function(a) {
      r.setTilesetProperties(a, n, i);
    }), r;
  }
  static async fromUrlAsync(e, i) {
    i = W(i, {});
    const n = Lt.createIfNeeded(e);
    let o;
    n.extension === "json" ? o = n.getBaseUri(!0) : n.isDataUri && (o = "");
    const r = await Cn.loadJson(n), a = await oS(
      n,
      r
    ), g = new Cn(i);
    g._resource = n, g._url = e, g._basePath = o, g._metadataExtension = a, g._geometricError = r.geometricError, g._scaledGeometricError = r.geometricError;
    const c = r.asset;
    g._asset = c, g._extras = r.extras;
    const l = H(r.asset.gltfUpAxis) ? ts.fromName(r.asset.gltfUpAxis) : ts.Y, h = W(i.modelUpAxis, l), d = W(i.modelForwardAxis, ts.X);
    return g._gltfUpMatrix = new J(), g._properties = r.properties, g._extensionsUsed = r.extensionsUsed, g._extensions = r.extensions, g._modelUpAxis = h, g._modelForwardAxis = d, g._root = g.loadTileset(n, r), g;
  }
  static async loadJson(e) {
    return Lt.createIfNeeded(e).fetchJson();
  }
  getBoundingBox(e) {
    if (!this.root)
      return !1;
    const i = this.root.boundingVolume;
    return i ? (i.getAABB(e), !0) : !1;
  }
  loadTileset(e, i, n) {
    const o = i.asset;
    if (!H(o))
      throw new Error("Tileset must have an asset property.");
    if (o.version !== "0.0" && o.version !== "1.0" && o.version !== "1.1")
      throw new Error(
        "The tileset must be 3D Tiles version 0.0, 1.0, or 1.1"
      );
    H(i.extensionsRequired) && Cn.checkSupportedExtensions(i.extensionsRequired);
    const r = this._statistics, a = o.tilesetVersion;
    H(a) && (this._basePath += `?v=${a}`, e = e.clone(), e.setQueryParameters({ v: a }));
    const g = rS(this, e, i.root, n);
    H(n) && (n.children.push(g), g._depth = n._depth + 1);
    const c = [];
    for (c.push(g); c.length > 0; ) {
      const l = c.pop();
      ++r.numberOfTilesTotal, this._allTilesAdditive = this._allTilesAdditive && l.refine === gs.ADD;
      const h = l._header.children;
      if (H(h))
        for (let d = 0; d < h.length; ++d) {
          const C = h[d], p = rS(this, e, C, l);
          l.children.push(p), p._depth = l._depth + 1, c.push(p);
        }
      this._cullWithChildrenBounds && Tx.checkChildrenWithinParent(l);
    }
    return queueMicrotask(() => {
      this.dispatchEvent({
        type: "jsonloaded",
        tileset: i,
        url: e.url
      });
    }), g;
  }
  registerPlugin(e) {
    if (e[nS] === !0)
      throw new Error("A plugin can only be registered to a single tile set");
    return this.plugins.push(e), e[nS] = !0, e.init && e.init(this), e;
  }
  raycast(e, i) {
    if (!!this._root && this.raycastMethod !== Cn.RAYCAST_NONE)
      if (e.firstHitOnly) {
        const n = $x(this, this._root, e);
        n && i.push(n);
      } else
        ev(this, this._root, e, i);
  }
  get raycastMethod() {
    return this._raycastMethod;
  }
  set raycastMethod(e) {
    e !== this._raycastMethod && (this._raycastMethod = parseInt(e, 10), this._needsRefreshAllLoadedTiles = !0, this._engine && this._engine.requestRender());
  }
  get root() {
    return this._root;
  }
  get modelMatrix() {
    return this._modelMatrix;
  }
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  get cacheBytes() {
    return this._cacheBytes;
  }
  set cacheBytes(e) {
    this._cacheBytes = e;
  }
  get maximumCacheOverflowBytes() {
    return this._maximumCacheOverflowBytes;
  }
  set maximumCacheOverflowBytes(e) {
    this._maximumCacheOverflowBytes = e;
  }
  get gltfUpMatrix() {
    switch (this._modelUpAxis) {
      case ts.X:
        this._gltfUpMatrix.makeRotationAxis(_U, -Math.PI / 2);
        break;
      case ts.Y:
        this._gltfUpMatrix.makeRotationAxis(wU, Math.PI / 2);
        break;
    }
    return this._gltfUpMatrix;
  }
  get metadataExtension() {
    return this._metadataExtension;
  }
  get schema() {
    if (H(this._metadataExtension))
      return this._metadataExtension.schema;
  }
  get metadata() {
    if (H(this._metadataExtension))
      return this._metadataExtension.tileset;
  }
  get foveatedConeSize() {
    return this._foveatedConeSize;
  }
  set foveatedConeSize(e) {
    this._foveatedConeSize = e;
  }
  get totalMemoryUsageInBytes() {
    return this._statistics.totalByteLength;
  }
  get statistics() {
    return this._statistics;
  }
  get foveatedMinimumScreenSpaceErrorRelaxation() {
    return this._foveatedMinimumScreenSpaceErrorRelaxation;
  }
  set foveatedMinimumScreenSpaceErrorRelaxation(e) {
    this._foveatedMinimumScreenSpaceErrorRelaxation = e;
  }
  get maximumScreenSpaceError() {
    return this._maximumScreenSpaceError;
  }
  set maximumScreenSpaceError(e) {
    this._maximumScreenSpaceError = e, this._screenSpaceError = e, this._engine && this._engine.requestRender();
  }
  get debug() {
    return this._debug;
  }
  set debug(e) {
    this._debug !== e && (this._debug = e, e ? (this._debugTilesPlugin = new $Z(), this._debugTilesPlugin.displayBoxBounds = this._displayBoxBounds, this._debugTilesPlugin.displayRegionBounds = this._displayRegionBounds, this.registerPlugin(this._debugTilesPlugin)) : this._debugTilesPlugin && this._debugTilesPlugin.dispose());
  }
  get debugTilesPlugin() {
    return this._debugTilesPlugin;
  }
  get displayBoxBounds() {
    return this._displayBoxBounds;
  }
  set displayBoxBounds(e) {
    this._displayBoxBounds = e, this._debugTilesPlugin && (this._debugTilesPlugin.displayBoxBounds = e);
  }
  get displayRegionBounds() {
    return this._displayRegionBounds;
  }
  set displayRegionBounds(e) {
    this._displayRegionBounds = e, this._debugTilesPlugin && (this._debugTilesPlugin.displayRegionBounds = e);
  }
  get displaySphereBounds() {
    return this._displaySphereBounds;
  }
  set displaySphereBounds(e) {
    this._displaySphereBounds = e, this._debugTilesPlugin && (this._debugTilesPlugin.displaySphereBounds = e);
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get materialManager() {
    return this._materialManager;
  }
  set materialManager(e) {
    e !== this._materialManager && (e && (e.engine = this._engine, e.tiles = this, e.init(), e.isIdentity3DTilesMaterialManager && (e.type = this._identityType)), this._materialManager = e, this._needsRefreshAllLoadedTiles = !0, this._engine.requestRender());
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(e) {
    e !== this._castShadow && (this._castShadow = e, this._needsRefreshAllLoadedTiles = !0, this._engine && this._engine.requestRender());
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set receiveShadow(e) {
    e !== this._receiveShadow && (this._receiveShadow = e, this._needsRefreshAllLoadedTiles = !0, this._engine && this._engine.requestRender());
  }
  get instancedElementManager() {
    return this._instancedElementManager;
  }
  get editableElementManager() {
    return this._editableElementManager;
  }
  get elementsManager() {
    return this._elementsManager;
  }
  get forceUnlit() {
    return this._forceUnlit;
  }
  set forceUnlit(e) {
    e === this._forceUnlit || !this._gltfLoader || (this._forceUnlit = e, this._gltfLoader.setForceUnlit(e), this.dispose(), this.engine && this.engine.requestRender());
  }
};
let ns = Cn;
f(ns, "RAYCAST_NONE", 0), f(ns, "RAYCAST_DEFAULT", 1), f(ns, "RAYCAST_BVH", 2), f(ns, "supportedExtensions", {
  "3DTILES_metadata": !0,
  "3DTILES_implicit_tiling": !0,
  "3DTILES_multiple_contents": !0
}), f(ns, "checkSupportedExtensions", function(e) {
  for (let i = 0; i < e.length; i++)
    if (!Cn.supportedExtensions[e[i]])
      throw new Error(
        `Unsupported 3D Tiles Extension: ${e[i]}`
      );
});
function rS(s, t, e, i) {
  if (!(H(e.implicitTiling) || Ei(e, "3DTILES_implicit_tiling")))
    return new Ny(s, t, e, i);
  const o = s.schema, r = new ZZ(
    t,
    e,
    o
  ), a = new Yi({
    subdivisionScheme: r.subdivisionScheme,
    subtreeLevels: r.subtreeLevels,
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }), g = r.subtreeUriTemplate.getDerivedResource({
    templateValues: a.getTemplateValues()
  }).url, l = dt(e, !0);
  l.contents = [
    {
      uri: g
    }
  ], delete l.content, delete l.extensions;
  const h = new Ny(s, t, l, i);
  return h.implicitTileset = r, h.implicitCoordinates = a, h;
}
function RU(s, t) {
  const e = s._requestedTilesInFlight;
  let i = 0;
  for (let n = 0; n < e.length; ++n) {
    const o = e[n], r = t.frameCount - o._touchedFrame >= 1;
    if (o._contentState !== li.LOADING) {
      ++i;
      continue;
    } else if (r) {
      o.cancelRequests(), ++i;
      continue;
    }
    i > 0 && (e[n - i] = o);
  }
  e.length -= i;
}
function Ei(s, t) {
  return H(s) && H(s.extensions) && H(s.extensions[t]);
}
function DU(s) {
  const t = s._processingQueue;
  let e = 0;
  for (let i = 0; i < t.length; i++) {
    const n = t[i];
    if (n.isDestroyed() || n._contentState !== li.PROCESSING) {
      ++e;
      continue;
    }
    e && (t[i - e] = n);
  }
  t.length -= e;
}
function ov(s, t, e) {
  t.isDestroyed() || (e.isDestroyed() || e._contentResource.url, H(s.message) ? s.message : s.toString());
}
function KU(s) {
  s._minimumPriority.depth = Number.MAX_VALUE, s._maximumPriority.depth = -Number.MAX_VALUE, s._minimumPriority.foveatedFactor = Number.MAX_VALUE, s._maximumPriority.foveatedFactor = -Number.MAX_VALUE, s._minimumPriority.distance = Number.MAX_VALUE, s._maximumPriority.distance = -Number.MAX_VALUE, s._minimumPriority.reverseScreenSpaceError = Number.MAX_VALUE, s._maximumPriority.reverseScreenSpaceError = -Number.MAX_VALUE;
}
function HU(s, t) {
  if (!H(s._root))
    return !1;
  s._statistics.clear(), s._updatedVisibilityFrame = t.frameCount, KU(s), s._cullRequestsWhileMoving = s.cullRequestsWhileMoving, s.getTraversal().selectTiles(s, t), NU(s), VU(s, t), s.dispatchEvent({ type: "update-after" });
}
function PU(s, t) {
  return s._priority - t._priority;
}
function NU(s) {
  const t = s._requestedTiles;
  t.sort(PU);
  for (let e = 0; e < t.length; ++e)
    zU(s, t[e]);
}
function FU(s) {
  const t = s.tileset, e = s._content;
  if (e.isMultiple3DTileContents) {
    const i = e._contents, n = i.length;
    for (let o = 0; o < n; ++o) {
      const r = i[o].scene;
      t.group.add(r);
    }
  } else {
    const i = e.scene;
    t.group.add(i);
  }
}
function kU(s) {
  const t = s.tileset, e = s._content;
  if (e.isMultiple3DTileContents) {
    const i = e._contents, n = i.length;
    for (let o = 0; o < n; ++o) {
      const r = i[o].scene;
      t.group.remove(r);
    }
  } else {
    const i = e.scene;
    t.group.remove(i);
  }
}
function aS(s, t) {
  const e = s.tileset;
  t ? FU(s) : kU(s), e.dispatchEvent({
    type: "visibilitychange",
    tile: s,
    visible: t
  });
}
function VU(s, t) {
  s._styleApplied = !0;
  const e = s._prevSelectedTiles, i = s._selectedTiles, { statistics: n } = s;
  let o = 0, r = 0;
  for (o = 0, r = e.length; o < r; o++) {
    const g = e[o];
    i.includes(g) || aS(g, !1);
  }
  for (o = 0, r = i.length; o < r; o++) {
    const g = i[o];
    e.includes(g) || aS(g, !0), g.update(s, t);
  }
  n.selected = i.length, s._prevSelectedTiles = [...i];
  const a = s._emptyTiles;
  for (let g = 0; g < a.length; ++g)
    a[g].update(s, t);
}
function zU(s, t) {
  if (t.hasEmptyContent)
    return;
  const { statistics: e } = s, i = t.requestContent();
  !H(i) || (i.then((n) => {
    !H(n) || t.isDestroyed() || s.isDestroyed() || (s._processingQueue.push(t), ++e.numberOfTilesProcessing, s._engine.requestRender());
  }).catch((n) => {
    ov(n, s, t);
  }), s._requestedTilesInFlight.push(t));
}
function gS(s, t) {
  s._statistics.decrementLoadCounts(t.content), --s._statistics.numberOfTilesWithContentReady, t.unloadContent();
}
function XU(s) {
  DU(s);
  const t = s._processingQueue, { cacheBytes: e, maximumCacheOverflowBytes: i, statistics: n } = s;
  for (let o = 0; o < t.length; ++o) {
    const r = t[o];
    try {
      r.process(s), r.contentReady && --n.numberOfTilesProcessing;
    } catch {
      --n.numberOfTilesProcessing, ov();
    }
  }
}
class rv extends ns {
  constructor(e) {
    const i = W(e.errorTarget, 64), n = W(e.forceUnlit, !1), o = W(e.cullWithChildrenBounds, !0), r = W(e.cullRequestsWhileMoving, !0), a = W(e.cullRequestsWhileMovingMultiplier, 60), g = W(e.dynamicScreenSpaceError, !0), c = W(e.dynamicScreenSpaceErrorHeightFalloff, 0.25), l = W(e.dynamicScreenSpaceErrorDensity, 278e-5), h = W(e.foveatedScreenSpaceError, !1), d = W(e.foveatedConeSize, 0.3), C = W(e.foveatedMinimumScreenSpaceErrorRelaxation, 0.8), p = W(e.progressiveResolutionHeightFraction, 0.5), m = e.cacheBytes, b = e._maximumCacheOverflowBytes, S = e.loaders;
    super({
      maximumScreenSpaceError: i,
      forceUnlit: n,
      cullWithChildrenBounds: o,
      cullRequestsWhileMoving: r,
      cullRequestsWhileMovingMultiplier: a,
      dynamicScreenSpaceError: g,
      dynamicScreenSpaceErrorHeightFalloff: c,
      dynamicScreenSpaceErrorDensity: l,
      foveatedScreenSpaceError: h,
      foveatedConeSize: d,
      foveatedMinimumScreenSpaceErrorRelaxation: C,
      progressiveResolutionHeightFraction: p,
      cacheBytes: m,
      maximumCacheOverflowBytes: b,
      loaders: S
    });
    f(this, "_showDebug", !1);
    f(this, "transformFromEcefToPlane", (e, i, n = 0) => {
      let o = Ze.eastNorthUpToFixedFrame(Ze.lnglatToEcef(e, i, n));
      o.invert();
      const r = new J(), a = this.engine.map.projectArrayCoordinate([e, i]);
      r.makeTranslation(a[0], a[1], 0);
      const g = new J();
      g.multiplyMatrices(r, o), g.decompose(this.position, this.quaternion, this.scale);
    });
    f(this, "lockCameraViewport", () => {
      const e = this.getCamera(), i = this._lockedCamera = e.clone();
      this.setCamera(i), this._updateCameraHelper(i);
    });
    f(this, "releaseCameraViewport", () => {
      const e = this._engine;
      if (this._lockedCamera) {
        const n = e.camera;
        this.setCamera(n), this._lockedCamera = null;
      }
      this._destroyCameraHelper();
    });
    this._errorTarget = i;
    const A = e.url;
    e = W(e, {});
    const u = e.assetId;
    if (H(u))
      fa.fromAssetId(u).then((y) => {
        let I;
        y.extension === "json" ? I = y.getBaseUri(!0) : y.isDataUri && (I = ""), this._resource = y, this._url = A, this._basePath = I, ns.loadJson(y).then(async (M) => {
          this.setTilesetProperties(M, y, e);
        });
      });
    else {
      const y = Lt.createIfNeeded(A);
      let I;
      y.extension === "json" ? I = y.getBaseUri(!0) : y.isDataUri && (I = ""), this._resource = y, this._url = A, this._basePath = I, ns.loadJson(y).then(async (M) => {
        this.setTilesetProperties(M, y, e);
      });
    }
  }
  static async fromAssetId(e, i = {}) {
    const n = await fa.fromAssetId(e);
    return i.url = n, new rv(i);
  }
  _updateCameraHelper(e) {
    const i = this._engine;
    this._destroyCameraHelper();
    const n = this._cameraHelper = new zA(e);
    i.add(n);
  }
  _destroyCameraHelper() {
    const e = this._engine;
    this._cameraHelper && (e.remove(this._cameraHelper), this._cameraHelper.dispose(), this._cameraHelper = null);
  }
  get showDebug() {
    return this._showDebug;
  }
  set showDebug(e) {
    this._showDebug !== e && (this.debug = e, this.displayBoxBounds = e, this.displayRegionBounds = e, this.displaySphereBounds = e, this._showDebug = e);
  }
  get errorTarget() {
    return this.maximumScreenSpaceError;
  }
  set errorTarget(e) {
    this.maximumScreenSpaceError = e;
  }
  get cullWithChildrenBounds() {
    return this._cullWithChildrenBounds;
  }
  set cullWithChildrenBounds(e) {
    this._cullWithChildrenBounds = e;
  }
  get cullRequestsWhileMoving() {
    return this._cullRequestsWhileMoving;
  }
  set cullRequestsWhileMoving(e) {
    this._cullRequestsWhileMoving = e;
  }
  get foveatedConeSize() {
    return this._foveatedConeSize;
  }
  set foveatedConeSize(e) {
    this._foveatedConeSize = e;
  }
  get loadSiblings() {
    return this._loadSiblings;
  }
  set loadSiblings(e) {
    this._loadSiblings = e;
  }
}
const ua = class extends Gi {
  constructor(t) {
    super(t), this.type = "GeoJSONDataSource";
  }
  async _convertStreamingDataToObjectData(t) {
    return await t.json();
  }
  _parseObjectDataToDataItems(t) {
    let e = null, i = null;
    Array.isArray(t) ? e = t : Array.isArray(t.features) || t.type === "FeatureCollection" ? (e = t.features, i = t.properties) : t.type === "Feature" && (e = [t]);
    const n = [];
    for (let o = 0; o < e.length; o++)
      n.push(new Ds(e[o], i));
    return n;
  }
};
let gr = ua;
f(gr, "fromGeoJSON", function(t, e) {
  typeof t == "string" && console.error("It seems that you are trying to pass a URL to GeoJSONDataSource.fromGeoJSON, please use GeoJSONDataSource.fromURL instead.");
  let i = new ua(e);
  return i.setData(t), i;
}), f(gr, "fromURL", async function(t, e) {
  let i = new ua(e);
  return await i.load(t), i;
}), f(gr, "fromGeoJSONObject", function(t, e) {
  return console.warn("GeoJSONDataSource.fromGeoJSONObject is deprecated, please use GeoJSONDataSource.fromGeoJSON instead."), ua.fromGeoJSON(t, e);
}), f(gr, "fromObject", function(t, e) {
  return console.warn("GeoJSONDataSource.fromObject is deprecated, please use GeoJSONDataSource.fromGeoJSON instead."), ua.fromGeoJSON(t, e);
});
var gd = { exports: {} };
gd.exports = av;
gd.exports.parse = av;
gd.exports.stringify = gv;
var cS = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/, lS = new RegExp("^" + cS.source + "(\\s" + cS.source + "){1,}");
function av(s) {
  var t = s.split(";"), e = t.pop(), i = (t.shift() || "").split("=").pop(), n = 0;
  function o(A) {
    var u = e.substring(n).match(A);
    return u ? (n += u[0].length, u[0]) : null;
  }
  function r(A) {
    return A && i.match(/\d+/) && (A.crs = {
      type: "name",
      properties: {
        name: "urn:ogc:def:crs:EPSG::" + i
      }
    }), A;
  }
  function a() {
    o(/^\s*/);
  }
  function g() {
    a();
    for (var A = 0, u = [], y = [u], I = u, M; M = o(/^(\()/) || o(/^(\))/) || o(/^(,)/) || o(lS); ) {
      if (M === "(")
        y.push(I), I = [], y[y.length - 1].push(I), A++;
      else if (M === ")") {
        if (I.length === 0 || (I = y.pop(), !I))
          return null;
        if (A--, A === 0)
          break;
      } else if (M === ",")
        I = [], y[y.length - 1].push(I);
      else if (!M.split(/\s/g).some(isNaN))
        Array.prototype.push.apply(I, M.split(/\s/g).map(parseFloat));
      else
        return null;
      a();
    }
    return A !== 0 ? null : u;
  }
  function c() {
    for (var A = [], u, y; y = o(lS) || o(/^(,)/); )
      y === "," ? (A.push(u), u = []) : y.split(/\s/g).some(isNaN) || (u || (u = []), Array.prototype.push.apply(u, y.split(/\s/g).map(parseFloat))), a();
    if (u)
      A.push(u);
    else
      return null;
    return A.length ? A : null;
  }
  function l() {
    if (!o(/^(point(\sz)?)/i) || (a(), !o(/^(\()/)))
      return null;
    var A = c();
    return !A || (a(), !o(/^(\))/)) ? null : {
      type: "Point",
      coordinates: A[0]
    };
  }
  function h() {
    if (!o(/^(multipoint)/i))
      return null;
    a();
    var A = e.substring(e.indexOf("(") + 1, e.length - 1).replace(/\(/g, "").replace(/\)/g, "");
    e = "MULTIPOINT (" + A + ")";
    var u = g();
    return u ? (a(), {
      type: "MultiPoint",
      coordinates: u
    }) : null;
  }
  function d() {
    if (!o(/^(multilinestring)/i))
      return null;
    a();
    var A = g();
    return A ? (a(), {
      type: "MultiLineString",
      coordinates: A
    }) : null;
  }
  function C() {
    if (!o(/^(linestring(\sz)?)/i) || (a(), !o(/^(\()/)))
      return null;
    var A = c();
    return !A || !o(/^(\))/) ? null : {
      type: "LineString",
      coordinates: A
    };
  }
  function p() {
    if (!o(/^(polygon(\sz)?)/i))
      return null;
    a();
    var A = g();
    return A ? {
      type: "Polygon",
      coordinates: A
    } : null;
  }
  function m() {
    if (!o(/^(multipolygon)/i))
      return null;
    a();
    var A = g();
    return A ? {
      type: "MultiPolygon",
      coordinates: A
    } : null;
  }
  function b() {
    var A = [], u;
    if (!o(/^(geometrycollection)/i) || (a(), !o(/^(\()/)))
      return null;
    for (; u = S(); )
      A.push(u), a(), o(/^(,)/), a();
    return o(/^(\))/) ? {
      type: "GeometryCollection",
      geometries: A
    } : null;
  }
  function S() {
    return l() || C() || p() || h() || d() || m() || b();
  }
  return r(S());
}
function gv(s) {
  s.type === "Feature" && (s = s.geometry);
  function t(r) {
    return r.join(" ");
  }
  function e(r) {
    return r.map(t).join(", ");
  }
  function i(r) {
    return r.map(e).map(o).join(", ");
  }
  function n(r) {
    return r.map(i).map(o).join(", ");
  }
  function o(r) {
    return "(" + r + ")";
  }
  switch (s.type) {
    case "Point":
      return "POINT (" + t(s.coordinates) + ")";
    case "LineString":
      return "LINESTRING (" + e(s.coordinates) + ")";
    case "Polygon":
      return "POLYGON (" + i(s.coordinates) + ")";
    case "MultiPoint":
      return "MULTIPOINT (" + e(s.coordinates) + ")";
    case "MultiPolygon":
      return "MULTIPOLYGON (" + n(s.coordinates) + ")";
    case "MultiLineString":
      return "MULTILINESTRING (" + i(s.coordinates) + ")";
    case "GeometryCollection":
      return "GEOMETRYCOLLECTION (" + s.geometries.map(gv).join(", ") + ")";
    default:
      throw new Error("stringify requires a valid GeoJSON Feature or geometry object as input");
  }
}
const Eh = class extends Gi {
  constructor(e = {}) {
    super(e);
    f(this, "_coordinatesKey", "coordinates");
    f(this, "_parseCoordinates");
    f(this, "_parseFeature");
    this.type = "JSONDataSource", e.coordinatesKey && (this._coordinatesKey = e.coordinatesKey), e.parseCoordinates && (this._parseCoordinates = e.parseCoordinates), e.parseFeature && (this._parseFeature = e.parseFeature);
  }
  async _convertStreamingDataToObjectData(e) {
    return await e.json();
  }
  _convertObjectDataToJSONData(e) {
    return Array.isArray(e) ? e : [e];
  }
  _parseObjectDataToDataItems(e) {
    const i = this._convertObjectDataToJSONData(e), n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o], g = {};
      let c = null;
      if (this._parseFeature)
        n.push(this._parseFeature(a));
      else {
        for (const l of Object.keys(a))
          l !== this.coordinatesKey ? g[l] = a[l] : this.parseCoordinates || (c = gd.exports(a[l]));
        this._parseCoordinates && (c = this._parseCoordinates(a)), c = this._formatGeometry(c), n.push(new Ds({ geometry: c, properties: g }));
      }
    }
    return n;
  }
  get coordinatesKey() {
    return this._coordinatesKey;
  }
  set coordinatesKey(e) {
    this._coordinatesKey = e;
  }
  set parseCoordinates(e) {
    this._parseCoordinates = e;
  }
  get parseCoordinates() {
    return this._parseCoordinates;
  }
  set parseFeature(e) {
    this._parseFeature = e;
  }
  get parseFeature() {
    return this._parseFeature;
  }
};
let ra = Eh;
f(ra, "fromURL", async function(e, i) {
  let n = new Eh(i);
  return await n.load(e), n;
}), f(ra, "fromUrl", async function(e, i) {
  return console.warn("JSONDataSource.fromUrl is deprecated, please use JSONDataSource.fromURL instead."), await this.fromURL(e, i);
}), f(ra, "fromJSON", function(e, i) {
  let n = new Eh(i);
  return n.setData(e), n;
});
var hS = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {}, ss = [], mn = [], WU = typeof Uint8Array < "u" ? Uint8Array : Array, hf = !1;
function cv() {
  hf = !0;
  for (var s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, e = s.length; t < e; ++t)
    ss[t] = s[t], mn[s.charCodeAt(t)] = t;
  mn["-".charCodeAt(0)] = 62, mn["_".charCodeAt(0)] = 63;
}
function ZU(s) {
  hf || cv();
  var t, e, i, n, o, r, a = s.length;
  if (a % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  o = s[a - 2] === "=" ? 2 : s[a - 1] === "=" ? 1 : 0, r = new WU(a * 3 / 4 - o), i = o > 0 ? a - 4 : a;
  var g = 0;
  for (t = 0, e = 0; t < i; t += 4, e += 3)
    n = mn[s.charCodeAt(t)] << 18 | mn[s.charCodeAt(t + 1)] << 12 | mn[s.charCodeAt(t + 2)] << 6 | mn[s.charCodeAt(t + 3)], r[g++] = n >> 16 & 255, r[g++] = n >> 8 & 255, r[g++] = n & 255;
  return o === 2 ? (n = mn[s.charCodeAt(t)] << 2 | mn[s.charCodeAt(t + 1)] >> 4, r[g++] = n & 255) : o === 1 && (n = mn[s.charCodeAt(t)] << 10 | mn[s.charCodeAt(t + 1)] << 4 | mn[s.charCodeAt(t + 2)] >> 2, r[g++] = n >> 8 & 255, r[g++] = n & 255), r;
}
function UU(s) {
  return ss[s >> 18 & 63] + ss[s >> 12 & 63] + ss[s >> 6 & 63] + ss[s & 63];
}
function OU(s, t, e) {
  for (var i, n = [], o = t; o < e; o += 3)
    i = (s[o] << 16) + (s[o + 1] << 8) + s[o + 2], n.push(UU(i));
  return n.join("");
}
function dS(s) {
  hf || cv();
  for (var t, e = s.length, i = e % 3, n = "", o = [], r = 16383, a = 0, g = e - i; a < g; a += r)
    o.push(OU(s, a, a + r > g ? g : a + r));
  return i === 1 ? (t = s[e - 1], n += ss[t >> 2], n += ss[t << 4 & 63], n += "==") : i === 2 && (t = (s[e - 2] << 8) + s[e - 1], n += ss[t >> 10], n += ss[t >> 4 & 63], n += ss[t << 2 & 63], n += "="), o.push(n), o.join("");
}
function cd(s, t, e, i, n) {
  var o, r, a = n * 8 - i - 1, g = (1 << a) - 1, c = g >> 1, l = -7, h = e ? n - 1 : 0, d = e ? -1 : 1, C = s[t + h];
  for (h += d, o = C & (1 << -l) - 1, C >>= -l, l += a; l > 0; o = o * 256 + s[t + h], h += d, l -= 8)
    ;
  for (r = o & (1 << -l) - 1, o >>= -l, l += i; l > 0; r = r * 256 + s[t + h], h += d, l -= 8)
    ;
  if (o === 0)
    o = 1 - c;
  else {
    if (o === g)
      return r ? NaN : (C ? -1 : 1) * (1 / 0);
    r = r + Math.pow(2, i), o = o - c;
  }
  return (C ? -1 : 1) * r * Math.pow(2, o - i);
}
function lv(s, t, e, i, n, o) {
  var r, a, g, c = o * 8 - n - 1, l = (1 << c) - 1, h = l >> 1, d = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, C = i ? 0 : o - 1, p = i ? 1 : -1, m = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, r = l) : (r = Math.floor(Math.log(t) / Math.LN2), t * (g = Math.pow(2, -r)) < 1 && (r--, g *= 2), r + h >= 1 ? t += d / g : t += d * Math.pow(2, 1 - h), t * g >= 2 && (r++, g /= 2), r + h >= l ? (a = 0, r = l) : r + h >= 1 ? (a = (t * g - 1) * Math.pow(2, n), r = r + h) : (a = t * Math.pow(2, h - 1) * Math.pow(2, n), r = 0)); n >= 8; s[e + C] = a & 255, C += p, a /= 256, n -= 8)
    ;
  for (r = r << n | a, c += n; c > 0; s[e + C] = r & 255, C += p, r /= 256, c -= 8)
    ;
  s[e + C - p] |= m * 128;
}
var QU = {}.toString, hv = Array.isArray || function(s) {
  return QU.call(s) == "[object Array]";
}, YU = 50;
q.TYPED_ARRAY_SUPPORT = hS.TYPED_ARRAY_SUPPORT !== void 0 ? hS.TYPED_ARRAY_SUPPORT : !0;
Th();
function Th() {
  return q.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Fs(s, t) {
  if (Th() < t)
    throw new RangeError("Invalid typed array length");
  return q.TYPED_ARRAY_SUPPORT ? (s = new Uint8Array(t), s.__proto__ = q.prototype) : (s === null && (s = new q(t)), s.length = t), s;
}
function q(s, t, e) {
  if (!q.TYPED_ARRAY_SUPPORT && !(this instanceof q))
    return new q(s, t, e);
  if (typeof s == "number") {
    if (typeof t == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return df(this, s);
  }
  return dv(this, s, t, e);
}
q.poolSize = 8192;
q._augment = function(s) {
  return s.__proto__ = q.prototype, s;
};
function dv(s, t, e, i) {
  if (typeof t == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer ? qU(s, t, e, i) : typeof t == "string" ? JU(s, t, e) : $U(s, t);
}
q.from = function(s, t, e) {
  return dv(null, s, t, e);
};
q.TYPED_ARRAY_SUPPORT && (q.prototype.__proto__ = Uint8Array.prototype, q.__proto__ = Uint8Array, typeof Symbol < "u" && Symbol.species && q[Symbol.species]);
function uv(s) {
  if (typeof s != "number")
    throw new TypeError('"size" argument must be a number');
  if (s < 0)
    throw new RangeError('"size" argument must not be negative');
}
function jU(s, t, e, i) {
  return uv(t), t <= 0 ? Fs(s, t) : e !== void 0 ? typeof i == "string" ? Fs(s, t).fill(e, i) : Fs(s, t).fill(e) : Fs(s, t);
}
q.alloc = function(s, t, e) {
  return jU(null, s, t, e);
};
function df(s, t) {
  if (uv(t), s = Fs(s, t < 0 ? 0 : uf(t) | 0), !q.TYPED_ARRAY_SUPPORT)
    for (var e = 0; e < t; ++e)
      s[e] = 0;
  return s;
}
q.allocUnsafe = function(s) {
  return df(null, s);
};
q.allocUnsafeSlow = function(s) {
  return df(null, s);
};
function JU(s, t, e) {
  if ((typeof e != "string" || e === "") && (e = "utf8"), !q.isEncoding(e))
    throw new TypeError('"encoding" must be a valid string encoding');
  var i = Iv(t, e) | 0;
  s = Fs(s, i);
  var n = s.write(t, e);
  return n !== i && (s = s.slice(0, n)), s;
}
function TA(s, t) {
  var e = t.length < 0 ? 0 : uf(t.length) | 0;
  s = Fs(s, e);
  for (var i = 0; i < e; i += 1)
    s[i] = t[i] & 255;
  return s;
}
function qU(s, t, e, i) {
  if (t.byteLength, e < 0 || t.byteLength < e)
    throw new RangeError("'offset' is out of bounds");
  if (t.byteLength < e + (i || 0))
    throw new RangeError("'length' is out of bounds");
  return e === void 0 && i === void 0 ? t = new Uint8Array(t) : i === void 0 ? t = new Uint8Array(t, e) : t = new Uint8Array(t, e, i), q.TYPED_ARRAY_SUPPORT ? (s = t, s.__proto__ = q.prototype) : s = TA(s, t), s;
}
function $U(s, t) {
  if (ds(t)) {
    var e = uf(t.length) | 0;
    return s = Fs(s, e), s.length === 0 || t.copy(s, 0, 0, e), s;
  }
  if (t) {
    if (typeof ArrayBuffer < "u" && t.buffer instanceof ArrayBuffer || "length" in t)
      return typeof t.length != "number" || pO(t.length) ? Fs(s, 0) : TA(s, t);
    if (t.type === "Buffer" && hv(t.data))
      return TA(s, t.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function uf(s) {
  if (s >= Th())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Th().toString(16) + " bytes");
  return s | 0;
}
q.isBuffer = yn;
function ds(s) {
  return !!(s != null && s._isBuffer);
}
q.compare = function(t, e) {
  if (!ds(t) || !ds(e))
    throw new TypeError("Arguments must be Buffers");
  if (t === e)
    return 0;
  for (var i = t.length, n = e.length, o = 0, r = Math.min(i, n); o < r; ++o)
    if (t[o] !== e[o]) {
      i = t[o], n = e[o];
      break;
    }
  return i < n ? -1 : n < i ? 1 : 0;
};
q.isEncoding = function(t) {
  switch (String(t).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
q.concat = function(t, e) {
  if (!hv(t))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (t.length === 0)
    return q.alloc(0);
  var i;
  if (e === void 0)
    for (e = 0, i = 0; i < t.length; ++i)
      e += t[i].length;
  var n = q.allocUnsafe(e), o = 0;
  for (i = 0; i < t.length; ++i) {
    var r = t[i];
    if (!ds(r))
      throw new TypeError('"list" argument must be an Array of Buffers');
    r.copy(n, o), o += r.length;
  }
  return n;
};
function Iv(s, t) {
  if (ds(s))
    return s.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(s) || s instanceof ArrayBuffer))
    return s.byteLength;
  typeof s != "string" && (s = "" + s);
  var e = s.length;
  if (e === 0)
    return 0;
  for (var i = !1; ; )
    switch (t) {
      case "ascii":
      case "latin1":
      case "binary":
        return e;
      case "utf8":
      case "utf-8":
      case void 0:
        return Lh(s).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return e * 2;
      case "hex":
        return e >>> 1;
      case "base64":
        return Sv(s).length;
      default:
        if (i)
          return Lh(s).length;
        t = ("" + t).toLowerCase(), i = !0;
    }
}
q.byteLength = Iv;
function eO(s, t, e) {
  var i = !1;
  if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((e === void 0 || e > this.length) && (e = this.length), e <= 0) || (e >>>= 0, t >>>= 0, e <= t))
    return "";
  for (s || (s = "utf8"); ; )
    switch (s) {
      case "hex":
        return lO(this, t, e);
      case "utf8":
      case "utf-8":
        return fv(this, t, e);
      case "ascii":
        return gO(this, t, e);
      case "latin1":
      case "binary":
        return cO(this, t, e);
      case "base64":
        return rO(this, t, e);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return hO(this, t, e);
      default:
        if (i)
          throw new TypeError("Unknown encoding: " + s);
        s = (s + "").toLowerCase(), i = !0;
    }
}
q.prototype._isBuffer = !0;
function dr(s, t, e) {
  var i = s[t];
  s[t] = s[e], s[e] = i;
}
q.prototype.swap16 = function() {
  var t = this.length;
  if (t % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var e = 0; e < t; e += 2)
    dr(this, e, e + 1);
  return this;
};
q.prototype.swap32 = function() {
  var t = this.length;
  if (t % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var e = 0; e < t; e += 4)
    dr(this, e, e + 3), dr(this, e + 1, e + 2);
  return this;
};
q.prototype.swap64 = function() {
  var t = this.length;
  if (t % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var e = 0; e < t; e += 8)
    dr(this, e, e + 7), dr(this, e + 1, e + 6), dr(this, e + 2, e + 5), dr(this, e + 3, e + 4);
  return this;
};
q.prototype.toString = function() {
  var t = this.length | 0;
  return t === 0 ? "" : arguments.length === 0 ? fv(this, 0, t) : eO.apply(this, arguments);
};
q.prototype.equals = function(t) {
  if (!ds(t))
    throw new TypeError("Argument must be a Buffer");
  return this === t ? !0 : q.compare(this, t) === 0;
};
q.prototype.inspect = function() {
  var t = "", e = YU;
  return this.length > 0 && (t = this.toString("hex", 0, e).match(/.{2}/g).join(" "), this.length > e && (t += " ... ")), "<Buffer " + t + ">";
};
q.prototype.compare = function(t, e, i, n, o) {
  if (!ds(t))
    throw new TypeError("Argument must be a Buffer");
  if (e === void 0 && (e = 0), i === void 0 && (i = t ? t.length : 0), n === void 0 && (n = 0), o === void 0 && (o = this.length), e < 0 || i > t.length || n < 0 || o > this.length)
    throw new RangeError("out of range index");
  if (n >= o && e >= i)
    return 0;
  if (n >= o)
    return -1;
  if (e >= i)
    return 1;
  if (e >>>= 0, i >>>= 0, n >>>= 0, o >>>= 0, this === t)
    return 0;
  for (var r = o - n, a = i - e, g = Math.min(r, a), c = this.slice(n, o), l = t.slice(e, i), h = 0; h < g; ++h)
    if (c[h] !== l[h]) {
      r = c[h], a = l[h];
      break;
    }
  return r < a ? -1 : a < r ? 1 : 0;
};
function Av(s, t, e, i, n) {
  if (s.length === 0)
    return -1;
  if (typeof e == "string" ? (i = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = n ? 0 : s.length - 1), e < 0 && (e = s.length + e), e >= s.length) {
    if (n)
      return -1;
    e = s.length - 1;
  } else if (e < 0)
    if (n)
      e = 0;
    else
      return -1;
  if (typeof t == "string" && (t = q.from(t, i)), ds(t))
    return t.length === 0 ? -1 : uS(s, t, e, i, n);
  if (typeof t == "number")
    return t = t & 255, q.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(s, t, e) : Uint8Array.prototype.lastIndexOf.call(s, t, e) : uS(s, [t], e, i, n);
  throw new TypeError("val must be string, number or Buffer");
}
function uS(s, t, e, i, n) {
  var o = 1, r = s.length, a = t.length;
  if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
    if (s.length < 2 || t.length < 2)
      return -1;
    o = 2, r /= 2, a /= 2, e /= 2;
  }
  function g(C, p) {
    return o === 1 ? C[p] : C.readUInt16BE(p * o);
  }
  var c;
  if (n) {
    var l = -1;
    for (c = e; c < r; c++)
      if (g(s, c) === g(t, l === -1 ? 0 : c - l)) {
        if (l === -1 && (l = c), c - l + 1 === a)
          return l * o;
      } else
        l !== -1 && (c -= c - l), l = -1;
  } else
    for (e + a > r && (e = r - a), c = e; c >= 0; c--) {
      for (var h = !0, d = 0; d < a; d++)
        if (g(s, c + d) !== g(t, d)) {
          h = !1;
          break;
        }
      if (h)
        return c;
    }
  return -1;
}
q.prototype.includes = function(t, e, i) {
  return this.indexOf(t, e, i) !== -1;
};
q.prototype.indexOf = function(t, e, i) {
  return Av(this, t, e, i, !0);
};
q.prototype.lastIndexOf = function(t, e, i) {
  return Av(this, t, e, i, !1);
};
function tO(s, t, e, i) {
  e = Number(e) || 0;
  var n = s.length - e;
  i ? (i = Number(i), i > n && (i = n)) : i = n;
  var o = t.length;
  if (o % 2 !== 0)
    throw new TypeError("Invalid hex string");
  i > o / 2 && (i = o / 2);
  for (var r = 0; r < i; ++r) {
    var a = parseInt(t.substr(r * 2, 2), 16);
    if (isNaN(a))
      return r;
    s[e + r] = a;
  }
  return r;
}
function iO(s, t, e, i) {
  return dd(Lh(t, s.length - e), s, e, i);
}
function Cv(s, t, e, i) {
  return dd(CO(t), s, e, i);
}
function nO(s, t, e, i) {
  return Cv(s, t, e, i);
}
function sO(s, t, e, i) {
  return dd(Sv(t), s, e, i);
}
function oO(s, t, e, i) {
  return dd(fO(t, s.length - e), s, e, i);
}
q.prototype.write = function(t, e, i, n) {
  if (e === void 0)
    n = "utf8", i = this.length, e = 0;
  else if (i === void 0 && typeof e == "string")
    n = e, i = this.length, e = 0;
  else if (isFinite(e))
    e = e | 0, isFinite(i) ? (i = i | 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var o = this.length - e;
  if ((i === void 0 || i > o) && (i = o), t.length > 0 && (i < 0 || e < 0) || e > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  n || (n = "utf8");
  for (var r = !1; ; )
    switch (n) {
      case "hex":
        return tO(this, t, e, i);
      case "utf8":
      case "utf-8":
        return iO(this, t, e, i);
      case "ascii":
        return Cv(this, t, e, i);
      case "latin1":
      case "binary":
        return nO(this, t, e, i);
      case "base64":
        return sO(this, t, e, i);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return oO(this, t, e, i);
      default:
        if (r)
          throw new TypeError("Unknown encoding: " + n);
        n = ("" + n).toLowerCase(), r = !0;
    }
};
q.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function rO(s, t, e) {
  return t === 0 && e === s.length ? dS(s) : dS(s.slice(t, e));
}
function fv(s, t, e) {
  e = Math.min(s.length, e);
  for (var i = [], n = t; n < e; ) {
    var o = s[n], r = null, a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
    if (n + a <= e) {
      var g, c, l, h;
      switch (a) {
        case 1:
          o < 128 && (r = o);
          break;
        case 2:
          g = s[n + 1], (g & 192) === 128 && (h = (o & 31) << 6 | g & 63, h > 127 && (r = h));
          break;
        case 3:
          g = s[n + 1], c = s[n + 2], (g & 192) === 128 && (c & 192) === 128 && (h = (o & 15) << 12 | (g & 63) << 6 | c & 63, h > 2047 && (h < 55296 || h > 57343) && (r = h));
          break;
        case 4:
          g = s[n + 1], c = s[n + 2], l = s[n + 3], (g & 192) === 128 && (c & 192) === 128 && (l & 192) === 128 && (h = (o & 15) << 18 | (g & 63) << 12 | (c & 63) << 6 | l & 63, h > 65535 && h < 1114112 && (r = h));
      }
    }
    r === null ? (r = 65533, a = 1) : r > 65535 && (r -= 65536, i.push(r >>> 10 & 1023 | 55296), r = 56320 | r & 1023), i.push(r), n += a;
  }
  return aO(i);
}
var IS = 4096;
function aO(s) {
  var t = s.length;
  if (t <= IS)
    return String.fromCharCode.apply(String, s);
  for (var e = "", i = 0; i < t; )
    e += String.fromCharCode.apply(
      String,
      s.slice(i, i += IS)
    );
  return e;
}
function gO(s, t, e) {
  var i = "";
  e = Math.min(s.length, e);
  for (var n = t; n < e; ++n)
    i += String.fromCharCode(s[n] & 127);
  return i;
}
function cO(s, t, e) {
  var i = "";
  e = Math.min(s.length, e);
  for (var n = t; n < e; ++n)
    i += String.fromCharCode(s[n]);
  return i;
}
function lO(s, t, e) {
  var i = s.length;
  (!t || t < 0) && (t = 0), (!e || e < 0 || e > i) && (e = i);
  for (var n = "", o = t; o < e; ++o)
    n += AO(s[o]);
  return n;
}
function hO(s, t, e) {
  for (var i = s.slice(t, e), n = "", o = 0; o < i.length; o += 2)
    n += String.fromCharCode(i[o] + i[o + 1] * 256);
  return n;
}
q.prototype.slice = function(t, e) {
  var i = this.length;
  t = ~~t, e = e === void 0 ? i : ~~e, t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), e < t && (e = t);
  var n;
  if (q.TYPED_ARRAY_SUPPORT)
    n = this.subarray(t, e), n.__proto__ = q.prototype;
  else {
    var o = e - t;
    n = new q(o, void 0);
    for (var r = 0; r < o; ++r)
      n[r] = this[r + t];
  }
  return n;
};
function ui(s, t, e) {
  if (s % 1 !== 0 || s < 0)
    throw new RangeError("offset is not uint");
  if (s + t > e)
    throw new RangeError("Trying to access beyond buffer length");
}
q.prototype.readUIntLE = function(t, e, i) {
  t = t | 0, e = e | 0, i || ui(t, e, this.length);
  for (var n = this[t], o = 1, r = 0; ++r < e && (o *= 256); )
    n += this[t + r] * o;
  return n;
};
q.prototype.readUIntBE = function(t, e, i) {
  t = t | 0, e = e | 0, i || ui(t, e, this.length);
  for (var n = this[t + --e], o = 1; e > 0 && (o *= 256); )
    n += this[t + --e] * o;
  return n;
};
q.prototype.readUInt8 = function(t, e) {
  return e || ui(t, 1, this.length), this[t];
};
q.prototype.readUInt16LE = function(t, e) {
  return e || ui(t, 2, this.length), this[t] | this[t + 1] << 8;
};
q.prototype.readUInt16BE = function(t, e) {
  return e || ui(t, 2, this.length), this[t] << 8 | this[t + 1];
};
q.prototype.readUInt32LE = function(t, e) {
  return e || ui(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
};
q.prototype.readUInt32BE = function(t, e) {
  return e || ui(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
};
q.prototype.readIntLE = function(t, e, i) {
  t = t | 0, e = e | 0, i || ui(t, e, this.length);
  for (var n = this[t], o = 1, r = 0; ++r < e && (o *= 256); )
    n += this[t + r] * o;
  return o *= 128, n >= o && (n -= Math.pow(2, 8 * e)), n;
};
q.prototype.readIntBE = function(t, e, i) {
  t = t | 0, e = e | 0, i || ui(t, e, this.length);
  for (var n = e, o = 1, r = this[t + --n]; n > 0 && (o *= 256); )
    r += this[t + --n] * o;
  return o *= 128, r >= o && (r -= Math.pow(2, 8 * e)), r;
};
q.prototype.readInt8 = function(t, e) {
  return e || ui(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
};
q.prototype.readInt16LE = function(t, e) {
  e || ui(t, 2, this.length);
  var i = this[t] | this[t + 1] << 8;
  return i & 32768 ? i | 4294901760 : i;
};
q.prototype.readInt16BE = function(t, e) {
  e || ui(t, 2, this.length);
  var i = this[t + 1] | this[t] << 8;
  return i & 32768 ? i | 4294901760 : i;
};
q.prototype.readInt32LE = function(t, e) {
  return e || ui(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
};
q.prototype.readInt32BE = function(t, e) {
  return e || ui(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
};
q.prototype.readFloatLE = function(t, e) {
  return e || ui(t, 4, this.length), cd(this, t, !0, 23, 4);
};
q.prototype.readFloatBE = function(t, e) {
  return e || ui(t, 4, this.length), cd(this, t, !1, 23, 4);
};
q.prototype.readDoubleLE = function(t, e) {
  return e || ui(t, 8, this.length), cd(this, t, !0, 52, 8);
};
q.prototype.readDoubleBE = function(t, e) {
  return e || ui(t, 8, this.length), cd(this, t, !1, 52, 8);
};
function Wi(s, t, e, i, n, o) {
  if (!ds(s))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t > n || t < o)
    throw new RangeError('"value" argument is out of bounds');
  if (e + i > s.length)
    throw new RangeError("Index out of range");
}
q.prototype.writeUIntLE = function(t, e, i, n) {
  if (t = +t, e = e | 0, i = i | 0, !n) {
    var o = Math.pow(2, 8 * i) - 1;
    Wi(this, t, e, i, o, 0);
  }
  var r = 1, a = 0;
  for (this[e] = t & 255; ++a < i && (r *= 256); )
    this[e + a] = t / r & 255;
  return e + i;
};
q.prototype.writeUIntBE = function(t, e, i, n) {
  if (t = +t, e = e | 0, i = i | 0, !n) {
    var o = Math.pow(2, 8 * i) - 1;
    Wi(this, t, e, i, o, 0);
  }
  var r = i - 1, a = 1;
  for (this[e + r] = t & 255; --r >= 0 && (a *= 256); )
    this[e + r] = t / a & 255;
  return e + i;
};
q.prototype.writeUInt8 = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 1, 255, 0), q.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = t & 255, e + 1;
};
function ld(s, t, e, i) {
  t < 0 && (t = 65535 + t + 1);
  for (var n = 0, o = Math.min(s.length - e, 2); n < o; ++n)
    s[e + n] = (t & 255 << 8 * (i ? n : 1 - n)) >>> (i ? n : 1 - n) * 8;
}
q.prototype.writeUInt16LE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 2, 65535, 0), q.TYPED_ARRAY_SUPPORT ? (this[e] = t & 255, this[e + 1] = t >>> 8) : ld(this, t, e, !0), e + 2;
};
q.prototype.writeUInt16BE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 2, 65535, 0), q.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = t & 255) : ld(this, t, e, !1), e + 2;
};
function hd(s, t, e, i) {
  t < 0 && (t = 4294967295 + t + 1);
  for (var n = 0, o = Math.min(s.length - e, 4); n < o; ++n)
    s[e + n] = t >>> (i ? n : 3 - n) * 8 & 255;
}
q.prototype.writeUInt32LE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 4, 4294967295, 0), q.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = t & 255) : hd(this, t, e, !0), e + 4;
};
q.prototype.writeUInt32BE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 4, 4294967295, 0), q.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t & 255) : hd(this, t, e, !1), e + 4;
};
q.prototype.writeIntLE = function(t, e, i, n) {
  if (t = +t, e = e | 0, !n) {
    var o = Math.pow(2, 8 * i - 1);
    Wi(this, t, e, i, o - 1, -o);
  }
  var r = 0, a = 1, g = 0;
  for (this[e] = t & 255; ++r < i && (a *= 256); )
    t < 0 && g === 0 && this[e + r - 1] !== 0 && (g = 1), this[e + r] = (t / a >> 0) - g & 255;
  return e + i;
};
q.prototype.writeIntBE = function(t, e, i, n) {
  if (t = +t, e = e | 0, !n) {
    var o = Math.pow(2, 8 * i - 1);
    Wi(this, t, e, i, o - 1, -o);
  }
  var r = i - 1, a = 1, g = 0;
  for (this[e + r] = t & 255; --r >= 0 && (a *= 256); )
    t < 0 && g === 0 && this[e + r + 1] !== 0 && (g = 1), this[e + r] = (t / a >> 0) - g & 255;
  return e + i;
};
q.prototype.writeInt8 = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 1, 127, -128), q.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = t & 255, e + 1;
};
q.prototype.writeInt16LE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 2, 32767, -32768), q.TYPED_ARRAY_SUPPORT ? (this[e] = t & 255, this[e + 1] = t >>> 8) : ld(this, t, e, !0), e + 2;
};
q.prototype.writeInt16BE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 2, 32767, -32768), q.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = t & 255) : ld(this, t, e, !1), e + 2;
};
q.prototype.writeInt32LE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 4, 2147483647, -2147483648), q.TYPED_ARRAY_SUPPORT ? (this[e] = t & 255, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : hd(this, t, e, !0), e + 4;
};
q.prototype.writeInt32BE = function(t, e, i) {
  return t = +t, e = e | 0, i || Wi(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), q.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = t & 255) : hd(this, t, e, !1), e + 4;
};
function pv(s, t, e, i, n, o) {
  if (e + i > s.length)
    throw new RangeError("Index out of range");
  if (e < 0)
    throw new RangeError("Index out of range");
}
function mv(s, t, e, i, n) {
  return n || pv(s, t, e, 4), lv(s, t, e, i, 23, 4), e + 4;
}
q.prototype.writeFloatLE = function(t, e, i) {
  return mv(this, t, e, !0, i);
};
q.prototype.writeFloatBE = function(t, e, i) {
  return mv(this, t, e, !1, i);
};
function yv(s, t, e, i, n) {
  return n || pv(s, t, e, 8), lv(s, t, e, i, 52, 8), e + 8;
}
q.prototype.writeDoubleLE = function(t, e, i) {
  return yv(this, t, e, !0, i);
};
q.prototype.writeDoubleBE = function(t, e, i) {
  return yv(this, t, e, !1, i);
};
q.prototype.copy = function(t, e, i, n) {
  if (i || (i = 0), !n && n !== 0 && (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && n < i && (n = i), n === i || t.length === 0 || this.length === 0)
    return 0;
  if (e < 0)
    throw new RangeError("targetStart out of bounds");
  if (i < 0 || i >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (n < 0)
    throw new RangeError("sourceEnd out of bounds");
  n > this.length && (n = this.length), t.length - e < n - i && (n = t.length - e + i);
  var o = n - i, r;
  if (this === t && i < e && e < n)
    for (r = o - 1; r >= 0; --r)
      t[r + e] = this[r + i];
  else if (o < 1e3 || !q.TYPED_ARRAY_SUPPORT)
    for (r = 0; r < o; ++r)
      t[r + e] = this[r + i];
  else
    Uint8Array.prototype.set.call(
      t,
      this.subarray(i, i + o),
      e
    );
  return o;
};
q.prototype.fill = function(t, e, i, n) {
  if (typeof t == "string") {
    if (typeof e == "string" ? (n = e, e = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), t.length === 1) {
      var o = t.charCodeAt(0);
      o < 256 && (t = o);
    }
    if (n !== void 0 && typeof n != "string")
      throw new TypeError("encoding must be a string");
    if (typeof n == "string" && !q.isEncoding(n))
      throw new TypeError("Unknown encoding: " + n);
  } else
    typeof t == "number" && (t = t & 255);
  if (e < 0 || this.length < e || this.length < i)
    throw new RangeError("Out of range index");
  if (i <= e)
    return this;
  e = e >>> 0, i = i === void 0 ? this.length : i >>> 0, t || (t = 0);
  var r;
  if (typeof t == "number")
    for (r = e; r < i; ++r)
      this[r] = t;
  else {
    var a = ds(t) ? t : Lh(new q(t, n).toString()), g = a.length;
    for (r = 0; r < i - e; ++r)
      this[r + e] = a[r % g];
  }
  return this;
};
var dO = /[^+\/0-9A-Za-z-_]/g;
function uO(s) {
  if (s = IO(s).replace(dO, ""), s.length < 2)
    return "";
  for (; s.length % 4 !== 0; )
    s = s + "=";
  return s;
}
function IO(s) {
  return s.trim ? s.trim() : s.replace(/^\s+|\s+$/g, "");
}
function AO(s) {
  return s < 16 ? "0" + s.toString(16) : s.toString(16);
}
function Lh(s, t) {
  t = t || 1 / 0;
  for (var e, i = s.length, n = null, o = [], r = 0; r < i; ++r) {
    if (e = s.charCodeAt(r), e > 55295 && e < 57344) {
      if (!n) {
        if (e > 56319) {
          (t -= 3) > -1 && o.push(239, 191, 189);
          continue;
        } else if (r + 1 === i) {
          (t -= 3) > -1 && o.push(239, 191, 189);
          continue;
        }
        n = e;
        continue;
      }
      if (e < 56320) {
        (t -= 3) > -1 && o.push(239, 191, 189), n = e;
        continue;
      }
      e = (n - 55296 << 10 | e - 56320) + 65536;
    } else
      n && (t -= 3) > -1 && o.push(239, 191, 189);
    if (n = null, e < 128) {
      if ((t -= 1) < 0)
        break;
      o.push(e);
    } else if (e < 2048) {
      if ((t -= 2) < 0)
        break;
      o.push(
        e >> 6 | 192,
        e & 63 | 128
      );
    } else if (e < 65536) {
      if ((t -= 3) < 0)
        break;
      o.push(
        e >> 12 | 224,
        e >> 6 & 63 | 128,
        e & 63 | 128
      );
    } else if (e < 1114112) {
      if ((t -= 4) < 0)
        break;
      o.push(
        e >> 18 | 240,
        e >> 12 & 63 | 128,
        e >> 6 & 63 | 128,
        e & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return o;
}
function CO(s) {
  for (var t = [], e = 0; e < s.length; ++e)
    t.push(s.charCodeAt(e) & 255);
  return t;
}
function fO(s, t) {
  for (var e, i, n, o = [], r = 0; r < s.length && !((t -= 2) < 0); ++r)
    e = s.charCodeAt(r), i = e >> 8, n = e % 256, o.push(n), o.push(i);
  return o;
}
function Sv(s) {
  return ZU(uO(s));
}
function dd(s, t, e, i) {
  for (var n = 0; n < i && !(n + e >= t.length || n >= s.length); ++n)
    t[n + e] = s[n];
  return n;
}
function pO(s) {
  return s !== s;
}
function yn(s) {
  return s != null && (!!s._isBuffer || bv(s) || mO(s));
}
function bv(s) {
  return !!s.constructor && typeof s.constructor.isBuffer == "function" && s.constructor.isBuffer(s);
}
function mO(s) {
  return typeof s.readFloatLE == "function" && typeof s.slice == "function" && bv(s.slice(0, 0));
}
class ut extends Error {
  constructor(t, e, i, ...n) {
    Array.isArray(e) && (e = e.join(" ")), super(e), Error.captureStackTrace !== void 0 && Error.captureStackTrace(this, ut), this.code = t;
    for (const o of n)
      for (const r in o) {
        const a = o[r];
        this[r] = yn(a) ? a.toString(i.encoding) : a == null ? a : JSON.parse(JSON.stringify(a));
      }
  }
}
const yO = function(s) {
  return typeof s == "object" && s !== null && !Array.isArray(s);
}, Bv = function(s) {
  const t = [];
  for (let e = 0, i = s.length; e < i; e++) {
    const n = s[e];
    if (n == null || n === !1)
      t[e] = { disabled: !0 };
    else if (typeof n == "string")
      t[e] = { name: n };
    else if (yO(n)) {
      if (typeof n.name != "string")
        throw new ut("CSV_OPTION_COLUMNS_MISSING_NAME", [
          "Option columns missing name:",
          `property "name" is required at position ${e}`,
          "when column is an object literal"
        ]);
      t[e] = n;
    } else
      throw new ut("CSV_INVALID_COLUMN_DEFINITION", [
        "Invalid column definition:",
        "expect a string or a literal object,",
        `got ${JSON.stringify(n)} at position ${e}`
      ]);
  }
  return t;
};
class AS {
  constructor(t = 100) {
    this.size = t, this.length = 0, this.buf = q.allocUnsafe(t);
  }
  prepend(t) {
    if (yn(t)) {
      const e = this.length + t.length;
      if (e >= this.size && (this.resize(), e >= this.size))
        throw Error("INVALID_BUFFER_STATE");
      const i = this.buf;
      this.buf = q.allocUnsafe(this.size), t.copy(this.buf, 0), i.copy(this.buf, t.length), this.length += t.length;
    } else {
      const e = this.length++;
      e === this.size && this.resize();
      const i = this.clone();
      this.buf[0] = t, i.copy(this.buf, 1, 0, e);
    }
  }
  append(t) {
    const e = this.length++;
    e === this.size && this.resize(), this.buf[e] = t;
  }
  clone() {
    return q.from(this.buf.slice(0, this.length));
  }
  resize() {
    const t = this.length;
    this.size = this.size * 2;
    const e = q.allocUnsafe(this.size);
    this.buf.copy(e, 0, 0, t), this.buf = e;
  }
  toString(t) {
    return t ? this.buf.slice(0, this.length).toString(t) : Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
  }
  toJSON() {
    return this.toString("utf8");
  }
  reset() {
    this.length = 0;
  }
}
const SO = 12, bO = 13, BO = 10, wO = 32, _O = 9, xO = function(s) {
  return {
    bomSkipped: !1,
    bufBytesStart: 0,
    castField: s.cast_function,
    commenting: !1,
    error: void 0,
    enabled: s.from_line === 1,
    escaping: !1,
    escapeIsQuote: yn(s.escape) && yn(s.quote) && q.compare(s.escape, s.quote) === 0,
    expectedRecordLength: Array.isArray(s.columns) ? s.columns.length : void 0,
    field: new AS(20),
    firstLineToHeaders: s.cast_first_line_to_header,
    needMoreDataSize: Math.max(
      s.comment !== null ? s.comment.length : 0,
      ...s.delimiter.map((t) => t.length),
      s.quote !== null ? s.quote.length : 0
    ),
    previousBuf: void 0,
    quoting: !1,
    stop: !1,
    rawBuffer: new AS(100),
    record: [],
    recordHasError: !1,
    record_length: 0,
    recordDelimiterMaxLength: s.record_delimiter.length === 0 ? 2 : Math.max(...s.record_delimiter.map((t) => t.length)),
    trimChars: [q.from(" ", s.encoding)[0], q.from("	", s.encoding)[0]],
    wasQuoting: !1,
    wasRowDelimiter: !1,
    timchars: [
      q.from(q.from([bO], "utf8").toString(), s.encoding),
      q.from(q.from([BO], "utf8").toString(), s.encoding),
      q.from(q.from([SO], "utf8").toString(), s.encoding),
      q.from(q.from([wO], "utf8").toString(), s.encoding),
      q.from(q.from([_O], "utf8").toString(), s.encoding)
    ]
  };
}, vO = function(s) {
  return s.replace(/([A-Z])/g, function(t, e) {
    return "_" + e.toLowerCase();
  });
}, CS = function(s) {
  const t = {};
  for (const i in s)
    t[vO(i)] = s[i];
  if (t.encoding === void 0 || t.encoding === !0)
    t.encoding = "utf8";
  else if (t.encoding === null || t.encoding === !1)
    t.encoding = null;
  else if (typeof t.encoding != "string" && t.encoding !== null)
    throw new ut("CSV_INVALID_OPTION_ENCODING", [
      "Invalid option encoding:",
      "encoding must be a string or null to return a buffer,",
      `got ${JSON.stringify(t.encoding)}`
    ], t);
  if (t.bom === void 0 || t.bom === null || t.bom === !1)
    t.bom = !1;
  else if (t.bom !== !0)
    throw new ut("CSV_INVALID_OPTION_BOM", [
      "Invalid option bom:",
      "bom must be true,",
      `got ${JSON.stringify(t.bom)}`
    ], t);
  if (t.cast_function = null, t.cast === void 0 || t.cast === null || t.cast === !1 || t.cast === "")
    t.cast = void 0;
  else if (typeof t.cast == "function")
    t.cast_function = t.cast, t.cast = !0;
  else if (t.cast !== !0)
    throw new ut("CSV_INVALID_OPTION_CAST", [
      "Invalid option cast:",
      "cast must be true or a function,",
      `got ${JSON.stringify(t.cast)}`
    ], t);
  if (t.cast_date === void 0 || t.cast_date === null || t.cast_date === !1 || t.cast_date === "")
    t.cast_date = !1;
  else if (t.cast_date === !0)
    t.cast_date = function(i) {
      const n = Date.parse(i);
      return isNaN(n) ? i : new Date(n);
    };
  else if (typeof t.cast_date != "function")
    throw new ut("CSV_INVALID_OPTION_CAST_DATE", [
      "Invalid option cast_date:",
      "cast_date must be true or a function,",
      `got ${JSON.stringify(t.cast_date)}`
    ], t);
  if (t.cast_first_line_to_header = null, t.columns === !0)
    t.cast_first_line_to_header = void 0;
  else if (typeof t.columns == "function")
    t.cast_first_line_to_header = t.columns, t.columns = !0;
  else if (Array.isArray(t.columns))
    t.columns = Bv(t.columns);
  else if (t.columns === void 0 || t.columns === null || t.columns === !1)
    t.columns = !1;
  else
    throw new ut("CSV_INVALID_OPTION_COLUMNS", [
      "Invalid option columns:",
      "expect an array, a function or true,",
      `got ${JSON.stringify(t.columns)}`
    ], t);
  if (t.group_columns_by_name === void 0 || t.group_columns_by_name === null || t.group_columns_by_name === !1)
    t.group_columns_by_name = !1;
  else {
    if (t.group_columns_by_name !== !0)
      throw new ut("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
        "Invalid option group_columns_by_name:",
        "expect an boolean,",
        `got ${JSON.stringify(t.group_columns_by_name)}`
      ], t);
    if (t.columns === !1)
      throw new ut("CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME", [
        "Invalid option group_columns_by_name:",
        "the `columns` mode must be activated."
      ], t);
  }
  if (t.comment === void 0 || t.comment === null || t.comment === !1 || t.comment === "")
    t.comment = null;
  else if (typeof t.comment == "string" && (t.comment = q.from(t.comment, t.encoding)), !yn(t.comment))
    throw new ut("CSV_INVALID_OPTION_COMMENT", [
      "Invalid option comment:",
      "comment must be a buffer or a string,",
      `got ${JSON.stringify(t.comment)}`
    ], t);
  const e = JSON.stringify(t.delimiter);
  if (Array.isArray(t.delimiter) || (t.delimiter = [t.delimiter]), t.delimiter.length === 0)
    throw new ut("CSV_INVALID_OPTION_DELIMITER", [
      "Invalid option delimiter:",
      "delimiter must be a non empty string or buffer or array of string|buffer,",
      `got ${e}`
    ], t);
  if (t.delimiter = t.delimiter.map(function(i) {
    if (i == null || i === !1)
      return q.from(",", t.encoding);
    if (typeof i == "string" && (i = q.from(i, t.encoding)), !yn(i) || i.length === 0)
      throw new ut("CSV_INVALID_OPTION_DELIMITER", [
        "Invalid option delimiter:",
        "delimiter must be a non empty string or buffer or array of string|buffer,",
        `got ${e}`
      ], t);
    return i;
  }), t.escape === void 0 || t.escape === !0 ? t.escape = q.from('"', t.encoding) : typeof t.escape == "string" ? t.escape = q.from(t.escape, t.encoding) : (t.escape === null || t.escape === !1) && (t.escape = null), t.escape !== null && !yn(t.escape))
    throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(t.escape)}`);
  if (t.from === void 0 || t.from === null)
    t.from = 1;
  else if (typeof t.from == "string" && /\d+/.test(t.from) && (t.from = parseInt(t.from)), Number.isInteger(t.from)) {
    if (t.from < 0)
      throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(s.from)}`);
  } else
    throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(t.from)}`);
  if (t.from_line === void 0 || t.from_line === null)
    t.from_line = 1;
  else if (typeof t.from_line == "string" && /\d+/.test(t.from_line) && (t.from_line = parseInt(t.from_line)), Number.isInteger(t.from_line)) {
    if (t.from_line <= 0)
      throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(s.from_line)}`);
  } else
    throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(s.from_line)}`);
  if (t.ignore_last_delimiters === void 0 || t.ignore_last_delimiters === null)
    t.ignore_last_delimiters = !1;
  else if (typeof t.ignore_last_delimiters == "number")
    t.ignore_last_delimiters = Math.floor(t.ignore_last_delimiters), t.ignore_last_delimiters === 0 && (t.ignore_last_delimiters = !1);
  else if (typeof t.ignore_last_delimiters != "boolean")
    throw new ut("CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS", [
      "Invalid option `ignore_last_delimiters`:",
      "the value must be a boolean value or an integer,",
      `got ${JSON.stringify(t.ignore_last_delimiters)}`
    ], t);
  if (t.ignore_last_delimiters === !0 && t.columns === !1)
    throw new ut("CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS", [
      "The option `ignore_last_delimiters`",
      "requires the activation of the `columns` option"
    ], t);
  if (t.info === void 0 || t.info === null || t.info === !1)
    t.info = !1;
  else if (t.info !== !0)
    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(t.info)}`);
  if (t.max_record_size === void 0 || t.max_record_size === null || t.max_record_size === !1)
    t.max_record_size = 0;
  else if (!(Number.isInteger(t.max_record_size) && t.max_record_size >= 0))
    if (typeof t.max_record_size == "string" && /\d+/.test(t.max_record_size))
      t.max_record_size = parseInt(t.max_record_size);
    else
      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(t.max_record_size)}`);
  if (t.objname === void 0 || t.objname === null || t.objname === !1)
    t.objname = void 0;
  else if (yn(t.objname)) {
    if (t.objname.length === 0)
      throw new Error("Invalid Option: objname must be a non empty buffer");
    t.encoding === null || (t.objname = t.objname.toString(t.encoding));
  } else if (typeof t.objname == "string") {
    if (t.objname.length === 0)
      throw new Error("Invalid Option: objname must be a non empty string");
  } else if (typeof t.objname != "number")
    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${t.objname}`);
  if (t.objname !== void 0) {
    if (typeof t.objname == "number") {
      if (t.columns !== !1)
        throw Error("Invalid Option: objname index cannot be combined with columns or be defined as a field");
    } else if (t.columns === !1)
      throw Error("Invalid Option: objname field must be combined with columns or be defined as an index");
  }
  if (t.on_record === void 0 || t.on_record === null)
    t.on_record = void 0;
  else if (typeof t.on_record != "function")
    throw new ut("CSV_INVALID_OPTION_ON_RECORD", [
      "Invalid option `on_record`:",
      "expect a function,",
      `got ${JSON.stringify(t.on_record)}`
    ], t);
  if (t.quote === null || t.quote === !1 || t.quote === "")
    t.quote = null;
  else if (t.quote === void 0 || t.quote === !0 ? t.quote = q.from('"', t.encoding) : typeof t.quote == "string" && (t.quote = q.from(t.quote, t.encoding)), !yn(t.quote))
    throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(t.quote)}`);
  if (t.raw === void 0 || t.raw === null || t.raw === !1)
    t.raw = !1;
  else if (t.raw !== !0)
    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(t.raw)}`);
  if (t.record_delimiter === void 0)
    t.record_delimiter = [];
  else if (typeof t.record_delimiter == "string" || yn(t.record_delimiter)) {
    if (t.record_delimiter.length === 0)
      throw new ut("CSV_INVALID_OPTION_RECORD_DELIMITER", [
        "Invalid option `record_delimiter`:",
        "value must be a non empty string or buffer,",
        `got ${JSON.stringify(t.record_delimiter)}`
      ], t);
    t.record_delimiter = [t.record_delimiter];
  } else if (!Array.isArray(t.record_delimiter))
    throw new ut("CSV_INVALID_OPTION_RECORD_DELIMITER", [
      "Invalid option `record_delimiter`:",
      "value must be a string, a buffer or array of string|buffer,",
      `got ${JSON.stringify(t.record_delimiter)}`
    ], t);
  if (t.record_delimiter = t.record_delimiter.map(function(i, n) {
    if (typeof i != "string" && !yn(i))
      throw new ut("CSV_INVALID_OPTION_RECORD_DELIMITER", [
        "Invalid option `record_delimiter`:",
        "value must be a string, a buffer or array of string|buffer",
        `at index ${n},`,
        `got ${JSON.stringify(i)}`
      ], t);
    if (i.length === 0)
      throw new ut("CSV_INVALID_OPTION_RECORD_DELIMITER", [
        "Invalid option `record_delimiter`:",
        "value must be a non empty string or buffer",
        `at index ${n},`,
        `got ${JSON.stringify(i)}`
      ], t);
    return typeof i == "string" && (i = q.from(i, t.encoding)), i;
  }), typeof t.relax_column_count != "boolean")
    if (t.relax_column_count === void 0 || t.relax_column_count === null)
      t.relax_column_count = !1;
    else
      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(t.relax_column_count)}`);
  if (typeof t.relax_column_count_less != "boolean")
    if (t.relax_column_count_less === void 0 || t.relax_column_count_less === null)
      t.relax_column_count_less = !1;
    else
      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(t.relax_column_count_less)}`);
  if (typeof t.relax_column_count_more != "boolean")
    if (t.relax_column_count_more === void 0 || t.relax_column_count_more === null)
      t.relax_column_count_more = !1;
    else
      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(t.relax_column_count_more)}`);
  if (typeof t.relax_quotes != "boolean")
    if (t.relax_quotes === void 0 || t.relax_quotes === null)
      t.relax_quotes = !1;
    else
      throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(t.relax_quotes)}`);
  if (typeof t.skip_empty_lines != "boolean")
    if (t.skip_empty_lines === void 0 || t.skip_empty_lines === null)
      t.skip_empty_lines = !1;
    else
      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(t.skip_empty_lines)}`);
  if (typeof t.skip_records_with_empty_values != "boolean")
    if (t.skip_records_with_empty_values === void 0 || t.skip_records_with_empty_values === null)
      t.skip_records_with_empty_values = !1;
    else
      throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(t.skip_records_with_empty_values)}`);
  if (typeof t.skip_records_with_error != "boolean")
    if (t.skip_records_with_error === void 0 || t.skip_records_with_error === null)
      t.skip_records_with_error = !1;
    else
      throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(t.skip_records_with_error)}`);
  if (t.rtrim === void 0 || t.rtrim === null || t.rtrim === !1)
    t.rtrim = !1;
  else if (t.rtrim !== !0)
    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(t.rtrim)}`);
  if (t.ltrim === void 0 || t.ltrim === null || t.ltrim === !1)
    t.ltrim = !1;
  else if (t.ltrim !== !0)
    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(t.ltrim)}`);
  if (t.trim === void 0 || t.trim === null || t.trim === !1)
    t.trim = !1;
  else if (t.trim !== !0)
    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(t.trim)}`);
  if (t.trim === !0 && s.ltrim !== !1 ? t.ltrim = !0 : t.ltrim !== !0 && (t.ltrim = !1), t.trim === !0 && s.rtrim !== !1 ? t.rtrim = !0 : t.rtrim !== !0 && (t.rtrim = !1), t.to === void 0 || t.to === null)
    t.to = -1;
  else if (typeof t.to == "string" && /\d+/.test(t.to) && (t.to = parseInt(t.to)), Number.isInteger(t.to)) {
    if (t.to <= 0)
      throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(s.to)}`);
  } else
    throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(s.to)}`);
  if (t.to_line === void 0 || t.to_line === null)
    t.to_line = -1;
  else if (typeof t.to_line == "string" && /\d+/.test(t.to_line) && (t.to_line = parseInt(t.to_line)), Number.isInteger(t.to_line)) {
    if (t.to_line <= 0)
      throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(s.to_line)}`);
  } else
    throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(s.to_line)}`);
  return t;
}, fS = function(s) {
  return s.every((t) => t == null || t.toString && t.toString().trim() === "");
}, pS = 13, _I = 10, ul = {
  utf8: q.from([239, 187, 191]),
  utf16le: q.from([255, 254])
}, TO = function(s = {}) {
  const t = {
    bytes: 0,
    comment_lines: 0,
    empty_lines: 0,
    invalid_field_length: 0,
    lines: 1,
    records: 0
  }, e = CS(s);
  return {
    info: t,
    original_options: s,
    options: e,
    state: xO(e),
    __needMoreData: function(i, n, o) {
      if (o)
        return !1;
      const { quote: r } = this.options, { quoting: a, needMoreDataSize: g, recordDelimiterMaxLength: c } = this.state, l = n - i - 1, h = Math.max(
        g,
        c,
        a ? r.length + c : 0
      );
      return l < h;
    },
    parse: function(i, n, o, r) {
      const { bom: a, from_line: g, ltrim: c, max_record_size: l, raw: h, relax_quotes: d, rtrim: C, skip_empty_lines: p, to: m, to_line: b } = this.options;
      let { comment: S, escape: A, quote: u, record_delimiter: y } = this.options;
      const { bomSkipped: I, previousBuf: M, rawBuffer: G, escapeIsQuote: x } = this.state;
      let L;
      if (M === void 0)
        if (i === void 0) {
          r();
          return;
        } else
          L = i;
      else
        M !== void 0 && i === void 0 ? L = M : L = q.concat([M, i]);
      if (I === !1)
        if (a === !1)
          this.state.bomSkipped = !0;
        else if (L.length < 3) {
          if (n === !1) {
            this.state.previousBuf = L;
            return;
          }
        } else {
          for (const R in ul)
            if (ul[R].compare(L, 0, ul[R].length) === 0) {
              const w = ul[R].length;
              this.state.bufBytesStart += w, L = L.slice(w), this.options = CS({ ...this.original_options, encoding: R }), { comment: S, escape: A, quote: u } = this.options;
              break;
            }
          this.state.bomSkipped = !0;
        }
      const E = L.length;
      let T;
      for (T = 0; T < E && !this.__needMoreData(T, E, n); T++) {
        if (this.state.wasRowDelimiter === !0 && (this.info.lines++, this.state.wasRowDelimiter = !1), b !== -1 && this.info.lines > b) {
          this.state.stop = !0, r();
          return;
        }
        this.state.quoting === !1 && y.length === 0 && this.__autoDiscoverRecordDelimiter(L, T) && (y = this.options.record_delimiter);
        const R = L[T];
        if (h === !0 && G.append(R), (R === pS || R === _I) && this.state.wasRowDelimiter === !1 && (this.state.wasRowDelimiter = !0), this.state.escaping === !0)
          this.state.escaping = !1;
        else {
          if (A !== null && this.state.quoting === !0 && this.__isEscape(L, T, R) && T + A.length < E)
            if (x) {
              if (this.__isQuote(L, T + A.length)) {
                this.state.escaping = !0, T += A.length - 1;
                continue;
              }
            } else {
              this.state.escaping = !0, T += A.length - 1;
              continue;
            }
          if (this.state.commenting === !1 && this.__isQuote(L, T))
            if (this.state.quoting === !0) {
              const D = L[T + u.length], K = C && this.__isCharTrimable(L, T + u.length), P = S !== null && this.__compareBytes(S, L, T + u.length, D), k = this.__isDelimiter(L, T + u.length, D), V = y.length === 0 ? this.__autoDiscoverRecordDelimiter(L, T + u.length) : this.__isRecordDelimiter(D, L, T + u.length);
              if (A !== null && this.__isEscape(L, T, R) && this.__isQuote(L, T + A.length))
                T += A.length - 1;
              else if (!D || k || V || P || K) {
                this.state.quoting = !1, this.state.wasQuoting = !0, T += u.length - 1;
                continue;
              } else if (d === !1) {
                const N = this.__error(
                  new ut("CSV_INVALID_CLOSING_QUOTE", [
                    "Invalid Closing Quote:",
                    `got "${String.fromCharCode(D)}"`,
                    `at line ${this.info.lines}`,
                    "instead of delimiter, record delimiter, trimable character",
                    "(if activated) or comment"
                  ], this.options, this.__infoField())
                );
                if (N !== void 0)
                  return N;
              } else
                this.state.quoting = !1, this.state.wasQuoting = !0, this.state.field.prepend(u), T += u.length - 1;
            } else if (this.state.field.length !== 0) {
              if (d === !1) {
                const D = this.__error(
                  new ut("INVALID_OPENING_QUOTE", [
                    "Invalid Opening Quote:",
                    `a quote is found inside a field at line ${this.info.lines}`
                  ], this.options, this.__infoField(), {
                    field: this.state.field
                  })
                );
                if (D !== void 0)
                  return D;
              }
            } else {
              this.state.quoting = !0, T += u.length - 1;
              continue;
            }
          if (this.state.quoting === !1) {
            const D = this.__isRecordDelimiter(R, L, T);
            if (D !== 0) {
              if (this.state.commenting && this.state.wasQuoting === !1 && this.state.record.length === 0 && this.state.field.length === 0)
                this.info.comment_lines++;
              else {
                if (this.state.enabled === !1 && this.info.lines + (this.state.wasRowDelimiter === !0 ? 1 : 0) >= g) {
                  this.state.enabled = !0, this.__resetField(), this.__resetRecord(), T += D - 1;
                  continue;
                }
                if (p === !0 && this.state.wasQuoting === !1 && this.state.record.length === 0 && this.state.field.length === 0) {
                  this.info.empty_lines++, T += D - 1;
                  continue;
                }
                this.info.bytes = this.state.bufBytesStart + T;
                const V = this.__onField();
                if (V !== void 0)
                  return V;
                this.info.bytes = this.state.bufBytesStart + T + D;
                const N = this.__onRecord(o);
                if (N !== void 0)
                  return N;
                if (m !== -1 && this.info.records >= m) {
                  this.state.stop = !0, r();
                  return;
                }
              }
              this.state.commenting = !1, T += D - 1;
              continue;
            }
            if (this.state.commenting)
              continue;
            if ((S === null ? 0 : this.__compareBytes(S, L, T, R)) !== 0) {
              this.state.commenting = !0;
              continue;
            }
            const P = this.__isDelimiter(L, T, R);
            if (P !== 0) {
              this.info.bytes = this.state.bufBytesStart + T;
              const k = this.__onField();
              if (k !== void 0)
                return k;
              T += P - 1;
              continue;
            }
          }
        }
        if (this.state.commenting === !1 && l !== 0 && this.state.record_length + this.state.field.length > l)
          return this.__error(
            new ut("CSV_MAX_RECORD_SIZE", [
              "Max Record Size:",
              "record exceed the maximum number of tolerated bytes",
              `of ${l}`,
              `at line ${this.info.lines}`
            ], this.options, this.__infoField())
          );
        const w = c === !1 || this.state.quoting === !0 || this.state.field.length !== 0 || !this.__isCharTrimable(L, T), v = C === !1 || this.state.wasQuoting === !1;
        if (w === !0 && v === !0)
          this.state.field.append(R);
        else {
          if (C === !0 && !this.__isCharTrimable(L, T))
            return this.__error(
              new ut("CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE", [
                "Invalid Closing Quote:",
                "found non trimable byte after quote",
                `at line ${this.info.lines}`
              ], this.options, this.__infoField())
            );
          w === !1 && (T += this.__isCharTrimable(L, T) - 1);
          continue;
        }
      }
      if (n === !0)
        if (this.state.quoting === !0) {
          const R = this.__error(
            new ut("CSV_QUOTE_NOT_CLOSED", [
              "Quote Not Closed:",
              `the parsing is finished with an opening quote at line ${this.info.lines}`
            ], this.options, this.__infoField())
          );
          if (R !== void 0)
            return R;
        } else if (this.state.wasQuoting === !0 || this.state.record.length !== 0 || this.state.field.length !== 0) {
          this.info.bytes = this.state.bufBytesStart + T;
          const R = this.__onField();
          if (R !== void 0)
            return R;
          const w = this.__onRecord(o);
          if (w !== void 0)
            return w;
        } else
          this.state.wasRowDelimiter === !0 ? this.info.empty_lines++ : this.state.commenting === !0 && this.info.comment_lines++;
      else
        this.state.bufBytesStart += T, this.state.previousBuf = L.slice(T);
      this.state.wasRowDelimiter === !0 && (this.info.lines++, this.state.wasRowDelimiter = !1);
    },
    __onRecord: function(i) {
      const { columns: n, group_columns_by_name: o, encoding: r, info: a, from: g, relax_column_count: c, relax_column_count_less: l, relax_column_count_more: h, raw: d, skip_records_with_empty_values: C } = this.options, { enabled: p, record: m } = this.state;
      if (p === !1)
        return this.__resetRecord();
      const b = m.length;
      if (n === !0) {
        if (C === !0 && fS(m)) {
          this.__resetRecord();
          return;
        }
        return this.__firstLineToColumns(m);
      }
      if (n === !1 && this.info.records === 0 && (this.state.expectedRecordLength = b), b !== this.state.expectedRecordLength) {
        const S = n === !1 ? new ut("CSV_RECORD_INCONSISTENT_FIELDS_LENGTH", [
          "Invalid Record Length:",
          `expect ${this.state.expectedRecordLength},`,
          `got ${b} on line ${this.info.lines}`
        ], this.options, this.__infoField(), {
          record: m
        }) : new ut("CSV_RECORD_INCONSISTENT_COLUMNS", [
          "Invalid Record Length:",
          `columns length is ${n.length},`,
          `got ${b} on line ${this.info.lines}`
        ], this.options, this.__infoField(), {
          record: m
        });
        if (c === !0 || l === !0 && b < this.state.expectedRecordLength || h === !0 && b > this.state.expectedRecordLength)
          this.info.invalid_field_length++, this.state.error = S;
        else {
          const A = this.__error(S);
          if (A)
            return A;
        }
      }
      if (C === !0 && fS(m)) {
        this.__resetRecord();
        return;
      }
      if (this.state.recordHasError === !0) {
        this.__resetRecord(), this.state.recordHasError = !1;
        return;
      }
      if (this.info.records++, g === 1 || this.info.records >= g) {
        const { objname: S } = this.options;
        if (n !== !1) {
          const A = {};
          for (let u = 0, y = m.length; u < y; u++)
            n[u] === void 0 || n[u].disabled || (o === !0 && A[n[u].name] !== void 0 ? Array.isArray(A[n[u].name]) ? A[n[u].name] = A[n[u].name].concat(m[u]) : A[n[u].name] = [A[n[u].name], m[u]] : A[n[u].name] = m[u]);
          if (d === !0 || a === !0) {
            const u = Object.assign(
              { record: A },
              d === !0 ? { raw: this.state.rawBuffer.toString(r) } : {},
              a === !0 ? { info: this.__infoRecord() } : {}
            ), y = this.__push(
              S === void 0 ? u : [A[S], u],
              i
            );
            if (y)
              return y;
          } else {
            const u = this.__push(
              S === void 0 ? A : [A[S], A],
              i
            );
            if (u)
              return u;
          }
        } else if (d === !0 || a === !0) {
          const A = Object.assign(
            { record: m },
            d === !0 ? { raw: this.state.rawBuffer.toString(r) } : {},
            a === !0 ? { info: this.__infoRecord() } : {}
          ), u = this.__push(
            S === void 0 ? A : [m[S], A],
            i
          );
          if (u)
            return u;
        } else {
          const A = this.__push(
            S === void 0 ? m : [m[S], m],
            i
          );
          if (A)
            return A;
        }
      }
      this.__resetRecord();
    },
    __firstLineToColumns: function(i) {
      const { firstLineToHeaders: n } = this.state;
      try {
        const o = n === void 0 ? i : n.call(null, i);
        if (!Array.isArray(o))
          return this.__error(
            new ut("CSV_INVALID_COLUMN_MAPPING", [
              "Invalid Column Mapping:",
              "expect an array from column function,",
              `got ${JSON.stringify(o)}`
            ], this.options, this.__infoField(), {
              headers: o
            })
          );
        const r = Bv(o);
        this.state.expectedRecordLength = r.length, this.options.columns = r, this.__resetRecord();
        return;
      } catch (o) {
        return o;
      }
    },
    __resetRecord: function() {
      this.options.raw === !0 && this.state.rawBuffer.reset(), this.state.error = void 0, this.state.record = [], this.state.record_length = 0;
    },
    __onField: function() {
      const { cast: i, encoding: n, rtrim: o, max_record_size: r } = this.options, { enabled: a, wasQuoting: g } = this.state;
      if (a === !1)
        return this.__resetField();
      let c = this.state.field.toString(n);
      if (o === !0 && g === !1 && (c = c.trimRight()), i === !0) {
        const [l, h] = this.__cast(c);
        if (l !== void 0)
          return l;
        c = h;
      }
      this.state.record.push(c), r !== 0 && typeof c == "string" && (this.state.record_length += c.length), this.__resetField();
    },
    __resetField: function() {
      this.state.field.reset(), this.state.wasQuoting = !1;
    },
    __push: function(i, n) {
      const { on_record: o } = this.options;
      if (o !== void 0) {
        const r = this.__infoRecord();
        try {
          i = o.call(null, i, r);
        } catch (a) {
          return a;
        }
        if (i == null)
          return;
      }
      n(i);
    },
    __cast: function(i) {
      const { columns: n, relax_column_count: o } = this.options;
      if (Array.isArray(n) === !0 && o && this.options.columns.length <= this.state.record.length)
        return [void 0, void 0];
      if (this.state.castField !== null)
        try {
          const a = this.__infoField();
          return [void 0, this.state.castField.call(null, i, a)];
        } catch (a) {
          return [a];
        }
      if (this.__isFloat(i))
        return [void 0, parseFloat(i)];
      if (this.options.cast_date !== !1) {
        const a = this.__infoField();
        return [void 0, this.options.cast_date.call(null, i, a)];
      }
      return [void 0, i];
    },
    __isCharTrimable: function(i, n) {
      return ((r, a) => {
        const { timchars: g } = this.state;
        e:
          for (let c = 0; c < g.length; c++) {
            const l = g[c];
            for (let h = 0; h < l.length; h++)
              if (l[h] !== r[a + h])
                continue e;
            return l.length;
          }
        return 0;
      })(i, n);
    },
    __isFloat: function(i) {
      return i - parseFloat(i) + 1 >= 0;
    },
    __compareBytes: function(i, n, o, r) {
      if (i[0] !== r)
        return 0;
      const a = i.length;
      for (let g = 1; g < a; g++)
        if (i[g] !== n[o + g])
          return 0;
      return a;
    },
    __isDelimiter: function(i, n, o) {
      const { delimiter: r, ignore_last_delimiters: a } = this.options;
      if (a === !0 && this.state.record.length === this.options.columns.length - 1)
        return 0;
      if (a !== !1 && typeof a == "number" && this.state.record.length === a - 1)
        return 0;
      e:
        for (let g = 0; g < r.length; g++) {
          const c = r[g];
          if (c[0] === o) {
            for (let l = 1; l < c.length; l++)
              if (c[l] !== i[n + l])
                continue e;
            return c.length;
          }
        }
      return 0;
    },
    __isRecordDelimiter: function(i, n, o) {
      const { record_delimiter: r } = this.options, a = r.length;
      e:
        for (let g = 0; g < a; g++) {
          const c = r[g], l = c.length;
          if (c[0] === i) {
            for (let h = 1; h < l; h++)
              if (c[h] !== n[o + h])
                continue e;
            return c.length;
          }
        }
      return 0;
    },
    __isEscape: function(i, n, o) {
      const { escape: r } = this.options;
      if (r === null)
        return !1;
      const a = r.length;
      if (r[0] === o) {
        for (let g = 0; g < a; g++)
          if (r[g] !== i[n + g])
            return !1;
        return !0;
      }
      return !1;
    },
    __isQuote: function(i, n) {
      const { quote: o } = this.options;
      if (o === null)
        return !1;
      const r = o.length;
      for (let a = 0; a < r; a++)
        if (o[a] !== i[n + a])
          return !1;
      return !0;
    },
    __autoDiscoverRecordDelimiter: function(i, n) {
      const { encoding: o } = this.options, r = i[n];
      return r === pS ? i[n + 1] === _I ? (this.options.record_delimiter.push(q.from(`\r
`, o)), this.state.recordDelimiterMaxLength = 2, 2) : (this.options.record_delimiter.push(q.from("\r", o)), this.state.recordDelimiterMaxLength = 1, 1) : r === _I ? (this.options.record_delimiter.push(q.from(`
`, o)), this.state.recordDelimiterMaxLength = 1, 1) : 0;
    },
    __error: function(i) {
      const { encoding: n, raw: o, skip_records_with_error: r } = this.options, a = typeof i == "string" ? new Error(i) : i;
      if (r) {
        this.state.recordHasError = !0, this.options.on_skip !== void 0 && this.options.on_skip(a, o ? this.state.rawBuffer.toString(n) : void 0);
        return;
      } else
        return a;
    },
    __infoDataSet: function() {
      return {
        ...this.info,
        columns: this.options.columns
      };
    },
    __infoRecord: function() {
      const { columns: i, raw: n, encoding: o } = this.options;
      return {
        ...this.__infoDataSet(),
        error: this.state.error,
        header: i === !0,
        index: this.state.record.length,
        raw: n ? this.state.rawBuffer.toString(o) : void 0
      };
    },
    __infoField: function() {
      const { columns: i } = this.options, n = Array.isArray(i);
      return {
        ...this.__infoRecord(),
        column: n === !0 ? i.length > this.state.record.length ? i[this.state.record.length].name : null : this.state.record.length,
        quoting: this.state.wasQuoting
      };
    }
  };
}, LO = function(s, t = {}) {
  typeof s == "string" && (s = q.from(s));
  const e = t && t.objname ? {} : [], i = TO(t), n = (g) => {
    i.options.objname === void 0 ? e.push(g) : e[g[0]] = g[1];
  }, o = () => {
  }, r = i.parse(s, !1, n, o);
  if (r !== void 0)
    throw r;
  const a = i.parse(void 0, !0, n, o);
  if (a !== void 0)
    throw a;
  return e;
}, Rh = class extends ra {
  constructor(t) {
    super(t), this.type = "CSVDataSource";
  }
  async _convertStreamingDataToObjectData(t) {
    return await t.text();
  }
  _convertObjectDataToJSONData(t) {
    return LO(t, {
      columns: !0,
      skip_empty_lines: !0
    });
  }
};
let cg = Rh;
f(cg, "fromURL", async function(t, e) {
  let i = new Rh(e);
  return await i.load(t), i;
}), f(cg, "fromUrl", async function(t, e) {
  return console.warn("CSVDataSource.fromUrl is deprecated, please use CSVDataSource.fromURL instead."), await this.fromURL(t, e);
}), f(cg, "fromCSVString", function(t, e) {
  let i = new Rh(e);
  return i.setData(t), i;
});
new js();
new Zt(new B(0, 0, 1), 0);
const Il = new B(), Al = new J();
class wv extends Wt {
  constructor(e = {}) {
    super(e);
    f(this, "_container");
    f(this, "_point");
    f(this, "_dom");
    f(this, "_div");
    f(this, "_visible");
    f(this, "_offset");
    f(this, "_stopPropagation", !1);
    f(this, "_enableDragging", !1);
    f(this, "handleMouseDown", (e) => {
      e.preventDefault();
      const i = this.engine.rendering.canvas.getBoundingClientRect();
      this._sub = new Z().set(this._screenPos.x - e.x + i.left, this._screenPos.y - e.y + i.top), (this.stopPropagation || this.enableDragging) && e.stopPropagation(), rA ? (e.target.setPointerCapture(e.pointerId), document.addEventListener(ye.MOVE, this.handleMouseMove), document.addEventListener(ye.UP, this.handleMouseUp)) : (document.addEventListener(ye.MOVE, this.handleMouseMove), document.addEventListener(ye.UP, this.handleMouseUp));
    });
    f(this, "handleMouseUp", (e) => {
      document.removeEventListener(ye.MOVE, this.handleMouseMove), document.removeEventListener(ye.UP, this.handleMouseUp), rA && e.target.releasePointerCapture && e.target.releasePointerCapture(e.pointerId);
    });
    f(this, "handleMouseMove", (e) => {
      e.preventDefault();
      const i = this.engine, n = i.rendering.canvas.getBoundingClientRect(), o = e.clientX + this._sub.x - n.left, r = e.clientY + this._sub.y - n.top;
      Il.copy(i.rendering.picking.pickSeaLevelWorldPosition({
        x: o,
        y: r
      }));
      const a = [Il.x, Il.y, Il.z], g = i.map.unprojectArrayCoordinate(a);
      this.point = [g[0], g[1], this.point[2] || 0], i.requestRender();
    });
    f(this, "handleWheel", (e) => {
      e.preventDefault(), e.stopPropagation();
      const i = new WheelEvent("wheel", {
        bubbles: !1,
        cancelable: !0,
        clientX: e.clientX,
        clientY: e.clientY,
        screenX: e.screenX,
        screenY: e.screenY,
        deltaX: e.deltaX,
        deltaY: e.deltaY,
        deltaZ: e.deltaZ,
        deltaMode: e.deltaMode
      });
      this.engine.map.projectionName === zs ? this.engine.rendering.renderer.domElement.dispatchEvent(i) : this.engine.container.dispatchEvent(i);
    });
    this.isDOMOverlay = !0, this.parameters = e;
  }
  afterAddToEngine(e) {
    this.engine = e;
    const i = e.container, n = i instanceof HTMLElement || i && typeof i == "object" && i.nodeType === 1 && typeof i.nodeName == "string";
    this._container = n ? i : i.container || i._container;
    let o = !1;
    const r = e.map._mapType, g = Vt + "-overlay", c = this._container.children;
    if (c && (o = Array.from(c).some((l) => l.id === g)), o)
      this._div = Array.from(c).find((l) => l.id === g);
    else if (this._div = document.createElement("div"), this._div.id = `${Vt}-overlay`, Re(this._div, `${Vt}-overlay-pane`), r === "bmapgl") {
      const l = i == null ? void 0 : i.container;
      l && l instanceof HTMLElement && i.container.appendChild(this._div);
    } else
      i instanceof HTMLElement ? i.appendChild(this._div) : r === "mapbox" && i._container.appendChild(this._div);
    this.dom = this.initDom(), this.point = this.parameters.point || [], this.offset = this.parameters.offset || [0, 0], this.className = this.parameters.className || "", this.enableDragging = this._enableDragging || !1, this.visible = this.parameters.visible || !0, this.afterInit();
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  initDom() {
    if (!this.parameters.dom) {
      console.warn("`DOMOverlay` must contain a property `dom`.");
      return;
    }
    return this.parameters.dom;
  }
  afterInit() {
  }
  onBeforeScenePrepareRender(e, i, n) {
    if (!!this.dom && this.visible) {
      this.camera = n, this.renderer = e.renderer;
      let o = new Z();
      e.renderer.getSize(o), Al.multiplyMatrices(n.matrixWorldInverse, this.matrixWorld), Al.multiplyMatrices(n.projectionMatrix, Al);
      const r = new Me(0, 0, 0, 1);
      r.applyMatrix4(Al), r.divideScalar(r.w), r.z > 1 || r.z < -1 ? Re(this.dom, `${Vt}-hidden`) : ih(this.dom, `${Vt}-hidden`);
      const a = (1 + r.x) * o.x / 2, g = (1 - r.y) * o.y / 2, c = this.dom.clientWidth, l = this.dom.clientHeight;
      let h = a - c / 2 + this.offset[0], d, C = a + c / 2 + this.offset[0], p;
      if (this.isPopup ? (d = g - l + this.offset[1], p = g + this.offset[1]) : (d = g - l / 2 + this.offset[1], p = g + l / 2 + this.offset[1]), C < 0 || h > o.x || p < 0 || d > o.y) {
        this.dom.style.visibility !== "hidden" && (this.dom.style.visibility = "hidden");
        return;
      }
      this.dom.style.position = "absolute", this.dom.style.visibility === "hidden" && (this.dom.style.visibility = "visible"), this.dom.style.left = h + "px", this.dom.style.top = d + "px";
      const b = new B(
        this.matrixWorld.elements[12],
        this.matrixWorld.elements[13],
        this.matrixWorld.elements[14]
      ).clone().project(n), S = (1 + b.x) * o.x / 2, A = (1 - b.y) * o.y / 2;
      this._screenPos = new Z().set(S, A), this.dom.ondragstart = () => !1, this.enableDragging ? this.dom.style.touchAction = "auto" : this.dom.style.touchAction = "none";
    }
  }
  onDispose() {
  }
  dispose() {
    this.onDispose(), this.enableDragging && (this.dom.removeEventListener(ye.DOWN, this.handleMouseDown), this.dom.removeEventListener(ye.UP, this.handleMouseUp), document.removeEventListener(ye.MOVE, this.handleMouseMove), document.removeEventListener(ye.UP, this.handleMouseUp)), this.dom.removeEventListener("wheel", this.handleWheel), this.dom.remove(), this._div.childElementCount === 0 && this._div.remove();
  }
  get dom() {
    return this._dom;
  }
  set dom(e) {
    if (this._dom && (this.enableDragging && (this._dom.removeEventListener(ye.DOWN, this.handleMouseDown), this._dom.removeEventListener(ye.UP, this.handleMouseUp)), this._div.removeChild(this._dom)), typeof e == "string") {
      const i = document.createElement("div");
      Re(i, `${Vt}-dom-overlay-custom`);
      const o = new DOMParser().parseFromString(e, "text/html").body.children;
      for (let r = 0; r < o.length; r++)
        i.appendChild(o.item(r));
      this._dom = i;
    } else
      this._dom = e;
    this._div.appendChild(this._dom), this._dom.style.visibility = this.visible ? "visble" : "hidden", this._dom.setAttribute("draggable", "false"), this._dom.ondragstart = () => !1, this.enableDragging && (this._dom.addEventListener(ye.DOWN, this.handleMouseDown), this._dom.addEventListener(ye.UP, this.handleMouseUp), this._dom.style.cursor = "pointer"), this._dom.addEventListener("wheel", this.handleWheel);
  }
  get point() {
    return this._point;
  }
  set point(e) {
    Array.isArray(e) && e.length > 1 && (this._point = e, this.engine && this.position.set(...this.engine.map.projectArrayCoordinate(e)));
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    e !== this._visible && (this._visible = e, this.dom && (this.dom.style.visibility = e ? "visible" : "hidden"));
  }
  get offset() {
    return this._offset;
  }
  set offset(e) {
    this._offset = e;
  }
  get stopPropagation() {
    return this._stopPropagation;
  }
  set stopPropagation(e) {
    this._stopPropagation = e;
  }
  get enableDragging() {
    return this._enableDragging;
  }
  set enableDragging(e) {
    this._enableDragging !== e && (this._enableDragging = e, this.dom && (e ? (this.dom.addEventListener(ye.DOWN, this.handleMouseDown), this.dom.addEventListener(ye.UP, this.handleMouseUp), this.dom.style.cursor = "pointer") : (this.dom.removeEventListener(ye.DOWN, this.handleMouseDown), this.dom.removeEventListener(ye.UP, this.handleMouseUp), this.dom.style.cursor = "auto")));
  }
  get className() {
    return this._className;
  }
  set className(e) {
    e !== this._className && (this.dom && (this._className && ih(this.dom, this._className), Re(this.dom, e)), this._className = e);
  }
}
class KY extends wv {
  constructor(e) {
    super(e);
    f(this, "_titleDiv");
    f(this, "_contentDiv");
    f(this, "_title");
    f(this, "_content");
    f(this, "_closePopup");
    f(this, "click", () => {
      this.visible = !1;
    });
    this.isPopup = !0;
  }
  initDom() {
    const e = document.createElement("div");
    Re(e, `${Vt}-popup`);
    const i = document.createElement("div");
    Re(i, "frame");
    const n = this._titleDiv = document.createElement("div");
    Re(n, "title"), n.innerText = this.title;
    const o = this._closePopup = document.createElement("div");
    Re(o, "close"), o.innerText = "x", o.addEventListener("click", this.click);
    const r = this._contentDiv = document.createElement("div");
    Re(r, "content"), r.innerText = this.content, i.appendChild(o), i.appendChild(n), i.appendChild(r);
    const a = document.createElement("div");
    return Re(a, "triangle"), e.appendChild(i), e.appendChild(a), e;
  }
  afterInit() {
    this.title = this.parameters.title || "title", this.content = this.parameters.content || "content";
  }
  onDispose() {
    this._closePopup.removeEventListener("click", this.click);
  }
  get title() {
    return this._title;
  }
  set title(e) {
    e && (this._title = e, this._titleDiv && (this._titleDiv.innerText = e));
  }
  get content() {
    return this._content;
  }
  set content(e) {
    this._content = e, this._contentDiv && (this._contentDiv.innerText = e);
  }
}
class HY extends wv {
  constructor(e = {}) {
    super(e);
    f(this, "_icon");
    f(this, "_width");
    f(this, "_height");
    this.isMarker = !0;
  }
  initDom() {
    let e = document.createElement("img");
    return Re(e, `${Vt}-marker`), e;
  }
  afterInit() {
    this.icon = this.parameters.icon || "https://webmap0.bdimg.com/image/api/marker_red.png", this.width = this.parameters.width || 25, this.height = this.parameters.height || 25;
  }
  get icon() {
    return this._icon;
  }
  set icon(e) {
    this.dom && (this.dom.src = e), this._icon = e;
  }
  get width() {
    return this._width;
  }
  set width(e) {
    this.dom && (this.dom.width = e), this._width = e;
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this.dom && (this.dom.height = e), this._height = e;
  }
}
class GO extends Os {
  constructor() {
    super(...arguments);
    f(this, "isPoints", !0);
    f(this, "isEventEntitySupported", !0);
  }
  get size() {
    return this.material.size;
  }
  set size(e) {
    this.material.size = e;
  }
  raycast(e, i) {
    if (!this.visible)
      return;
    const n = e.params.Points.threshold;
    let o = n * this.size;
    this.material.uniforms.zoomUnits && (o *= this.material.uniforms.zoomUnits.value), e.params.Points.threshold = o, Ug.prototype.raycast.call(this, e, i), e.params.Points.threshold = n;
  }
  getEntityByIndex(e) {
    const i = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const n = {
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e], n[r] = o[r][e];
    return n;
  }
}
class MO extends Qe {
  constructor(t) {
    super(t), this.parameters = t;
  }
  setData(t) {
    const { vertexSizes: e, vertexColors: i } = this.parameters, { aPositions: n, aObjectIndices: o, aMapIndexs: r, aColors: a, aSizes: g } = t;
    this.setAttribute("position", new ae(n, 3)), this.setAttribute("objectIndex", new ae(o, 1)), this.setAttribute("aMapIndex", new ae(r, 1)), i && this.setAttribute("aColor", new ae(a, 4)), e && this.setAttribute("aSize", new ae(g, 1));
  }
}
const EO = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_SIZE
    attribute float aSize;
    varying float vSize;
#endif

#ifdef MVT_USE_VERTEX_OFFSET
    attribute vec2 aOffset;
#else
    uniform vec2 uOffset;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
    varying vec4 vColor;
#endif

uniform float size;
uniform float pixelRatio;
uniform vec2 resolution;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 
    #include <mvt_selective_vertex>

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);

    #ifdef MVT_USE_VERTEX_OFFSET
        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;
    #else
        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;
    #endif

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    gl_Position.xy = gl_Position.xy - offset;

    #ifdef MVT_USE_VERTEX_SIZE
        vSize = aSize * pixelRatio;
        gl_PointSize = vSize;
    #else
        gl_PointSize = size * pixelRatio;
    #endif

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #endif

    #include <logdepthbuf_vertex>
}`, RO = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform float uShapeType;
uniform float opacity;

#ifdef MVT_USE_VERTEX_SIZE
    varying float vSize;
#else
    uniform float size;
#endif
uniform bool useMap;
uniform sampler2D map;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = vec4(color, 1.0);
    #endif

    if (uShapeType == 2.) {
        float d = distance(gl_PointCoord, vec2(0.5, 0.5));
        #ifdef MVT_USE_VERTEX_SIZE
            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);
        #else
            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);
        #endif
        
        if (alpha <= 0.) {
            discard;
        } else {
            gl_FragColor.a *= alpha;
        }
    }
 
    if (useMap) {
        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));
     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);
     //    gl_FragColor.a += tColor.a;
        
        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);
        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);
        // gl_FragColor.a += tColor.a;
        // gl_FragColor = tColor;
    }

    if (gl_FragColor.a <= 0.) {
        discard;
    }

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, DO = new Ot(), KO = we.merge([
  Xt.fog,
  zn,
  Ho,
  {
    isEmissive: { value: !1 },
    color: { value: [1, 1, 0] },
    size: { value: 30 },
    vertexColors: { value: !1 },
    vertexSizes: { value: !1 },
    uShapeType: { value: 2 },
    opacity: { value: 1 },
    map: { value: null },
    useMap: { value: !1 },
    uOffset: { value: [0, 0] }
  }
]);
class HO extends di {
  constructor(t) {
    super(), this.name = "SimplePointMaterial", this.vertexShader = EO, this.fragmentShader = RO, this.isSimplePointMaterial = !0, Object.assign(this.uniforms, we.clone(KO)), Po(this), oi(this, [
      "size",
      "uShapeType",
      "opacity",
      "isEmissive"
    ]), Js(this, [
      ["offset", "uOffset"]
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexSizes", "MVT_USE_VERTEX_SIZE"]
    ]), No(this), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const i = this.mapSrc, n = "url_map";
          if (this.userData[n] === e)
            return;
          if (i && i.dispose(), !e) {
            this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[n];
            return;
          }
          const r = DO.load(e);
          r.wrapS = r.wrapT = hs, this.uniforms.map.value = r, this.userData[n] = e, this.uniforms.useMap.value = !0;
        }
      }
    }), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class PY extends GO {
  constructor(e) {
    super(e);
    f(this, "geometry");
    f(this, "material");
    f(this, "color");
    f(this, "vertexColors");
    f(this, "size");
    f(this, "vertexSizes");
    f(this, "opacity");
    this.parameters = e, this.defineMaterialProxyProperties([
      "size",
      "uShapeType",
      "opacity",
      "emissive",
      "vertexColors",
      "vertexSizes",
      "color",
      "mapSrc"
    ]), this.defineMaterialUpdateProxyProperties([
      "transparent"
    ]);
  }
  collisionTest(e) {
    return this.parameters.vertexSizes && e.size ? {
      width: e.size,
      height: e.size
    } : {
      width: this.size,
      height: this.size
    };
  }
  initObject() {
    this.geometry = new MO(this.parameters), this.material = new HO(this.parameters), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.dataSource.data, { vertexSizes: i, vertexColors: n } = this.parameters;
    let o = [];
    this._enableCollision && this._collisionData ? o = this._collisionData : o = this.dataSource.userData;
    const r = [], a = [], g = [], c = [];
    for (let l = 0; l < o.length; l++) {
      const h = o[l].position, d = o[l].index;
      if (r.push(...h), a.push(d), n && e.color) {
        let C = pi(o[l].color);
        g.push(C[0], C[1], C[2], C[3]);
      }
      i && e.size && c.push(o[l].size);
    }
    this.geometry.setData({
      aPositions: r,
      aObjectIndices: a,
      aColors: g,
      aSizes: c
    }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, r), this.needsUpdate = !1;
  }
}
const PO = `#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float uScale;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform bool uFlat;
uniform bool keepSize;
uniform float elapsedTime;

varying vec2 vUv;
varying vec4 vColor;

#ifdef MVT_USE_VERTEX_ROTATEZ
    attribute float aRotateZ;
# else
    uniform float uRotateZ;
#endif

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

#ifdef USE_ANIMATION
uniform float jumpHeight;
uniform float jumpSpeed;
#endif

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

void main() { 
    #include <mvt_selective_vertex>

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    float rotateZ;
    #ifdef MVT_USE_VERTEX_ROTATEZ
        rotateZ = aRotateZ;
    # else
        rotateZ = uRotateZ;
    #endif

    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (uFlat) {
        float hw = width * 0.5;
        float hh = height * 0.5;
        if (keepSize) {
            hw *= pixelSize;
            hh *= pixelSize;
        }

        vec3 current = transformCoord(position, vec2(hw, hh), pIndex, -rotateZ);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(current, 1.0);
    }
    else {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = width / resolution.x * uScale;
        float hh = height / resolution.y * uScale;
        vec2 o = offset;
        if (!keepSize) {
            hw /= pixelSize;
            hh /= pixelSize;
            o /= pixelSize;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        #ifdef USE_ANIMATION
            float bounce = abs(sin(elapsedTime / 1000.0 * jumpSpeed)) * jumpHeight;
            gl_Position.y += (bounce * 2. / resolution.y);
        #endif

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`, NO = `#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;
varying vec4 vColor;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor *= vColor;

    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`, FO = new Ot(), kO = we.merge([
  Xt.fog,
  zn,
  wC,
  {
    emissive: { value: [0, 0, 0] },
    isEmissive: { value: !1 },
    width: { value: 12 },
    height: { value: 12 },
    offset: { value: [0, 0] },
    ulength: { value: 1 },
    useCanvasMap: { value: !1 },
    vertexIcons: { value: !1 },
    opacity: { value: 1 },
    map: { value: null },
    useMap: { value: !1 },
    uScale: { value: 1 },
    uFlat: { value: !1 },
    keepSize: { value: !0 },
    color: { value: [1, 1, 1] },
    vertexColors: { value: !1 },
    jumpHeight: { value: 0 },
    jumpSpeed: { value: 0 },
    uRotateZ: { value: 0 }
  }
]);
class VO extends di {
  constructor(t) {
    super(), this.name = "IconMaterial", this.vertexShader = PO, this.fragmentShader = NO, this.isIconMaterial = !0, Object.assign(this.uniforms, we.clone(kO)), Ka(this), Po(this), oi(this, [
      "width",
      "height",
      "offset",
      "opacity",
      "emissive",
      "isEmissive",
      "jumpHeight",
      "jumpSpeed"
    ]), Js(this, [
      ["scale", "uScale"],
      ["flat", "uFlat"],
      ["rotateZ", "uRotateZ"]
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"],
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["animationJump", "USE_ANIMATION"],
      ["isGlobe", "IS_GLOBE"]
    ]), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const i = this.mapSrc, n = this.userData[this.urlCacheKey], o = this;
          if (n !== e) {
            if (i && i.dispose(), !e) {
              this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[this.urlCacheKey];
              return;
            }
            FO.load(e, function(r) {
              r.wrapS = r.wrapT = hs, r.colorSpace = gt, o.uniforms.map.value = r, o.userData[o.urlCacheKey] = e, o.uniforms.useMap.value = !0, o.uniforms.useCanvasMap.value = !1;
            });
          }
        }
      },
      mapTexture: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.map.value = null, this.uniforms.useCanvasMap.value = !1;
            return;
          }
          e.wrapS = e.wrapT = hs, e.colorSpace = gt, this.uniforms.map.value = e, this.uniforms.useMap.value = !1, this.uniforms.useCanvasMap.value = !0, delete this.userData[this.urlCacheKey];
        }
      }
    }), this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class zO extends Qe {
  constructor(t) {
    super(t), this.parameters = t;
  }
  setData(t) {
    const { aPositions: e, aObjectIndices: i, aUvs: n, aColors: o, pIndices: r, rotateZs: a, indices: g } = t;
    this.setAttribute("position", new ae(e, 3)), this.setAttribute("pIndex", new ae(r, 1)), this.setAttribute("objectIndex", new ae(i, 1)), this.setAttribute("uv", new ae(n, 2)), this.parameters.vertexColors && this.setAttribute("aColor", new ae(o, 4)), this.parameters.vertexRotateZs && this.setAttribute("aRotateZ", new ae(a, 1)), this.setIndex(g), this.cachedObjectIndices = i;
  }
}
const xI = new B(), qn = new Me(), Cl = new J(), vI = new B(), fl = new B();
class _v extends Fo {
  constructor(e) {
    super(e);
    f(this, "isEventEntitySupported", !0);
    f(this, "_padding");
    f(this, "oldMapTextureRes", /* @__PURE__ */ new Map());
    f(this, "texture");
    f(this, "geometry");
    f(this, "material");
    f(this, "canvas");
    f(this, "ctx");
    f(this, "iconUrlHash", /* @__PURE__ */ new Map());
    f(this, "boxHash", /* @__PURE__ */ new Map());
    f(this, "gap", [2, 2]);
    f(this, "getTextureAndHash", (e, i, n, o, r) => {
      const a = this.iconUrlHash;
      if (!r && this.oldMapTextureRes)
        return this.oldMapTextureRes;
      if (!e[0] || !e[0][i])
        return { texture: this.texture, iconUrlHash: a };
      let g = a.size, c = a.size, l = /* @__PURE__ */ new Map();
      for (let d = 0; d < e.length; d++) {
        const C = e[d][i];
        a.get(C) === void 0 && (a.set(C, g), l.set(C, g), g++);
      }
      return c === a.size ? this.oldMapTextureRes : Array.from(a.entries()).map(([d, C]) => new Promise((p, m) => {
        Xw(d, (b) => {
          a.set(d, b), p(d);
        });
      }));
    });
    this.parameters = e, this._padding = this.parameters.padding !== void 0 ? this.parameters.padding : [2, 2];
    const i = this.canvas = document.createElement("canvas");
    i.width = i.height = 1, this.ctx = i.getContext("2d"), this.texture = new ls(i), this.defineMaterialProxyProperties([
      "width",
      "height",
      "offset",
      "map",
      "mapSrc",
      "transparent",
      "opacity",
      "flat",
      "keepSize",
      "color",
      "vertexColors",
      "animationJump",
      "jumpHeight",
      "jumpSpeed"
    ]), this.boxes = [], this.boxSize = e.boxSize || 100;
  }
  initObject() {
    let { vertexIcons: e, ...i } = this.parameters;
    this.geometry = new zO(this.parameters), this.material = new VO(i), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  getDefaultParams() {
    return {
      width: 12,
      height: 12
    };
  }
  collisionTest(e) {
    return {
      width: this.width,
      height: this.height
    };
  }
  createTexture() {
    if (!this.canvas)
      return this.oldMapTextureRes;
    const e = this.ctx, i = this.iconUrlHash;
    for (let [o, r] of i) {
      const a = o, g = i.get(a);
      if (typeof g == "string")
        continue;
      const c = this.boxes.findIndex((p) => p.key === o);
      if (c >= 0) {
        const p = this.boxes.splice(c, 1);
        this.boxes.unshift(p[0]);
        continue;
      }
      const l = g.width, h = g.height, d = l + this.gap[0], C = h + this.gap[1];
      this.boxes.unshift({
        w: d,
        h: C,
        width: l,
        height: h,
        key: o,
        icon: g
      });
    }
    for (let o = 0; o < this.boxes.length; o++) {
      const r = this.boxes[o];
      this.boxHash.set(r.key, r);
    }
    return TC(this.boxes, e, this.canvas, {
      fillStyle: this._fillStyle,
      fontSize: this.parameters.fontSize,
      gap: this.gap,
      padding: this.padding,
      dpr: this.engine.rendering.pixelRatio
    }) ? (this.texture.dispose(), this.texture = new ls(this.canvas)) : this.texture.needsUpdate = !0, this.oldMapTextureRes = { texture: this.texture, iconUrlHash: i }, { texture: this.texture, iconUrlHash: i };
  }
  async _updateData() {
    const {
      vertexIcons: e,
      inconPropName: i = "icon",
      width: n,
      height: o
    } = this.parameters;
    let r = [];
    this._enableCollision && this._collisionData ? r = this._collisionData : r = this.dataSource.userData;
    const a = [], g = [], c = [], l = [], h = [], d = [], C = [];
    let p = "", m = {};
    if (e) {
      let S = this.getTextureAndHash(r, i, n, o, !0), A;
      Array.isArray(S) ? (await Promise.all(S), A = this.createTexture()) : A = S, p = A.texture, m = A.iconUrlHash || {}, this.material.mapTexture = p, this.material.uniforms.ulength.value = m.size;
      for (let u = 0; u < r.length; u++) {
        const y = r[u].position, I = r[u].index, M = r[u][i], G = r[u].rotateZ || 0, x = this.boxHash.get(M);
        if (!x)
          continue;
        const L = r[u].color;
        let E;
        this.parameters.vertexColors && (L ? E = pi(L) : E = [1, 1, 1, 1]), this.parameters.vertexRotateZs && C.push(G, G, G, G);
        for (let K = 0; K < 4; K++)
          a.push(...y), g.push(K), c.push(I), E && d.push(...E);
        const T = x.x / this.canvas.width, R = (x.x + x.w) / this.canvas.width, w = (x.y + x.h) / this.canvas.height, v = x.y / this.canvas.height;
        l.push(
          T,
          w,
          T,
          v,
          R,
          v,
          R,
          w
        );
        const D = u * 4;
        h.push(
          D,
          D + 2,
          D + 1,
          D,
          D + 3,
          D + 2
        );
      }
    } else
      for (let S = 0; S < r.length; S++) {
        const A = r[S].position, u = r[S].index, y = r[S].color, I = r[S].rotateZ || 0;
        let M;
        this.parameters.vertexColors && (y ? M = pi(y) : M = [1, 1, 1, 1]), this.parameters.vertexRotateZs && C.push(I, I, I, I);
        for (let x = 0; x < 4; x++)
          a.push(...A), g.push(x), c.push(u), M && d.push(...M);
        l.push(0, 1, 0, 0, 1, 0, 1, 1);
        const G = S * 4;
        h.push(
          G,
          G + 2,
          G + 1,
          G,
          G + 3,
          G + 2
        );
      }
    this.geometry.setData({
      aColors: d,
      aPositions: a,
      pIndices: g,
      aObjectIndices: c,
      aUvs: l,
      rotateZs: C,
      indices: h
    }), this.geometry.computeBoundingSphere();
    const b = this.geometry.boundingSphere.center;
    this.originCenter = new B().copy(b), this.makeGeometryOffsetPosition(this.geometry, a), this.needsUpdate = !1, this.engine.requestRender();
  }
  getEntityByIndex(e) {
    const i = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const n = {
      index: e,
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e];
    return n;
  }
  raycast(e, i) {
    const n = this.flat;
    if (!this.visible)
      return;
    if (n) {
      this.geometry.boundingSphere === null && this.geometry.computeBoundingSphere();
      const { width: E, height: T } = this.parameters;
      let R = Math.max(E, T) / 2;
      this.keepSize && (R *= this.material.uniforms.zoomUnits.value), this.geometry.boundingSphere.radius += R, le.prototype.raycast.call(this, e, i), this.geometry.boundingSphere.radius -= R;
      return;
    }
    const o = this.geometry, r = o.getAttribute("position");
    if (!r || !r.array || !r.array.length === 0)
      return;
    const a = o.getAttribute("offset");
    let g = [];
    a && (g = a.array);
    let c = e.camera;
    c || (c = this.engine.camera);
    const l = e.mouse;
    if (!l)
      return;
    const h = this.material.uniforms.resolution.value, d = l.x, C = l.y;
    let p = this.width / h.x, m = this.height / h.y;
    const b = p, S = m;
    let A = 0, u = 0, y = 0, I = 0, M = 0, G = 0;
    Cl.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse), Cl.multiplyMatrices(Cl, this.matrixWorld);
    const x = r.array;
    let L = 0;
    for (let E = 0, T = x.length - 11; E < T; E += 12) {
      if (qn.set(x[E], x[E + 1], x[E + 2], 1), qn.applyMatrix4(Cl), qn.divideScalar(qn.w), this.parameters.vertexOffsets ? (L = E / 12 * 8, M = g[L] || 0, G = g[L + 1] || 0) : (M = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[0] : 0, G = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[1] : 0), qn.x += M * 2 / h.x, qn.y -= G * 2 / h.y, !this.keepSize) {
        const { x: R, y: w, z: v } = this.originCenter, D = this.getPixelSize(
          new B(x[E] + R, x[E + 1] + w, x[E + 2] + v)
        );
        p = b / D, m = S / D, M /= D, G /= D;
      }
      if (A = qn.x - p, y = qn.x + p, u = qn.y - m, I = qn.y + m, A <= d && y >= d && u <= C && I >= C) {
        xI.set(x[E], x[E + 1], x[E + 2]), xI.applyMatrix4(this.matrixWorld);
        const R = {
          instanceId: E / 12,
          object: this,
          distance: xI.distanceTo(c.position)
        };
        i.push(R);
      }
    }
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  set padding(e) {
    this._padding = e;
  }
  get padding() {
    return this._padding;
  }
  getVertexPosition(e, i) {
    const n = this.geometry, o = n.attributes.position, r = n.morphAttributes.position, a = n.morphTargetsRelative;
    i.fromBufferAttribute(o, e);
    const g = e % 4;
    let c = this.parameters.width / 2, l = this.parameters.height / 2;
    if (this.keepSize) {
      const d = this.originCenter, C = this.getPixelSize(new B().addVectors(d, i));
      c *= C, l *= C;
    }
    g === 1 ? c = -c : g === 2 || (g === 3 ? l = -l : (l = -l, c = -c)), i.x += c, i.y += l;
    const h = this.morphTargetInfluences;
    if (r && h) {
      fl.set(0, 0, 0);
      for (let d = 0, C = r.length; d < C; d++) {
        const p = h[d], m = r[d];
        p !== 0 && (vI.fromBufferAttribute(m, e), a ? fl.addScaledVector(vI, p) : fl.addScaledVector(vI.sub(i), p));
      }
      i.add(fl);
    }
    return i;
  }
  getPixelSize(e) {
    const { camera: i, rendering: n } = this.engine;
    return i.isOrthographicCamera ? this.material.uniforms.zoomUnits.value : 0.2 * i.projectionMatrix.elements[5] / n.resolution.y * i.position.distanceTo(e);
  }
  getEntityIndexByFace(e, i) {
    return this.geometry.cachedObjectIndices[i];
  }
}
_v.prototype._computeIntersections = le.prototype._computeIntersections;
const bt = new Me(), ho = new J(), jr = new Z();
class NY extends Os {
  constructor(e) {
    super(e);
    f(this, "isDomPoints", !0);
    f(this, "frustumCulled", !1);
    f(this, "_visible", !0);
    f(this, "onBeforeScenePrepareRenderHook", (e, i, n) => {
      this.container = e.map.container;
      let o = e.renderer;
      const r = this.points, a = this.nodes;
      o.getSize(jr), ho.multiplyMatrices(n.matrixWorldInverse, this.matrixWorld), ho.multiplyMatrices(n.projectionMatrix, ho);
      for (let g = 0; g < r.length; g++) {
        bt.set(r[g][0], r[g][1], r[g][2], 1), bt.applyMatrix4(ho), bt.divideScalar(bt.w);
        const c = (bt.x + 1) / 2 * jr.x, l = (-bt.y + 1) / 2 * jr.y;
        if (!a[g])
          return;
        bt.x > 1 || bt.x < -1 || bt.y > 1 || bt < -1 || bt.z > 1 || bt < -1 ? Re(a[g], `${Vt}-hidden`) : ih(a[g], `${Vt}-hidden`), a[g].style.left = c + this.offset[0] + "px", a[g].style.top = l + this.offset[1] + "px";
      }
    });
    this.points = [], this.nodes = [], this.offset = [0, 0], this.parameters = e;
  }
  renderItem(e) {
    const i = document.createElement("div");
    return i.style.position = "absolute", i.style.width = "60px", i.style.height = "40px", i.style.background = "#FFFFFF", i;
  }
  clone() {
    const e = super.clone();
    return e.parameters = this.parameters, e.renderItem = this.renderItem, e;
  }
  _updateData() {
    const e = this.engine, i = e.camera, n = e.renderer, { offset: o = [0, 0] } = this.parameters;
    for (let g = 0; g < this.nodes.length; g++)
      this.nodes[g].remove();
    this.nodes = [], this.points = [];
    const r = this.dataSource;
    if (!r)
      return;
    r.needsUpdate && r.update(), n.getSize(jr), ho.multiplyMatrices(i.matrixWorldInverse, this.matrixWorld), ho.multiplyMatrices(i.projectionMatrix, ho);
    const a = r.data && r.data.position || [];
    for (let g = 0, c = r.size; g < c; g++) {
      const l = a[g];
      this.points.push(l);
      const h = this.renderItem(r.getDataItem(g));
      bt.set(l[0], l[1], l[2], 1), bt.applyMatrix4(ho), bt.divideScalar(bt.w);
      const d = (bt.x + 1) / 2 * jr.x, C = (-bt.y + 1) / 2 * jr.y;
      bt.x > 1 || bt.x < -1 || bt.y > 1 || bt < -1 || bt.z > 1 || bt < -1 ? Re(h, `${Vt}-hidden`) : ih(h, `${Vt}-hidden`), Re(h, `${Vt}-dom-points`), h.style.left = d + o[0] + "px", h.style.top = C + o[1] + "px", h.style.visibility = this.visible === !0 ? "" : "hidden", this.nodes.push(h), this.container.appendChild(h);
    }
    this.offset = o, this.needsUpdate = !1, this.engine && this.engine.requestRender();
  }
  onDispose() {
    this.nodes && this.nodes.length && this.nodes.forEach((e) => {
      e.remove();
    }), this.points = [], this.nodes = [];
  }
  set visible(e) {
    if (this._visible === e)
      return;
    this._visible = e;
    let i = e ? "" : "hidden";
    this.nodes && this.nodes.length && this.nodes.forEach((n) => {
      n.style.visibility = i;
    });
  }
  get visible() {
    return this._visible;
  }
}
const XO = `#define GLSLIFY 1
#include <common>

attribute float pIndex;
attribute float aMapIndex;

uniform float pixelRatio;
uniform float width;
uniform float height;
uniform float ulength;
uniform vec2 resolution;
uniform vec2 offset;
uniform vec3 positionOffset;
uniform bool uFlat;
uniform bool keepSize;
uniform float scaleRatio;

#ifdef MVT_USE_VERTEX_SIZE
    attribute vec2 aSize;
#endif

#ifdef MVT_USE_VERTEX_POSITION_OFFSET
    attribute vec3 aPositionOffsets;
#endif

varying vec2 vUv;

#include <mvt_selective_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {
    #include <mvt_selective_vertex>
    float setWidth = width;
    float setHeight = height;

    #ifdef MVT_USE_VERTEX_SIZE
        setWidth = aSize.x * scaleRatio;
        setHeight = aSize.y * scaleRatio;
    #endif

    vec2 o = offset * scaleRatio;
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (uFlat) {
        float hw = setWidth * 0.5;
        float hh = setHeight * 0.5;
        if (keepSize) {
            hw *= pixelSize;
            hh *= pixelSize;
            o *= pixelSize;
        }
        if (pIndex == 1.0) {
            hw = -hw;
        } else if (pIndex == 2.0) {

        } else if (pIndex == 3.0) {
            hh = -hh;
        } else {
            hw = -hw;
            hh = -hh;
        }
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);
    }
    else {
        vec3 setPositionOffset = positionOffset;
        #ifdef MVT_USE_VERTEX_POSITION_OFFSET
            setPositionOffset = aPositionOffsets;
        #endif
        worldPosition.x += setPositionOffset.x;
        worldPosition.y += setPositionOffset.y;
        worldPosition.z += setPositionOffset.z;

        gl_Position = projectionMatrix * viewMatrix * worldPosition;
        float w = gl_Position.w;
        gl_Position /= w;

        float hw = setWidth / resolution.x;
        float hh = setHeight / resolution.y;
        if (!keepSize) {
            hw /= pixelSize;
            hh /= pixelSize;
            o /= pixelSize;
        }

        gl_Position.x += o.x * 2. / resolution.x;
        gl_Position.y -= o.y * 2. / resolution.y;

        if (pIndex == 1.0) {
            gl_Position.x -= hw;
            gl_Position.y += hh;
        } else if (pIndex == 2.0) {
            gl_Position.x += hw;
            gl_Position.y += hh;
        } else if (pIndex == 3.0) {
            gl_Position.x += hw;
            gl_Position.y -= hh;
        } else {
            gl_Position.x -= hw;
            gl_Position.y -= hh;
        }

        gl_Position *= w;
    }

    vUv = uv;

    #include <logdepthbuf_vertex>
}`, WO = `#define GLSLIFY 1
#include <common>

uniform float opacity;

uniform bool useMap;
uniform bool useCanvasMap;
uniform sampler2D map;
uniform float width;
uniform float height;

varying vec2 vUv;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_emissive_pars_fragment>

void main() {

    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));
    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);

    if (gl_FragColor.a <= 0.) {
        discard;
    }
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment> 
    #include <logdepthbuf_fragment> 
    #include <mvt_emissive_fragment>
    #include <colorspace_fragment>
}`, ZO = new Ot(), UO = we.merge([
  Xt.fog,
  zn,
  wC,
  {
    emissive: { value: [0, 0, 0] },
    isEmissive: { value: !1 },
    width: { value: 12 },
    height: { value: 12 },
    offset: { value: [0, 0] },
    positionOffset: { value: [0, 0, 0] },
    ulength: { value: 1 },
    useCanvasMap: { value: !1 },
    vertexIcons: { value: !1 },
    opacity: { value: 1 },
    map: { value: null },
    useMap: { value: !1 },
    uFlat: { value: !1 },
    keepSize: { value: !0 },
    scaleRatio: { value: 1 }
  }
]);
class OO extends di {
  constructor(t) {
    super(), this.name = "LabelMaterial", this.vertexShader = XO, this.fragmentShader = WO, this.isLabelMaterial = !0, Object.assign(this.uniforms, we.clone(UO)), Ka(this), Po(this), Js(this, [
      ["flat", "uFlat"]
    ]), ri(this, [
      ["vertexBackgroundCanvas", "MVT_USE_VERTEX_SIZE"],
      ["vertexBackgrounds", "MVT_USE_VERTEX_SIZE"],
      ["vertexPositionOffsets", "MVT_USE_VERTEX_POSITION_OFFSET"]
    ]), oi(this, [
      "width",
      "height",
      "offset",
      "positionOffset",
      "opacity",
      "emissive",
      "isEmissive",
      "scaleRatio"
    ]), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const i = this.mapSrc, n = this.userData[this.urlCacheKey], o = this;
          if (n !== e) {
            if (i && i.dispose(), !e) {
              this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[this.urlCacheKey];
              return;
            }
            ZO.load(e, function(r) {
              r.wrapS = r.wrapT = hs, r.colorSpace = gt, o.uniforms.map.value = r, o.userData[o.urlCacheKey] = e, o.uniforms.useMap.value = !0, o.uniforms.useCanvasMap.value = !1;
            });
          }
        }
      },
      mapTexture: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          if (!e) {
            this.uniforms.map.value = null, this.uniforms.useCanvasMap.value = !1;
            return;
          }
          e.wrapS = e.wrapT = hs, e.colorSpace = gt, this.uniforms.map.value = e, this.uniforms.useMap.value = !1, this.uniforms.useCanvasMap.value = !0, delete this.userData[this.urlCacheKey];
        }
      }
    }), this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class QO extends Qe {
  constructor(t) {
    super(t), this.parameters = t;
  }
  setData(t) {
    const { vertexBackgrounds: e, vertexBackgroundCanvas: i, vertexPositionOffsets: n } = this.parameters, { aPositions: o, aObjectIndices: r, aUvs: a, pIndices: g, indices: c, aSize: l, aPositionOffsets: h } = t;
    this.setAttribute("position", new ae(o, 3)), this.setAttribute("pIndex", new ae(g, 1)), this.setAttribute("objectIndex", new ae(r, 1)), this.setAttribute("uv", new ae(a, 2)), (e || i) && this.setAttribute("aSize", new ae(l, 2)), n && this.setAttribute("aPositionOffsets", new ae(h, 3)), this.setIndex(c);
  }
}
const TI = new B(), $n = new Me(), pl = new J();
class YO extends Fo {
  constructor(e) {
    super(e);
    f(this, "isEventEntitySupported", !0);
    f(this, "isLabel", !0);
    f(this, "geometry");
    f(this, "material");
    f(this, "canvas");
    f(this, "ctx");
    f(this, "texture");
    f(this, "iconUrlHash", /* @__PURE__ */ new Map());
    f(this, "canvasHash", /* @__PURE__ */ new Map());
    f(this, "boxHash", /* @__PURE__ */ new Map());
    f(this, "gap", [2, 2]);
    f(this, "_padding");
    f(this, "_fillStyle");
    f(this, "oldMapTextureRes", {});
    f(this, "_instanceIds", []);
    f(this, "labelHash");
    this.parameters = e, this._padding = [0, 0, 0, 0], this.parameters.padding && (this.padding = this.parameters.padding), this._fillStyle = this.parameters.fillStyle || "#fff";
    const i = e.maxCacheSize || 2e3;
    this.labelHash = new wa({
      max: i,
      onRemove: (r, a) => {
        this.boxHash.delete(a);
      }
    });
    const n = this.canvas = document.createElement("canvas");
    n.width = n.height = 1;
    const o = this.ctx = n.getContext("2d");
    o.textAlign = "start", this.texture = new ls(n), this.defineMaterialProxyProperties([
      "width",
      "height",
      "offset",
      "transparent",
      "opacity",
      "flat",
      "keepSize",
      "positionOffset"
    ]), this.boxes = [], this.boxSize = e.boxSize || 100, e.labelTest && (document.body.append(n), n.style.cssText = "position: absolute; z-index: 111; top: 10px; left: 10px; background: #fff");
  }
  initObject() {
    const {
      background: e,
      fontSize: i,
      padding: n,
      fillStyle: o,
      vertexVisible: r,
      visiblePropName: a,
      backgroundCanvasPropName: g,
      maxCacheSize: c,
      ...l
    } = this.parameters;
    this.geometry = new QO(this.parameters), this.material = new OO(l), this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  clone() {
    return new this.constructor(this.parameters);
  }
  getDefaultParams() {
    return {
      width: 12,
      height: 12,
      fontSize: 14
    };
  }
  collisionTest(e) {
    return {
      width: this.width,
      height: this.height
    };
  }
  createLabelTexture(e) {
    const {
      backgroundCanvas: i,
      backgroundCanvasPropName: n
    } = e, o = this.labelHash, r = this.iconUrlHash, a = o.cache, g = this.canvasHash, c = this.ctx;
    let l;
    for (let d in a)
      if (a.hasOwnProperty(d)) {
        const C = JSON.parse(d), { icon: p, text: m, id: b } = C, S = b ? g.get(d) : r.get(p);
        if (typeof S == "string" || S === void 0)
          continue;
        const A = this.boxes.findIndex((G) => G.key === d);
        if (A >= 0) {
          const G = this.boxes.splice(A, 1);
          this.boxes.unshift(G[0]);
          continue;
        }
        const u = S.width, y = S.height, I = u + this.gap[0], M = y + this.gap[1];
        this.boxes.unshift({
          w: I,
          h: M,
          width: u,
          height: y,
          key: d,
          icon: S,
          text: m
        });
      }
    for (let d = 0; d < this.boxes.length; d++) {
      const C = this.boxes[d];
      this.boxHash.set(C.key, C);
    }
    return TC(this.boxes, c, this.canvas, {
      fillStyle: this._fillStyle,
      fontSize: this.parameters.fontSize,
      gap: this.gap,
      padding: this.padding,
      dpr: this.engine.rendering.pixelRatio,
      drawText: !(n || i),
      textAlign: this.parameters.textAlign
    }) ? (this.texture.dispose(), this.texture = new ls(this.canvas)) : this.texture.needsUpdate = !0, l = this.texture, l;
  }
  async _updateData() {
    const {
      vertexSizes: e,
      vertexBackgrounds: i,
      vertexBackgroundCanvas: n,
      vertexPositionOffsets: o,
      vertexVisible: r = !1,
      background: a,
      bgPropName: g = "background",
      textPropName: c = "text",
      visiblePropName: l = "visible",
      backgroundCanvas: h,
      backgroundCanvasPropName: d
    } = this.parameters;
    let C = [];
    this._enableCollision && this._collisionData ? C = this._collisionData : C = this.dataSource.userData, C.length > (this.parameters.maxCacheSize || 2e3) && console.warn(`Label\u6570\u91CF\u8D85\u8FC7\u4E86\u6700\u5927\u9650\u5236\uFF0C\u8BF7\u66F4\u65B0maxCacheSize\u53C2\u6570\uFF1B\u5F53\u524D\u6700\u5927\u503C\u4E3A${this.parameters.maxCacheSize || 2e3}`);
    let p = this.labelHash;
    const m = this.iconUrlHash, b = this.canvasHash;
    b.clear();
    let S = p.length, A = p.length, u = [];
    if (h || d)
      for (let w = 0; w < C.length; w++) {
        let v = this.parameters.vertexBackgroundCanvas ? C[w][d] : h;
        const D = C[w][c], K = JSON.stringify({
          id: C[w].id || C[w].index,
          text: String(D)
        });
        v instanceof Promise ? u.push(v.then((P) => {
          b.get(K) === void 0 && b.set(K, P);
        })) : b.get(K) === void 0 && b.set(K, v), p.get(K) === void 0 && (p.set(K, S), S++);
      }
    else {
      for (let w = 0; w < C.length; w++) {
        const v = this.parameters.vertexBackgrounds ? C[w][g] : a, D = C[w][c], K = JSON.stringify({
          icon: v,
          text: String(D)
        });
        m.get(v) === void 0 && m.set(v, v), p.get(K) === void 0 && (p.set(K, S), S++);
      }
      u = Array.from(m.entries()).filter((w) => typeof w[1] == "string").map(([w, v]) => new Promise((D, K) => {
        this.url2canvas(w, (P) => {
          m.set(w, P), D(w);
        });
      }));
    }
    u.length > 0 && await Promise.all(u);
    let y;
    if (A === S && this.oldTexture && (y = this.oldTexture), y || (y = this.createLabelTexture({
      backgroundCanvasPropName: d,
      backgroundCanvas: h
    }), this.oldTexture = y), !y)
      return;
    this.material.mapTexture = y, this.material.uniforms.ulength.value = p.length, this._instanceIds = [];
    const I = [], M = [], G = [], x = [], L = [], E = [], T = [];
    let R = 0;
    for (let w = 0; w < C.length; w++) {
      let v = C[w].position;
      const D = C[w].index, K = C[w][c], P = C[w][l];
      if (r && P === !1)
        continue;
      this._instanceIds.push(w);
      const k = h || d ? JSON.stringify({
        id: C[w].id || C[w].index,
        text: String(K)
      }) : JSON.stringify({
        icon: i ? C[w][g] : a,
        text: String(K)
      }), V = this.boxHash.get(k);
      if (!V)
        continue;
      for (let $ = 0; $ < 4; $++)
        I.push(...v), M.push($), G.push(D), o && T.push(...C[w].positionOffset);
      const N = V.x / this.canvas.width, z = (V.x + V.w) / this.canvas.width, O = (V.y + V.h) / this.canvas.height, Q = V.y / this.canvas.height;
      x.push(
        N,
        O,
        N,
        Q,
        z,
        Q,
        z,
        O
      );
      const U = R * 4;
      if (L.push(
        U,
        U + 2,
        U + 1,
        U,
        U + 3,
        U + 2
      ), R++, i || n) {
        let $ = V.width, ee = V.height;
        const { originWidth: se, originHeight: ie } = V.icon;
        ie && se && ($ = se, ee = ie), e && ($ = C[w].width, ee = C[w].height), E.push(
          $,
          ee,
          $,
          ee,
          $,
          ee,
          $,
          ee
        );
      }
    }
    this.geometry.setData({
      aPositions: I,
      pIndices: M,
      aObjectIndices: G,
      aUvs: x,
      indices: L,
      aSize: E,
      aPositionOffsets: T
    }), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, I), this.needsUpdate = !1, this.engine.requestRender();
  }
  url2canvas(e, i) {
    if (typeof e == "object")
      i(e);
    else {
      let n = new Image();
      n.crossOrigin = "anonymous", n.onload = function() {
        let o = n.width, r = n.height, a = document.createElement("canvas");
        a.width = o, a.height = r, a.getContext("2d").drawImage(n, 0, 0, o, r), i(a);
      }, n.onerror = function() {
        let o = document.createElement("canvas");
        o.width = 20, o.height = 40;
        let r = o.getContext("2d");
        r.fillStyle = "red", r.beginPath(), r.lineTo(0, 0), r.lineTo(20, 0), r.lineTo(10, 40), r.closePath(), r.fill(), i(o);
      }, n.src = e;
    }
  }
  getEntityByIndex(e) {
    const i = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const n = {
      index: e,
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e];
    return n;
  }
  raycast(e, i) {
    const n = this.flat;
    if (!this.visible || n)
      return;
    const o = this.geometry, r = o.getAttribute("position");
    if (!r || !r.array || !r.array.length === 0)
      return;
    const a = o.getAttribute("offset");
    let g = [];
    a && (g = a.array);
    let c = e.camera;
    c || (c = this.engine.camera);
    const l = e.mouse;
    if (!l)
      return;
    const h = this.material.uniforms.resolution.value, d = l.x, C = l.y;
    let p = this.width / h.x, m = this.height / h.y, b = [];
    const S = o.getAttribute("aSize");
    S && (b = S.array);
    let A = [];
    const u = o.getAttribute("aPositionOffsets");
    A = u ? u.array : [];
    let y = 0, I = 0, M = 0, G = 0, x = 0, L = 0;
    pl.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse), pl.multiplyMatrices(pl, this.matrixWorld);
    const E = r.array;
    let T = 0, R = 0, w = 1;
    this.keepSize || (w = this.material.uniforms.zoomUnits.value);
    for (let v = 0, D = E.length - 11; v < D; v += 12) {
      const K = this.material.positionOffset || [0, 0, 0];
      if (this.parameters.vertexPositionOffsets && (K[0] = A[v], K[1] = A[v + 1], K[2] = A[v + 2]), $n.set(
        E[v] + K[0],
        E[v + 1] + K[1],
        E[v + 2] + K[2],
        1
      ), $n.applyMatrix4(pl), $n.divideScalar($n.w), this.parameters.vertexOffsets ? (T = v / 12 * 8, x = g[T] || 0, L = g[T + 1] || 0) : (x = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[0] : 0, L = this.material.uniforms.offset.value ? this.material.uniforms.offset.value[1] : 0), $n.x += x * 2 / h.x / w, $n.y -= L * 2 / h.y / w, (this.parameters.vertexSizes || this.parameters.vertexBackgrounds || this.parameters.vertexBackgroundCanvas) && (R = v / 12 * 8, p = b[R] / h.x, m = b[R + 1] / h.y), y = $n.x - p / w, M = $n.x + p / w, I = $n.y - m / w, G = $n.y + m / w, y <= d && M >= d && I <= C && G >= C) {
        TI.set(E[v], E[v + 1], E[v + 2]), TI.applyMatrix4(this.matrixWorld);
        const P = v / 12, V = {
          instanceId: this._instanceIds[P],
          object: this,
          distance: TI.distanceTo(c.position)
        };
        i.push(V);
      }
    }
  }
  set padding(e) {
    e.length === 2 ? this._padding = [e[0], e[1], e[0], e[1]] : e.length === 3 ? this._padding = [e[0], e[1], e[2], e[1]] : e.length >= 4 && (this._padding = [e[0], e[1], e[2], e[3]]);
  }
  get padding() {
    return this._padding;
  }
  onDispose() {
    this.texture && this.texture.dispose(), this.canvas && (this.canvas = null), this.iconUrlHash.clear(), this.labelHash.clear(), this.boxHash.clear();
  }
}
function LA(s, t, e, i, n, o) {
  if (n - i <= e)
    return;
  const r = i + n >> 1;
  xv(s, t, r, i, n, o % 2), LA(s, t, e, i, r - 1, o + 1), LA(s, t, e, r + 1, n, o + 1);
}
function xv(s, t, e, i, n, o) {
  for (; n > i; ) {
    if (n - i > 600) {
      const c = n - i + 1, l = e - i + 1, h = Math.log(c), d = 0.5 * Math.exp(2 * h / 3), C = 0.5 * Math.sqrt(h * d * (c - d) / c) * (l - c / 2 < 0 ? -1 : 1), p = Math.max(i, Math.floor(e - l * d / c + C)), m = Math.min(n, Math.floor(e + (c - l) * d / c + C));
      xv(s, t, e, p, m, o);
    }
    const r = t[2 * e + o];
    let a = i, g = n;
    for (lg(s, t, i, e), t[2 * n + o] > r && lg(s, t, i, n); a < g; ) {
      for (lg(s, t, a, g), a++, g--; t[2 * a + o] < r; )
        a++;
      for (; t[2 * g + o] > r; )
        g--;
    }
    t[2 * i + o] === r ? lg(s, t, i, g) : (g++, lg(s, t, g, n)), g <= e && (i = g + 1), e <= g && (n = g - 1);
  }
}
function lg(s, t, e, i) {
  LI(s, e, i), LI(t, 2 * e, 2 * i), LI(t, 2 * e + 1, 2 * i + 1);
}
function LI(s, t, e) {
  const i = s[t];
  s[t] = s[e], s[e] = i;
}
function jO(s, t, e, i, n, o, r) {
  const a = [0, s.length - 1, 0], g = [];
  let c, l;
  for (; a.length; ) {
    const h = a.pop(), d = a.pop(), C = a.pop();
    if (d - C <= r) {
      for (let b = C; b <= d; b++)
        c = t[2 * b], l = t[2 * b + 1], c >= e && c <= n && l >= i && l <= o && g.push(s[b]);
      continue;
    }
    const p = Math.floor((C + d) / 2);
    c = t[2 * p], l = t[2 * p + 1], c >= e && c <= n && l >= i && l <= o && g.push(s[p]);
    const m = (h + 1) % 2;
    (h === 0 ? e <= c : i <= l) && (a.push(C), a.push(p - 1), a.push(m)), (h === 0 ? n >= c : o >= l) && (a.push(p + 1), a.push(d), a.push(m));
  }
  return g;
}
function JO(s, t, e, i, n, o) {
  const r = [0, s.length - 1, 0], a = [], g = n * n;
  for (; r.length; ) {
    const c = r.pop(), l = r.pop(), h = r.pop();
    if (l - h <= o) {
      for (let b = h; b <= l; b++)
        mS(t[2 * b], t[2 * b + 1], e, i) <= g && a.push(s[b]);
      continue;
    }
    const d = Math.floor((h + l) / 2), C = t[2 * d], p = t[2 * d + 1];
    mS(C, p, e, i) <= g && a.push(s[d]);
    const m = (c + 1) % 2;
    (c === 0 ? e - n <= C : i - n <= p) && (r.push(h), r.push(d - 1), r.push(m)), (c === 0 ? e + n >= C : i + n >= p) && (r.push(d + 1), r.push(l), r.push(m));
  }
  return a;
}
function mS(s, t, e, i) {
  const n = s - e, o = t - i;
  return n * n + o * o;
}
const qO = (s) => s[0], $O = (s) => s[1];
class yS {
  constructor(t, e = qO, i = $O, n = 64, o = Float64Array) {
    this.nodeSize = n, this.points = t;
    const r = t.length < 65536 ? Uint16Array : Uint32Array, a = this.ids = new r(t.length), g = this.coords = new o(t.length * 2);
    for (let c = 0; c < t.length; c++)
      a[c] = c, g[2 * c] = e(t[c]), g[2 * c + 1] = i(t[c]);
    LA(a, g, n, 0, a.length - 1, 0);
  }
  range(t, e, i, n) {
    return jO(this.ids, this.coords, t, e, i, n, this.nodeSize);
  }
  within(t, e, i) {
    return JO(this.ids, this.coords, t, e, i, this.nodeSize);
  }
}
const eQ = {
  minZoom: 0,
  maxZoom: 16,
  radius: 40,
  extent: 512,
  nodeSize: 64,
  log: !1,
  generateId: !1,
  reduce: null,
  map: (s) => s
};
class tQ {
  constructor(t) {
    this.options = Rg(Object.create(eQ), t), this.trees = new Array(this.options.maxZoom + 1);
  }
  convertDataItemsToGeoJSON(t) {
    return t.map((e) => ({
      type: "Feature",
      properties: e.attributes,
      geometry: {
        type: "Point",
        coordinates: e.coordinates
      }
    }));
  }
  load(t) {
    const { log: e, minZoom: i, maxZoom: n, nodeSize: o } = this.options;
    e && console.time("total time");
    const r = `prepare ${t.length} points`;
    e && console.time(r), this.points = this.convertDataItemsToGeoJSON(t);
    let a = [];
    for (let g = 0; g < this.points.length; g++) {
      const c = this.points[g];
      !Array.isArray(c) && !c.geometry || a.push(nQ(c, g));
    }
    this.trees[n + 1] = new yS(a, bS, BS, o, Float32Array), e && console.timeEnd(r);
    for (let g = n; g >= i; g--)
      a = this._cluster(a, g), this.trees[g] = new yS(a, bS, BS, o, Float32Array);
    return e && console.timeEnd("total time"), this;
  }
  getClusters(t, e) {
    let i = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const n = Math.max(-90, Math.min(90, t[1]));
    let o = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const r = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      i = -180, o = 180;
    else if (i > o) {
      const l = this.getClusters([i, n, 180, r], e), h = this.getClusters([-180, n, o, r], e);
      return l.concat(h);
    }
    const a = this.trees[this._limitZoom(e)], g = a.range(GA(i), MA(r), GA(o), MA(n)), c = [];
    for (const l of g) {
      const h = a.points[l];
      c.push(h.numPoints ? SS(h) : this.points[h.index]);
    }
    return c;
  }
  getChildren(t) {
    const e = this._getOriginId(t), i = this._getOriginZoom(t), n = "No cluster with the specified id.", o = this.trees[i];
    if (!o)
      throw new Error(n);
    const r = o.points[e];
    if (!r)
      throw new Error(n);
    const a = this.options.radius / (this.options.extent * Math.pow(2, i - 1)), g = o.within(r.x, r.y, a), c = [];
    for (const l of g) {
      const h = o.points[l];
      h.parentId === t && c.push(h.numPoints ? SS(h) : this.points[h.index]);
    }
    if (c.length === 0)
      throw new Error(n);
    return c;
  }
  getLeaves(t, e, i) {
    e = e || 10, i = i || 0;
    const n = [];
    return this._appendLeaves(n, t, e, i, 0), n;
  }
  getTile(t, e, i) {
    const n = this.trees[this._limitZoom(t)], o = Math.pow(2, t), { extent: r, radius: a } = this.options, g = a / r, c = (i - g) / o, l = (i + 1 + g) / o, h = {
      features: []
    };
    return this._addTileFeatures(
      n.range((e - g) / o, c, (e + 1 + g) / o, l),
      n.points,
      e,
      i,
      o,
      h
    ), e === 0 && this._addTileFeatures(
      n.range(1 - g / o, c, 1, l),
      n.points,
      o,
      i,
      o,
      h
    ), e === o - 1 && this._addTileFeatures(
      n.range(0, c, g / o, l),
      n.points,
      -1,
      i,
      o,
      h
    ), h.features.length ? h : null;
  }
  getClusterExpansionZoom(t) {
    let e = this._getOriginZoom(t) - 1;
    for (; e <= this.options.maxZoom; ) {
      const i = this.getChildren(t);
      if (e++, i.length !== 1)
        break;
      t = i[0].properties.cluster_id;
    }
    return e;
  }
  _appendLeaves(t, e, i, n, o) {
    const r = this.getChildren(e);
    for (const a of r) {
      const g = a.properties;
      if (g && g.cluster ? o + g.point_count <= n ? o += g.point_count : o = this._appendLeaves(t, g.cluster_id, i, n, o) : o < n ? o++ : t.push(a), t.length === i)
        break;
    }
    return o;
  }
  _addTileFeatures(t, e, i, n, o, r) {
    for (const a of t) {
      const g = e[a], c = g.numPoints, l = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (g.x * o - i)),
          Math.round(this.options.extent * (g.y * o - n))
        ]],
        tags: c ? vv(g) : this.points[g.index].properties
      };
      let h;
      c ? h = g.id : this.options.generateId ? h = g.index : this.points[g.index].id && (h = this.points[g.index].id), h !== void 0 && (l.id = h), r.features.push(l);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(t, this.options.maxZoom + 1));
  }
  _cluster(t, e) {
    const i = [], { radius: n, extent: o, reduce: r } = this.options, a = n / (o * Math.pow(2, e));
    for (let g = 0; g < t.length; g++) {
      const c = t[g];
      if (c.zoom <= e)
        continue;
      c.zoom = e;
      const l = this.trees[e + 1], h = l.within(c.x, c.y, a);
      let d = c.numPoints || 1, C = c.x * d, p = c.y * d, m = r && d > 1 ? this._map(c, !0) : null;
      const b = (g << 5) + (e + 1) + this.points.length;
      for (const S of h) {
        const A = l.points[S];
        if (A.zoom <= e)
          continue;
        A.zoom = e;
        const u = A.numPoints || 1;
        C += A.x * u, p += A.y * u, d += u, A.parentId = b, r && (m || (m = this._map(c, !0)), r(m, this._map(A)));
      }
      d === 1 ? i.push(c) : (c.parentId = b, i.push(iQ(C / d, p / d, b, d, m)));
    }
    return i;
  }
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, e) {
    if (t.numPoints)
      return e ? Rg({}, t.properties) : t.properties;
    const i = this.points[t.index].properties, n = this.options.map(i);
    return e && n === i ? Rg({}, n) : n;
  }
}
function iQ(s, t, e, i, n) {
  return {
    x: s,
    y: t,
    zoom: 1 / 0,
    id: e,
    parentId: -1,
    numPoints: i,
    properties: n
  };
}
function nQ(s, t) {
  const [e, i] = Array.isArray(s) ? s : s.geometry.coordinates;
  return {
    x: GA(e),
    y: MA(i),
    zoom: 1 / 0,
    index: t,
    parentId: -1
  };
}
function SS(s) {
  return {
    type: "Feature",
    id: s.id,
    properties: vv(s),
    geometry: {
      type: "Point",
      coordinates: [sQ(s.x), oQ(s.y)]
    }
  };
}
function vv(s) {
  const t = s.numPoints, e = t >= 1e4 ? `${Math.round(t / 1e3)}k` : t >= 1e3 ? `${Math.round(t / 100) / 10}k` : t;
  return Rg(Rg({}, s.properties), {
    cluster: !0,
    cluster_id: s.id,
    point_count: t,
    point_count_abbreviated: e
  });
}
function GA(s) {
  return s / 360 + 0.5;
}
function MA(s) {
  const t = Math.sin(s * Math.PI / 180), e = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function sQ(s) {
  return (s - 0.5) * 360;
}
function oQ(s) {
  const t = (180 - s * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
function Rg(s, t) {
  for (const e in t)
    s[e] = t[e];
  return s;
}
function bS(s) {
  return s.x;
}
function BS(s) {
  return s.y;
}
class rQ extends Os {
  constructor() {
    super(...arguments);
    f(this, "isEventEntitySupported", !0);
  }
  addComponent(e) {
    if (!e.isGeoObject) {
      console.warn("Only GeoObject can be added");
      return;
    }
    e.__eventProxyByParent = !0, this.add(e), e.afterAddToEngine(this.engine);
    const i = this.getChildDataSource(e);
    return i && (e.dataSource = i), this.needsUpdate = !0, e;
  }
  removeComponent(e) {
    this.remove(e), e.__eventProxyByParent = !1, e.dataSource = null, e.beforeRemoveFromEngine(this.engine), this.needsUpdate = !0;
  }
  getChildDataSource(e) {
    return this.dataSource;
  }
  onBeforeScenePrepareRender(e, i, n, o) {
    super.onBeforeScenePrepareRender && super.onBeforeScenePrepareRender(e, i, n, o);
    for (const r of this.children)
      r.onBeforeScenePrepareRender && r.onBeforeScenePrepareRender(e, i, n, o);
  }
  onBeforeSceneRender(e, i, n, o) {
    super.onBeforeSceneRender && super.onBeforeSceneRender(e, i, n, o);
    for (const r of this.children)
      r.onBeforeSceneRender && r.onBeforeSceneRender(e, i, n, o);
  }
  setDataSource(e) {
    super.setDataSource(e);
    for (const i of this.children)
      i.setDataSource(this.getChildDataSource(i));
  }
  _updateData() {
    for (const e of this.children)
      e.needsUpdate && e._updateData();
    this.needsUpdate = !1;
  }
  dispose() {
    for (const e of this.children)
      this.removeComponent(e);
  }
}
const aQ = {
  width: 30,
  height: 30,
  mapSrc: "https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png"
}, gQ = {
  fillStyle: "#ccc",
  fontSize: 16,
  flat: !1
}, cQ = {
  maxZoom: 18,
  minZoom: 5,
  radius: 50
};
class FY extends rQ {
  constructor(e = {}) {
    super(e);
    f(this, "_ready");
    f(this, "_cluster");
    f(this, "_clusterDataSource");
    f(this, "_icon");
    f(this, "_label");
    f(this, "_minUpdateInterval");
    f(this, "isEventEntitySupported", !0);
    f(this, "_minUpdateInterval", 300);
    f(this, "_lastUpdateTime", 0);
    f(this, "_updateTimeoutHandler", null);
    f(this, "_clusterData", []);
    f(this, "_updateRenderingData", () => {
      const { map: e } = this.engine, i = e.getBoundingBox(), n = Math.round(e.getZoom()), o = this._cluster.getClusters([...i.min, ...i.max], n);
      this._clusterData = o, this._clusterDataSource.objects.length > 0 && this._clusterDataSource.setData(o), this._clusterDataSource.update();
      for (const r of this.children)
        r._updateData();
    });
    this.parameters = e, this._ready = !1, this._cluster = new tQ(Object.assign({}, cQ, e.cluster)), this._cluster.load([]), (this._clusterDataSource = new gr()).defineAttribute("size").defineAttribute("icon").defineAttribute("text", (n) => (n && n.cluster ? n.point_count : 0) + "");
  }
  initObject() {
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e);
    const i = this.parameters;
    i.icon && (this._icon = this.addComponent(new _v(Object.assign({}, aQ, i.icon)))), i.label && (this._label = this.addComponent(new YO(Object.assign({}, gQ, i.label)))), this._ready = !0;
  }
  _updateData() {
    let e = this.dataSource.data;
    this.cachedData = e, this._cluster.load(this.dataSource.dataItems), this.needsUpdate = !1;
  }
  onBeforeScenePrepareRender(e, i, n, o) {
    if (!this._ready || !this.dataSource)
      return;
    this._needsUpdate && this._updateRenderingData(), clearTimeout(this._updateTimeoutHandler);
    const r = o.time;
    if (r - this._lastUpdateTime > this._minUpdateInterval) {
      this._updateRenderingData(), this._lastUpdateTime = r;
      return;
    }
    this._updateTimeoutHandler = setTimeout(() => {
      this._updateRenderingData(), e.requestRender();
    }, this._minUpdateInterval), super.onBeforeScenePrepareRender(e, i, n, o);
  }
  getChildDataSource() {
    return this._clusterDataSource;
  }
  getEntityByIndex(e) {
    const i = this._clusterDataSource;
    if (!i)
      return;
    const n = {
      index: e,
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e];
    return n;
  }
  get minUpdateInterval() {
    return this._minUpdateInterval;
  }
  set minUpdateInterval(e) {
    e < 16 && (e = 16), this._minUpdateInterval = e;
  }
  get clusterDataSource() {
    return this._clusterDataSource;
  }
  get clusterData() {
    return this._clusterData;
  }
}
class lQ extends iv {
  constructor() {
    super();
    f(this, "setModelData", () => {
      const e = [
        -0.5,
        -0.5,
        0,
        -0.5,
        0.5,
        0,
        0.5,
        0.5,
        0,
        0.5,
        -0.5,
        0
      ], i = [
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        0
      ], n = [
        0,
        2,
        1,
        0,
        3,
        2
      ];
      this.setAttribute("position", new ae(e, 3)), this.setAttribute("uv", new ae(i, 2)), this.setIndex(n);
    });
    this.setModelData();
  }
}
const hQ = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#endif

#ifndef MVT_USE_VERTEX_SIZE
    uniform float size;
#endif

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

varying vec2 vPosition;
varying float vScale;

#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() {

    #include <mvt_selective_vertex>
    vPosition = position.xy;

    vec3 transformed = vec3(position);
    #ifdef MVT_USE_VERTEX_SIZE
        vScale = instanceMatrix[0][0];
    #else
        vScale = size;
        transformed *= size;
    #endif

    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));
    float pixelSize = getPixelSize(vec3(modelMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));
    if (keepSize) {
        transformed *= pixelSize;
    }

    #ifdef IS_GLOBE
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * ecefMatrix * vec4(transformed, 1.0);
    #else
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);
    #endif
    #include <logdepthbuf_vertex>

    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)
        vColor.xyz = instanceColor.xyz;
        vColor.a = 1.0;
    #endif
}`, dQ = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform vec3 borderColor;
uniform float opacity;
uniform float borderOpacity;
uniform float fillOpacity;
uniform float radius;
uniform float borderWidth;

varying vec2 vPosition;
varying float vScale;

#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    float dis = distance(vPosition, vec2(0, 0));

    // \u7528\u6765\u4FDD\u6301\u8FB9\u6846\u7684\u5BBD\u5EA6\u4E0D\u4F1A\u968F\u7740\u7F29\u653E\u800C\u53D8\u5316
    float radius2 = radius - (borderWidth / vScale) * radius;

    // \u7528\u4E8E\u6297\u952F\u9F7F
    float blur = 0.001;
    float pct = (1.0 - smoothstep(radius - blur, radius + blur, dis));
    vec4 border = vec4(borderColor, borderOpacity);
    #ifdef MVT_USE_VERTEX_COLOR
        vec4 currentColor = mix(vec4(vColor.rgb, fillOpacity), border, smoothstep( radius2 - blur,radius2 + blur, dis));
    #else
        vec4 currentColor = mix(vec4(color, fillOpacity), border, smoothstep( radius2 - blur,radius2 + blur, dis));
    #endif

    // \u8BBE\u7F6E\u7684\u81EA\u8EAB\u989C\u8272\u7684\u900F\u660E\u5EA6\u4F18\u5148\u7EA7\u9AD8\u4E8E\u8BBE\u7F6E\u7684opacity\u4F18\u5148\u7EA7
    gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);
    if (gl_FragColor.a < 0.001) {
        discard;
    }
    gl_FragColor.a *= opacity;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment>
    #include <colorspace_fragment>
}`, uQ = `#define GLSLIFY 1
#include <common>

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif
uniform float radius;
uniform float opacity;
varying vec2 vPosition;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

void main() {
    float d = distance(vPosition, vec2(0, 0));
    if (d > 0.5) {
        discard;
    }
    vec4 fillColor;
    #ifdef MVT_USE_VERTEX_COLOR
        fillColor = vColor;
    #else
        fillColor = vec4(color, 1.0);
    #endif
    
    fillColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));
    // \u8FB9\u7F18\u6297\u952F\u9F7F
    if(d > -0.99 * radius) {
        fillColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); 
    }
    fillColor.a *= opacity;
    gl_FragColor = fillColor;
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <mvt_selective_fragment>
    #include <logdepthbuf_fragment>   
    #include <colorspace_fragment>
}`, IQ = {
  height: { value: 0 },
  size: { value: 1 },
  size3: { value: [1, 1, 1] },
  resolution: { value: [1, 1] },
  zoomUnits: { value: 1 },
  color: { value: [1, 0, 0] },
  opacity: { value: 1 }
}, AQ = {
  animationRotatePeriod: { value: 4e3 },
  animationJumpPeriod: { value: 4e3 },
  animationJumpHeight: { value: 30 },
  animationPeriodOffset: { value: !1 },
  animationEffect: { value: !0 },
  animationEffectPeriod: { value: 4e3 },
  animationPeriod: { value: 4e3 }
}, CQ = (s) => {
  Object.defineProperties(s, {
    color: {
      get: function() {
        return this.uniforms.color.value;
      },
      set: function(t) {
        this.uniforms.color.value = Oh(t);
      }
    },
    height: {
      get: function() {
        return this.uniforms.height.value;
      },
      set: function(t) {
        this.uniforms.height.value = t;
      }
    },
    size: {
      get: function() {
        return this.uniforms.size.value;
      },
      set: function(t) {
        this.uniforms.size.value = t;
      }
    },
    size3: {
      get: function() {
        return this.uniforms.size3.value;
      },
      set: function(t) {
        Array.isArray(t) && t.length === 3 && (this.uniforms.size3.value = t);
      }
    },
    useSize3: {
      get: function() {
        return this.defines.USE_SIZE3;
      },
      set: function(t) {
        t === this.defines.USE_SIZE3 && (this.defines.USE_SIZE3 = !!t), this.needsUpdate = !0;
      }
    },
    opacity: {
      get: function() {
        return this.uniforms.opacity.value;
      },
      set: function(t) {
        this.uniforms.opacity.value = t;
      }
    }
  });
}, fQ = (s) => {
  Object.defineProperties(s, {
    animationRotate: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_ROTATE;
      },
      set: function(t) {
        t !== this.animationRotate && (t ? this.defines.ENABLE_ANIMATION_ROTATE = !0 : delete this.defines.ENABLE_ANIMATION_ROTATE, this.needsUpdate = !0);
      }
    },
    animationRotatePeriod: {
      get: function() {
        return this.uniforms.animationRotatePeriod.value;
      },
      set: function(t) {
        this.uniforms.animationRotatePeriod.value = t;
      }
    },
    animationJump: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_JUMP;
      },
      set: function(t) {
        t !== this.animationJump && (t ? this.defines.ENABLE_ANIMATION_JUMP = !0 : delete this.defines.ENABLE_ANIMATION_JUMP, this.needsUpdate = !0);
      }
    },
    animationJumpPeriod: {
      get: function() {
        return this.uniforms.animationJumpPeriod.value;
      },
      set: function(t) {
        this.uniforms.animationJumpPeriod.value = t;
      }
    },
    animationJumpHeight: {
      get: function() {
        return this.uniforms.animationJumpHeight.value;
      },
      set: function(t) {
        this.uniforms.animationJumpHeight.value = t;
      }
    },
    animationPeriodOffset: {
      get: function() {
        return this.uniforms.animationPeriodOffset.value;
      },
      set: function(t) {
        this.uniforms.animationPeriodOffset.value = t;
      }
    },
    animationEffect: {
      get: function() {
        return this.uniforms.animationEffect.value;
      },
      set: function(t) {
        this.uniforms.animationEffect.value = t;
      }
    },
    animationEffectPeriod: {
      get: function() {
        return this.uniforms.animationEffectPeriod.value;
      },
      set: function(t) {
        this.uniforms.animationEffectPeriod.value = t;
      }
    },
    animationScale: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_SCALE;
      },
      set: function(t) {
        t !== this.animationScale && (t ? this.defines.ENABLE_ANIMATION_SCALE = !0 : delete this.defines.ENABLE_ANIMATION_SCALE, this.needsUpdate = !0);
      }
    },
    animationBreath: {
      get: function() {
        return !!this.defines.ENABLE_ANIMATION_BREATH;
      },
      set: function(t) {
        t !== this.animationBreath && (t ? this.defines.ENABLE_ANIMATION_BREATH = !0 : delete this.defines.ENABLE_ANIMATION_BREATH, this.needsUpdate = !0);
      }
    },
    animationPeriod: {
      get: function() {
        return this.uniforms.animationPeriod.value;
      },
      set: function(t) {
        this.uniforms.animationPeriod.value = t;
      }
    }
  });
}, pQ = we.merge([
  Xt.fog,
  IQ,
  AQ,
  zn,
  wC,
  {
    isCesium: { value: !1 }
  }
]);
class mQ extends di {
  constructor(t) {
    super(), this.type = "InstancedEffectPointMaterial", this.isInstancedEffectPointMaterial = !0, this.lights = !1, Object.assign(this.uniforms, we.clone(pQ)), CQ(this), fQ(this), Po(this), Ka(this), this.setValues(t);
  }
}
let GI = we.merge([
  Ho,
  {
    color: { value: [1, 0.5, 0] },
    borderColor: { value: [0, 1, 0] },
    borderOpacity: { value: 1 },
    fillOpacity: { value: 1 },
    opacity: { value: 1 },
    radius: { value: 0.5 },
    borderWidth: { value: 1 },
    isEmissive: { value: !1 }
  }
]);
class yQ extends mQ {
  constructor(e) {
    super();
    f(this, "name", "CircleMaterial");
    f(this, "isCircleMaterial", !0);
    this.depthTest = !1, this.depthWrite = !1, e.vertexSizes || (GI = we.merge([
      GI,
      {
        size: { value: 100 }
      }
    ])), Object.assign(this.uniforms, we.clone(GI)), oi(this, [
      "borderWidth",
      "borderOpacity",
      "fillOpacity",
      "isEmissive"
    ]), Xn(this, [
      "borderColor"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["vertexSizes", "MVT_USE_VERTEX_SIZE"],
      ["isGlobe", "IS_GLOBE"]
    ]), No(this), this.vertexShader = hQ, e.type === "Gradient" ? this.fragmentShader = uQ : this.fragmentShader = dQ, this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(e);
  }
}
class kY extends tv {
  constructor(e) {
    super(e);
    f(this, "geometry");
    f(this, "material");
    f(this, "color");
    f(this, "size");
    f(this, "opacity");
    f(this, "type");
    f(this, "borderColor");
    f(this, "borderWidth");
    f(this, "borderOpacity");
    f(this, "fillOpacity");
    f(this, "getInstanceLocalMatrix", (e, i, n) => {
      const { vertexSizes: o } = this.parameters, { size: r } = this.dataSource.data;
      if (o && r) {
        const a = new J();
        return a.makeScale(r[n], r[n], r[n]), a;
      }
      return null;
    });
    f(this, "addCustomAttributes", () => {
      const { vertexColors: e } = this.parameters, { color: i } = this.dataSource.data, n = [];
      e && i && i.forEach((o) => {
        const r = pi(o);
        n.push(r[0], r[1], r[2]);
      }), this.instanceColor = new Ni(new Float32Array(n), 3);
    });
    this.parameters = e, this.defineMaterialProxyProperties([
      "color",
      "size",
      "size3",
      "opacity",
      "borderWidth",
      "borderColor",
      "borderOpacity",
      "fillOpacity",
      "radius",
      "keepSize",
      "transparent"
    ]);
  }
  initObject() {
    const e = this.engine.map.isGlobe;
    this.geometry = new lQ(), this.material = new yQ(this.parameters), this.material.isGlobe = e, this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  collisionTest(e) {
    let i = 0;
    return this.material.keepSize && (this.parameters.vertexSizes && e.size ? i = e.size : i = this.size), {
      width: i,
      height: i
    };
  }
}
const SQ = `#define GLSLIFY 1
#include <common>
uniform sampler2D gradientMap;

varying vec2 vUv;

#include <logdepthbuf_pars_vertex>
void main() { 
    
    gl_Position = vec4(position, 1.0);
    // vUv = position.xy;
    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);
    // vec4 gray = texture2D(gradientMap, vUv);

    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);
    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);
    // m0 /= m0.w;
    // m1 /= m1.w;
    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);
    // pixel.z = 100. * gray.a;

    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);
    #include <logdepthbuf_vertex>
}`, bQ = `#define GLSLIFY 1
#include <common>

uniform sampler2D heatmap;
uniform sampler2D gradientMap;
uniform sampler2D heatmapDepth;
uniform float opacity;
uniform vec2 resolution;

varying vec2 vUv;

#include <packing>

#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
    uniform float logDepthBufFC;
#endif

void main() {
    vec4 color = texture2D(heatmap, vUv);
    
    if (color.a <= 0.) {
        discard;
    }
    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));
    float addAlpha = 1.0;
    if (color.a < 0.3) {
        addAlpha = color.a * 3.3;
    }
    // if (color.a < 0.3) {
    //     gl_FragColor.a = color.a * 3.3;
    // } else {
    //     gl_FragColor.a = 1.0;
    // }
    gl_FragColor.a *= color.a;
    gl_FragColor.a *= opacity;

    vec4 depthColor = texture2D(heatmapDepth, vUv);

    #if defined( USE_LOGDEPTHBUF ) 
        gl_FragDepthEXT = unpackRGBAToDepth(depthColor);
    #endif
    #include <colorspace_fragment>
}`, BQ = we.merge([
  Xt.fog,
  {
    heatmap: { value: null },
    heatmapDepth: { value: null },
    gradientMap: { value: null },
    opacity: { value: 1 },
    isEmissive: { value: !1 }
  }
]);
class wQ extends di {
  constructor(t) {
    super(t), this.name = "HeatmapMaterial", this.isHeatmapMaterial = !0, this.fog = !0, this.lights = !1, this.transparent = !0, this.fragmentShader = bQ, this.vertexShader = SQ, Object.assign(this.uniforms, we.clone(BQ)), oi(this, [
      "opacity",
      "resolution",
      "isEmissive"
    ]), Js(this, []), ri(this, []), this._cachedGradient = null, Object.defineProperties(this, {
      gradient: {
        get: function() {
          return this._cachedGradient;
        },
        set: function(e) {
          this._cachedGradient = e, this.updateGradientMap();
        }
      }
    }), this.createGradientMap(), this.uniforms.gradientMap.value = this._cachedGradientMap, this.setValues(t);
  }
  createGradientMap() {
    let t = document.createElement("canvas");
    t.width = 64, t.height = 2;
    let e = t.getContext("2d"), i = e.createLinearGradient(0, 0, 64, 0);
    i.addColorStop(0, "rgba(0,0,255,1)"), i.addColorStop(0.3, "rgba(0,255,0,1)"), i.addColorStop(0.6, "rgba(255,255,0,1)"), i.addColorStop(1, "rgba(255,0,0,1)"), e.fillStyle = i, e.fillRect(0, 0, 64, 2), this._cachedGradientMap = new ls(t);
  }
  updateGradientMap() {
    let t = this._cachedGradient;
    if (Object.prototype.toString.call(t) !== "[object Object]")
      return;
    let i = this._cachedGradientMap.image.getContext("2d");
    i.clearRect(0, 0, 64, 2);
    let n = i.createLinearGradient(0, 0, 64, 0);
    for (const o in t)
      Object.hasOwnProperty.call(t, o) && n.addColorStop(o, t[o]);
    i.fillStyle = n, i.fillRect(0, 0, 64, 2), this._cachedGradientMap.needsUpdate = !0;
  }
  dispose() {
    this._cachedGradientMap && this._cachedGradientMap.dispose(), super.dispose();
  }
}
const _Q = `#define GLSLIFY 1
#include <common>

attribute float instancedWeight;

uniform float radius;
uniform float maxValue;
uniform float minValue;
uniform bool keepSize;
uniform float attenuateMValueFactor;
uniform float pixelRatio;
uniform vec2 resolution;

varying vec2 vUv;
varying float vWeight;

#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 

    float range = (maxValue - minValue) * attenuateMValueFactor;

    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));
    float pixelSize = getPixelSize(worldPosition.xyz);

    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize, 1.0);
        range *= pixelSize;
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);
    }
    
    // gl_Position = vec4(position, 1.0);
    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;
   
    vUv = vec2(position.x + 0.5, position.y + 0.5);
    
    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);

    #include <logdepthbuf_vertex>
}`, xQ = `#define GLSLIFY 1
#include <common>

uniform sampler2D circleMap;

varying vec2 vUv;
varying float vWeight;
varying float vZDepth;
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;
    // gl_FragColor.a = 1.;
    //#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);
        // int d = int(gl_FragDepthEXT * 16581375.0);
        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;
        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;
        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;
        // gl_FragColor.r = gl_FragDepthEXT; // a
        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);
        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);
        // int d = int(gl_FragDepthEXT * 10000000.0);
        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; 
        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; 
        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; 
        // gl_FragColor.r = gl_FragDepthEXT;
        // gl_FragColor.r = gl_FragCoord.z;

        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);
        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );
        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;
        // gl_FragColor.rgb = encode;

    // #else 
    //     gl_FragColor.r = gl_FragCoord.z;
    // #endif
    // gl_FragColor.r = 1.0;
    // gl_FragColor.a = gl_FragCoord.z;
}`, vQ = we.merge([
  Xt.fog,
  {
    radius: { value: 30 },
    circleMap: { value: null },
    minValue: { value: 0 },
    maxValue: { value: 100 },
    keepSize: { value: !1 },
    attenuateMValueFactor: { value: 0 }
  }
]);
class TQ extends di {
  constructor(t) {
    super(t), this.type = "HeatmapTextureMaterial", this.isHeatmapTextureMaterial = !0, this.fog = !0, this.lights = !1, this.transparent = !0, this.depthTest = !1, this.fragmentShader = xQ, this.vertexShader = _Q, Object.assign(this.uniforms, we.clone(vQ)), oi(this, [
      "radius",
      "minValue",
      "maxValue",
      "keepSize",
      "attenuateMValueFactor"
    ]), Js(this, []), ri(this, []);
    const e = this.createCircleMap();
    this.uniforms.circleMap.value = e, this.setValues(t), this.blending = kA, this.blendSrc = Ll, this.blendDst = ql, this.blendSrcAlpha = Ll, this.blendDstAlpha = Ll;
  }
  createCircleMap() {
    let t = document.createElement("canvas");
    t.width = 64, t.height = 64;
    let e = t.getContext("2d"), i = e.createRadialGradient(32, 32, 0, 32, 32, 32);
    return i.addColorStop(0, "rgba(0,0,0,1)"), i.addColorStop(1, "rgba(0,0,0,0)"), e.fillStyle = i, e.arc(32, 32, 32, 0, Math.PI * 2, !1), e.fill(), new ls(t);
  }
  dispose() {
    this.uniforms.circleMap.value && this.uniforms.circleMap.value.dispose(), super.dispose();
  }
}
const LQ = `#define GLSLIFY 1
#include <common>
attribute vec3 instancedPosition;

uniform float radius;
uniform bool keepSize;
uniform float pixelRatio;
uniform vec2 resolution;

#include <logdepthbuf_pars_vertex>
#include <mvt_extra_vertex_utils>

void main() { 

    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));
    float pixelSize = getPixelSize(worldPosition.xyz);
    if (keepSize) {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize * 1.1, 1.0);
    } else {
        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * 1.1, 1.0);
    }
    #include <logdepthbuf_vertex>
}`, GQ = `#define GLSLIFY 1
#include <common>
#include <packing>
#include <logdepthbuf_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>

    #if defined( USE_LOGDEPTHBUF ) 
    
        gl_FragColor = packDepthToRGBA(gl_FragDepthEXT);
    #else
        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);
    #endif
    
}`, MQ = we.merge([
  Xt.fog,
  {
    radius: { value: 30 },
    circleMap: { value: null },
    minValue: { value: 0 },
    maxValue: { value: 100 },
    keepSize: { value: !1 },
    attenuateMValueFactor: { value: 0 }
  }
]);
class EQ extends di {
  constructor(t) {
    super(t), this.type = "HeatmapDepthTextureMaterial", this.isHeatmapDepthTextureMaterial = !0, this.fog = !0, this.lights = !1, this.transparent = !0, this.depthTest = !1, this.fragmentShader = GQ, this.vertexShader = LQ, Object.assign(this.uniforms, we.clone(MQ)), oi(this, [
      "radius",
      "minValue",
      "maxValue",
      "keepSize",
      "attenuateMValueFactor"
    ]), Js(this, []), ri(this, []), this.setValues(t);
  }
}
class RQ extends Fb {
  constructor() {
    super();
    const t = this.geometry = new Og();
    this.setAttribute("position", t.attributes.position), this.setAttribute("uv", t.attributes.uv), this.setIndex(t.index);
  }
  dispose() {
    this.geometry.dispose();
  }
}
class VY extends Fo {
  constructor(e) {
    super(e);
    f(this, "isHeatmap", !0);
    f(this, "frustumCulled", !1);
    f(this, "geometry");
    f(this, "material");
    f(this, "scene");
    f(this, "pointMesh");
    f(this, "pointMaterial");
    f(this, "pointGeometry");
    f(this, "renderTarget");
    f(this, "depthMaterial");
    f(this, "depthRenderTarget");
    this.parameters = e, this.defineMaterialProxyProperties([
      "resolution"
    ]);
  }
  getDefaultParams() {
    return {
      radius: 100,
      maxValue: 1,
      gradient: {
        0: "rgba(0,0,255,1)",
        0.3: "rgba(0,255,0,1)",
        0.6: "rgba(255,255,0,1)",
        1: "rgba(255,0,0,1)"
      }
    };
  }
  initObject() {
    let e = this.parameters;
    const i = this.geometry = new Qe();
    i.setAttribute("position", new Fe(new Float32Array([
      -1,
      1,
      0,
      1,
      1,
      0,
      -1,
      -1,
      0,
      1,
      -1,
      0
    ]), 3)), i.setAttribute("uv", new Fe(new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      1,
      0
    ]), 2)), i.setIndex([0, 2, 1, 2, 3, 1]), (this.material = new wQ({})).setCommonUniforms(this.engine.rendering.uniforms);
    const [o, r] = this.resolution || [], a = this.scene = new Kh();
    this.renderTarget = new It(o, r), this.depthRenderTarget = new It(o, r, {}), this.depthMaterial = new EQ({
      keepSize: this.parameters.keepSize
    });
    const g = this.pointGeometry = new RQ(), c = this.pointMaterial = new TQ({
      keepSize: this.parameters.keepSize
    });
    c.setCommonUniforms(this.engine.rendering.uniforms), this.depthMaterial.setCommonUniforms(this.engine.rendering.uniforms);
    const l = this.pointMesh = new ad(g, c);
    l.engine = this.engine, this.pointMesh.matrixAutoUpdate = !0, l.frustumCulled = !1, a.add(l), this.material.uniforms.heatmap.value = this.renderTarget.texture, this.material.uniforms.heatmapDepth.value = this.depthRenderTarget.texture, e.gradient !== void 0 && (this.gradient = e.gradient), e.radius !== void 0 && (this.radius = e.radius), e.minValue !== void 0 && (this.minValue = e.minValue), e.maxValue !== void 0 && (this.maxValue = e.maxValue), e.opacity !== void 0 && (this.opacity = e.opacity), e.keepSize !== void 0 && (this.keepSize = e.keepSize), e.attenuateMValueFactor !== void 0 && (this.attenuateMValueFactor = e.attenuateMValueFactor);
  }
  onBeforeSceneRenderHook(e, i, n, o) {
    let r = e.renderer;
    const a = o.cameraOffset;
    this.scene.position.set(-a.x, -a.y, -a.z), r.setRenderTarget(this.renderTarget), r.autoClear === !1 && r.clear(), r.render(this.scene, n), r.setRenderTarget(this.depthRenderTarget), r.autoClear === !1 && r.clear(), this.scene.overrideMaterial = this.depthMaterial, r.render(this.scene, n), this.scene.overrideMaterial = null, r.setRenderTarget(null);
  }
  set dataSource(e) {
    this.pointMesh.dataSource = e;
  }
  get dataSource() {
    return this.pointMesh.dataSource;
  }
  _updateData() {
    this.pointMesh.dataSource && (this.pointMesh.addCustomAttributes = (e, i) => {
      let n = i.data, o = [];
      for (let r = 0; r < n.position.length; r++) {
        const a = n.count[r] ? n.count[r] : 1;
        o.push(a);
      }
      e.setAttribute(
        "instancedWeight",
        new Ni(new Float32Array(o), 1)
      );
    }, this.pointMesh._updateData());
  }
  dispose() {
    this.material.dispose(), this.geometry.dispose(), this.pointGeometry.dispose(), this.pointMaterial.dispose(), this.renderTarget.dispose(), this.depthMaterial.dispose(), this.depthRenderTarget.dispose();
  }
  set gradient(e) {
    Object.prototype.toString.call(e) === "[object Object]" && (this.material.gradient = e);
  }
  set radius(e) {
    !isNaN(e) && e > 0 && (this.pointMaterial.radius = e, this.depthMaterial.radius = e);
  }
  get radius() {
    return this.pointMaterial.radius;
  }
  set minValue(e) {
    isNaN(e) || (this.pointMaterial.minValue = e);
  }
  get minValue() {
    return this.pointMaterial.minValue;
  }
  set maxValue(e) {
    isNaN(e) || (this.pointMaterial.maxValue = e);
  }
  get maxValue() {
    return this.pointMaterial.maxValue;
  }
  set opacity(e) {
    isNaN(e) || (this.material.opacity = e);
  }
  get opacity() {
    return this.material.opacity;
  }
  set keepSize(e) {
    this.pointMaterial.keepSize = e, this.depthMaterial.keepSize = e;
  }
  get keepSize() {
    return this.pointMaterial.keepSize;
  }
  set attenuateMValueFactor(e) {
    this.pointMaterial.attenuateMValueFactor = e;
  }
}
const DQ = `#define GLSLIFY 1
#include <common>

uniform float positionOffsetX;
uniform float positionOffsetY;
uniform float pixelOffsetX;
uniform float pixelOffsetY;
uniform float positionOffsetZ;
uniform bool uFlat;
#ifdef RENDER_IN_POSTPROCESS
    uniform float cameraFar;
#endif

attribute float pIndex;
attribute vec2 wh;

#ifdef IS_GLOBE
    attribute mat4 instanceMatrix;
#endif

#ifdef MVT_USE_VERTEX_ROTATEZ
    attribute float aRotateZ;
# else
    uniform float uRotateZ;
#endif

varying vec2 vUv;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif
#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

void main() {
    #include <mvt_selective_vertex>
    // float x = position.x;
    // float y = position.y;
    vUv = uv;

    float rotateZ;
    #ifdef MVT_USE_VERTEX_ROTATEZ
        rotateZ = aRotateZ;
    # else
        rotateZ = uRotateZ;
    #endif

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = instanceMatrix;

        currentInstanceMatrix[3][0] = position.x;
        currentInstanceMatrix[3][1] = position.y;
        currentInstanceMatrix[3][2] = position.z;

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));

    #ifdef RENDER_IN_POSTPROCESS
    vec4 clipSpacePosition = projectionMatrix * viewMatrix * worldPosition;
    vClipSpacePosition.xy = ((clipSpacePosition.xy / clipSpacePosition.w) + 1.0) / 2.0;

    float fcoef = 1.0 / log2(cameraFar + 1.0);
    float logDepth = log2(max(1e-6, 1.0 + clipSpacePosition.w)) * fcoef;
    vLogDepth = logDepth;
    #endif

    if (uFlat) {
        // viewMatrix[0]\u8868\u793A\u76F8\u673A\u7684\u53F3\u65B9\u5411\uFF0C\u4E0D\u7BA1\u76F8\u673A\u5982\u4F55\u503E\u659Ctilt\uFF0C\u6CD5\u5411\u91CF\u90FD\u6307\u5411\u6B63\u5317\u65B9\u5411\uFF0C\u6B63\u597D\u53EF\u4EE5\u7528\u6765\u8BA1\u7B97\u548C\u6587\u5B57\u7684\u5939\u89D2
        mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;
        vec4 right = localViewMatrix[0];
        float theta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));
        if (theta < 0.0) {
            rotateZ += PI;
        }
        // TODO \u652F\u6301offset
        float hw = wh.x * 0.5;
        float hh = wh.y * 0.5;
        if (keepSize) {
            float pixelSize = getPixelSize(worldPosition.xyz);
            hw = hw * pixelSize;
            hh = hh * pixelSize;
        }

        vec3 current = transformCoord(currentPosition, vec2(hw, hh), pIndex, -rotateZ);
        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);

        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    }
    else {
        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
        worldPosition.x += positionOffsetX;
        worldPosition.y += positionOffsetY;
        worldPosition.z += positionOffsetZ;
        vec4 pos = projectionMatrix * viewMatrix * worldPosition;
        float w = pos.w;
        vec3 screen = pos.xyz / w;
        
        float hw = wh.x / resolution.x;
        float hh = wh.y / resolution.y;
        if (!keepSize) {
            float pixelSize = getPixelSize(worldPosition.xyz);
            hw = hw / pixelSize;
            hh = hh / pixelSize;
        }

        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);
        gl_Position = vec4(current, 1.0);

        gl_Position.x += pixelOffsetX * 2. / resolution.x;
        gl_Position.y += pixelOffsetY * 2. / resolution.y;

        gl_Position *= w;
    }
    #include <logdepthbuf_vertex>
    // gl_PointSize = size * pixelRatio;
    // vSize = size;
    // vOffset = offset;
}`, KQ = `#define GLSLIFY 1
#include <common>

uniform sampler2D map;
uniform sampler2D depthTexture;
uniform vec4 backgroundColor;
uniform float opacity;
uniform float lineHeight;

#ifdef RENDER_IN_POSTPROCESS
    uniform float cameraFar;
#endif

varying vec2 vUv;

#ifdef RENDER_IN_POSTPROCESS
    varying vec2 vClipSpacePosition;
    varying float vLogDepth;
#endif

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <tonemapping_pars_fragment>
#include <output_pars_fragment>
void main() {
    #include <logdepthbuf_fragment>
    // gl_FragColor = vec4(1., 0, 0, 1.);
    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));

    #ifdef RENDER_IN_POSTPROCESS
    float depthValue = texture2D(depthTexture, vClipSpacePosition).r;
    float bias = 0.001; // \u907F\u514D\u8BBE\u7F6E\u4E00\u4E2A\u9608\u503C\uFF0C\u7CBE\u5EA6\u8BEF\u5DEE\u9020\u6210\u6587\u5B57\u7ED8\u5236\u4E0D\u7A33\u5B9A
    if (vLogDepth > depthValue + bias) {
        discard;
    }
    #endif

    if (backgroundColor.a > 0.0) {
        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);
    }

    if (gl_FragColor.a <= 0.0) {
        discard;
    }
    gl_FragColor.a *= opacity;

    #include <mvt_selective_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
    #include <output_fragment>
}`, HQ = we.merge([
  Xt.fog,
  zn,
  Ho,
  {
    map: {
      value: null
    },
    pixelRatio: {
      value: 1
    },
    lineHeight: {
      value: 14
    },
    pixelOffsetX: {
      value: 0
    },
    pixelOffsetY: {
      value: 0
    },
    positionOffsetX: {
      value: 0
    },
    positionOffsetZ: {
      value: 0
    },
    positionOffsetY: {
      value: 0
    },
    backgroundColor: {
      value: [1, 1, 0, 0]
    },
    uFlat: {
      value: !1
    },
    opacity: {
      value: 1
    },
    isEmissive: {
      value: !1
    },
    uRotateZ: {
      value: 0
    },
    keepSize: {
      value: !0
    },
    depthTexture: {
      value: null
    },
    cameraFar: {
      value: 0
    }
  }
]);
class PQ extends di {
  constructor(t) {
    super(), this.name = "DefaultTextMaterial", this.vertexShader = DQ, this.fragmentShader = KQ, this.isDefaultTextMaterial = !0, this.transparent = !0, this.depthTest = !1, this.depthWrite = !1, Object.assign(this.uniforms, we.clone(HQ)), Po(this), Ka(this), oi(this, [
      "lineHeight",
      "pixelRatio",
      "map",
      "depthTexture",
      "cameraFar",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "isEmissive"
    ]), Js(this, [
      ["flat", "uFlat"],
      ["rotateZ", "uRotateZ"]
    ]), ri(this, [
      ["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"],
      ["isGlobe", "IS_GLOBE"],
      ["isRenderInPostprocess", "RENDER_IN_POSTPROCESS"]
    ]), No(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
}
let Jr;
const MI = new B(), uo = new Me(), ml = new J();
class zY extends Fo {
  constructor(e) {
    super(e);
    f(this, "isEventEntitySupported", !0);
    f(this, "_fontSize");
    f(this, "_fontFamily");
    f(this, "_fillStyle");
    f(this, "_padding");
    f(this, "_strokeStyle");
    f(this, "_shouldStroke");
    f(this, "_collisionBoxCache", {});
    f(this, "isRenderInPostprocess", !1);
    f(this, "geometry");
    f(this, "material");
    f(this, "cachedData", []);
    f(this, "drawingData");
    f(this, "canvas");
    f(this, "ctx");
    f(this, "texture");
    f(this, "matrixAutoUpdate", !0);
    f(this, "sortByStyle", (e) => this.parameters.vertexStyles ? e.sort((i, n) => n.styleId - i.styleId) : e);
    f(this, "getStrictStyleId", (e) => {
      if (this.parameters.vertexStyles) {
        let {
          fontSize: i,
          fontWeight: n,
          lineWidth: o,
          fillStyle: r = [],
          strokeStyle: a = []
        } = e;
        return `${i}_${n}_${o}_${r[0]}_${r[1]}_${r[2]}_${r[3]}_${a[0]}_${a[1]}_${a[2]}_${a[3]}`;
      }
      return 0;
    });
    f(this, "updateRenderingData", () => {
      const e = this.engine.rendering.pixelRatio, i = this.engine.map.isGlobe, n = this.canvas, o = this.ctx, r = this._fontSize, a = this._fontFamily, g = this._fillStyle, c = this._padding, l = this.cachedData || [], h = Vw(l);
      l.length === 0 && (h.w = 1, h.h = 1);
      let d = h.w, C = h.h;
      n.width = d * e, n.height = C * e, o.save(), o.scale(e, e), o.textBaseline = "top", o.fillStyle = g, this._shouldStroke && (o.strokeStyle = this._strokeStyle, this._lineWidth > 0 && (o.lineWidth = this._lineWidth)), o.font = r + "px " + a, this.shadowColor && (o.shadowColor = this.shadowColor, o.shadowOffsetX = this.shadowOffsetX || 0, o.shadowOffsetY = this.shadowOffsetY || 0, o.shadowBlur = this.shadowBlur || 0);
      const p = [], m = [], b = [], S = [], A = [], u = [], y = [], I = [];
      let M = r, G = 1 / 0, x = 1 / 0, L = 1 / 0, E = -1 / 0, T = -1 / 0, R = -1 / 0;
      for (let V = 0; V < l.length; V++) {
        const N = l[V].position, [z, O, Q = 0] = N;
        z < G && (G = z), z > E && (E = z), O < x && (x = O), O > T && (T = O), Q < L && (L = Q), Q > R && (R = Q);
      }
      let w = (G + E) / 2, v = (x + T) / 2, D = (L + R) / 2;
      w = Number.isNaN(w) ? 0 : w, v = Number.isNaN(v) ? 0 : v, D = Number.isNaN(D) ? 0 : D;
      let K = [w, v, D], P = new J();
      for (let V = 0, N = l.length; V < N; ++V) {
        const z = l[V], O = this.getStrictStyleId(z);
        if (this.parameters.vertexStyles && Jr !== O) {
          Jr = O;
          let { fontWeight: fe, fontSize: be, fillStyle: pe, strokeStyle: Te, lineWidth: ge } = z;
          fe >= 10 && fe % 10 === 0 ? o.font = fe * 10 + " " + be + "px " + a : o.font = be + "px " + a, M = be, ge > 0 && (o.lineWidth = ge, o.strokeStyle = "rgba(" + Te.join(",") + ")"), o.fillStyle = "rgba(" + pe.join(",") + ")";
        }
        let Q = String(z.text).split("\\");
        for (let fe = 0; fe < Q.length; fe++)
          (this._shouldStroke || this.parameters.vertexStyles) && o.strokeText(Q[fe], z.x + c[0], z.y + c[1] + fe * M), o.fillText(Q[fe], z.x + c[0], z.y + c[1] + fe * M);
        let [U, $, ee = 0] = z.position;
        if (i) {
          P = Ze.eastNorthUpToFixedFrame(
            new B(U, $, ee),
            null,
            P
          ), P.elements[12] = 0, P.elements[13] = 0, P.elements[14] = 0;
          for (let fe = 0; fe < 4; fe++)
            for (let be = 0; be < 16; be++)
              I.push(P.elements[be]);
        }
        U -= K[0], $ -= K[1], ee -= K[2], p.push(
          U,
          $,
          ee,
          U,
          $,
          ee,
          U,
          $,
          ee,
          U,
          $,
          ee
        ), b.push(0, 1, 2, 3), A.push(
          z.w,
          z.h,
          z.w,
          z.h,
          z.w,
          z.h,
          z.w,
          z.h
        );
        const se = V * 4;
        S.push(
          se,
          se + 2,
          se + 1,
          se,
          se + 3,
          se + 2
        );
        const ie = z.x / d, Y = (z.x + z.w) / d, Ie = (z.y + z.h) / C, xe = z.y / C;
        m.push(
          ie,
          Ie,
          ie,
          xe,
          Y,
          xe,
          Y,
          Ie
        ), u.push(z.index, z.index, z.index, z.index), this.parameters.vertexRotateZs && y.push(z.rotateZ, z.rotateZ, z.rotateZ, z.rotateZ);
      }
      o.restore();
      const k = this.geometry;
      k.setAttribute("position", new ae(p, 3)), k.setAttribute("pIndex", new ae(b, 1)), k.setAttribute("wh", new ae(A, 2)), k.setAttribute("uv", new ae(m, 2)), i && k.setAttribute("instanceMatrix", new ae(I, 16)), this.parameters.vertexRotateZs && k.setAttribute("aRotateZ", new ae(y, 1)), k.setIndex(S), k.computeBoundingSphere(), this.makeMeshPositionOffset(K), p.length > 0 && (this.texture && this.texture.dispose(), this.texture = new ls(this.canvas), this.texture.minFilter = Gt, this.texture.magFilter = Gt, this.texture.generateMipmaps = !1, this.material.uniforms.map.value = this.texture), this.needsUpdate = !1, Jr = null;
    });
    this.parameters = e, this._fontSize = this.parameters.fontSize !== void 0 ? this.parameters.fontSize : 16, this._fontFamily = this.parameters.fontFamily !== void 0 ? this.parameters.fontFamily : "Microsoft Yahei", this._fillStyle = this.parameters.fillStyle !== void 0 ? this.parameters.fillStyle : "#ff0", this._padding = this.parameters.padding !== void 0 ? this.parameters.padding : [2, 2], this.strokeStyle = this.parameters.strokeStyle, this._lineWidth = this.parameters.lineWidth, this.isRenderInPostprocess = this.parameters.isRenderInPostprocess || !1, this.cachedData = [], this.drawingData = [];
    const i = this.canvas = document.createElement("canvas");
    i.width = i.height = 1;
    const n = this.ctx = i.getContext("2d");
    n.textAlign = "start", n.textBaseline = "top", this.defineMaterialProxyProperties([
      "lineHeight",
      "map",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "flat",
      "emissive",
      "keepSize"
    ]);
  }
  initObject() {
    let {
      padding: e,
      fillStyle: i,
      strokeStyle: n,
      lineWidth: o,
      fontSize: r,
      fontFamily: a,
      vertexStyles: g,
      ...c
    } = this.parameters;
    const l = this.engine.map.isGlobe;
    this.geometry = new Qe(this.parameters), this.material = new PQ(c), this.material.isGlobe = l, this.material.setCommonUniforms(this.engine.rendering.uniforms), this.texture = new ls(this.canvas), this.texture.minFilter = Gt, this.texture.magFilter = Gt, this.texture.generateMipmaps = !1, this.material.uniforms.map.value = this.texture;
  }
  _updateData() {
    this._enableCollision && this._collisionData ? (this.cachedData = this.sortByStyle(this._collisionData), Jr = null) : (this.cachedData = this.sortByStyle(this.dataSource.userData).map((e) => {
      let i = this.collisionTest(e);
      return {
        ...e,
        w: i.width,
        h: i.height
      };
    }), Jr = null), this.update();
  }
  onBeforeScenePrepareRenderHook(e, i, n) {
    const o = e.rendering.main.sceneRendering.depthTexture;
    this.material.uniforms.depthTexture.value = o, this.material.uniforms.cameraFar.value = e.rendering.camera.far;
  }
  update() {
    this.updateRenderingData();
  }
  collisionTest(e) {
    const i = this.ctx, n = this.engine.rendering.pixelRatio, o = this._fontSize, r = this._fontFamily, a = this._padding;
    i.save(), i.scale(n, n), i.textBaseline = "top";
    let g = "";
    if (this.parameters.vertexStyles) {
      let { text: S, fontWeight: A, fontSize: u, lineWidth: y } = e;
      g += `${S}_${u}_${A}_${y}`;
    } else
      g += `${e.text}_${o}`;
    if (this._collisionBoxCache[g])
      return this._collisionBoxCache[g];
    let c = o;
    const l = this.getStrictStyleId(e);
    if (this.parameters.vertexStyles && l !== Jr) {
      let { fontWeight: S, fontSize: A, lineWidth: u } = e;
      S >= 10 && S % 10 === 0 ? i.font = S * 10 + " " + A + "px " + r : i.font = A + "px " + r, c = A, u > 0 && (i.lineWidth = u);
    } else
      i.font = o + "px " + r;
    let h = String(e.text).split("\\");
    const d = h.map((S) => i.measureText(S).width);
    let C = Math.max(...d), p = c * h.length;
    const m = C + 2 * a[0], b = p + 2 * a[1];
    return i.restore(), this._collisionBoxCache[g] = {
      width: m,
      height: b
    }, {
      width: m,
      height: b
    };
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  getEntityByIndex(e) {
    const i = this.dataSource;
    this._enableCollision && this._collisionData && (e = this._collisionData[e].index);
    const n = {
      index: e,
      value: i.getDataItem(e),
      itemIndex: i.getDataItemIndex(e),
      pairs: {}
    }, o = i.data;
    for (const r of Object.keys(o))
      n.pairs[r] = o[r][e];
    return n;
  }
  raycast(e, i) {
    const n = this.flat;
    if (!this.visible || n)
      return;
    const o = this.geometry, r = o.getAttribute("position");
    if (!r || !r.array || !r.array.length === 0)
      return;
    let a = e.camera;
    a || (a = this.engine.camera);
    const g = e.mouse;
    if (!g)
      return;
    const c = this.material.uniforms.resolution.value, l = g.x, h = g.y;
    let d = [];
    const C = o.getAttribute("wh");
    C && (d = C.array);
    let p = 0, m = 0, b = 0, S = 0, A = 0, u = 0;
    ml.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), ml.multiplyMatrices(ml, this.matrixWorld);
    const y = r.array;
    let I = 0, M = 1;
    this.keepSize || (M = this.material.uniforms.zoomUnits.value);
    for (let G = 0, x = y.length - 11; G < x; G += 12)
      if (uo.set(
        y[G],
        y[G + 1],
        y[G + 2],
        1
      ), uo.applyMatrix4(ml), uo.divideScalar(uo.w), I = G / 12 * 8, A = d[I] / c.x, u = d[I + 1] / c.y, p = uo.x - A / M, b = uo.x + A / M, m = uo.y - u / M, S = uo.y + u / M, p <= l && b >= l && m <= h && S >= h) {
        MI.set(y[G], y[G + 1], y[G + 2]), MI.applyMatrix4(this.matrixWorld);
        const E = {
          instanceId: G / 12,
          object: this,
          distance: MI.distanceTo(a.position)
        };
        i.push(E);
      }
  }
  set fontSize(e) {
    this._fontSize !== e && (this._fontSize = e, this._collisionBoxCache = {}, this.needsUpdate = !0, this.engine.requestRender());
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this._collisionBoxCache = {}, this.needsUpdate = !0, this.engine.requestRender());
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fillStyle(e) {
    this._fillStyle = e, this.needsUpdate = !0, this.engine.requestRender();
  }
  get fillStyle() {
    return this._fillStyle;
  }
  set strokeStyle(e) {
    this._shouldStroke = !!e, this._strokeStyle = e, this.needsUpdate = !0, this.engine && this.engine.requestRender();
  }
  get strokeStyle() {
    return this._strokeStyle;
  }
  set lineWidth(e) {
    this._lineWidth = e, this.needsUpdate = !0, this.engine.requestRender();
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set padding(e) {
    this._padding !== e && (this._padding = e, this._collisionBoxCache = {}, this.needsUpdate = !0, this.engine.requestRender());
  }
  get padding() {
    return this._padding;
  }
}
const NQ = `#define GLSLIFY 1
#include <common>

uniform float positionOffsetX;
uniform float positionOffsetY;
uniform float pixelOffsetX;
uniform float pixelOffsetY;
uniform float positionOffsetZ;
uniform bool uFlat;

attribute float pIndex;
attribute vec4 iconFrame;
attribute vec2 wh;
attribute vec4 strokeStyle;
attribute vec3 fillStyle;
attribute vec4 sizeAndOffset;

#ifdef IS_ALIGN_ROTATE
attribute float verticalOffsets;
#endif

varying vec4 vStrokeStyle;
varying vec3 vFillStyle;
varying float vFontSize;

#ifdef IS_GLOBE
    attribute mat4 ecefMatrix;
#endif

#ifdef MVT_USE_VERTEX_ROTATEZ
    attribute float aRotateZ;
# else
    uniform float uRotateZ;
#endif

uniform float elapsedTime;
#ifdef MVT_ENABLE_FADE
    attribute float fadeOpacity;
    attribute float fadeSince;
    uniform float fadeDuration;
    varying float vFadeOpacity;
#endif

varying vec2 vUv;
#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>
#include <mvt_keepsize_pars_vertex>
#include <mvt_extra_vertex_utils>

vec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {
    float x = coord.x;
    float y = coord.y;
    if (corner == 1.0) {
        // \u5DE6\u4E0A
        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);
    } else if (corner == 2.0) {
        // \u53F3\u4E0A
        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);
        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else if (corner == 3.0) {
        // \u53F3\u4E0B
        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);
    } else {
        // \u5DE6\u4E0B
        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);
        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);
    }
    return vec3(x, y, coord.z);
}

void main() {
    #include <mvt_selective_vertex>
    // float x = position.x;
    // float y = position.y;
    vUv = uv;

    float rotateZ;
    #ifdef MVT_USE_VERTEX_ROTATEZ
        rotateZ = aRotateZ;
    # else
        rotateZ = uRotateZ;
    #endif

    mat4 currentInstanceMatrix = mat4(1.0);
    vec3 currentPosition = position;
    #ifdef IS_GLOBE
        currentInstanceMatrix = ecefMatrix;

        currentInstanceMatrix[3][0] = position.x;
        currentInstanceMatrix[3][1] = position.y;
        currentInstanceMatrix[3][2] = position.z;

        currentPosition = vec3(0.0, 0.0, 0.0);
    #endif

    float width = iconFrame.z;
    float height = iconFrame.w;
    float scale = sizeAndOffset.x / height;

    currentPosition.x += positionOffsetX;
    currentPosition.y += positionOffsetY;
    currentPosition.z += positionOffsetZ;
   vec4 worldPosition = (modelMatrix * currentInstanceMatrix * vec4(currentPosition, 1.0));
    if (uFlat) {
        // viewMatrix[0]\u8868\u793A\u76F8\u673A\u7684\u53F3\u65B9\u5411\uFF0C\u4E0D\u7BA1\u76F8\u673A\u5982\u4F55\u503E\u659Ctilt\uFF0C\u6CD5\u5411\u91CF\u90FD\u6307\u5411\u6B63\u5317\u65B9\u5411\uFF0C\u6B63\u597D\u53EF\u4EE5\u7528\u6765\u8BA1\u7B97\u548C\u6587\u5B57\u7684\u5939\u89D2
        mat4 localViewMatrix = viewMatrix * currentInstanceMatrix;
        vec4 right = localViewMatrix[0];
        float cosTheta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));

        float rotateOffset = 0.0;
        #ifdef IS_ALIGN_ROTATE
        // \u7528\u4E8E\u5224\u65AD\u65B9\u5411
        float sinTheta = sin(rotateZ) * right.x - cos(rotateZ) * -right.y;

        // [-\u03C0, \u03C0] + 0.25 PI
        float theta = atan(sinTheta, cosTheta) + PI * 0.25;
        if (theta < 0.0) {
            theta += 2.0 * PI;
        }

        float deg = degrees(theta);

        float isVertical = 0.0;
        // \u6839\u636E theta \u5212\u5206\u8C61\u9650
        if (deg >= 90.0 && deg < 180.0) {
            rotateOffset = -PI * 0.5;
            rotateZ += PI;
            isVertical = 1.0;
        } else if (deg >= 180.0 && deg < 270.0) {
            rotateZ += PI;
        } else if (deg >= 270.0){
            rotateOffset = -PI * 0.5;
            isVertical = 1.0;
        }
        #else
        if (cosTheta < 0.0) {
            rotateZ += PI;
        }
        #endif

        // TODO \u652F\u6301offset
        float hw = width * 0.5 * scale;
        float hh = height * 0.5 * scale;

        float pixelSize = 1.0;
        if (keepSize) {
            pixelSize = getPixelSize(worldPosition.xyz);
            // pixelSize = pixelSize * 2.0;
            hw = hw * pixelSize;
            hh = hh * pixelSize;

        }

        vec3 current = currentPosition;

        #ifdef IS_ALIGN_ROTATE
        float xOffset = isVertical == 1.0 ? ((verticalOffsets - sizeAndOffset.w) * pixelSize * scale) : sizeAndOffset.z * pixelSize * scale;
        float yOffset = isVertical == 1.0 ? 0.0 : sizeAndOffset.w * pixelSize * scale;
        #else
        float xOffset = sizeAndOffset.z * pixelSize * scale;
        float yOffset = sizeAndOffset.w * pixelSize * scale;
        #endif

        xOffset += pixelOffsetX * scale;
        yOffset += pixelOffsetY * scale;

        current = transformCoord(current, vec2(hw, hh), pIndex, -rotateZ + rotateOffset);
        current = transformCoord(current, vec2(xOffset, yOffset), 2.0, -rotateZ);

        gl_Position = projectionMatrix * modelViewMatrix * currentInstanceMatrix * vec4(current, 1.0);

        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    }
    else {
        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);
        vec4 pos = projectionMatrix * viewMatrix * worldPosition;
        float w = pos.w;
       
        vec3 screen = pos.xyz / w;

        float hw = width / resolution.x * scale;
        float hh = height / resolution.y * scale;

        float pixelSize = 1.0;
        if (!keepSize) {
            pixelSize = getPixelSize(worldPosition.xyz);
            pixelSize = pixelSize * 2.0;

            hw /= pixelSize;
            hh /= pixelSize;
        }

        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);
        current.x += sizeAndOffset.z * 2.0 / resolution.x * scale / pixelSize + pixelOffsetX / resolution.x;
        current.y += sizeAndOffset.w * 2.0 / resolution.y * scale / pixelSize + pixelOffsetY / resolution.y;
        gl_Position = vec4(current, 1.0);

        gl_Position *= w;
    }

    #ifdef MVT_ENABLE_FADE
        float fadeDiff = (elapsedTime - fadeSince) / fadeDuration;
        if (fadeOpacity > 2.0) {
            fadeDiff = clamp(fadeDiff, 0.0, 1.0);
            vFadeOpacity = fadeOpacity - fadeDiff - 2.0;
            vFadeOpacity = vFadeOpacity * vFadeOpacity;
        } else {
            vFadeOpacity = fadeOpacity + fadeDiff;
            vFadeOpacity = sqrt(vFadeOpacity);
        }
        vFadeOpacity = clamp(vFadeOpacity, 0.0, 1.0);
    #endif

    vStrokeStyle = strokeStyle;
    vFillStyle = fillStyle;

    vFontSize = sizeAndOffset.y;

    #include <logdepthbuf_vertex>
    // gl_PointSize = size * pixelRatio;
    // vSize = size;
    // vOffset = offset;
}`, FQ = `#define GLSLIFY 1
#include <common>

#define SDF_BUFFER 6.0
#define SDF_PX 8.0

uniform sampler2D map;
uniform vec4 backgroundColor;
uniform float opacity;
uniform float lineHeight;
uniform vec3 color;
uniform float sdfBuffer;
uniform float pixelRatio;
uniform float isHalo;
varying vec2 vUv;

varying vec4 vStrokeStyle;
varying vec3 vFillStyle;
varying float vgamma_scale;
varying float vFontSize;

#include <mvt_selective_pars_fragment>
#include <logdepthbuf_pars_fragment>

#ifdef MVT_ENABLE_FADE
    varying float vFadeOpacity;
#endif
void main() {
    #include <logdepthbuf_fragment>

    float fontScale = vFontSize / 24.0;
    float gamma = (0.105 / pixelRatio) / fontScale;
    float buff = (256.0 - 64.0) / 256.0;

    vec3 outColor = vFillStyle;

    if (isHalo > 0.0) {
        if (vStrokeStyle.w > 0.0) {
          outColor = vStrokeStyle.xyz;
          buff = (SDF_BUFFER - vStrokeStyle.w / fontScale) / SDF_PX;
        }
    }

    float distance = texture2D(map, vec2(vUv.x, vUv.y)).r;
    float alpha = smoothstep(buff - gamma, buff + gamma, distance);

    alpha = clamp(alpha * 1.5, 0.0, 1.0);

    gl_FragColor = vec4(outColor, alpha);

    #ifdef MVT_ENABLE_FADE
        gl_FragColor.a *= vFadeOpacity;
    #endif
    
    #include <mvt_selective_fragment> 
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}`, kQ = we.merge([
  Xt.fog,
  zn,
  Ho,
  {
    map: {
      value: null
    },
    pixelRatio: {
      value: 1
    },
    lineHeight: {
      value: 14
    },
    pixelOffsetX: {
      value: 0
    },
    pixelOffsetY: {
      value: 0
    },
    positionOffsetX: {
      value: 0
    },
    positionOffsetZ: {
      value: 0
    },
    positionOffsetY: {
      value: 0
    },
    backgroundColor: {
      value: [1, 1, 0, 0]
    },
    uFlat: {
      value: !1
    },
    opacity: {
      value: 1
    },
    isEmissive: {
      value: !1
    },
    uRotateZ: {
      value: 0
    },
    keepSize: {
      value: !0
    },
    outlineBuffer: {
      value: 0
    },
    outlineColor: {
      value: new Ce(0)
    },
    color: {
      value: new Ce(16777215)
    },
    sdfBuffer: {
      value: 0.75
    },
    gamma: {
      value: 0.1
    },
    isHalo: {
      value: 0
    },
    fadeDuration: {
      value: 300
    }
  }
]);
class wS extends di {
  constructor(t) {
    super(), this.name = "SDFTextMaterial", this.vertexShader = NQ, this.fragmentShader = FQ, this.isSDFTextMaterial = !0, this.transparent = !0, this.depthTest = !1, this.depthWrite = !1, Object.assign(this.uniforms, we.clone(kQ)), Po(this), Ka(this), oi(this, [
      "lineHeight",
      "pixelRatio",
      "map",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "isEmissive",
      "isHalo",
      "fadeDuration"
    ]), Js(this, [
      ["flat", "uFlat"],
      ["rotateZ", "uRotateZ"]
    ]), ri(this, [
      ["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"],
      ["isGlobe", "IS_GLOBE"],
      ["alignRotate", "IS_ALIGN_ROTATE"],
      ["enableFade", "MVT_ENABLE_FADE"]
    ]), No(this), Xn(this, [
      "color"
    ]), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
}
class VQ extends Os {
  constructor() {
    super(...arguments);
    f(this, "isGroup", !0);
  }
}
let _S;
const zQ = {
  center: 0,
  left: 1,
  right: -1
}, XQ = (s, t, e) => 0.2 * Math.tan(t / 2) * s / e * 10, WQ = new J(), EI = 2, ZQ = {
  fontSize: 24 * EI,
  buffer: 3 * EI,
  radius: 8 * EI
}, xS = new B(), qr = {
  fontSize: 16,
  fontWeight: "400",
  fillStyle: [1, 1, 0],
  strokeStyle: [0, 0, 0],
  lineWidth: 0
};
class XY extends VQ {
  constructor(e) {
    super(e);
    f(this, "frustumCulled", !0);
    f(this, "_needsUpdate", !1);
    f(this, "_enableFade", !1);
    f(this, "texture", null);
    f(this, "_padding", [0, 0]);
    f(this, "_characterSet", UH());
    f(this, "_collisionBoxCache", {});
    f(this, "_sdfTextureNeedUpdate", !1);
    f(this, "updateRenderingData", () => {
      const [e, i] = this.material.resolution || [], n = this.engine.map.isGlobe;
      let o = new J();
      if (isNaN(e) || e <= 0 || isNaN(i) || i <= 0) {
        console.warn("resolution is invalid");
        return;
      }
      const r = 1, a = "break-word", g = -1, c = [], l = [], h = [], d = [], C = [], p = [], m = [], b = [], S = [], A = [], u = [], y = [], I = [], {
        mapping: M,
        width: G,
        height: x
      } = this.fontAtalasManager.atlas || {};
      let L = [0], E = 0, T = null;
      for (let w = 0; w < this.cachedData.length; w++) {
        T = this.cachedData[w];
        const v = T.position;
        T.index;
        const D = T.text, K = T.textStyle, {
          fontSize: P = this._fontSize,
          fontWeight: k = this._fontWeight,
          lineWidth: V = this._lineWidth,
          strokeStyle: N = this._strokeStyle,
          fillStyle: z = this._fillStyle,
          rotateZ: O = 0,
          hOffset: Q = 0,
          vOffset: U = 0,
          offset: $ = [0, 0]
        } = K || {}, ee = Array.from(D).map((Ve) => Ve + k), se = this._letterSpacing * this._fontSettings.fontSize, {
          x: ie,
          y: Y,
          rowWidth: Ie,
          rowNum: xe,
          heightSize: fe,
          textHeights: be,
          size: [pe, Te]
        } = Nw(
          D,
          ee,
          r,
          a,
          g * P,
          M,
          se
        ), ge = ie.length;
        E = E + L[w];
        const lt = Array.from(D);
        let Ke = 0, Pe = 0;
        const nt = fe / 2;
        for (let Ve = 0; Ve < ge; Ve++) {
          const rt = lt[Ve];
          if (rt === "\\")
            continue;
          const on = M[rt + k];
          if (!on)
            return;
          if (n) {
            o = Ze.eastNorthUpToFixedFrame(
              xS.fromArray(v),
              null,
              o
            ), o.elements[12] = 0, o.elements[13] = 0, o.elements[14] = 0;
            for (let mi = 0; mi < 4; mi++)
              for (let Qt = 0; Qt < 16; Qt++)
                b.push(o.elements[Qt]);
          }
          if (h.push(0, 1, 2, 3), this.alignRotate) {
            const mi = be[Ve], Qt = Pe + mi / 2 - nt;
            Pe += mi, u.push(
              Qt,
              Qt,
              Qt,
              Qt
            );
          }
          const $e = (E + Ke) * 4;
          d.push(
            $e,
            $e + 2,
            $e + 1,
            $e,
            $e + 3,
            $e + 2
          ), c.push(
            ...v,
            ...v,
            ...v,
            ...v
          );
          let { x: st, y: ot, width: et, height: Je } = on;
          et += this._fontSettings.buffer * 2, l.push(
            st,
            ot,
            et,
            Je,
            st,
            ot,
            et,
            Je,
            st,
            ot,
            et,
            Je,
            st,
            ot,
            et,
            Je
          );
          const _n = st / G, xn = ot / x, vn = _n + et / G, nc = xn + Je / x;
          C.push(
            _n,
            nc,
            _n,
            xn,
            vn,
            xn,
            vn,
            nc
          );
          const Ad = (1 - zQ[this.textAlign]) * (pe - Ie[Ve]) / 2, Cd = $[0] * P + Q, fd = $[1] * P + U, Zn = (0 - 1) * pe / 2 + Ad + ie[Ve] + Cd, Un = Te / xe * (xe - 1) / 2 - Y[Ve] + fd, On = P * (Je / this._fontSettings.fontSize);
          if (A.push(
            On,
            P,
            Zn,
            Un,
            On,
            P,
            Zn,
            Un,
            On,
            P,
            Zn,
            Un,
            On,
            P,
            Zn,
            Un
          ), p.push(
            N[0],
            N[1],
            N[2],
            V,
            N[0],
            N[1],
            N[2],
            V,
            N[0],
            N[1],
            N[2],
            V,
            N[0],
            N[1],
            N[2],
            V
          ), m.push(
            z[0],
            z[1],
            z[2],
            z[0],
            z[1],
            z[2],
            z[0],
            z[1],
            z[2],
            z[0],
            z[1],
            z[2]
          ), this.parameters.vertexRotateZs && S.push(O, O, O, O), this._enableFade) {
            const mi = T.fadeOpacity || 1e-3, Qt = T.fadeSince || 0;
            y.push(mi, mi, mi, mi), I.push(Qt, Qt, Qt, Qt);
          }
          Ke++;
        }
        L.push(Ke);
      }
      const R = this.geometry;
      R.setAttribute("position", new ae(c, 3)), R.setAttribute("pIndex", new ae(h, 1)), R.setAttribute("sizeAndOffset", new ae(A, 4)), R.setAttribute("iconFrame", new ae(l, 4)), R.setAttribute("uv", new ae(C, 2)), R.setAttribute("strokeStyle", new ae(p, 4)), R.setAttribute("fillStyle", new ae(m, 3)), this.alignRotate && R.setAttribute("verticalOffsets", new ae(u, 1)), n && R.setAttribute("ecefMatrix", new ae(b, 16)), this.parameters.vertexRotateZs && R.setAttribute("aRotateZ", new ae(S, 1)), this._enableFade && (R.setAttribute("fadeOpacity", new ae(y, 1)), R.setAttribute("fadeSince", new ae(I, 1))), R.setIndex(d), R.computeBoundingSphere(), this.makeGeometryOffsetPosition(R, c), this.needsUpdate = !1, this._enableFade && (this.material[0].fadeDuration = this._fadeData.fadeDuration, this.material[1].fadeDuration = this._fadeData.fadeDuration);
    });
    f(this, "getStrictStyleId", (e) => {
      if (this.parameters.vertexStyles) {
        let {
          fontSize: i,
          fontWeight: n,
          lineWidth: o,
          fillStyle: r = [],
          strokeStyle: a = []
        } = e;
        return `${i}_${n}_${o}_${r[0]}_${r[1]}_${r[2]}_${a[0]}_${a[1]}_${a[2]}`;
      }
      return 0;
    });
    this.parameters = e, this._flat = W(this.parameters.flat, !1), this._fontSize = W(this.parameters.fontSize, qr.fontSize), this._fontWeight = W(this.parameters.fontWeight, qr.fontWeight), this._letterSpacing = W(this.parameters.letterSpacing, 0);
    const i = W(this.parameters.fillStyle, qr.fillStyle);
    Array.isArray(i) ? this._fillStyle = i : this._fillStyle = pi(i), this._lineWidth = W(this.parameters.lineWidth, qr.lineWidth), this.outlineWidth = W(this.parameters.lineWidth, qr.lineWidth);
    const n = W(this.parameters.strokeStyle, qr.strokeStyle);
    Array.isArray(n) ? this._strokeStyle = n : this._strokeStyle = pi(n), this._fontFamily = W(this.parameters.fontFamily, "Microsoft Yahei"), this._padding = W(this.parameters.padding, [2, 2]), this._margin = W(this.parameters.margin, [0, 0]), this.textAlign = W(this.parameters.textAlign, "center"), this.alignRotate = W(this.parameters.alignRotate, !1), this._enableFade = W(this.parameters.enableFade, !1), this.cachedData = [], this.shouldUpdateRenderingData = !1, this.drawingData = [], this._fadeData = new kw();
    const o = this.canvas = document.createElement("canvas");
    o.width = o.height = 1;
    const r = this.ctx = o.getContext("2d");
    r.textAlign = "start", r.textBaseline = "top", this.matrixAutoUpdate = !0;
  }
  initObject() {
    const {
      fillStyle: e,
      strokeStyle: i,
      fontFamily: n,
      vertexStyles: o,
      ...r
    } = this.parameters;
    this.geometry = new Qe(this.parameters);
    const a = new wS(r);
    a.setCommonUniforms(this.engine.rendering.uniforms), a.isHalo = 0, a.enableFade = this._enableFade;
    const g = new wS(r);
    g.setCommonUniforms(this.engine.rendering.uniforms), g.isHalo = 1, g.enableFade = this._enableFade, this.material = [a, g], this.defineMaterialProperties([
      "lineHeight",
      "pixelRatio",
      "map",
      "pixelOffsetX",
      "pixelOffsetY",
      "positionOffsetX",
      "positionOffsetY",
      "positionOffsetZ",
      "backgroundColor",
      "resolution",
      "opacity",
      "flat",
      "isGlobe",
      "alignRotate"
    ]), this.add(new le(this.geometry, g)), this.add(new le(this.geometry, a));
    const c = this.engine.map.isGlobe;
    this.material.isGlobe = c;
    const l = `${this.fontFamily} ${this._fontWeight}`;
    this.fontStack = l;
    const h = new Fw();
    this.fontAtalasManager = h;
  }
  onBeforeSceneRender(e, i, n, o) {
    super.onBeforeSceneRender(e, i, n, o), this._enableFade && !this._fadeData.isStable(o.elapsedTime) && e.requestRender();
  }
  update() {
    this.updateRenderingData();
  }
  updateSdfTexture() {
    if (this._sdfTextureNeedUpdate) {
      this._fontSettings = {
        fontFamily: this._fontFamily,
        fontWeight: "400",
        characterSet: this._characterSet,
        sdf: !0,
        ...ZQ
      }, this.fontAtalasManager.setProps(this._fontSettings);
      const {
        textureData: e,
        width: i,
        height: n
      } = this.fontAtalasManager.atlas;
      if (!this.texture) {
        const o = new Uint8Array(i * n);
        this.texture = new Ga(o, i, n), this.texture.minFilter = this.texture.magFilter = Gt, this.texture.format = Ps;
      }
      this.texture.image.data.set(e), this.texture.needsUpdate = !0, this.material.map = this.texture, this._sdfTextureNeedUpdate = !1;
    }
  }
  _updateData() {
    this._enableCollision && this._collisionData ? this.cachedData = this._collisionData : this.cachedData = this.dataSource.userData.map((a) => {
      let g = this.collisionTest(a);
      return {
        ...a,
        w: g.width,
        h: g.height
      };
    }), this._enableFade && (this._fadeData.update(this.cachedData, this.engine.rendering.uniforms.elapsedTime.value), this.cachedData = this._fadeData.data);
    let e = {};
    this.fontAtalasManager && this.fontAtalasManager.mapping && (e = this.fontAtalasManager.mapping);
    let i = /* @__PURE__ */ new Map(), n = !1;
    const o = this.cachedData, r = o.length;
    for (let a = 0; a < r; a++) {
      const g = o[a], c = g.text, l = g.textStyle || {}, h = {
        fontSize: W(l.fontSize, this._fontSize),
        fontWeight: W(l.fontWeight, this._fontWeight),
        lineWidth: W(l.lineWidth, this._lineWidth),
        fillStyle: W(l.fillStyle, this._fillStyle),
        strokeStyle: W(l.strokeStyle, this._strokeStyle)
      }, d = Array.from(c);
      for (let C = 0, p = d.length; C < p; C++) {
        const m = d[C], b = m + h.fontWeight;
        i.set(b, {
          char: m,
          textStyle: h
        }), e[b] || (n = !0);
      }
    }
    n && (this._sdfTextureNeedUpdate = !0, this._characterSet = i.values()), this.updateSdfTexture(this._characterSet), this.update();
  }
  _setupCanvas(e, i) {
    e.save(), e.scale(i, i), e.textBaseline = "top";
  }
  _calculateTransform(e, i) {
    return this.engine.map.isGlobe ? (i || (i = new J()), Ze.eastNorthUpToFixedFrame(xS.fromArray(e), null, i), i.extractRotation(i), i) : WQ;
  }
  _processTextStyle(e = {}) {
    return {
      fontSize: W(e.fontSize, this._fontSize),
      fontWeight: W(e.fontWeight, this._fontWeight),
      lineWidth: W(e.lineWidth, this._lineWidth),
      fillStyle: W(e.fillStyle, this._fillStyle),
      strokeStyle: W(e.strokeStyle, this._strokeStyle),
      rotateZ: W(e.rotateZ, 0)
    };
  }
  _generateCacheName(e, i) {
    let n = "";
    if (this._flat) {
      const r = e.position.join("_");
      n += r;
    }
    if (this.parameters.vertexStyles) {
      const { fontWeight: o, fontSize: r, lineWidth: a } = i;
      n += `${e.text}_${r}_${o}_${a}`;
    } else
      n += `${e.text}_${this._fontSize}`;
    return n;
  }
  _calculateRotation(e, i, n) {
    const o = new J();
    o.multiplyMatrices(e, i);
    const r = o.elements[0], a = o.elements[1], g = Math.sin(n), c = Math.cos(n);
    return g * -a + c * r;
  }
  _calculateCharInfo(e, i, n, o, r, a) {
    const c = i.measureText(e).width;
    return {
      char: e,
      width: c + 2 * a[0],
      height: n,
      offsetX: o + c / 2,
      offsetY: r
    };
  }
  _calculatePixelSize(e, i) {
    const o = this._rendering.renderState.cameraOffset;
    i.sub(o);
    const r = e.position.distanceTo(i), a = e.fov * Math.PI / 180, g = this._rendering.resolution.y;
    return XQ(r, a, g);
  }
  _processTextLayout(e, i, n) {
    const o = this.ctx, r = this._padding, a = String(e).split("\\"), c = -(i * a.length) / 2;
    return a.map((l, h) => {
      const d = [];
      let C = 0;
      for (let m = 0; m < l.length; m++) {
        const b = l[m], A = o.measureText(b).width;
        d.push({
          char: b,
          width: A,
          height: i,
          offsetX: 0,
          offsetY: -(c + i / 2 + h * i)
        }), C += A;
      }
      let p = -C / 2;
      for (let m = 0; m < d.length; m++) {
        const b = d[m];
        p += b.width / 2, b.offsetX = p, p += b.width / 2, b.width += 2 * r[0];
      }
      return d;
    });
  }
  _applyRotateZ(e, i, n) {
    const o = this.engine.camera.matrixWorld;
    return this._calculateRotation(o, n, i) < 0 && (i += Math.PI), e.map((a) => {
      const g = a.offsetX, c = a.offsetY;
      return {
        ...a,
        offsetX: g * Math.cos(i) - c * Math.sin(i),
        offsetY: g * Math.sin(i) + c * Math.cos(i)
      };
    });
  }
  collisionTest(e) {
    const i = this.ctx, n = this.engine.rendering.pixelRatio, o = this._fontSize, r = this._fontFamily, a = this._padding, g = this._processTextStyle(e.textStyle);
    this._setupCanvas(i, n);
    const c = this._generateCacheName(e, g);
    if (this._collisionBoxCache[c]) {
      const u = this._collisionBoxCache[c], y = u.chars;
      if (y) {
        const I = u.rotationMatrix, M = this._applyRotateZ(y, g.rotateZ, I);
        return {
          ...this._collisionBoxCache[c],
          chars: M
        };
      }
      return u;
    }
    let l = o;
    const h = this.getStrictStyleId(g);
    if (h === _S) {
      let { fontWeight: u, fontSize: y, lineWidth: I } = g;
      u >= 10 && u % 10 === 0 ? i.font = u * 10 + " " + y + "px " + r : i.font = y + "px " + r, l = y, I > 0 && (i.lineWidth = I);
    } else
      i.font = o + "px " + r, _S = h;
    if (this._flat) {
      const u = this._calculateTransform(e.position), I = this._processTextLayout(e.text, l, g).flat();
      return this._collisionBoxCache[c] = {
        chars: I,
        rotationMatrix: u
      }, {
        chars: this._applyRotateZ(I, g.rotateZ, u),
        rotationMatrix: u
      };
    }
    let C = String(e.text).split("\\");
    const p = C.map((u) => i.measureText(u).width);
    let m = Math.max(...p), b = l * C.length;
    const S = m + 2 * a[0], A = b + 2 * a[1];
    return i.restore(), this._collisionBoxCache[c] = {
      width: S,
      height: A
    }, {
      width: S,
      height: A
    };
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  set fontSize(e) {
    this._fontSize !== e && (this._fontSize = e, this._collisionBoxCache = {}, this._sdfTextureNeedUpdate = !0);
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this._collisionBoxCache = {}, this._sdfTextureNeedUpdate = !0);
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fillStyle(e) {
    this._fillStyle = e;
  }
  get fillStyle() {
    return this._fillStyle;
  }
  set padding(e) {
    this._padding !== e && (this._padding = e, this._collisionBoxCache = {});
  }
  get padding() {
    return this._padding;
  }
  set strokeStyle(e) {
    this._shouldStroke = !!e, this._strokeStyle = e;
  }
  get strokeStyle() {
    return this._strokeStyle;
  }
  get enableFade() {
    return this._enableFade;
  }
  set enableFade(e) {
    this._enableFade = e, this.material[0].enableFade = e, this.material[1].enableFade = e;
  }
  defineMaterialProperties(e = []) {
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      Object.defineProperty(this.material, n, {
        get: function() {
          return this && this[0][n];
        },
        set: function(o) {
          this.forEach((r) => {
            r[n] = o;
          });
        }
      });
    }
    this.defineMaterialProxyProperties(e);
  }
}
class UQ extends Os {
  constructor() {
    super(...arguments);
    f(this, "isLine", !0);
    f(this, "isLineSegments", !0);
  }
}
function OQ(s, t, e) {
  let i;
  return s.isVector3 ? i = s.distanceTo(t) : i = br(s, t), Math.ceil(i / e);
}
const QQ = [];
function YQ(s, t, e) {
  const i = QQ;
  i.length = s;
  let n = 0;
  if (t === e) {
    for (n = 0; n < s; n++)
      i[n] = t;
    return i;
  }
  const r = (e - t) / s;
  for (let a = 0; a < s; a++) {
    const g = t + a * r;
    i[a] = g;
  }
  return i;
}
const jQ = new B(), vS = new B();
function Tv(s, t) {
  const e = s.length, i = new Array(e);
  for (let n = 0; n < e; n++)
    vS.fromArray(s[n]), i[n] = t.cartesianToCartographic(vS, jQ).z;
  return i;
}
const JQ = new B(), qQ = new B(), $Q = new B(), TS = new B(), LS = new B();
new B();
const RI = new Lr();
new B();
new B();
new B();
function e9(s, t, e, i, n, o, r, a) {
  const g = i.scaleToGeodeticSurface(s, JQ), c = i.scaleToGeodeticSurface(t, qQ), l = OQ(s, t, e), h = i.cartesianToCartographic(g, $Q), d = i.cartesianToCartographic(c, TS), C = YQ(l, n, o);
  RI.setEndPoints(h, d);
  const p = RI.surfaceDistance / l;
  let m = a;
  h.z = n;
  let b = i.cartographicToCartesian(h, LS);
  b.toArray(r, m), m += 3;
  for (let S = 1; S < l; S++) {
    const A = RI.interpolateUsingSurfaceDistance(
      S * p,
      TS
    );
    A.z = C[S], b = i.cartographicToCartesian(A, LS), b.toArray(r, m), m += 3;
  }
  return m;
}
const t9 = new B(), i9 = new B(), GS = new B(), MS = new B(), ES = new B(), DI = new B(), KI = new B();
function n9(s, t, e) {
  let i;
  return s.isVector3 ? i = s.distanceTo(t) : i = br(s, t), Math.ceil(i / e);
}
const s9 = new B(), RS = new B();
function o9(s, t) {
  const e = s.length, i = new Array(e);
  for (let n = 0; n < e; n++)
    RS.fromArray(s[n]), i[n] = t.cartesianToCartographic(RS, s9).z;
  return i;
}
class r9 extends Qe {
  constructor(t) {
    super(t), this._granularity = t.granularity || X.RADIANS_PER_DEGREE, this._height = t.height || 0, this.parameters = t;
  }
  setData(t) {
    this._needsUpdate = !0, this.engine.map.isGlobe ? this.updateGeometry3D(t) : this.updateGeometryColumbus(t), this._needsUpdate = !1;
  }
  updateGeometryColumbus(t) {
    const { vertexColors: e } = this.parameters, i = [], n = [], o = [], r = [];
    let a = 0;
    for (let g = 0; g < t.position.length; g++) {
      const c = t.position[g], l = t.index[g];
      for (let h = 0; h < c.length - 1; h++) {
        const d = c[h], C = c[h + 1];
        if (i.push(
          d[0],
          d[1],
          d[2],
          C[0],
          C[1],
          C[2]
        ), r.push(a, a + 1), n.push(l, l), e && t.color) {
          let p = pi(t.color[g]);
          o.push(p[0], p[1], p[2], p[3]), o.push(p[0], p[1], p[2], p[3]);
        }
        a += 2;
      }
    }
    this.cachedPositions = i, this.setAttribute("position", new ae(i, 3)), this.setAttribute("objectIndex", new ae(n, 1)), e && this.setAttribute("color", new ae(o, 4)), this.setIndex(r);
  }
  updateGeometry3D(t) {
    const { vertexColors: e } = this.parameters, i = [], n = [], o = [], r = [];
    let a = 0;
    const g = this._granularity, c = this.engine.map.map.ellipsoid || De.WGS84, l = X.chordLength(
      g,
      c.maximumRadius
    );
    for (let h = 0; h < t.position.length; h++) {
      const d = t.position[h], C = t.index[h], p = t.color && t.color[h], m = o9(d, c).map((A) => A + this._height), b = this.generateArc({
        positions: d,
        minDistance: l,
        ellipsoid: c,
        height: m
      }), S = b.length / 3;
      for (let A = 0; A < S - 1; A++) {
        if (i.push(
          b[A * 3],
          b[A * 3 + 1],
          b[A * 3 + 2],
          b[(A + 1) * 3],
          b[(A + 1) * 3 + 1],
          b[(A + 1) * 3 + 2]
        ), n.push(C, C), r.push(a, a + 1), e && p) {
          let u = pi(p);
          o.push(u[0], u[1], u[2], u[3]), o.push(u[0], u[1], u[2], u[3]);
        }
        a += 2;
      }
    }
    this.cachedPositions = i, this.setAttribute("position", new ae(i, 3)), this.setAttribute("objectIndex", new ae(n, 1)), e && this.setAttribute("color", new ae(o, 4)), this.setIndex(r);
  }
  generateArc(t) {
    t || (t = {});
    const e = t.positions, i = e.length, n = t.ellipsoid || De.WGS84;
    let o = t.height || 0;
    const r = Array.isArray(o);
    if (i < 1)
      return [];
    if (i === 1) {
      MS.fromArray(e[0]);
      const b = n.scaleToGeodeticSurface(MS, t9);
      if (o = r ? o[0] : o, o !== 0) {
        const S = n.geodeticSurfaceNormal(b, GS);
        _.multiplyByScalar(S, o, S), _.add(b, S, b);
      }
      return [b.x, b.y, b.z];
    }
    let a = t.minDistance;
    H(a) || (a = X.chordLength(this._granularity, n.maximumRadius));
    let g = 0, c;
    for (let b = 0; b < i - 1; b++)
      g += n9(e[b], e[b + 1], a);
    const l = (g + 1) * 3, h = new Array(l);
    let d = 0;
    const C = new B();
    for (c = 0; c < i - 1; c++) {
      DI.fromArray(e[c]), KI.fromArray(e[c + 1]), C.crossVectors(DI, KI).normalize();
      const b = r ? o[c] : o, S = r ? o[c + 1] : o;
      d = e9(
        DI,
        KI,
        a,
        n,
        b,
        S,
        h,
        d
      );
    }
    ES.set(...e[i - 1]);
    const p = n.cartesianToCartographic(ES, i9);
    return p.z = r ? o[i - 1] : o, n.cartographicToCartesian(p, GS).toArray(h, d), d += 3, h;
  }
}
class WY extends UQ {
  constructor(e) {
    super(e);
    f(this, "geometry");
    f(this, "material");
    f(this, "color");
    this.parameters = e, this.defineGeometryProxyProperties([
      "granularity"
    ]), this.defineMaterialColorProxyProperties([
      "color"
    ]);
  }
  initObject() {
    this.geometry = new r9(this.parameters), this.geometry.engine = this.engine, this.material = new _r(this.parameters);
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.needsUpdate = !1;
  }
}
class a9 extends Qe {
  constructor() {
    super(...arguments);
    f(this, "_volumeSegmentLines", (e, i, n, o, r, a, g, c, l, h, d) => {
      let C = 0, p = new Z();
      const m = [g[0], g[1]], b = [a[0], a[1]];
      let S = cA(b, m);
      if (d && (p = Ks(S), this._volumeExtrusions(e, i, o, n, a, p, l)), !c)
        p = Ks(S), this._volumeExtrusions(e, i, o, n, g, p, l), C += 2;
      else {
        const A = [c[0], c[1]];
        let u = cA(m, A), y = new Z();
        y.addVectors(S, u), y.normalize();
        const I = Jw(S, u), M = Ks(S), G = Math.min(l, l / I.dot(M));
        this._volumeExtrusions(e, i, o, n, g, I, G), C += 2;
      }
      return C;
    });
    f(this, "_volumeExtrusions", (e, i, n, o, r, a, g) => {
      n.push(a.x, a.y, 0, -a.x, -a.y, 0), e.push(r[0] + a.x * g / 2, r[1] + a.y * g / 2, r[2]), i.push(r[0] - a.x * g / 2, r[1] - a.y * g / 2, r[2]), o.push(g, g);
    });
  }
  createVolumeGeometry(e, i) {
    let n = this.parameters.lineWidth * i, o = [];
    for (let r = 0; r < e.length; r++) {
      const { vertices: a } = this.lineToShadowVolumeMesh(e[r], n);
      o.push([a]);
    }
    return o;
  }
  lineToShadowVolumeMesh(e, i) {
    let n = 0, o = null, r = null, a = null, g = null;
    const c = [], l = [], h = [], d = [], C = [], p = [];
    let m = !0;
    for (let A = 1, u = e.length - 1; A <= u; A++) {
      if (o = g || e[A - 1], r = e[A], a = e[A + 1], a && DC(r, a)) {
        g = o;
        continue;
      }
      const y = this._volumeSegmentLines(
        C,
        p,
        d,
        l,
        h,
        o,
        r,
        a,
        i,
        n,
        m
      );
      y !== -1 && (n += y, g = null), m = !1;
    }
    const b = this.conversion(C, 3), S = this.conversion(p, 3);
    return c.push(...b.concat(S.reverse())), c.push(c[0]), {
      vertices: c,
      indices: h,
      normals: l,
      widths: d
    };
  }
  conversion(e, i) {
    let n = e.length, o = n % i === 0 ? n / i : Math.floor(n / i + 1), r = [];
    for (let a = 0; a < o; a++) {
      let g = e.slice(a * i, a * i + i);
      r.push(g);
    }
    return r;
  }
}
const DS = new B(), g9 = new B(), c9 = new B(), l9 = new B(), yl = new B(), HI = new B(), Mn = new B(), Ts = new B(), Ls = new B(), hg = new B(), $r = new B(), h9 = new B();
new B();
const KS = new B(), HS = new B(), ea = new Lr();
function PS(s, t, e) {
  let i;
  return s.isVector3 ? i = s.distanceTo(t) : i = br(s, t), Math.ceil(i / e);
}
const d9 = [], u9 = (s, t, e) => {
  const i = d9;
  i.length = s;
  let n = 0;
  if (t === e) {
    for (n = 0; n < s; n++)
      i[n] = t;
    return i;
  }
  const r = (e - t) / s;
  for (let a = 0; a < s; a++) {
    const g = t + a * r;
    i[a] = g;
  }
  return i;
};
function I9(s, t, e) {
  return e.copy(s).sub(t), e.normalize(), e;
}
function NS(s, t, e, i) {
  return I9(s, t, i), i.cross(e).normalize(), i.cross(e).normalize(), i;
}
const A9 = 0, C9 = new B(), f9 = new B(), p9 = new B();
function m9(s, t, e, i, n) {
  const o = NS(
    s,
    t,
    i,
    f9
  ), r = NS(e, t, i, p9);
  n.copy(o).add(r).normalize();
  const a = C9.copy(i).cross(n), g = r.dot(a) < A9;
  return g && n.negate(), {
    miter: n,
    isFlip: g
  };
}
const Sl = new B(), ta = new B(), PI = new B();
class y9 extends a9 {
  constructor(e) {
    super();
    f(this, "isFatLineGeometry", !0);
    f(this, "_segmentLines", (e, i, n, o, r, a, g, c, l, h, d, C, p, m, b, S, A) => {
      let u = 0, y = new Z(), I = new Z(), M = new Z();
      const G = this.parameters.lineCap === "square", x = this.parameters.lineCap === "round", L = this.parameters.lineJoin === "bevel", E = this.parameters.lineJoin === "round", T = [d[0], d[1]], R = [h[0], h[1]];
      let w = this.getFlatDirection(R, T), v = 0;
      this._needsCounter && (v = br(d, h), this._flags.totalDistance += v), this._flags.normal || (this._flags.normal = new Z(), this._flags.normal = Ks(w));
      let D = 1, K = -1, P, k, V;
      if (!this._flags.started)
        if (this._flags.started = !0, P = this._flags.totalDistance - v, V = this._flags.totalDistance, k = P - v, G) {
          const N = new Z(), z = new Z();
          N.addVectors(this._flags.normal, w), z.subVectors(this._flags.normal, w), g.push(
            z.x,
            z.y,
            0,
            -N.x,
            -N.y,
            0
          ), e.push(
            h[0],
            h[1],
            h[2],
            h[0],
            h[1],
            h[2]
          );
          const O = [d[0] - h[0], d[1] - h[1], d[2] - h[2]];
          b.push(
            h[0] + O[0],
            h[1] + O[0],
            h[2] + O[0],
            h[0] + O[0],
            h[1] + O[0],
            h[2] + O[0]
          ), S.push(
            d[0],
            d[1],
            d[2],
            d[0],
            d[1],
            d[2]
          ), i.push(
            this._flags.totalDistance - v,
            0,
            this._flags.totalDistance - v,
            1
          ), n.push(
            P,
            P
          ), o.push(
            k,
            V,
            k,
            V
          ), a.push(
            p,
            K,
            p,
            K
          ), r.push(0, 0), this.parameters.vertexColors && c.push(
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3]
          );
        } else if (x) {
          const N = w.clone();
          N.negate();
          const z = new Z();
          z.subVectors(this._flags.normal, w), z.normalize();
          const O = new Z();
          O.addVectors(this._flags.normal, w), O.normalize();
          const Q = this._flags.normal.clone(), U = this._flags.normal.clone();
          U.negate(), g.push(N.x, N.y, 0), g.push(z.x, z.y, 0), g.push(-O.x, -O.y, 0), g.push(Q.x, Q.y, 0), g.push(U.x, U.y, 0);
          const $ = [d[0] - h[0], d[1] - h[1], d[2] - h[2]];
          for (let ee = 0; ee < 5; ee++)
            e.push(h[0], h[1], h[2]), b.push(h[0] + $[0], h[1] + $[1], h[2] + $[2]), S.push(d[0], d[1], d[2]), a.push(p, K), i.push(this._flags.totalDistance - v, 0), n.push(P), o.push(k, V), r.push(0), this.parameters.vertexColors && c.push(m[0], m[1], m[2], m[3]);
          l.push(
            A + 0,
            A + 2,
            A + 1,
            A + 1,
            A + 2,
            A + 3,
            A + 3,
            A + 2,
            A + 4
          ), u += 3, A += 3;
        } else
          this._extrusions(
            e,
            g,
            i,
            n,
            o,
            r,
            a,
            c,
            h,
            h,
            d,
            this._flags.normal,
            P,
            k,
            V,
            p,
            K,
            !0,
            m,
            b,
            S
          );
      if (l.push(
        ...this._flags.lastFlip === -1 ? [A + 0, A + 1, A + 2] : [A + 1, A + 0, A + 2]
      ), P = this._flags.totalDistance, k = this._flags.totalDistance - v, !C)
        V = P + v;
      else {
        const N = br(d, C);
        V = P + N;
      }
      if (C) {
        const N = [C[0], C[1]];
        I = this.getFlatDirection(T, N), M.addVectors(w, I), M.normalize();
        const z = Jw(w, I), O = Ks(w), Q = p / z.dot(O);
        let U = M.dot(this._flags.normal) > 0 ? -1 : 1, $ = L;
        if (!$ && this.parameters.lineJoin === "miter" && Math.abs(Q) > (this.parameters.miterLimit || p * 2) && ($ = !0), $) {
          const ee = Math.min(p * 2, Math.abs(Q));
          g.push(this._flags.normal.x * U, this._flags.normal.y * U, 0), g.push(-z.x * U, -z.y * U, 0), e.push(
            d[0],
            d[1],
            d[2],
            d[0],
            d[1],
            d[2]
          ), b.push(
            h[0],
            h[1],
            h[2],
            h[0],
            h[1],
            h[2]
          ), S.push(
            C[0],
            C[1],
            C[2],
            C[0],
            C[1],
            C[2]
          ), a.push(
            p,
            D,
            ee,
            D
          ), n.push(
            P,
            P
          ), o.push(
            k,
            V,
            k,
            V
          ), r.push(0, 0), l.push(
            ...this._flags.lastFlip === -U ? this._flags.lastFlip === -1 ? [A + 2, A + 1, A + 3] : [A + 1, A + 2, A + 3] : this._flags.lastFlip === -1 ? [A + 0, A + 2, A + 3] : [A + 2, A + 0, A + 3]
          ), y = Ks(I), this._flags.normal.copy(y), g.push(this._flags.normal.x * U, this._flags.normal.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(p, D), n.push(P), o.push(k, V), r.push(0), g.push(-z.x * U, -z.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(ee, K), n.push(P), o.push(k, V), r.push(0), g.push(this._flags.normal.x * U, this._flags.normal.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(
            p,
            K
          ), n.push(P), o.push(k, V), r.push(0), l.push(
            ...U === 1 ? [A + 2, A + 3, A + 4] : [A + 3, A + 2, A + 4]
          ), this._flipedUV(i, this._flags.totalDistance, U, !0), this.parameters.vertexColors && c.push(
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3]
          ), u += 5;
        } else if (E) {
          const ee = Math.min(p * 2, Math.abs(Q));
          g.push(this._flags.normal.x * U, this._flags.normal.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(
            p,
            D
          ), n.push(P), o.push(k, V), r.push(0), g.push(z.x * U, z.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(
            p,
            D
          ), n.push(P), o.push(k, V), r.push(0), g.push(z.x * U, z.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(
            p,
            K
          ), n.push(P), o.push(k, V), r.push(0), g.push(-z.x * U, -z.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(ee, D), n.push(P), o.push(k, V), r.push(0), g.push(-z.x * U, -z.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(ee, K), n.push(P), o.push(k, V), r.push(0), l.push(
            ...this._flags.lastFlip === -U ? this._flags.lastFlip === -1 ? [A + 2, A + 1, A + 5, A + 2, A + 5, A + 3] : [A + 1, A + 2, A + 5, A + 5, A + 2, A + 3] : this._flags.lastFlip === -1 ? [A + 0, A + 2, A + 5, A + 2, A + 3, A + 5] : [A + 2, A + 0, A + 5, A + 3, A + 2, A + 5]
          ), y = Ks(I), this._flags.normal.copy(y), g.push(this._flags.normal.x * U, this._flags.normal.y * U, 0), e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(C[0], C[1], C[2]), a.push(p, K), n.push(P), o.push(k, V), r.push(0), l.push(
            ...U === -1 ? [A + 6, A + 4, A + 7] : [A + 4, A + 6, A + 7]
          ), this._flipedUV(i, this._flags.totalDistance, U, !1), this.parameters.vertexColors && c.push(
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3]
          ), u += 6;
        } else
          this._extrusions(
            e,
            g,
            i,
            n,
            o,
            r,
            a,
            c,
            d,
            h,
            C,
            z,
            P,
            k,
            V,
            Q,
            D,
            !1,
            m,
            b,
            S
          ), this._extrusions(
            e,
            g,
            i,
            n,
            o,
            r,
            a,
            c,
            d,
            h,
            C,
            z,
            P,
            k,
            V,
            Q,
            K,
            !1,
            m,
            b,
            S
          ), l.push(
            ...this._flags.lastFlip === -1 ? [A + 2, A + 1, A + 3] : [A + 2, A + 0, A + 3]
          ), U = -1, this._flags.normal.copy(z), u += 4;
        this._flags.lastFlip = U;
      } else {
        if (this._flags.normal = Ks(w), G) {
          const N = new Z(), z = new Z();
          N.addVectors(w, this._flags.normal), z.subVectors(w, this._flags.normal), g.push(
            N.x,
            N.y,
            0,
            z.x,
            z.y,
            0
          ), e.push(
            d[0],
            d[1],
            d[2],
            d[0],
            d[1],
            d[2]
          ), b.push(
            h[0],
            h[1],
            h[2],
            h[0],
            h[1],
            h[2]
          );
          const O = [d[0] - h[0], d[1] - h[1], d[2] - h[2]];
          S.push(
            d[0] + O[0],
            d[1] + O[1],
            d[2] + O[2],
            d[0] + O[0],
            d[1] + O[1],
            d[2] + O[2]
          ), a.push(p, D, p, D), i.push(
            this._flags.totalDistance,
            0,
            this._flags.totalDistance,
            1
          ), n.push(
            P,
            P
          ), o.push(
            k,
            V,
            k,
            V
          ), r.push(0, 0), this.parameters.vertexColors && c.push(
            m[0],
            m[1],
            m[2],
            m[3],
            m[0],
            m[1],
            m[2],
            m[3]
          );
        } else
          this._extrusions(
            e,
            g,
            i,
            n,
            o,
            r,
            a,
            c,
            d,
            h,
            C,
            this._flags.normal,
            P,
            k,
            V,
            p,
            D,
            !1,
            m,
            b,
            S
          );
        if (l.push(
          ...this._flags.lastFlip === -1 ? [A + 2, A + 1, A + 3] : [A + 2, A + 0, A + 3]
        ), u += 2, x) {
          const N = new Z();
          N.addVectors(w, this._flags.normal), N.normalize();
          const z = new Z();
          z.subVectors(w, this._flags.normal), z.normalize();
          const O = w.clone();
          g.push(N.x, N.y, 0), g.push(z.x, z.y, 0), g.push(O.x, O.y, 0);
          const Q = d[0] + (d[0] - h[0]), U = d[1] + (d[1] - h[1]), $ = d[2] + (d[2] - h[2]);
          for (let ee = 0; ee < 3; ee++)
            e.push(d[0], d[1], d[2]), b.push(h[0], h[1], h[2]), S.push(Q, U, $), a.push(p, D), i.push(this._flags.totalDistance, 0), n.push(P), o.push(
              k,
              V,
              k,
              V
            ), r.push(0), this.parameters.vertexColors && c.push(m[0], m[1], m[2], m[3]);
          l.push(
            A + 2,
            A + 3,
            A + 4,
            A + 4,
            A + 3,
            A + 5,
            A + 4,
            A + 5,
            A + 6
          ), u += 3;
        }
      }
      return u;
    });
    f(this, "_extrusions", (e, i, n, o, r, a, g, c, l, h, d, C, p, m, b, S, A, u, y, I, M) => {
      if (i.push(
        C.x,
        C.y,
        0,
        -C.x,
        -C.y,
        0
      ), e.push(
        l[0],
        l[1],
        l[2],
        l[0],
        l[1],
        l[2]
      ), u) {
        const G = [d[0] - l[0], d[1] - l[1], d[2] - l[2]];
        I.push(
          h[0] - G[0],
          h[1] - G[1],
          h[2] - G[2],
          h[0] - G[0],
          h[1] - G[1],
          h[2] - G[2]
        );
      } else
        I.push(
          h[0],
          h[1],
          h[2],
          h[0],
          h[1],
          h[2]
        );
      if (d)
        M.push(
          d[0],
          d[1],
          d[2],
          d[0],
          d[1],
          d[2]
        );
      else {
        const G = [l[0] - h[0], l[1] - h[1], l[2] - h[2]];
        M.push(
          l[0] + G[0],
          l[1] + G[1],
          l[2] + G[2],
          l[0] + G[0],
          l[1] + G[1],
          l[2] + G[2]
        );
      }
      g.push(
        S,
        A,
        S,
        A
      ), n.push(p, 0, p, 1), o.push(p, p), r.push(m, b, m, b), a.push(0, 0), this.parameters.vertexColors && c.push(
        y[0],
        y[1],
        y[2],
        y[3],
        y[0],
        y[1],
        y[2],
        y[3]
      );
    });
    this.parameters = e, this._granularity = e.granularity || X.RADIANS_PER_DEGREE, this._needsUpdate = !1, this._needsCounter = !1, this._height = e.height || 0, this._flags = {
      lastFlip: -1,
      started: !1,
      normal: null,
      totalDistance: 0
    };
  }
  setData(e) {
    this._needsUpdate = !0, this.cachedData = e, (this.parameters.dashed || this.parameters.enableAnimation || this.parameters.mapSrc || this.parameters.map) && (this._needsCounter = !0), this.updateGeometry(), this._needsUpdate = !1;
  }
  updateGeometryColumbus(e) {
    const i = [], n = [], o = [], r = [], a = [], g = [], c = [], l = [], h = [], d = [], C = [], p = [], m = [], b = [];
    let S = 0;
    for (let A = 0; A < e.position.length; A++) {
      const u = lA(e.position[A]), y = e.index[A], I = this.parameters.vertexWidths ? e.lineWidth[A] : this.parameters.lineWidth, M = this.parameters.vertexColors ? pi(e.color[A]) : [1, 1, 1, 1];
      this._flags = {
        lastFlip: -1,
        started: !1,
        normal: null,
        totalDistance: 0
      };
      const G = u.length;
      let x = i.length / 3, L = Math.random();
      C.push(L, L), o.push(0, 0), p.push(y, y);
      for (let E = 1; E < G; E++) {
        const T = u[E - 1], R = u[E], w = E < G - 1 ? u[E + 1] : null, v = this._segmentLines(
          i,
          n,
          g,
          c,
          d,
          a,
          h,
          l,
          r,
          T,
          R,
          w,
          I,
          M,
          m,
          b,
          x
        );
        v !== -1 && (x += v);
        for (let D = 0; D < v; D++)
          o.push(E / G), this._needsCounter && this.parameters.enableAnimationChaos && C.push(L), p.push(y);
        S = Math.max(this._flags.totalDistance, S);
      }
      if (this._needsCounter)
        for (let E = 0; E < d.length; E++)
          d[E] = S;
    }
    this.cachedPositions = i, this.cachedPrevs = m, this.cachedNexts = b, this.setAttribute("position", new ae(i, 3)), this.setAttribute("prev", new ae(m, 3)), this.setAttribute("next", new ae(b, 3)), this.setAttribute("uv", new ae(n, 2)), this.setAttribute("normal", new ae(h, 3)), this.setAttribute("expandAndPrev", new ae(a, 2)), this.setAttribute("counter", new ae(o, 1)), this.setAttribute("objectIndex", new ae(p, 1)), this._needsCounter && (this.setAttribute("lengths", new ae(g, 1)), this.setAttribute("totalLength", new ae(d, 1)), this.setAttribute("prevAndNextLength", new ae(c, 2)), this.setAttribute("randomFactor", new ae(C, 1))), this.parameters.vertexColors && this.setAttribute("aColor", new ae(l, 4)), this.setIndex(r), this.computeBoundingSphere();
  }
  updateGeometry3D(e) {
    const i = [], n = [], o = [], r = [], a = [], g = [], c = [], l = [], h = [], d = [], C = [], p = [], m = this._granularity, b = this.engine.map.map.ellipsoid || De.WGS84, S = X.chordLength(
      m,
      b.maximumRadius
    );
    let A = 0;
    const u = this.parameters.vertexColors;
    let y = 0;
    for (let M = 0, G = e.position.length; M < G; M++) {
      const x = [];
      let L = lA(e.position[M]);
      const E = e.index[M], T = this.parameters.vertexWidths ? e.lineWidth[M] : this.parameters.lineWidth, R = this.parameters.vertexColors ? pi(e.color[M]) : [1, 1, 1, 1], w = Tv(L, b).map(($) => $ + this._height), {
        positions: v,
        normals: D,
        lengths: K,
        randoms: P,
        totalLength: k,
        prevs: V,
        nexts: N,
        expandAndPrevs: z,
        prevAndNextLengths: O,
        uvs: Q
      } = this.generateArc({
        positions: L,
        indices: o,
        minDistance: S,
        ellipsoid: b,
        height: w,
        width: T,
        bevelIndices: x
      });
      y = Math.max(y, k);
      const U = v.length / 3;
      for (let $ = 0; $ < U; $ += 4) {
        o.push(A + $, A + $ + 1, A + $ + 2), o.push(A + $ + 2, A + $ + 1, A + $ + 3);
        const ee = $ + 4;
        x.includes(ee) && (o.push(A + $ + 2, A + $ + 3, A + ee), $++);
      }
      A += U, i.push(...v), g.push(...D), d.push(...V), h.push(...N), n.push(...Q), p.push(...O), C.push(...z), l.push(...new Array(K.length).fill(E)), u && a.push(...new Array(K.length).fill(R).flat()), this._needsCounter && (r.push(...K), this.parameters.enableAnimationChaos && c.push(...P));
    }
    let I;
    this._needsCounter && (I = new Array(i.length / 3).fill(y)), this.cachedPositions = i, this.setAttribute("position", new ae(i, 3)), this.setAttribute("prev", new ae(d, 3)), this.setAttribute("next", new ae(h, 3)), this.setAttribute("expandAndPrev", new ae(C, 2)), this.setAttribute("normal", new ae(g, 3)), this.setAttribute("objectIndex", new ae(l, 1)), this.setAttribute("uv", new ae(n, 2)), this.setAttribute("prevAndNextLength", new ae(p, 2)), u && this.setAttribute("aColor", new ae(a, 4)), this._needsCounter && this.setAttribute("totalLength", new ae(I, 1)), this.setIndex(o);
  }
  updateGeometry() {
    const e = this.cachedData;
    this.engine.map.isGlobe ? this.updateGeometry3D(e) : this.updateGeometryColumbus(e);
  }
  getFlatDirection(e, i) {
    return DC(e, i) ? this._flags.normal ? new Z(this._flags.normal.y, -this._flags.normal.x) : new Z(1, 0) : cA(e, i);
  }
  generateArc(e) {
    e || (e = {});
    const i = e.positions, n = e.indices, o = e.bevelIndices || [], r = i.length, a = e.ellipsoid || De.WGS84, g = e.width || 1;
    let c = e.height || 0;
    const l = Array.isArray(c);
    if (r < 1)
      return [];
    if (r === 1) {
      const Q = a.scaleToGeodeticSurface(i[0], DS);
      if (c = l ? c[0] : c, c !== 0) {
        const U = a.geodeticSurfaceNormal(Q, Mn);
        _.multiplyByScalar(U, c, U), _.add(Q, U, Q);
      }
      return [Q.x, Q.y, Q.z];
    }
    let h = e.minDistance;
    H(h) || (h = X.chordLength(this._granularity, a.maximumRadius));
    let d = 0;
    for (let Q = 0; Q < r - 1; Q++)
      d += PS(i[Q], i[Q + 1], h);
    const C = r - 2, p = d * 2 + C, m = p, b = p * 2, S = p * 3, A = new Array(S), u = new Array(S), y = new Array(m), I = new Array(m), M = new Array(S), G = new Array(S), x = new Array(b), L = new Array(b), E = new Array(b), T = new Array(m);
    let R = 0, w = 0;
    const v = new B(), D = new B();
    let K;
    const P = {
      lastFlip: !1,
      curFlip: !1
    }, k = {
      last: 0,
      next: 0
    }, V = new B(), N = new B();
    let z;
    for (let Q = 0; Q < r - 1; Q++) {
      if (Sl.fromArray(i[Q]), ta.fromArray(i[Q + 1]), v.crossVectors(Sl, ta).normalize(), Q < r - 2) {
        De.WGS84.geodeticSurfaceNormal(ta, V), PI.fromArray(i[Q + 2]), D.crossVectors(ta, PI).normalize();
        const { isFlip: Ie } = m9(Sl, ta, PI, V, N);
        z = N, P.curFlip = !Ie;
      } else
        z = v;
      const U = K || v;
      k.last = Math.min(g * 2, g / U.dot(v)), k.next = Math.min(g * 2, Math.abs(g / z.dot(v)));
      const $ = l ? c[Q] : c, ee = l ? c[Q + 1] : c, se = Q < r - 2, ie = this.generateCartesianArc(
        Sl,
        ta,
        h,
        a,
        $,
        ee,
        A,
        M,
        G,
        R,
        v,
        D,
        z,
        U,
        k,
        P,
        u,
        g,
        y,
        x,
        w,
        se,
        o,
        L,
        T
      );
      R = ie.index;
      const Y = ie.surfaceDistance;
      w += Y, K || (K = h9), z && K.copy(z), P.lastFlip = P.curFlip;
    }
    const O = Math.random();
    I.fill(O);
    for (let Q = 0; Q < T.length; Q++) {
      let U, $, ee = Q - 1;
      for (; ee >= 0 && T[ee] === T[Q]; )
        ee--;
      let se = Q + 1;
      for (; se < T.length && T[se] === T[Q]; )
        se++;
      ee < 0 ? U = 0 : U = y[ee], se >= T.length ? $ = y[y.length - 1] : $ = y[se], E[Q * 2] = U, E[Q * 2 + 1] = $;
    }
    return {
      positions: A,
      normals: u,
      lengths: y,
      randoms: I,
      totalLength: w,
      prevs: M,
      nexts: G,
      expandAndPrevs: x,
      prevAndNextLengths: E,
      uvs: L,
      indices: n
    };
  }
  generateCartesianArc(e, i, n, o, r, a, g, c, l, h, d, C, p, m, b, S, A, u, y, I, M, G, x, L, E) {
    const T = o.scaleToGeodeticSurface(e, DS), R = o.scaleToGeodeticSurface(i, g9), w = PS(e, i, n), v = o.cartesianToCartographic(T, c9), D = o.cartesianToCartographic(R, l9), K = u9(w, r, a), { lastFlip: P, curFlip: k } = S;
    ea.setEndPoints(v, D);
    const V = ea.surfaceDistance / w;
    let N = h;
    v.z = r, D.z = a;
    const z = KS.copy(d).negate(), O = m ? HS.copy(m).negate() : void 0, Q = b.last, U = b.next;
    let $ = d, ee = z, se = u, ie = u;
    P ? (ee = O, ie = Q) : ($ = m || d, se = Q);
    let Y = N / 3, Ie = o.cartographicToCartesian(v, Mn);
    if (Ie.toArray(g, N), $.toArray(A, N), y[Y] = M, L[Y * 2] = M, L[Y * 2 + 1] = 0, I[Y * 2] = se, I[Y * 2 + 1] = -1, E[Y] = 1, N += 3, Y = N / 3, Ie.toArray(g, N), ee.toArray(A, N), I[Y * 2] = ie, I[Y * 2 + 1] = -1, y[Y] = M, L[Y * 2] = M, L[Y * 2 + 1] = 1, E[Y] = 1, N += 3, w > 1) {
      const pe = ea.interpolateUsingSurfaceDistance(
        V,
        HI
      );
      pe.z = K[1], o.cartographicToCartesian(pe, Ts);
    } else
      o.cartographicToCartesian(D, Ts);
    Ls.subVectors(Mn, Ts), Ls.add(Mn), Ls.toArray(c, h), Ls.toArray(c, h + 3), Ts.toArray(l, h), Ts.toArray(l, h + 3);
    let xe;
    for (let pe = 1; pe < w; pe++)
      xe ? yl.copy(HI) : ea.interpolateUsingSurfaceDistance(
        pe * V,
        yl
      ), w === pe + 1 ? xe = D : (xe = ea.interpolateUsingSurfaceDistance(
        (pe + 1) * V,
        HI
      ), xe.z = K[pe + 1]), yl.z = K[pe], hg.copy(Mn), Ie = o.cartographicToCartesian(yl, Mn), o.cartographicToCartesian(xe, $r), Y = N / 3, Ie.toArray(g, N), d.toArray(A, N), I[Y * 2] = u, I[Y * 2 + 1] = 1, hg.toArray(c, N), $r.toArray(l, N), y[Y] = M + pe * V, L[Y * 2] = M + pe * V, L[Y * 2 + 1] = 0, E[Y] = -1, N += 3, Y = N / 3, Ie.toArray(g, N), z.toArray(A, N), I[Y * 2] = u, I[Y * 2 + 1] = 1, hg.toArray(c, N), $r.toArray(l, N), y[Y] = M + pe * V, L[Y * 2] = M + pe * V, L[Y * 2 + 1] = 1, E[Y] = -1, N += 3, Y = N / 3, Ie.toArray(g, N), d.toArray(A, N), I[Y * 2] = u, I[Y * 2 + 1] = -1, hg.toArray(c, N), $r.toArray(l, N), y[Y] = M + pe * V, L[Y * 2] = M + pe * V, L[Y * 2 + 1] = 0, E[Y] = 1, N += 3, Y = N / 3, Ie.toArray(g, N), z.toArray(A, N), I[Y * 2] = u, I[Y * 2 + 1] = -1, hg.toArray(c, N), $r.toArray(l, N), y[Y] = M + pe * V, L[Y * 2] = M + pe * V, L[Y * 2 + 1] = 1, E[Y] = 1, N += 3;
    const fe = ea.surfaceDistance;
    Ls.subVectors(Mn, $r), Ls.add(Mn), o.cartographicToCartesian(D, Ts);
    const be = p ? HS.copy(p).negate() : void 0;
    return $ = d, ee = z, se = u, ie = u, G && (k ? (ee = be || d, ie = U) : ($ = p || d, se = U)), Y = N / 3, Ts.toArray(g, N), $.toArray(A, N), y[Y] = M + fe, I[Y * 2] = se, I[Y * 2 + 1] = 1, L[Y * 2] = M + fe, L[Y * 2 + 1] = 0, Mn.toArray(c, N), Ls.toArray(l, N), E[Y] = -1, N += 3, Y = N / 3, Ts.toArray(g, N), ee.toArray(A, N), y[Y] = M + fe, I[Y * 2] = ie, I[Y * 2 + 1] = 1, Mn.toArray(c, N), Ls.toArray(l, N), L[Y * 2] = M + fe, L[Y * 2 + 1] = 1, E[Y] = -1, N += 3, G && (Y = N / 3, x.push(Y), Ts.toArray(g, N), k ? C.toArray(A, N) : KS.copy(C).negate().toArray(A, N), y[Y] = M + fe, I[Y * 2] = u, I[Y * 2 + 1] = 1, L[Y * 2] = M + fe, L[Y * 2 + 1] = 1, E[Y] = -1, Mn.toArray(c, N), Ls.toArray(l, N), N += 3), {
      index: N,
      surfaceDistance: fe,
      lastLength: V
    };
  }
  _flipedUV(e, i, n, o) {
    o ? n === -1 ? e.push(i, 1, i, 0, i, 1, i, 0, i, 1) : e.push(i, 0, i, 1, i, 0, i, 1, i, 0) : n === -1 ? e.push(i, 1, i, 1, i, 1, i, 0, i, 0, i, 1) : e.push(i, 0, i, 0, i, 0, i, 1, i, 1, i, 0);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
new B();
new B();
const FS = new J(), NI = new yt(), bl = new Bn(), S9 = new J();
class ZY extends Fo {
  constructor(e) {
    super();
    f(this, "isEventEntitySupported", !0);
    f(this, "_resolution", new Z());
    f(this, "geometry");
    f(this, "material");
    f(this, "lineJoin");
    f(this, "lineCap");
    f(this, "miterLimit");
    f(this, "keepSize");
    f(this, "color");
    f(this, "vertexColors");
    f(this, "mapSrc");
    f(this, "opacity");
    f(this, "alphaTest");
    f(this, "dashed");
    f(this, "dashArray");
    f(this, "dashOffset");
    f(this, "dashRatio");
    f(this, "enableAnimation");
    f(this, "enableAnimationChaos");
    f(this, "animationSpeed");
    f(this, "animationTailType");
    f(this, "animationTailRatio");
    f(this, "animationTailLength");
    f(this, "animationIdle");
    f(this, "makeGeometryOffsetPosition", (e) => {
      if (!this._enableRtc)
        return;
      const i = e.boundingSphere && e.boundingSphere.center;
      if (!i) {
        this._cachedRtc = [0, 0, 0], this.updateTransform();
        return;
      }
      const { x: n, y: o, z: r } = i, a = e.cachedPositions, g = e.cachedPrevs, c = e.cachedNexts;
      this.makePostionArrayOffset(e.attributes.position.array, n, o, r, a), e.attributes.prev && this.makePostionArrayOffset(e.attributes.prev.array, n, o, r, g), e.attributes.next && this.makePostionArrayOffset(e.attributes.next.array, n, o, r, c), this.geometry.computeBoundingSphere(), this._cachedRtc = [n, o, r], this.updateTransform();
    });
    this.parameters = e, this.parameters.lineJoin = this.parameters.lineJoin || "bevel", this.defineGeometryProxyProperties([
      "lineJoin",
      "lineCap",
      "miterLimit"
    ]), this.defineMaterialProxyProperties([
      "antialias",
      "map",
      "mapSrc",
      "mapGap",
      "height",
      "keepSize",
      "transparent",
      "opacity",
      "alphaTest",
      "dashed",
      "dashArray",
      "dashOffset",
      "dashRatio",
      "enableAnimation",
      "enableAnimationChaos",
      "animationInterval",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "color",
      "vertexColors",
      "vertexWidths",
      "emissive",
      "keepDashLength"
    ]);
  }
  getDefaultParams() {
    return {
      lineWidth: 4
    };
  }
  initObject() {
    const { lineJoin: e, lineCap: i, ...n } = this.parameters, o = this.geometry = new y9(this.parameters);
    o.engine = this.engine, n.enablePrevAndNext = !0, (this.material = new bg(n)).setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.makeGeometryOffsetPosition(this.geometry), this.needsUpdate = !1;
  }
  afterGeometryUpdate() {
    this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
  }
  computeViewportTransformation(e, i, n, o) {
    const r = e.x || 0, a = e.y || 0, g = e.width || 0, c = e.height || 0;
    i = i || 0, n = n || 1;
    const l = g * 0.5, h = c * 0.5, d = (n - i) * 0.5, C = l, p = h, m = d, b = r + l, S = a + h, A = i + d, u = 1, y = o.elements;
    return y[0] = C, y[1] = 0, y[2] = 0, y[3] = 0, y[4] = 0, y[5] = p, y[6] = 0, y[7] = 0, y[8] = 0, y[9] = 0, y[10] = m, y[11] = 0, y[12] = b, y[13] = S, y[14] = A, y[15] = u, o;
  }
  onBeforeScenePrepareRenderHook() {
    const { x: e, y: i } = this.engine.rendering.uniforms.resolution.value;
    (this._resolution.x !== e || this._resolution.y !== i) && (this.material.uniforms.viewportTransform.value.copy(this.computeViewportTransformation({
      width: this.engine.rendering.uniforms.resolution.value.x,
      height: this.engine.rendering.uniforms.resolution.value.y
    }, 0, 1, S9)), this._resolution.set(e, i)), this.material.uniforms.cameraNear.value = this.engine.camera.near, this.material.uniforms.cameraFar.value = this.engine.camera.far, this.material.uniforms.fovY.value = this.engine.camera.fov / 180 * Math.PI, this.material.uniforms.fovX.value = this.material.uniforms.fovY.value * this.engine.camera.aspect;
  }
  get lineWidth() {
    return this.parameters.lineWidth;
  }
  set lineWidth(e) {
    this.parameters.lineWidth = e, this.needsUpdate = !0, this.engine.requestRender();
  }
  raycast(e, i) {
    if (!this.visible)
      return;
    const n = this.geometry, o = this.matrixWorld, r = e.params.Line.threshold, a = n.drawRange;
    let g = this.lineWidth / 2;
    if (this.material.keepSize && (g *= this.material.uniforms.zoomUnits.value), n.boundingSphere === null && n.computeBoundingSphere(), bl.copy(n.boundingSphere), bl.applyMatrix4(o), bl.radius += g, e.ray.intersectsSphere(bl) === !1)
      return;
    FS.copy(o).invert(), NI.copy(e.ray).applyMatrix4(FS);
    const c = g / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = c * c, h = new B(), d = new B(), C = new B(), p = new B(), m = 2;
    if (n.isBufferGeometry) {
      const b = n.index, S = n.attributes, A = S.position, u = S.objectIndex;
      if (b !== null) {
        const y = Math.max(0, a.start), I = Math.min(b.count, a.start + a.count);
        for (let M = y, G = I - 1; M < G; M += m) {
          const x = b.getX(M), L = b.getX(M + 1);
          if (h.fromBufferAttribute(A, x), d.fromBufferAttribute(A, L), NI.distanceSqToSegment(h, d, p, C) > l)
            continue;
          p.applyMatrix4(this.matrixWorld);
          const T = e.ray.origin.distanceTo(p);
          T < e.near || T > e.far || i.push({
            distance: T,
            point: C.clone().applyMatrix4(this.matrixWorld),
            index: u.getX(x),
            face: null,
            faceIndex: null,
            object: this
          });
        }
      } else {
        const y = Math.max(0, a.start), I = Math.min(A.count, a.start + a.count);
        for (let M = y, G = I - 1; M < G; M += m) {
          if (h.fromBufferAttribute(A, M), d.fromBufferAttribute(A, M + 1), NI.distanceSqToSegment(h, d, p, C) > l)
            continue;
          p.applyMatrix4(this.matrixWorld);
          const L = e.ray.origin.distanceTo(p);
          L < e.near || L > e.far || i.push({
            distance: L,
            point: C.clone().applyMatrix4(this.matrixWorld),
            index: M,
            face: null,
            faceIndex: null,
            object: this
          });
        }
      }
    }
    e.params.Line.threshold = r;
  }
}
const Io = new B(), b9 = new B(), B9 = new B(), w9 = new B(), _9 = new B();
new B();
const x9 = new B(), v9 = new B(), T9 = new B(), L9 = [], G9 = (s, t, e, i) => (_.subtract(t, s, Io), _.multiplyByScalar(
  Io,
  e / i,
  Io
), _.add(s, Io, Io), [Io.x, Io.y, Io.z]), M9 = [], E9 = (s, t, e) => {
  const i = M9;
  i.length = s;
  let n = 0;
  if (t === e) {
    for (n = 0; n < s; n++)
      i[n] = t;
    return i;
  }
  const r = (e - t) / s;
  for (let a = 0; a < s; a++) {
    const g = t + a * r;
    i[a] = g;
  }
  return i;
}, kS = (s, t, e) => {
  const i = s.distanceTo(t);
  return Math.ceil(i / e);
};
class R9 extends Qe {
  constructor(e) {
    super();
    f(this, "isWallGeometry", !0);
    f(this, "_needsUpdate", !1);
    f(this, "isClockWise", (e) => {
      let i = e.length, n = 0;
      for (let o = i - 1, r = 0; r < i; o = r++)
        n += e[o][0] * e[r][1] - e[r][0] * e[o][1];
      return n < 0;
    });
    f(this, "subdivideLine", (e, i, n, o, r, a) => {
      const g = kS(e, i, n), c = e.distanceTo(i), l = c / g;
      r || (r = []), a || (a = []);
      const h = new B(), d = new B(), C = o.cartesianToCartographic(e, d).z, p = o.cartesianToCartographic(i, d).z, m = E9(g, C, p), b = w9;
      let S = _9, A = x9, u = 0;
      for (let y = 0; y < g; y++) {
        const I = h.fromArray(G9(e, i, l * y, c));
        o.geodeticSurfaceNormal(I, b), A = o.scaleToGeodeticSurface(I, A), S = _.multiplyByScalar(b, m[y], S), S = _.add(A, S, S), a[u] = S.x, a[u + 1] = S.y, a[u + 2] = S.z, S = _.multiplyByScalar(b, m[y] + this._height, S), S = _.add(A, S, S), r[u] = S.x, r[u + 1] = S.y, r[u + 2] = S.z, u += 3;
      }
      return o.geodeticSurfaceNormal(i, b), A = o.scaleToGeodeticSurface(i, A), S = _.multiplyByScalar(b, p, S), S = _.add(A, S, S), a[u] = S.x, a[u + 1] = S.y, a[u + 2] = S.z, S = _.multiplyByScalar(b, p + this._height, S), S = _.add(A, S, S), r[u] = S.x, r[u + 1] = S.y, r[u + 2] = S.z, {
        topPositions: r,
        bottomPositions: a
      };
    });
    this._height = e.height || 100, this.parameters = e;
  }
  setData(e) {
    this._needsUpdate = !0, this.cachedData = e, this.updateGeometry();
  }
  computeWallGeometry3D(e, i, n, o) {
    let r, a, g, c, l, h = e.length;
    const d = X.chordLength(
      n,
      i.maximumRadius
    );
    let C = 0;
    for (g = 0; g < h - 1; g++)
      C += kS(
        e[g],
        e[(g + 1) % h],
        d
      );
    const p = C + h - 1;
    a = p * 3, r = new Array(a * 2);
    const m = [], b = [];
    for (g = 0; g < h - 1; g++) {
      c = e[g], l = e[(g + 1) % h];
      const {
        topPositions: R,
        bottomPositions: w
      } = this.subdivideLine(
        c,
        l,
        d,
        i
      );
      m.push(...w), b.push(...R);
    }
    r = [
      ...m,
      ...m
    ], h = r.length;
    let S = [], A = 0;
    for (h /= 6, g = 0; g < h - 1; g++) {
      const R = g, w = R + 1, v = R + h, D = v + 1;
      c = b9.fromArray(r, R * 3), l = B9.fromArray(r, w * 3), !_.equalsEpsilon(
        c,
        l,
        X.EPSILON10,
        X.EPSILON10
      ) && (S[A++] = R + o, S[A++] = v + o, S[A++] = w + o, S[A++] = w + o, S[A++] = v + o, S[A++] = D + o);
    }
    r = [
      ...b,
      ...m
    ], h = b.length / 3;
    const u = [];
    u.length = r.length;
    const y = [];
    y.length = h * 4;
    let I = new B(), M = new B(), G = new B();
    new B();
    let x = !0, L = new B();
    const E = [];
    let T = 0;
    for (g = 0; g < p; g++) {
      I.fromArray(b, g * 3), G.fromArray(b, (g + 1) * 3);
      let R = g * 2, w = (g + a / 3) * 2;
      if (G.x === void 0) {
        y[R] = T, y[R + 1] = 1, y[w] = T, y[w + 1] = 0;
        continue;
      }
      E.push(I.distanceTo(G)), y[R] = T, y[R + 1] = 1, y[w] = T, y[w + 1] = 0, T += E[g];
    }
    for (g = 0; g < p; g++) {
      if (I.fromArray(b, g * 3), M.fromArray(m, g * 3), G.fromArray(b, (g + 1) * 3), (_.equalsEpsilon(
        I,
        G,
        X.EPSILON10
      ) || g === p - 1) && (x = !1), x) {
        const v = _.subtract(
          G,
          I,
          T9
        ), D = _.subtract(
          M,
          I,
          v9
        );
        L = _.normalize(
          _.cross(D, v, L),
          L
        ), E.push(I.distanceTo(G));
      }
      let R = g * 3, w = g * 3 + a;
      u[R] = L.x, u[R + 1] = L.y, u[R + 2] = L.z, u[w] = L.x, u[w + 1] = L.y, u[w + 2] = L.z, x = !0;
    }
    return {
      edgePositions: r,
      edgeIndices: S,
      edgeNormals: u,
      edgeUvs: y,
      totalDistance: Array.from({ length: p * 2 }, () => T)
    };
  }
  updateGeometry3D() {
    let e = this.cachedData;
    const i = this.engine.map.map.ellipsoid || De.WGS84, n = [], o = [], r = [], a = [], g = [];
    let c = 0, l = 0, h = e.position.length;
    for (c = 0; c < h; c++) {
      const d = e.position[c];
      this.parameters.vertexColors && pi(e.color[c]);
      const C = d.map((G) => new B().fromArray(G));
      let m = Sr.fromPoints(C, i).projectPointsOntoPlane(
        C,
        L9
      );
      this.isClockWise(m.map((G) => G.toArray())) && C.reverse();
      const S = X.RADIANS_PER_DEGREE, {
        edgePositions: A,
        edgeIndices: u,
        edgeNormals: y,
        edgeUvs: I,
        totalDistance: M
      } = this.computeWallGeometry3D(C, i, S, l);
      n.push(...A), o.push(...u), r.push(...y), a.push(...I), g.push(...M), l += A.length / 3;
    }
    this.cachedPositions = n, this.setAttribute("position", new ae(n, 3)), this.setAttribute("normal", new ae(r, 3)), this.setAttribute("uv", new ae(a, 2)), this.setAttribute("totalDistance", new ae(g, 1)), this.setIndex(o);
  }
  updateGeometryColumbus() {
    let e = this.cachedData;
    const i = [], n = [], o = [], r = [], a = [], g = [], c = [];
    for (let l = 0; l < e.position.length; l++) {
      const h = e.position[l];
      e.index[l];
      const d = this.parameters.vertexColors ? pi(e.color[l]) : [1, 1, 1, 1], C = this.parameters.vertexHeights ? e.height[l] : this._height;
      let p = 0;
      const m = h.length;
      let b = i.length / 3;
      for (let S = 0; S < m; S++) {
        const A = h[S], u = [h[S][0], h[S][1], h[S][2] + C], y = S < m - 1 ? h[S + 1] : null;
        if (!(y && DC(A, y)) && (i.push(...A, ...u), g.push(...d, ...d), o.push(S / (m - 1), S / (m - 1)), a.push(p, p), n.push(p, 0, p, 1), S < m - 1)) {
          p += br(A, y);
          let I = b + 2 * S;
          r.push(
            I + 1,
            I + 2,
            I,
            I + 3,
            I + 2,
            I + 1
          );
        }
      }
      for (let S = 0; S < m; S++)
        c.push(p, p);
      b += m * 2;
    }
    this.cachedPositions = i, this.setAttribute("position", new ae(i, 3)), this.setAttribute("uv", new ae(n, 2)), this.setAttribute("counter", new ae(o, 1)), this.setAttribute("distances", new ae(a, 1)), this.setAttribute("totalDistance", new ae(c, 1)), this.parameters.vertexColors && this.setAttribute("aColor", new ae(g, 4)), this.setIndex(r);
  }
  updateGeometry() {
    this.engine.map.isGlobe ? this.updateGeometry3D() : this.updateGeometryColumbus(), this.computeBoundingSphere(), this._needsUpdate = !1;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e;
  }
}
const D9 = `#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>

#ifdef MVT_USE_VERTEX_COLOR
    attribute vec4 aColor;
#else
    uniform vec3 color;
#endif

attribute float counter;
attribute float totalDistance;
attribute float distances;

uniform float elapsedTime;
uniform bool vertexColors;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

uniform vec2 mapScale;

#ifdef USE_ANIMATION
uniform float animationSpeed;
uniform float animationTailType;
varying float vAnimationTailType;
uniform float animationTailRatio;
uniform float animationTailLength;
uniform float animationIdle;
varying float vAnimationOpacity;
#endif

void main() {

    #ifdef MVT_USE_VERTEX_COLOR
        vColor = aColor;
    #else
        vColor = vec4(color, 1.0);
    #endif

    vUV = uv / mapScale;
    vCounter = counter;
    vDistance = distances;
    vTotalDistance = totalDistance;

    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

    #ifdef USE_ANIMATION
        if (animationTailType < 3.0) {
            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;
            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);
            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;
        }
        else if (animationTailType == 3.0) {
            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;
        } 
        else if (animationTailType == 4.0) {
            vAnimationTailType = animationTailType;
        }
    #endif

    #include <beginnormal_vertex>
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    #include <fog_vertex>

    #include <logdepthbuf_vertex>
}`, K9 = `#define GLSLIFY 1
#include <common>
#include <bsdfs>
#include <fog_pars_fragment>

#include <logdepthbuf_pars_fragment>
varying vec3 vLightFront;
varying vec3 vIndirectFront;

uniform sampler2D map;
uniform bool useMap;
uniform float minOpacity;
uniform float maxOpacity;
uniform float opacity;
uniform float elapsedTime;

varying vec2 vUV;
varying vec4 vColor;
varying float vCounter;
varying float vDistance;
varying float vTotalDistance;

#ifdef USE_ANIMATION
uniform float animationRatio;
uniform float animationBales;
uniform float animationSpeed;
varying float vAnimationOpacity;
varying float vAnimationTailType;
#endif

void main() {

    vec4 c = vColor;

    if(useMap) {
        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));
        c *= texture;
    }

    #ifdef USE_ANIMATION
        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {
            c.a = 0.0;
        }

        if(vAnimationTailType == 4.) {
            float ratio = animationRatio;
            float bales = animationBales;
            if(animationRatio > 1.) {
                ratio = 1.;
            }
            if(animationRatio < .0) {
                ratio = .0;
            }
            if(animationBales < 1.) {
                bales = 1.;
            }
            if(mod((vUV.y - elapsedTime * animationSpeed * .0001), 1./bales) < ratio / bales) {
                c.a = (1. - vUV.y) * maxOpacity;
            } else {
                c.a = minOpacity;
            }
        } else {
            c.a *= vAnimationOpacity;
        }
    #endif

    gl_FragColor = c;
    gl_FragColor.a *= opacity;

    if (maxOpacity > minOpacity) {
        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);
    }
    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #include <fog_fragment>
    #include <logdepthbuf_fragment>
}`, H9 = new Ot(), P9 = we.merge([
  Xt.fog,
  zn,
  Ho,
  {
    map: { value: null },
    mapScale: { value: [1, 1] },
    useMap: { value: !1 },
    color: { value: [0, 1, 1] },
    minOpacity: { value: 0 },
    maxOpacity: { value: 1 },
    opacity: { value: 1 },
    vertexColors: { value: !1 },
    elapsedTime: { value: 0 },
    enableAnimation: { value: !1 },
    animationSpeed: { value: 1 },
    animationTailType: { value: 3 },
    animationTailRatio: { value: 0.2 },
    animationTailLength: { value: 100 },
    animationIdle: { value: 1e3 },
    animationRatio: { value: 0.5 },
    animationBales: { value: 5 },
    isEmissive: { value: !1 }
  }
]);
class N9 extends di {
  constructor(t) {
    super(), this.name = "WallMaterial", this.isWallMaterial = !0, this.fog = !0, this.side = xr, this.forceSinglePass = !1, this.fragmentShader = K9, this.vertexShader = D9, Object.assign(this.uniforms, we.clone(P9)), oi(this, [
      "map",
      "minOpacity",
      "maxOpacity",
      "opacity",
      "elapsedTime",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "animationBales",
      "animationRatio",
      "isEmissive"
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["enableAnimation", "USE_ANIMATION"]
    ]), No(this), Object.defineProperties(this, {
      mapSrc: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          const i = this.mapSrc, n = "url_map";
          if (this.userData[n] === e)
            return;
          if (i && i.dispose(), !e) {
            this.uniforms.map.value = null, this.uniforms.useMap.value = !1, delete this.userData[n];
            return;
          }
          const r = H9.load(e);
          r.wrapS = r.wrapT = ii, r.colorSpace = gt, this.uniforms.map.value = r, this.userData[n] = e, this.uniforms.useMap.value = !0;
        }
      },
      mapScale: {
        get: function() {
          return this.uniforms.map.value;
        },
        set: function(e) {
          typeof e == "number" ? this.uniforms.mapScale.value = [e, e] : this.uniforms.mapScale.value = e;
        }
      }
    }), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
class UY extends Fo {
  constructor(e) {
    super();
    f(this, "geometry");
    f(this, "material");
    f(this, "height");
    f(this, "color");
    f(this, "vertexColors");
    f(this, "map");
    f(this, "opacity");
    f(this, "minOpacity");
    f(this, "maxOpacity");
    f(this, "enableAnimation");
    f(this, "animationSpeed");
    f(this, "animationTailType");
    f(this, "animationTailRatio");
    f(this, "animationTailLength");
    f(this, "animationIdle");
    f(this, "animationRatio");
    f(this, "animationBales");
    this.parameters = e, this.defineGeometryUpdateProxyProperties([
      "height"
    ]), this.defineMaterialProxyProperties([
      "color",
      "vertexColors",
      "emissive",
      "map",
      "mapScale",
      "transparent",
      "opacity",
      "minOpacity",
      "maxOpacity",
      "enableAnimation",
      "animationSpeed",
      "animationTailType",
      "animationTailRatio",
      "animationTailLength",
      "animationIdle",
      "animationBales",
      "animationRatio"
    ]);
  }
  getDefaultParams() {
    return {
      height: 100
    };
  }
  initObject() {
    const { height: e, ...i } = this.parameters, n = this.geometry = new R9(this.parameters);
    n.engine = this.engine, (this.material = new N9(i)).setCommonUniforms(this.engine.rendering.uniforms);
  }
  _updateData() {
    const e = this.dataSource.data;
    this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.needsUpdate = !1;
  }
}
var cr = { exports: {} };
cr.exports = ud;
cr.exports.default = ud;
function ud(s, t, e) {
  e = e || 2;
  var i = t && t.length, n = i ? t[0] * e : s.length, o = Lv(s, 0, n, e, !0), r = [];
  if (!o || o.next === o.prev)
    return r;
  var a, g, c, l, h, d, C;
  if (i && (o = X9(s, t, o, e)), s.length > 80 * e) {
    a = c = s[0], g = l = s[1];
    for (var p = e; p < n; p += e)
      h = s[p], d = s[p + 1], h < a && (a = h), d < g && (g = d), h > c && (c = h), d > l && (l = d);
    C = Math.max(c - a, l - g), C = C !== 0 ? 32767 / C : 0;
  }
  return zg(o, r, e, a, g, C, 0), r;
}
function Lv(s, t, e, i, n) {
  var o, r;
  if (n === DA(s, t, e, i) > 0)
    for (o = t; o < e; o += i)
      r = VS(o, s[o], s[o + 1], r);
  else
    for (o = e - i; o >= t; o -= i)
      r = VS(o, s[o], s[o + 1], r);
  return r && Id(r, r.next) && (Wg(r), r = r.next), r;
}
function Br(s, t) {
  if (!s)
    return s;
  t || (t = s);
  var e = s, i;
  do
    if (i = !1, !e.steiner && (Id(e, e.next) || vt(e.prev, e, e.next) === 0)) {
      if (Wg(e), e = t = e.prev, e === e.next)
        break;
      i = !0;
    } else
      e = e.next;
  while (i || e !== t);
  return t;
}
function zg(s, t, e, i, n, o, r) {
  if (!!s) {
    !r && o && Q9(s, i, n, o);
    for (var a = s, g, c; s.prev !== s.next; ) {
      if (g = s.prev, c = s.next, o ? k9(s, i, n, o) : F9(s)) {
        t.push(g.i / e | 0), t.push(s.i / e | 0), t.push(c.i / e | 0), Wg(s), s = c.next, a = c.next;
        continue;
      }
      if (s = c, s === a) {
        r ? r === 1 ? (s = V9(Br(s), t, e), zg(s, t, e, i, n, o, 2)) : r === 2 && z9(s, t, e, i, n, o) : zg(Br(s), t, e, i, n, o, 1);
        break;
      }
    }
  }
}
function F9(s) {
  var t = s.prev, e = s, i = s.next;
  if (vt(t, e, i) >= 0)
    return !1;
  for (var n = t.x, o = e.x, r = i.x, a = t.y, g = e.y, c = i.y, l = n < o ? n < r ? n : r : o < r ? o : r, h = a < g ? a < c ? a : c : g < c ? g : c, d = n > o ? n > r ? n : r : o > r ? o : r, C = a > g ? a > c ? a : c : g > c ? g : c, p = i.next; p !== t; ) {
    if (p.x >= l && p.x <= d && p.y >= h && p.y <= C && da(n, a, o, g, r, c, p.x, p.y) && vt(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function k9(s, t, e, i) {
  var n = s.prev, o = s, r = s.next;
  if (vt(n, o, r) >= 0)
    return !1;
  for (var a = n.x, g = o.x, c = r.x, l = n.y, h = o.y, d = r.y, C = a < g ? a < c ? a : c : g < c ? g : c, p = l < h ? l < d ? l : d : h < d ? h : d, m = a > g ? a > c ? a : c : g > c ? g : c, b = l > h ? l > d ? l : d : h > d ? h : d, S = EA(C, p, t, e, i), A = EA(m, b, t, e, i), u = s.prevZ, y = s.nextZ; u && u.z >= S && y && y.z <= A; ) {
    if (u.x >= C && u.x <= m && u.y >= p && u.y <= b && u !== n && u !== r && da(a, l, g, h, c, d, u.x, u.y) && vt(u.prev, u, u.next) >= 0 || (u = u.prevZ, y.x >= C && y.x <= m && y.y >= p && y.y <= b && y !== n && y !== r && da(a, l, g, h, c, d, y.x, y.y) && vt(y.prev, y, y.next) >= 0))
      return !1;
    y = y.nextZ;
  }
  for (; u && u.z >= S; ) {
    if (u.x >= C && u.x <= m && u.y >= p && u.y <= b && u !== n && u !== r && da(a, l, g, h, c, d, u.x, u.y) && vt(u.prev, u, u.next) >= 0)
      return !1;
    u = u.prevZ;
  }
  for (; y && y.z <= A; ) {
    if (y.x >= C && y.x <= m && y.y >= p && y.y <= b && y !== n && y !== r && da(a, l, g, h, c, d, y.x, y.y) && vt(y.prev, y, y.next) >= 0)
      return !1;
    y = y.nextZ;
  }
  return !0;
}
function V9(s, t, e) {
  var i = s;
  do {
    var n = i.prev, o = i.next.next;
    !Id(n, o) && Gv(n, i, i.next, o) && Xg(n, o) && Xg(o, n) && (t.push(n.i / e | 0), t.push(i.i / e | 0), t.push(o.i / e | 0), Wg(i), Wg(i.next), i = s = o), i = i.next;
  } while (i !== s);
  return Br(i);
}
function z9(s, t, e, i, n, o) {
  var r = s;
  do {
    for (var a = r.next.next; a !== r.prev; ) {
      if (r.i !== a.i && J9(r, a)) {
        var g = Mv(r, a);
        r = Br(r, r.next), g = Br(g, g.next), zg(r, t, e, i, n, o, 0), zg(g, t, e, i, n, o, 0);
        return;
      }
      a = a.next;
    }
    r = r.next;
  } while (r !== s);
}
function X9(s, t, e, i) {
  var n = [], o, r, a, g, c;
  for (o = 0, r = t.length; o < r; o++)
    a = t[o] * i, g = o < r - 1 ? t[o + 1] * i : s.length, c = Lv(s, a, g, i, !1), c === c.next && (c.steiner = !0), n.push(j9(c));
  for (n.sort(W9), o = 0; o < n.length; o++)
    e = Z9(n[o], e);
  return e;
}
function W9(s, t) {
  return s.x - t.x;
}
function Z9(s, t) {
  var e = U9(s, t);
  if (!e)
    return t;
  var i = Mv(e, s);
  return Br(i, i.next), Br(e, e.next);
}
function U9(s, t) {
  var e = t, i = s.x, n = s.y, o = -1 / 0, r;
  do {
    if (n <= e.y && n >= e.next.y && e.next.y !== e.y) {
      var a = e.x + (n - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
      if (a <= i && a > o && (o = a, r = e.x < e.next.x ? e : e.next, a === i))
        return r;
    }
    e = e.next;
  } while (e !== t);
  if (!r)
    return null;
  var g = r, c = r.x, l = r.y, h = 1 / 0, d;
  e = r;
  do
    i >= e.x && e.x >= c && i !== e.x && da(n < l ? i : o, n, c, l, n < l ? o : i, n, e.x, e.y) && (d = Math.abs(n - e.y) / (i - e.x), Xg(e, s) && (d < h || d === h && (e.x > r.x || e.x === r.x && O9(r, e))) && (r = e, h = d)), e = e.next;
  while (e !== g);
  return r;
}
function O9(s, t) {
  return vt(s.prev, s, t.prev) < 0 && vt(t.next, s, s.next) < 0;
}
function Q9(s, t, e, i) {
  var n = s;
  do
    n.z === 0 && (n.z = EA(n.x, n.y, t, e, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== s);
  n.prevZ.nextZ = null, n.prevZ = null, Y9(n);
}
function Y9(s) {
  var t, e, i, n, o, r, a, g, c = 1;
  do {
    for (e = s, s = null, o = null, r = 0; e; ) {
      for (r++, i = e, a = 0, t = 0; t < c && (a++, i = i.nextZ, !!i); t++)
        ;
      for (g = c; a > 0 || g > 0 && i; )
        a !== 0 && (g === 0 || !i || e.z <= i.z) ? (n = e, e = e.nextZ, a--) : (n = i, i = i.nextZ, g--), o ? o.nextZ = n : s = n, n.prevZ = o, o = n;
      e = i;
    }
    o.nextZ = null, c *= 2;
  } while (r > 1);
  return s;
}
function EA(s, t, e, i, n) {
  return s = (s - e) * n | 0, t = (t - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, s | t << 1;
}
function j9(s) {
  var t = s, e = s;
  do
    (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
  while (t !== s);
  return e;
}
function da(s, t, e, i, n, o, r, a) {
  return (n - r) * (t - a) >= (s - r) * (o - a) && (s - r) * (i - a) >= (e - r) * (t - a) && (e - r) * (o - a) >= (n - r) * (i - a);
}
function J9(s, t) {
  return s.next.i !== t.i && s.prev.i !== t.i && !q9(s, t) && (Xg(s, t) && Xg(t, s) && $9(s, t) && (vt(s.prev, s, t.prev) || vt(s, t.prev, t)) || Id(s, t) && vt(s.prev, s, s.next) > 0 && vt(t.prev, t, t.next) > 0);
}
function vt(s, t, e) {
  return (t.y - s.y) * (e.x - t.x) - (t.x - s.x) * (e.y - t.y);
}
function Id(s, t) {
  return s.x === t.x && s.y === t.y;
}
function Gv(s, t, e, i) {
  var n = wl(vt(s, t, e)), o = wl(vt(s, t, i)), r = wl(vt(e, i, s)), a = wl(vt(e, i, t));
  return !!(n !== o && r !== a || n === 0 && Bl(s, e, t) || o === 0 && Bl(s, i, t) || r === 0 && Bl(e, s, i) || a === 0 && Bl(e, t, i));
}
function Bl(s, t, e) {
  return t.x <= Math.max(s.x, e.x) && t.x >= Math.min(s.x, e.x) && t.y <= Math.max(s.y, e.y) && t.y >= Math.min(s.y, e.y);
}
function wl(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function q9(s, t) {
  var e = s;
  do {
    if (e.i !== s.i && e.next.i !== s.i && e.i !== t.i && e.next.i !== t.i && Gv(e, e.next, s, t))
      return !0;
    e = e.next;
  } while (e !== s);
  return !1;
}
function Xg(s, t) {
  return vt(s.prev, s, s.next) < 0 ? vt(s, t, s.next) >= 0 && vt(s, s.prev, t) >= 0 : vt(s, t, s.prev) < 0 || vt(s, s.next, t) < 0;
}
function $9(s, t) {
  var e = s, i = !1, n = (s.x + t.x) / 2, o = (s.y + t.y) / 2;
  do
    e.y > o != e.next.y > o && e.next.y !== e.y && n < (e.next.x - e.x) * (o - e.y) / (e.next.y - e.y) + e.x && (i = !i), e = e.next;
  while (e !== s);
  return i;
}
function Mv(s, t) {
  var e = new RA(s.i, s.x, s.y), i = new RA(t.i, t.x, t.y), n = s.next, o = t.prev;
  return s.next = t, t.prev = s, e.next = n, n.prev = e, i.next = e, e.prev = i, o.next = i, i.prev = o, i;
}
function VS(s, t, e, i) {
  var n = new RA(s, t, e);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function Wg(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function RA(s, t, e) {
  this.i = s, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
ud.deviation = function(s, t, e, i) {
  var n = t && t.length, o = n ? t[0] * e : s.length, r = Math.abs(DA(s, 0, o, e));
  if (n)
    for (var a = 0, g = t.length; a < g; a++) {
      var c = t[a] * e, l = a < g - 1 ? t[a + 1] * e : s.length;
      r -= Math.abs(DA(s, c, l, e));
    }
  var h = 0;
  for (a = 0; a < i.length; a += 3) {
    var d = i[a] * e, C = i[a + 1] * e, p = i[a + 2] * e;
    h += Math.abs(
      (s[d] - s[p]) * (s[C + 1] - s[d + 1]) - (s[d] - s[C]) * (s[p + 1] - s[d + 1])
    );
  }
  return r === 0 && h === 0 ? 0 : Math.abs((h - r) / r);
};
function DA(s, t, e, i) {
  for (var n = 0, o = t, r = e - i; o < e; o += i)
    n += (s[r] - s[o]) * (s[o + 1] + s[r + 1]), r = o;
  return n;
}
ud.flatten = function(s) {
  for (var t = s[0][0].length, e = { vertices: [], holes: [], dimensions: t }, i = 0, n = 0; n < s.length; n++) {
    for (var o = 0; o < s[n].length; o++)
      for (var r = 0; r < t; r++)
        e.vertices.push(s[n][o][r]);
    n > 0 && (i += s[n - 1].length, e.holes.push(i));
  }
  return e;
};
function e3(s, t, e, i, n) {
  for (var o = n + 1; i <= n; ) {
    var r = i + n >>> 1, a = s[r], g = e !== void 0 ? e(a, t) : a - t;
    g >= 0 ? (o = r, n = r - 1) : i = r + 1;
  }
  return o;
}
function t3(s, t, e, i, n) {
  for (var o = n + 1; i <= n; ) {
    var r = i + n >>> 1, a = s[r], g = e !== void 0 ? e(a, t) : a - t;
    g > 0 ? (o = r, n = r - 1) : i = r + 1;
  }
  return o;
}
function i3(s, t, e, i, n) {
  for (var o = i - 1; i <= n; ) {
    var r = i + n >>> 1, a = s[r], g = e !== void 0 ? e(a, t) : a - t;
    g < 0 ? (o = r, i = r + 1) : n = r - 1;
  }
  return o;
}
function n3(s, t, e, i, n) {
  for (var o = i - 1; i <= n; ) {
    var r = i + n >>> 1, a = s[r], g = e !== void 0 ? e(a, t) : a - t;
    g <= 0 ? (o = r, i = r + 1) : n = r - 1;
  }
  return o;
}
function s3(s, t, e, i, n) {
  for (; i <= n; ) {
    var o = i + n >>> 1, r = s[o], a = e !== void 0 ? e(r, t) : r - t;
    if (a === 0)
      return o;
    a <= 0 ? i = o + 1 : n = o - 1;
  }
  return -1;
}
function dg(s, t, e, i, n, o) {
  return typeof e == "function" ? o(s, t, e, i === void 0 ? 0 : i | 0, n === void 0 ? s.length - 1 : n | 0) : o(s, t, void 0, e === void 0 ? 0 : e | 0, i === void 0 ? s.length - 1 : i | 0);
}
var If = {
  ge: function(s, t, e, i, n) {
    return dg(s, t, e, i, n, e3);
  },
  gt: function(s, t, e, i, n) {
    return dg(s, t, e, i, n, t3);
  },
  lt: function(s, t, e, i, n) {
    return dg(s, t, e, i, n, i3);
  },
  le: function(s, t, e, i, n) {
    return dg(s, t, e, i, n, n3);
  },
  eq: function(s, t, e, i, n) {
    return dg(s, t, e, i, n, s3);
  }
}, Ev = { exports: {} }, Af = o3, zS = +(Math.pow(2, 27) + 1);
function o3(s, t, e) {
  var i = s * t, n = zS * s, o = n - s, r = n - o, a = s - r, g = zS * t, c = g - t, l = g - c, h = t - l, d = i - r * l, C = d - a * l, p = C - r * h, m = a * h - p;
  return e ? (e[0] = m, e[1] = i, e) : [m, i];
}
var Rv = a3;
function r3(s, t) {
  var e = s + t, i = e - s, n = e - i, o = t - i, r = s - n, a = r + o;
  return a ? [a, e] : [e];
}
function a3(s, t) {
  var e = s.length | 0, i = t.length | 0;
  if (e === 1 && i === 1)
    return r3(s[0], t[0]);
  var n = e + i, o = new Array(n), r = 0, a = 0, g = 0, c = Math.abs, l = s[a], h = c(l), d = t[g], C = c(d), p, m;
  h < C ? (m = l, a += 1, a < e && (l = s[a], h = c(l))) : (m = d, g += 1, g < i && (d = t[g], C = c(d))), a < e && h < C || g >= i ? (p = l, a += 1, a < e && (l = s[a], h = c(l))) : (p = d, g += 1, g < i && (d = t[g], C = c(d)));
  for (var b = p + m, S = b - p, A = m - S, u = A, y = b, I, M, G, x, L; a < e && g < i; )
    h < C ? (p = l, a += 1, a < e && (l = s[a], h = c(l))) : (p = d, g += 1, g < i && (d = t[g], C = c(d))), m = u, b = p + m, S = b - p, A = m - S, A && (o[r++] = A), I = y + b, M = I - y, G = I - M, x = b - M, L = y - G, u = L + x, y = I;
  for (; a < e; )
    p = l, m = u, b = p + m, S = b - p, A = m - S, A && (o[r++] = A), I = y + b, M = I - y, G = I - M, x = b - M, L = y - G, u = L + x, y = I, a += 1, a < e && (l = s[a]);
  for (; g < i; )
    p = d, m = u, b = p + m, S = b - p, A = m - S, A && (o[r++] = A), I = y + b, M = I - y, G = I - M, x = b - M, L = y - G, u = L + x, y = I, g += 1, g < i && (d = t[g]);
  return u && (o[r++] = u), y && (o[r++] = y), r || (o[r++] = 0), o.length = r, o;
}
var g3 = c3;
function c3(s, t, e) {
  var i = s + t, n = i - s, o = i - n, r = t - n, a = s - o;
  return e ? (e[0] = a + r, e[1] = i, e) : [a + r, i];
}
var FI = Af, l3 = g3, Dv = h3;
function h3(s, t) {
  var e = s.length;
  if (e === 1) {
    var i = FI(s[0], t);
    return i[0] ? i : [i[1]];
  }
  var n = new Array(2 * e), o = [0.1, 0.1], r = [0.1, 0.1], a = 0;
  FI(s[0], t, o), o[0] && (n[a++] = o[0]);
  for (var g = 1; g < e; ++g) {
    FI(s[g], t, r);
    var c = o[1];
    l3(c, r[0], o), o[0] && (n[a++] = o[0]);
    var l = r[1], h = o[1], d = l + h, C = d - l, p = h - C;
    o[1] = d, p && (n[a++] = p);
  }
  return o[1] && (n[a++] = o[1]), a === 0 && (n[a++] = 0), n.length = a, n;
}
var Kv = u3;
function d3(s, t) {
  var e = s + t, i = e - s, n = e - i, o = t - i, r = s - n, a = r + o;
  return a ? [a, e] : [e];
}
function u3(s, t) {
  var e = s.length | 0, i = t.length | 0;
  if (e === 1 && i === 1)
    return d3(s[0], -t[0]);
  var n = e + i, o = new Array(n), r = 0, a = 0, g = 0, c = Math.abs, l = s[a], h = c(l), d = -t[g], C = c(d), p, m;
  h < C ? (m = l, a += 1, a < e && (l = s[a], h = c(l))) : (m = d, g += 1, g < i && (d = -t[g], C = c(d))), a < e && h < C || g >= i ? (p = l, a += 1, a < e && (l = s[a], h = c(l))) : (p = d, g += 1, g < i && (d = -t[g], C = c(d)));
  for (var b = p + m, S = b - p, A = m - S, u = A, y = b, I, M, G, x, L; a < e && g < i; )
    h < C ? (p = l, a += 1, a < e && (l = s[a], h = c(l))) : (p = d, g += 1, g < i && (d = -t[g], C = c(d))), m = u, b = p + m, S = b - p, A = m - S, A && (o[r++] = A), I = y + b, M = I - y, G = I - M, x = b - M, L = y - G, u = L + x, y = I;
  for (; a < e; )
    p = l, m = u, b = p + m, S = b - p, A = m - S, A && (o[r++] = A), I = y + b, M = I - y, G = I - M, x = b - M, L = y - G, u = L + x, y = I, a += 1, a < e && (l = s[a]);
  for (; g < i; )
    p = d, m = u, b = p + m, S = b - p, A = m - S, A && (o[r++] = A), I = y + b, M = I - y, G = I - M, x = b - M, L = y - G, u = L + x, y = I, g += 1, g < i && (d = -t[g]);
  return u && (o[r++] = u), y && (o[r++] = y), r || (o[r++] = 0), o.length = r, o;
}
(function(s) {
  var t = Af, e = Rv, i = Dv, n = Kv, o = 5, r = 11102230246251565e-32, a = (3 + 16 * r) * r, g = (7 + 56 * r) * r;
  function c(u, y, I, M) {
    return function(x, L, E) {
      var T = u(u(y(L[1], E[0]), y(-E[1], L[0])), u(y(x[1], L[0]), y(-L[1], x[0]))), R = u(y(x[1], E[0]), y(-E[1], x[0])), w = M(T, R);
      return w[w.length - 1];
    };
  }
  function l(u, y, I, M) {
    return function(x, L, E, T) {
      var R = u(u(I(u(y(E[1], T[0]), y(-T[1], E[0])), L[2]), u(I(u(y(L[1], T[0]), y(-T[1], L[0])), -E[2]), I(u(y(L[1], E[0]), y(-E[1], L[0])), T[2]))), u(I(u(y(L[1], T[0]), y(-T[1], L[0])), x[2]), u(I(u(y(x[1], T[0]), y(-T[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), T[2])))), w = u(u(I(u(y(E[1], T[0]), y(-T[1], E[0])), x[2]), u(I(u(y(x[1], T[0]), y(-T[1], x[0])), -E[2]), I(u(y(x[1], E[0]), y(-E[1], x[0])), T[2]))), u(I(u(y(L[1], E[0]), y(-E[1], L[0])), x[2]), u(I(u(y(x[1], E[0]), y(-E[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), E[2])))), v = M(R, w);
      return v[v.length - 1];
    };
  }
  function h(u, y, I, M) {
    return function(x, L, E, T, R) {
      var w = u(u(u(I(u(I(u(y(T[1], R[0]), y(-R[1], T[0])), E[2]), u(I(u(y(E[1], R[0]), y(-R[1], E[0])), -T[2]), I(u(y(E[1], T[0]), y(-T[1], E[0])), R[2]))), L[3]), u(I(u(I(u(y(T[1], R[0]), y(-R[1], T[0])), L[2]), u(I(u(y(L[1], R[0]), y(-R[1], L[0])), -T[2]), I(u(y(L[1], T[0]), y(-T[1], L[0])), R[2]))), -E[3]), I(u(I(u(y(E[1], R[0]), y(-R[1], E[0])), L[2]), u(I(u(y(L[1], R[0]), y(-R[1], L[0])), -E[2]), I(u(y(L[1], E[0]), y(-E[1], L[0])), R[2]))), T[3]))), u(I(u(I(u(y(E[1], T[0]), y(-T[1], E[0])), L[2]), u(I(u(y(L[1], T[0]), y(-T[1], L[0])), -E[2]), I(u(y(L[1], E[0]), y(-E[1], L[0])), T[2]))), -R[3]), u(I(u(I(u(y(T[1], R[0]), y(-R[1], T[0])), L[2]), u(I(u(y(L[1], R[0]), y(-R[1], L[0])), -T[2]), I(u(y(L[1], T[0]), y(-T[1], L[0])), R[2]))), x[3]), I(u(I(u(y(T[1], R[0]), y(-R[1], T[0])), x[2]), u(I(u(y(x[1], R[0]), y(-R[1], x[0])), -T[2]), I(u(y(x[1], T[0]), y(-T[1], x[0])), R[2]))), -L[3])))), u(u(I(u(I(u(y(L[1], R[0]), y(-R[1], L[0])), x[2]), u(I(u(y(x[1], R[0]), y(-R[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), R[2]))), T[3]), u(I(u(I(u(y(L[1], T[0]), y(-T[1], L[0])), x[2]), u(I(u(y(x[1], T[0]), y(-T[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), T[2]))), -R[3]), I(u(I(u(y(E[1], T[0]), y(-T[1], E[0])), L[2]), u(I(u(y(L[1], T[0]), y(-T[1], L[0])), -E[2]), I(u(y(L[1], E[0]), y(-E[1], L[0])), T[2]))), x[3]))), u(I(u(I(u(y(E[1], T[0]), y(-T[1], E[0])), x[2]), u(I(u(y(x[1], T[0]), y(-T[1], x[0])), -E[2]), I(u(y(x[1], E[0]), y(-E[1], x[0])), T[2]))), -L[3]), u(I(u(I(u(y(L[1], T[0]), y(-T[1], L[0])), x[2]), u(I(u(y(x[1], T[0]), y(-T[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), T[2]))), E[3]), I(u(I(u(y(L[1], E[0]), y(-E[1], L[0])), x[2]), u(I(u(y(x[1], E[0]), y(-E[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), E[2]))), -T[3]))))), v = u(u(u(I(u(I(u(y(T[1], R[0]), y(-R[1], T[0])), E[2]), u(I(u(y(E[1], R[0]), y(-R[1], E[0])), -T[2]), I(u(y(E[1], T[0]), y(-T[1], E[0])), R[2]))), x[3]), I(u(I(u(y(T[1], R[0]), y(-R[1], T[0])), x[2]), u(I(u(y(x[1], R[0]), y(-R[1], x[0])), -T[2]), I(u(y(x[1], T[0]), y(-T[1], x[0])), R[2]))), -E[3])), u(I(u(I(u(y(E[1], R[0]), y(-R[1], E[0])), x[2]), u(I(u(y(x[1], R[0]), y(-R[1], x[0])), -E[2]), I(u(y(x[1], E[0]), y(-E[1], x[0])), R[2]))), T[3]), I(u(I(u(y(E[1], T[0]), y(-T[1], E[0])), x[2]), u(I(u(y(x[1], T[0]), y(-T[1], x[0])), -E[2]), I(u(y(x[1], E[0]), y(-E[1], x[0])), T[2]))), -R[3]))), u(u(I(u(I(u(y(E[1], R[0]), y(-R[1], E[0])), L[2]), u(I(u(y(L[1], R[0]), y(-R[1], L[0])), -E[2]), I(u(y(L[1], E[0]), y(-E[1], L[0])), R[2]))), x[3]), I(u(I(u(y(E[1], R[0]), y(-R[1], E[0])), x[2]), u(I(u(y(x[1], R[0]), y(-R[1], x[0])), -E[2]), I(u(y(x[1], E[0]), y(-E[1], x[0])), R[2]))), -L[3])), u(I(u(I(u(y(L[1], R[0]), y(-R[1], L[0])), x[2]), u(I(u(y(x[1], R[0]), y(-R[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), R[2]))), E[3]), I(u(I(u(y(L[1], E[0]), y(-E[1], L[0])), x[2]), u(I(u(y(x[1], E[0]), y(-E[1], x[0])), -L[2]), I(u(y(x[1], L[0]), y(-L[1], x[0])), E[2]))), -R[3])))), D = M(w, v);
      return D[D.length - 1];
    };
  }
  function d(u) {
    var y = u === 3 ? c : u === 4 ? l : h;
    return y(e, t, i, n);
  }
  var C = d(3), p = d(4), m = [
    function() {
      return 0;
    },
    function() {
      return 0;
    },
    function(y, I) {
      return I[0] - y[0];
    },
    function(y, I, M) {
      var G = (y[1] - M[1]) * (I[0] - M[0]), x = (y[0] - M[0]) * (I[1] - M[1]), L = G - x, E;
      if (G > 0) {
        if (x <= 0)
          return L;
        E = G + x;
      } else if (G < 0) {
        if (x >= 0)
          return L;
        E = -(G + x);
      } else
        return L;
      var T = a * E;
      return L >= T || L <= -T ? L : C(y, I, M);
    },
    function(y, I, M, G) {
      var x = y[0] - G[0], L = I[0] - G[0], E = M[0] - G[0], T = y[1] - G[1], R = I[1] - G[1], w = M[1] - G[1], v = y[2] - G[2], D = I[2] - G[2], K = M[2] - G[2], P = L * w, k = E * R, V = E * T, N = x * w, z = x * R, O = L * T, Q = v * (P - k) + D * (V - N) + K * (z - O), U = (Math.abs(P) + Math.abs(k)) * Math.abs(v) + (Math.abs(V) + Math.abs(N)) * Math.abs(D) + (Math.abs(z) + Math.abs(O)) * Math.abs(K), $ = g * U;
      return Q > $ || -Q > $ ? Q : p(y, I, M, G);
    }
  ];
  function b(u) {
    var y = m[u.length];
    return y || (y = m[u.length] = d(u.length)), y.apply(void 0, u);
  }
  function S(u, y, I, M, G, x, L) {
    return function(T, R, w, v, D) {
      switch (arguments.length) {
        case 0:
        case 1:
          return 0;
        case 2:
          return M(T, R);
        case 3:
          return G(T, R, w);
        case 4:
          return x(T, R, w, v);
        case 5:
          return L(T, R, w, v, D);
      }
      for (var K = new Array(arguments.length), P = 0; P < arguments.length; ++P)
        K[P] = arguments[P];
      return u(K);
    };
  }
  function A() {
    for (; m.length <= o; )
      m.push(d(m.length));
    s.exports = S.apply(void 0, [b].concat(m));
    for (var u = 0; u <= o; ++u)
      s.exports[u] = m[u];
  }
  A();
})(Ev);
var Gh = If, Mo = Ev.exports[3], KA = 0, XS = 1, kI = 2, I3 = m3;
function Hv(s, t, e, i, n) {
  this.a = s, this.b = t, this.idx = e, this.lowerIds = i, this.upperIds = n;
}
function ug(s, t, e, i) {
  this.a = s, this.b = t, this.type = e, this.idx = i;
}
function A3(s, t) {
  var e = s.a[0] - t.a[0] || s.a[1] - t.a[1] || s.type - t.type;
  return e || s.type !== KA && (e = Mo(s.a, s.b, t.b), e) ? e : s.idx - t.idx;
}
function WS(s, t) {
  return Mo(s.a, s.b, t);
}
function C3(s, t, e, i, n) {
  for (var o = Gh.lt(t, i, WS), r = Gh.gt(t, i, WS), a = o; a < r; ++a) {
    for (var g = t[a], c = g.lowerIds, h = c.length; h > 1 && Mo(
      e[c[h - 2]],
      e[c[h - 1]],
      i
    ) > 0; )
      s.push(
        [
          c[h - 1],
          c[h - 2],
          n
        ]
      ), h -= 1;
    c.length = h, c.push(n);
    for (var l = g.upperIds, h = l.length; h > 1 && Mo(
      e[l[h - 2]],
      e[l[h - 1]],
      i
    ) < 0; )
      s.push(
        [
          l[h - 2],
          l[h - 1],
          n
        ]
      ), h -= 1;
    l.length = h, l.push(n);
  }
}
function Pv(s, t) {
  var e;
  return s.a[0] < t.a[0] ? e = Mo(s.a, s.b, t.a) : e = Mo(t.b, t.a, s.a), e || (t.b[0] < s.b[0] ? e = Mo(s.a, s.b, t.b) : e = Mo(t.b, t.a, s.b), e || s.idx - t.idx);
}
function f3(s, t, e) {
  var i = Gh.le(s, e, Pv), n = s[i], o = n.upperIds, r = o[o.length - 1];
  n.upperIds = [r], s.splice(
    i + 1,
    0,
    new Hv(e.a, e.b, e.idx, [r], o)
  );
}
function p3(s, t, e) {
  var i = e.a;
  e.a = e.b, e.b = i;
  var n = Gh.eq(s, e, Pv), o = s[n], r = s[n - 1];
  r.upperIds = o.upperIds, s.splice(n, 1);
}
function m3(s, t) {
  for (var e = s.length, i = t.length, n = [], o = 0; o < e; ++o)
    n.push(new ug(
      s[o],
      null,
      KA,
      o
    ));
  for (var o = 0; o < i; ++o) {
    var r = t[o], a = s[r[0]], g = s[r[1]];
    a[0] < g[0] ? n.push(
      new ug(a, g, kI, o),
      new ug(g, a, XS, o)
    ) : a[0] > g[0] && n.push(
      new ug(g, a, kI, o),
      new ug(a, g, XS, o)
    );
  }
  n.sort(A3);
  for (var c = n[0].a[0] - (1 + Math.abs(n[0].a[0])) * Math.pow(2, -52), l = [new Hv([c, 1], [c, 0], -1, [], [])], h = [], o = 0, d = n.length; o < d; ++o) {
    var C = n[o], p = C.type;
    p === KA ? C3(h, l, s, C.a, C.idx) : p === kI ? f3(l, s, C) : p3(l, s, C);
  }
  return h;
}
var y3 = If, S3 = b3;
function Nv(s, t) {
  this.stars = s, this.edges = t;
}
var Mr = Nv.prototype;
function VI(s, t, e) {
  for (var i = 1, n = s.length; i < n; i += 2)
    if (s[i - 1] === t && s[i] === e) {
      s[i - 1] = s[n - 2], s[i] = s[n - 1], s.length = n - 2;
      return;
    }
}
Mr.isConstraint = function() {
  var s = [0, 0];
  function t(e, i) {
    return e[0] - i[0] || e[1] - i[1];
  }
  return function(e, i) {
    return s[0] = Math.min(e, i), s[1] = Math.max(e, i), y3.eq(this.edges, s, t) >= 0;
  };
}();
Mr.removeTriangle = function(s, t, e) {
  var i = this.stars;
  VI(i[s], t, e), VI(i[t], e, s), VI(i[e], s, t);
};
Mr.addTriangle = function(s, t, e) {
  var i = this.stars;
  i[s].push(t, e), i[t].push(e, s), i[e].push(s, t);
};
Mr.opposite = function(s, t) {
  for (var e = this.stars[t], i = 1, n = e.length; i < n; i += 2)
    if (e[i] === s)
      return e[i - 1];
  return -1;
};
Mr.flip = function(s, t) {
  var e = this.opposite(s, t), i = this.opposite(t, s);
  this.removeTriangle(s, t, e), this.removeTriangle(t, s, i), this.addTriangle(s, i, e), this.addTriangle(t, e, i);
};
Mr.edges = function() {
  for (var s = this.stars, t = [], e = 0, i = s.length; e < i; ++e)
    for (var n = s[e], o = 0, r = n.length; o < r; o += 2)
      t.push([n[o], n[o + 1]]);
  return t;
};
Mr.cells = function() {
  for (var s = this.stars, t = [], e = 0, i = s.length; e < i; ++e)
    for (var n = s[e], o = 0, r = n.length; o < r; o += 2) {
      var a = n[o], g = n[o + 1];
      e < Math.min(a, g) && t.push([e, a, g]);
    }
  return t;
};
function b3(s, t) {
  for (var e = new Array(s), i = 0; i < s; ++i)
    e[i] = [];
  return new Nv(e, t);
}
var Fv = { exports: {} };
(function(s) {
  var t = Af, e = Rv, i = Kv, n = Dv, o = 6;
  function r(A) {
    var u = A === 3 ? l : A === 4 ? h : A === 5 ? d : C;
    return u(e, i, t, n);
  }
  function a() {
    return 0;
  }
  function g() {
    return 0;
  }
  function c() {
    return 0;
  }
  function l(A, u, y, I) {
    function M(G, x, L) {
      var E = y(G[0], G[0]), T = I(E, x[0]), R = I(E, L[0]), w = y(x[0], x[0]), v = I(w, G[0]), D = I(w, L[0]), K = y(L[0], L[0]), P = I(K, G[0]), k = I(K, x[0]), V = A(u(k, D), u(v, T)), N = u(P, R), z = u(V, N);
      return z[z.length - 1];
    }
    return M;
  }
  function h(A, u, y, I) {
    function M(G, x, L, E) {
      var T = A(y(G[0], G[0]), y(G[1], G[1])), R = I(T, x[0]), w = I(T, L[0]), v = I(T, E[0]), D = A(y(x[0], x[0]), y(x[1], x[1])), K = I(D, G[0]), P = I(D, L[0]), k = I(D, E[0]), V = A(y(L[0], L[0]), y(L[1], L[1])), N = I(V, G[0]), z = I(V, x[0]), O = I(V, E[0]), Q = A(y(E[0], E[0]), y(E[1], E[1])), U = I(Q, G[0]), $ = I(Q, x[0]), ee = I(Q, L[0]), se = A(A(I(u(ee, O), x[1]), A(I(u($, k), -L[1]), I(u(z, P), E[1]))), A(I(u($, k), G[1]), A(I(u(U, v), -x[1]), I(u(K, R), E[1])))), ie = A(A(I(u(ee, O), G[1]), A(I(u(U, v), -L[1]), I(u(N, w), E[1]))), A(I(u(z, P), G[1]), A(I(u(N, w), -x[1]), I(u(K, R), L[1])))), Y = u(se, ie);
      return Y[Y.length - 1];
    }
    return M;
  }
  function d(A, u, y, I) {
    function M(G, x, L, E, T) {
      var R = A(y(G[0], G[0]), A(y(G[1], G[1]), y(G[2], G[2]))), w = I(R, x[0]), v = I(R, L[0]), D = I(R, E[0]), K = I(R, T[0]), P = A(y(x[0], x[0]), A(y(x[1], x[1]), y(x[2], x[2]))), k = I(P, G[0]), V = I(P, L[0]), N = I(P, E[0]), z = I(P, T[0]), O = A(y(L[0], L[0]), A(y(L[1], L[1]), y(L[2], L[2]))), Q = I(O, G[0]), U = I(O, x[0]), $ = I(O, E[0]), ee = I(O, T[0]), se = A(y(E[0], E[0]), A(y(E[1], E[1]), y(E[2], E[2]))), ie = I(se, G[0]), Y = I(se, x[0]), Ie = I(se, L[0]), xe = I(se, T[0]), fe = A(y(T[0], T[0]), A(y(T[1], T[1]), y(T[2], T[2]))), be = I(fe, G[0]), pe = I(fe, x[0]), Te = I(fe, L[0]), ge = I(fe, E[0]), lt = A(A(A(I(A(I(u(ge, xe), L[1]), A(I(u(Te, ee), -E[1]), I(u(Ie, $), T[1]))), x[2]), A(I(A(I(u(ge, xe), x[1]), A(I(u(pe, z), -E[1]), I(u(Y, N), T[1]))), -L[2]), I(A(I(u(Te, ee), x[1]), A(I(u(pe, z), -L[1]), I(u(U, V), T[1]))), E[2]))), A(I(A(I(u(Ie, $), x[1]), A(I(u(Y, N), -L[1]), I(u(U, V), E[1]))), -T[2]), A(I(A(I(u(ge, xe), x[1]), A(I(u(pe, z), -E[1]), I(u(Y, N), T[1]))), G[2]), I(A(I(u(ge, xe), G[1]), A(I(u(be, K), -E[1]), I(u(ie, D), T[1]))), -x[2])))), A(A(I(A(I(u(pe, z), G[1]), A(I(u(be, K), -x[1]), I(u(k, w), T[1]))), E[2]), A(I(A(I(u(Y, N), G[1]), A(I(u(ie, D), -x[1]), I(u(k, w), E[1]))), -T[2]), I(A(I(u(Ie, $), x[1]), A(I(u(Y, N), -L[1]), I(u(U, V), E[1]))), G[2]))), A(I(A(I(u(Ie, $), G[1]), A(I(u(ie, D), -L[1]), I(u(Q, v), E[1]))), -x[2]), A(I(A(I(u(Y, N), G[1]), A(I(u(ie, D), -x[1]), I(u(k, w), E[1]))), L[2]), I(A(I(u(U, V), G[1]), A(I(u(Q, v), -x[1]), I(u(k, w), L[1]))), -E[2]))))), Ke = A(A(A(I(A(I(u(ge, xe), L[1]), A(I(u(Te, ee), -E[1]), I(u(Ie, $), T[1]))), G[2]), I(A(I(u(ge, xe), G[1]), A(I(u(be, K), -E[1]), I(u(ie, D), T[1]))), -L[2])), A(I(A(I(u(Te, ee), G[1]), A(I(u(be, K), -L[1]), I(u(Q, v), T[1]))), E[2]), I(A(I(u(Ie, $), G[1]), A(I(u(ie, D), -L[1]), I(u(Q, v), E[1]))), -T[2]))), A(A(I(A(I(u(Te, ee), x[1]), A(I(u(pe, z), -L[1]), I(u(U, V), T[1]))), G[2]), I(A(I(u(Te, ee), G[1]), A(I(u(be, K), -L[1]), I(u(Q, v), T[1]))), -x[2])), A(I(A(I(u(pe, z), G[1]), A(I(u(be, K), -x[1]), I(u(k, w), T[1]))), L[2]), I(A(I(u(U, V), G[1]), A(I(u(Q, v), -x[1]), I(u(k, w), L[1]))), -T[2])))), Pe = u(lt, Ke);
      return Pe[Pe.length - 1];
    }
    return M;
  }
  function C(A, u, y, I) {
    function M(G, x, L, E, T, R) {
      var w = A(A(y(G[0], G[0]), y(G[1], G[1])), A(y(G[2], G[2]), y(G[3], G[3]))), v = I(w, x[0]), D = I(w, L[0]), K = I(w, E[0]), P = I(w, T[0]), k = I(w, R[0]), V = A(A(y(x[0], x[0]), y(x[1], x[1])), A(y(x[2], x[2]), y(x[3], x[3]))), N = I(V, G[0]), z = I(V, L[0]), O = I(V, E[0]), Q = I(V, T[0]), U = I(V, R[0]), $ = A(A(y(L[0], L[0]), y(L[1], L[1])), A(y(L[2], L[2]), y(L[3], L[3]))), ee = I($, G[0]), se = I($, x[0]), ie = I($, E[0]), Y = I($, T[0]), Ie = I($, R[0]), xe = A(A(y(E[0], E[0]), y(E[1], E[1])), A(y(E[2], E[2]), y(E[3], E[3]))), fe = I(xe, G[0]), be = I(xe, x[0]), pe = I(xe, L[0]), Te = I(xe, T[0]), ge = I(xe, R[0]), lt = A(A(y(T[0], T[0]), y(T[1], T[1])), A(y(T[2], T[2]), y(T[3], T[3]))), Ke = I(lt, G[0]), Pe = I(lt, x[0]), nt = I(lt, L[0]), Ve = I(lt, E[0]), rt = I(lt, R[0]), on = A(A(y(R[0], R[0]), y(R[1], R[1])), A(y(R[2], R[2]), y(R[3], R[3]))), $e = I(on, G[0]), st = I(on, x[0]), ot = I(on, L[0]), et = I(on, E[0]), Je = I(on, T[0]), _n = A(A(A(I(A(A(I(A(I(u(Je, rt), E[1]), A(I(u(et, ge), -T[1]), I(u(Ve, Te), R[1]))), L[2]), I(A(I(u(Je, rt), L[1]), A(I(u(ot, Ie), -T[1]), I(u(nt, Y), R[1]))), -E[2])), A(I(A(I(u(et, ge), L[1]), A(I(u(ot, Ie), -E[1]), I(u(pe, ie), R[1]))), T[2]), I(A(I(u(Ve, Te), L[1]), A(I(u(nt, Y), -E[1]), I(u(pe, ie), T[1]))), -R[2]))), x[3]), A(I(A(A(I(A(I(u(Je, rt), E[1]), A(I(u(et, ge), -T[1]), I(u(Ve, Te), R[1]))), x[2]), I(A(I(u(Je, rt), x[1]), A(I(u(st, U), -T[1]), I(u(Pe, Q), R[1]))), -E[2])), A(I(A(I(u(et, ge), x[1]), A(I(u(st, U), -E[1]), I(u(be, O), R[1]))), T[2]), I(A(I(u(Ve, Te), x[1]), A(I(u(Pe, Q), -E[1]), I(u(be, O), T[1]))), -R[2]))), -L[3]), I(A(A(I(A(I(u(Je, rt), L[1]), A(I(u(ot, Ie), -T[1]), I(u(nt, Y), R[1]))), x[2]), I(A(I(u(Je, rt), x[1]), A(I(u(st, U), -T[1]), I(u(Pe, Q), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), x[1]), A(I(u(st, U), -L[1]), I(u(se, z), R[1]))), T[2]), I(A(I(u(nt, Y), x[1]), A(I(u(Pe, Q), -L[1]), I(u(se, z), T[1]))), -R[2]))), E[3]))), A(A(I(A(A(I(A(I(u(et, ge), L[1]), A(I(u(ot, Ie), -E[1]), I(u(pe, ie), R[1]))), x[2]), I(A(I(u(et, ge), x[1]), A(I(u(st, U), -E[1]), I(u(be, O), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), x[1]), A(I(u(st, U), -L[1]), I(u(se, z), R[1]))), E[2]), I(A(I(u(pe, ie), x[1]), A(I(u(be, O), -L[1]), I(u(se, z), E[1]))), -R[2]))), -T[3]), I(A(A(I(A(I(u(Ve, Te), L[1]), A(I(u(nt, Y), -E[1]), I(u(pe, ie), T[1]))), x[2]), I(A(I(u(Ve, Te), x[1]), A(I(u(Pe, Q), -E[1]), I(u(be, O), T[1]))), -L[2])), A(I(A(I(u(nt, Y), x[1]), A(I(u(Pe, Q), -L[1]), I(u(se, z), T[1]))), E[2]), I(A(I(u(pe, ie), x[1]), A(I(u(be, O), -L[1]), I(u(se, z), E[1]))), -T[2]))), R[3])), A(I(A(A(I(A(I(u(Je, rt), E[1]), A(I(u(et, ge), -T[1]), I(u(Ve, Te), R[1]))), x[2]), I(A(I(u(Je, rt), x[1]), A(I(u(st, U), -T[1]), I(u(Pe, Q), R[1]))), -E[2])), A(I(A(I(u(et, ge), x[1]), A(I(u(st, U), -E[1]), I(u(be, O), R[1]))), T[2]), I(A(I(u(Ve, Te), x[1]), A(I(u(Pe, Q), -E[1]), I(u(be, O), T[1]))), -R[2]))), G[3]), I(A(A(I(A(I(u(Je, rt), E[1]), A(I(u(et, ge), -T[1]), I(u(Ve, Te), R[1]))), G[2]), I(A(I(u(Je, rt), G[1]), A(I(u($e, k), -T[1]), I(u(Ke, P), R[1]))), -E[2])), A(I(A(I(u(et, ge), G[1]), A(I(u($e, k), -E[1]), I(u(fe, K), R[1]))), T[2]), I(A(I(u(Ve, Te), G[1]), A(I(u(Ke, P), -E[1]), I(u(fe, K), T[1]))), -R[2]))), -x[3])))), A(A(A(I(A(A(I(A(I(u(Je, rt), x[1]), A(I(u(st, U), -T[1]), I(u(Pe, Q), R[1]))), G[2]), I(A(I(u(Je, rt), G[1]), A(I(u($e, k), -T[1]), I(u(Ke, P), R[1]))), -x[2])), A(I(A(I(u(st, U), G[1]), A(I(u($e, k), -x[1]), I(u(N, v), R[1]))), T[2]), I(A(I(u(Pe, Q), G[1]), A(I(u(Ke, P), -x[1]), I(u(N, v), T[1]))), -R[2]))), E[3]), I(A(A(I(A(I(u(et, ge), x[1]), A(I(u(st, U), -E[1]), I(u(be, O), R[1]))), G[2]), I(A(I(u(et, ge), G[1]), A(I(u($e, k), -E[1]), I(u(fe, K), R[1]))), -x[2])), A(I(A(I(u(st, U), G[1]), A(I(u($e, k), -x[1]), I(u(N, v), R[1]))), E[2]), I(A(I(u(be, O), G[1]), A(I(u(fe, K), -x[1]), I(u(N, v), E[1]))), -R[2]))), -T[3])), A(I(A(A(I(A(I(u(Ve, Te), x[1]), A(I(u(Pe, Q), -E[1]), I(u(be, O), T[1]))), G[2]), I(A(I(u(Ve, Te), G[1]), A(I(u(Ke, P), -E[1]), I(u(fe, K), T[1]))), -x[2])), A(I(A(I(u(Pe, Q), G[1]), A(I(u(Ke, P), -x[1]), I(u(N, v), T[1]))), E[2]), I(A(I(u(be, O), G[1]), A(I(u(fe, K), -x[1]), I(u(N, v), E[1]))), -T[2]))), R[3]), I(A(A(I(A(I(u(et, ge), L[1]), A(I(u(ot, Ie), -E[1]), I(u(pe, ie), R[1]))), x[2]), I(A(I(u(et, ge), x[1]), A(I(u(st, U), -E[1]), I(u(be, O), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), x[1]), A(I(u(st, U), -L[1]), I(u(se, z), R[1]))), E[2]), I(A(I(u(pe, ie), x[1]), A(I(u(be, O), -L[1]), I(u(se, z), E[1]))), -R[2]))), G[3]))), A(A(I(A(A(I(A(I(u(et, ge), L[1]), A(I(u(ot, Ie), -E[1]), I(u(pe, ie), R[1]))), G[2]), I(A(I(u(et, ge), G[1]), A(I(u($e, k), -E[1]), I(u(fe, K), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), G[1]), A(I(u($e, k), -L[1]), I(u(ee, D), R[1]))), E[2]), I(A(I(u(pe, ie), G[1]), A(I(u(fe, K), -L[1]), I(u(ee, D), E[1]))), -R[2]))), -x[3]), I(A(A(I(A(I(u(et, ge), x[1]), A(I(u(st, U), -E[1]), I(u(be, O), R[1]))), G[2]), I(A(I(u(et, ge), G[1]), A(I(u($e, k), -E[1]), I(u(fe, K), R[1]))), -x[2])), A(I(A(I(u(st, U), G[1]), A(I(u($e, k), -x[1]), I(u(N, v), R[1]))), E[2]), I(A(I(u(be, O), G[1]), A(I(u(fe, K), -x[1]), I(u(N, v), E[1]))), -R[2]))), L[3])), A(I(A(A(I(A(I(u(ot, Ie), x[1]), A(I(u(st, U), -L[1]), I(u(se, z), R[1]))), G[2]), I(A(I(u(ot, Ie), G[1]), A(I(u($e, k), -L[1]), I(u(ee, D), R[1]))), -x[2])), A(I(A(I(u(st, U), G[1]), A(I(u($e, k), -x[1]), I(u(N, v), R[1]))), L[2]), I(A(I(u(se, z), G[1]), A(I(u(ee, D), -x[1]), I(u(N, v), L[1]))), -R[2]))), -E[3]), I(A(A(I(A(I(u(pe, ie), x[1]), A(I(u(be, O), -L[1]), I(u(se, z), E[1]))), G[2]), I(A(I(u(pe, ie), G[1]), A(I(u(fe, K), -L[1]), I(u(ee, D), E[1]))), -x[2])), A(I(A(I(u(be, O), G[1]), A(I(u(fe, K), -x[1]), I(u(N, v), E[1]))), L[2]), I(A(I(u(se, z), G[1]), A(I(u(ee, D), -x[1]), I(u(N, v), L[1]))), -E[2]))), R[3]))))), xn = A(A(A(I(A(A(I(A(I(u(Je, rt), E[1]), A(I(u(et, ge), -T[1]), I(u(Ve, Te), R[1]))), L[2]), I(A(I(u(Je, rt), L[1]), A(I(u(ot, Ie), -T[1]), I(u(nt, Y), R[1]))), -E[2])), A(I(A(I(u(et, ge), L[1]), A(I(u(ot, Ie), -E[1]), I(u(pe, ie), R[1]))), T[2]), I(A(I(u(Ve, Te), L[1]), A(I(u(nt, Y), -E[1]), I(u(pe, ie), T[1]))), -R[2]))), G[3]), A(I(A(A(I(A(I(u(Je, rt), E[1]), A(I(u(et, ge), -T[1]), I(u(Ve, Te), R[1]))), G[2]), I(A(I(u(Je, rt), G[1]), A(I(u($e, k), -T[1]), I(u(Ke, P), R[1]))), -E[2])), A(I(A(I(u(et, ge), G[1]), A(I(u($e, k), -E[1]), I(u(fe, K), R[1]))), T[2]), I(A(I(u(Ve, Te), G[1]), A(I(u(Ke, P), -E[1]), I(u(fe, K), T[1]))), -R[2]))), -L[3]), I(A(A(I(A(I(u(Je, rt), L[1]), A(I(u(ot, Ie), -T[1]), I(u(nt, Y), R[1]))), G[2]), I(A(I(u(Je, rt), G[1]), A(I(u($e, k), -T[1]), I(u(Ke, P), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), G[1]), A(I(u($e, k), -L[1]), I(u(ee, D), R[1]))), T[2]), I(A(I(u(nt, Y), G[1]), A(I(u(Ke, P), -L[1]), I(u(ee, D), T[1]))), -R[2]))), E[3]))), A(A(I(A(A(I(A(I(u(et, ge), L[1]), A(I(u(ot, Ie), -E[1]), I(u(pe, ie), R[1]))), G[2]), I(A(I(u(et, ge), G[1]), A(I(u($e, k), -E[1]), I(u(fe, K), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), G[1]), A(I(u($e, k), -L[1]), I(u(ee, D), R[1]))), E[2]), I(A(I(u(pe, ie), G[1]), A(I(u(fe, K), -L[1]), I(u(ee, D), E[1]))), -R[2]))), -T[3]), I(A(A(I(A(I(u(Ve, Te), L[1]), A(I(u(nt, Y), -E[1]), I(u(pe, ie), T[1]))), G[2]), I(A(I(u(Ve, Te), G[1]), A(I(u(Ke, P), -E[1]), I(u(fe, K), T[1]))), -L[2])), A(I(A(I(u(nt, Y), G[1]), A(I(u(Ke, P), -L[1]), I(u(ee, D), T[1]))), E[2]), I(A(I(u(pe, ie), G[1]), A(I(u(fe, K), -L[1]), I(u(ee, D), E[1]))), -T[2]))), R[3])), A(I(A(A(I(A(I(u(Je, rt), L[1]), A(I(u(ot, Ie), -T[1]), I(u(nt, Y), R[1]))), x[2]), I(A(I(u(Je, rt), x[1]), A(I(u(st, U), -T[1]), I(u(Pe, Q), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), x[1]), A(I(u(st, U), -L[1]), I(u(se, z), R[1]))), T[2]), I(A(I(u(nt, Y), x[1]), A(I(u(Pe, Q), -L[1]), I(u(se, z), T[1]))), -R[2]))), G[3]), I(A(A(I(A(I(u(Je, rt), L[1]), A(I(u(ot, Ie), -T[1]), I(u(nt, Y), R[1]))), G[2]), I(A(I(u(Je, rt), G[1]), A(I(u($e, k), -T[1]), I(u(Ke, P), R[1]))), -L[2])), A(I(A(I(u(ot, Ie), G[1]), A(I(u($e, k), -L[1]), I(u(ee, D), R[1]))), T[2]), I(A(I(u(nt, Y), G[1]), A(I(u(Ke, P), -L[1]), I(u(ee, D), T[1]))), -R[2]))), -x[3])))), A(A(A(I(A(A(I(A(I(u(Je, rt), x[1]), A(I(u(st, U), -T[1]), I(u(Pe, Q), R[1]))), G[2]), I(A(I(u(Je, rt), G[1]), A(I(u($e, k), -T[1]), I(u(Ke, P), R[1]))), -x[2])), A(I(A(I(u(st, U), G[1]), A(I(u($e, k), -x[1]), I(u(N, v), R[1]))), T[2]), I(A(I(u(Pe, Q), G[1]), A(I(u(Ke, P), -x[1]), I(u(N, v), T[1]))), -R[2]))), L[3]), I(A(A(I(A(I(u(ot, Ie), x[1]), A(I(u(st, U), -L[1]), I(u(se, z), R[1]))), G[2]), I(A(I(u(ot, Ie), G[1]), A(I(u($e, k), -L[1]), I(u(ee, D), R[1]))), -x[2])), A(I(A(I(u(st, U), G[1]), A(I(u($e, k), -x[1]), I(u(N, v), R[1]))), L[2]), I(A(I(u(se, z), G[1]), A(I(u(ee, D), -x[1]), I(u(N, v), L[1]))), -R[2]))), -T[3])), A(I(A(A(I(A(I(u(nt, Y), x[1]), A(I(u(Pe, Q), -L[1]), I(u(se, z), T[1]))), G[2]), I(A(I(u(nt, Y), G[1]), A(I(u(Ke, P), -L[1]), I(u(ee, D), T[1]))), -x[2])), A(I(A(I(u(Pe, Q), G[1]), A(I(u(Ke, P), -x[1]), I(u(N, v), T[1]))), L[2]), I(A(I(u(se, z), G[1]), A(I(u(ee, D), -x[1]), I(u(N, v), L[1]))), -T[2]))), R[3]), I(A(A(I(A(I(u(Ve, Te), L[1]), A(I(u(nt, Y), -E[1]), I(u(pe, ie), T[1]))), x[2]), I(A(I(u(Ve, Te), x[1]), A(I(u(Pe, Q), -E[1]), I(u(be, O), T[1]))), -L[2])), A(I(A(I(u(nt, Y), x[1]), A(I(u(Pe, Q), -L[1]), I(u(se, z), T[1]))), E[2]), I(A(I(u(pe, ie), x[1]), A(I(u(be, O), -L[1]), I(u(se, z), E[1]))), -T[2]))), G[3]))), A(A(I(A(A(I(A(I(u(Ve, Te), L[1]), A(I(u(nt, Y), -E[1]), I(u(pe, ie), T[1]))), G[2]), I(A(I(u(Ve, Te), G[1]), A(I(u(Ke, P), -E[1]), I(u(fe, K), T[1]))), -L[2])), A(I(A(I(u(nt, Y), G[1]), A(I(u(Ke, P), -L[1]), I(u(ee, D), T[1]))), E[2]), I(A(I(u(pe, ie), G[1]), A(I(u(fe, K), -L[1]), I(u(ee, D), E[1]))), -T[2]))), -x[3]), I(A(A(I(A(I(u(Ve, Te), x[1]), A(I(u(Pe, Q), -E[1]), I(u(be, O), T[1]))), G[2]), I(A(I(u(Ve, Te), G[1]), A(I(u(Ke, P), -E[1]), I(u(fe, K), T[1]))), -x[2])), A(I(A(I(u(Pe, Q), G[1]), A(I(u(Ke, P), -x[1]), I(u(N, v), T[1]))), E[2]), I(A(I(u(be, O), G[1]), A(I(u(fe, K), -x[1]), I(u(N, v), E[1]))), -T[2]))), L[3])), A(I(A(A(I(A(I(u(nt, Y), x[1]), A(I(u(Pe, Q), -L[1]), I(u(se, z), T[1]))), G[2]), I(A(I(u(nt, Y), G[1]), A(I(u(Ke, P), -L[1]), I(u(ee, D), T[1]))), -x[2])), A(I(A(I(u(Pe, Q), G[1]), A(I(u(Ke, P), -x[1]), I(u(N, v), T[1]))), L[2]), I(A(I(u(se, z), G[1]), A(I(u(ee, D), -x[1]), I(u(N, v), L[1]))), -T[2]))), -E[3]), I(A(A(I(A(I(u(pe, ie), x[1]), A(I(u(be, O), -L[1]), I(u(se, z), E[1]))), G[2]), I(A(I(u(pe, ie), G[1]), A(I(u(fe, K), -L[1]), I(u(ee, D), E[1]))), -x[2])), A(I(A(I(u(be, O), G[1]), A(I(u(fe, K), -x[1]), I(u(N, v), E[1]))), L[2]), I(A(I(u(se, z), G[1]), A(I(u(ee, D), -x[1]), I(u(N, v), L[1]))), -E[2]))), T[3]))))), vn = u(_n, xn);
      return vn[vn.length - 1];
    }
    return M;
  }
  var p = [
    a,
    g,
    c
  ];
  function m(A) {
    var u = p[A.length];
    return u || (u = p[A.length] = r(A.length)), u.apply(void 0, A);
  }
  function b(A, u, y, I, M, G, x, L) {
    function E(T, R, w, v, D, K) {
      switch (arguments.length) {
        case 0:
        case 1:
          return 0;
        case 2:
          return I(T, R);
        case 3:
          return M(T, R, w);
        case 4:
          return G(T, R, w, v);
        case 5:
          return x(T, R, w, v, D);
        case 6:
          return L(T, R, w, v, D, K);
      }
      for (var P = new Array(arguments.length), k = 0; k < arguments.length; ++k)
        P[k] = arguments[k];
      return A(P);
    }
    return E;
  }
  function S() {
    for (; p.length <= o; )
      p.push(r(p.length));
    s.exports = b.apply(void 0, [m].concat(p));
    for (var A = 0; A <= o; ++A)
      s.exports[A] = p[A];
  }
  S();
})(Fv);
var HA = Fv.exports[4], B3 = w3;
function _l(s, t, e, i, n, o) {
  var r = t.opposite(i, n);
  if (!(r < 0)) {
    if (n < i) {
      var a = i;
      i = n, n = a, a = o, o = r, r = a;
    }
    t.isConstraint(i, n) || HA(s[i], s[n], s[o], s[r]) < 0 && e.push(i, n);
  }
}
function w3(s, t) {
  for (var e = [], i = s.length, n = t.stars, o = 0; o < i; ++o)
    for (var r = n[o], a = 1; a < r.length; a += 2) {
      var g = r[a];
      if (!(g < o) && !t.isConstraint(o, g)) {
        for (var c = r[a - 1], l = -1, h = 1; h < r.length; h += 2)
          if (r[h - 1] === g) {
            l = r[h];
            break;
          }
        l < 0 || HA(s[o], s[g], s[c], s[l]) < 0 && e.push(o, g);
      }
    }
  for (; e.length > 0; ) {
    for (var g = e.pop(), o = e.pop(), c = -1, l = -1, r = n[o], d = 1; d < r.length; d += 2) {
      var C = r[d - 1], p = r[d];
      C === g ? l = p : p === g && (c = C);
    }
    c < 0 || l < 0 || HA(s[o], s[g], s[c], s[l]) >= 0 || (t.flip(o, g), _l(s, t, e, c, o, l), _l(s, t, e, o, l, c), _l(s, t, e, l, g, c), _l(s, t, e, g, c, l));
  }
}
var _3 = If, x3 = G3;
function kv(s, t, e, i, n, o, r) {
  this.cells = s, this.neighbor = t, this.flags = i, this.constraint = e, this.active = n, this.next = o, this.boundary = r;
}
var v3 = kv.prototype;
function Vv(s, t) {
  return s[0] - t[0] || s[1] - t[1] || s[2] - t[2];
}
v3.locate = function() {
  var s = [0, 0, 0];
  return function(t, e, i) {
    var n = t, o = e, r = i;
    return e < i ? e < t && (n = e, o = i, r = t) : i < t && (n = i, o = t, r = e), n < 0 ? -1 : (s[0] = n, s[1] = o, s[2] = r, _3.eq(this.cells, s, Vv));
  };
}();
function T3(s, t) {
  for (var e = s.cells(), i = e.length, n = 0; n < i; ++n) {
    var o = e[n], r = o[0], a = o[1], g = o[2];
    a < g ? a < r && (o[0] = a, o[1] = g, o[2] = r) : g < r && (o[0] = g, o[1] = r, o[2] = a);
  }
  e.sort(Vv);
  for (var c = new Array(i), n = 0; n < c.length; ++n)
    c[n] = 0;
  var l = [], h = [], d = new Array(3 * i), C = new Array(3 * i), p = null;
  t && (p = []);
  for (var m = new kv(
    e,
    d,
    C,
    c,
    l,
    h,
    p
  ), n = 0; n < i; ++n)
    for (var o = e[n], b = 0; b < 3; ++b) {
      var r = o[b], a = o[(b + 1) % 3], S = d[3 * n + b] = m.locate(a, r, s.opposite(a, r)), A = C[3 * n + b] = s.isConstraint(r, a);
      S < 0 && (A ? h.push(n) : (l.push(n), c[n] = 1), t && p.push([a, r, -1]));
    }
  return m;
}
function L3(s, t, e) {
  for (var i = 0, n = 0; n < s.length; ++n)
    t[n] === e && (s[i++] = s[n]);
  return s.length = i, s;
}
function G3(s, t, e) {
  var i = T3(s, e);
  if (t === 0)
    return e ? i.cells.concat(i.boundary) : i.cells;
  for (var n = 1, o = i.active, r = i.next, a = i.flags, g = i.cells, c = i.constraint, l = i.neighbor; o.length > 0 || r.length > 0; ) {
    for (; o.length > 0; ) {
      var h = o.pop();
      if (a[h] !== -n) {
        a[h] = n, g[h];
        for (var d = 0; d < 3; ++d) {
          var C = l[3 * h + d];
          C >= 0 && a[C] === 0 && (c[3 * h + d] ? r.push(C) : (o.push(C), a[C] = n));
        }
      }
    }
    var p = r;
    r = o, o = p, r.length = 0, n = -n;
  }
  var m = L3(g, a, t);
  return e ? m.concat(i.boundary) : m;
}
var M3 = I3, E3 = S3, R3 = B3, zI = x3, D3 = N3;
function K3(s) {
  return [Math.min(s[0], s[1]), Math.max(s[0], s[1])];
}
function H3(s, t) {
  return s[0] - t[0] || s[1] - t[1];
}
function P3(s) {
  return s.map(K3).sort(H3);
}
function xl(s, t, e) {
  return t in s ? s[t] : e;
}
function N3(s, t, e) {
  Array.isArray(t) ? (e = e || {}, t = t || []) : (e = t || {}, t = []);
  var i = !!xl(e, "delaunay", !0), n = !!xl(e, "interior", !0), o = !!xl(e, "exterior", !0), r = !!xl(e, "infinity", !1);
  if (!n && !o || s.length === 0)
    return [];
  var a = M3(s, t);
  if (i || n !== o || r) {
    for (var g = E3(s.length, P3(t)), c = 0; c < a.length; ++c) {
      var l = a[c];
      g.addTriangle(l[0], l[1], l[2]);
    }
    return i && R3(s, g), o ? n ? r ? zI(g, 0, r) : g.cells() : zI(g, 1, r) : zI(g, -1);
  } else
    return a;
}
function gi(s, t, e = 1e4) {
  for (let i = 0; i < t.length; i += e)
    s.push(...t.slice(i, i + e));
}
function F3(s) {
  let t = [], e = 0;
  for (e = 0; e < s.length - 1; e++)
    t.push([e, e + 1]);
  return t.push([e, 0]), t;
}
function k3(s, t) {
  const e = [];
  for (let i = 0; i < t.length; i++) {
    const n = t[i], [o, r] = n;
    i === 0 && e.push(s[o]), e.push(s[r]);
  }
  return e;
}
function V3(s) {
  let t = {}, e = {}, i = [], n = 0;
  for (let o = 0; o < s.length; o++) {
    const r = s[o], a = r[2] || 0, g = `${r[0]},${r[1]},${a}`;
    t[g] !== void 0 ? n++ : (t[g] = o - n, i.push(r));
    const c = t[g];
    e[o] = c;
  }
  return {
    indexMap: e,
    points: i
  };
}
function z3(s, t) {
  let e = [], i = {}, n = 0;
  for (let o = 0; o < s.length; o++) {
    const r = s[o];
    if (r[0] = t[r[0]], r[1] = t[r[1]], r[0] === r[1])
      continue;
    const a = `${r[0]},${r[1]}`;
    i[a] !== void 0 ? n++ : (i[a] = o - n, e.push(r));
  }
  return e;
}
function ZS(s) {
  let t = s.length, e = 0;
  for (let i = t - 1, n = 0; n < t; i = n++)
    e += s[i][0] * s[n][1] - s[n][0] * s[i][1];
  return e < 0;
}
const vl = [1, 1, 0, 1];
let X3 = new B(), US = new B();
const W3 = new B(), Z3 = new B(), U3 = new B(), OS = new B(), QS = new B(), YS = new B(), Gs = new B(), O3 = new Z(), Q3 = new Z(), Y3 = new Z(), jS = new B(), JS = new B(), j3 = new B(), qS = new B(), J3 = new B(), q3 = new B(), XI = new Z(), $S = [0, 0, 0], eb = [0, 0, 0], tb = [0, 0, 0], $3 = [], eY = (s, t, e) => {
  const i = $3;
  i.length = s;
  let n = 0;
  if (t === e) {
    for (n = 0; n < s; n++)
      i[n] = t;
    return i;
  }
  const r = (e - t) / s;
  for (let a = 0; a < s; a++) {
    const g = t + a * r;
    i[a] = g;
  }
  return i;
}, Ao = new B(), tY = (s, t, e, i) => (_.subtract(t, s, Ao), _.multiplyByScalar(
  Ao,
  e / i,
  Ao
), _.add(s, Ao, Ao), [Ao.x, Ao.y, Ao.z]), iY = new B(), nY = new B(), sY = (s, t, e, i, n, o, r, a = !0) => {
  r = r || X.RADIANS_PER_DEGREE;
  const g = !!o, c = i.slice(0);
  let l = 0;
  const h = t.length, d = new Array(h * 3), C = new Array(h * 2), p = new Array(h);
  let m = 0, b = 0, S = 0;
  for (l = 0; l < h; l++) {
    const x = t[l];
    if (d[m++] = x.x, d[m++] = x.y, d[m++] = x.z, g) {
      const L = o[l];
      C[b++] = L.x, C[b++] = L.y;
    }
    p[S++] = e[l];
  }
  const A = [], u = {}, y = {}, I = s.maximumRadius, M = X.chordLength(r, I), G = M * M;
  for (; c.length > 0; ) {
    const x = c.pop(), L = c.pop(), E = c.pop(), T = W3.fromArray(d, E * 3), R = Z3.fromArray(d, L * 3), w = U3.fromArray(d, x * 3), v = p[E], D = p[L], K = p[x];
    let P, k, V;
    g && (P = O3.fromArray(C, E * 2), k = Q3.fromArray(C, L * 2), V = Y3.fromArray(C, x * 2));
    const N = _.multiplyByScalar(
      _.normalize(T, OS),
      I,
      OS
    ), z = _.multiplyByScalar(
      _.normalize(R, QS),
      I,
      QS
    ), O = _.multiplyByScalar(
      _.normalize(w, YS),
      I,
      YS
    ), Q = _.magnitudeSquared(_.subtract(N, z, Gs)), U = _.magnitudeSquared(_.subtract(z, O, Gs)), $ = _.magnitudeSquared(_.subtract(O, N, Gs)), ee = Math.max(Q, U, $);
    let se, ie, Y, Ie;
    a && ee > G ? Q === ee ? (se = `${Math.min(E, L)} ${Math.max(E, L)}`, l = u[se], l == null ? (ie = _.add(T, R, Gs), _.multiplyByScalar(ie, 0.5, ie), d.push(ie.x, ie.y, ie.z), l = d.length / 3 - 1, u[se] = l, Ie = (v + D) * 0.5, p.push(Ie), y[se] = Ie, g && (Y = oe.add(P, k, Gs), oe.multiplyByScalar(Y, 0.5, Y), C.push(Y.x, Y.y))) : Ie = y[se], c.push(E, l, x), c.push(l, L, x)) : U === ee ? (se = `${Math.min(L, x)} ${Math.max(L, x)}`, l = u[se], l ? Ie = y[se] : (ie = _.add(R, w, Gs), _.multiplyByScalar(ie, 0.5, ie), d.push(ie.x, ie.y, ie.z), l = d.length / 3 - 1, u[se] = l, Ie = (D + K) * 0.5, p.push(Ie), y[se] = Ie, g && (Y = oe.add(k, V, Gs), oe.multiplyByScalar(Y, 0.5, Y), C.push(Y.x, Y.y))), c.push(L, l, E), c.push(l, x, E)) : $ === ee && (se = `${Math.min(x, E)} ${Math.max(x, E)}`, l = u[se], l ? Ie = y[se] : (ie = _.add(w, T, Gs), _.multiplyByScalar(ie, 0.5, ie), d.push(ie.x, ie.y, ie.z), l = d.length / 3 - 1, u[se] = l, Ie = (K + v) * 0.5, p.push(Ie), y[se] = Ie, g && (Y = oe.add(V, P, Gs), oe.multiplyByScalar(Y, 0.5, Y), C.push(Y.x, Y.y))), c.push(x, l, L), c.push(l, E, L)) : (A.push(E + n), A.push(L + n), A.push(x + n));
  }
  return {
    subdividedPositions: d,
    subdividedTexcoords: C,
    subdividedIndices: A,
    subdividedHeights: p
  };
};
class oY extends Qe {
  constructor(e) {
    super();
    f(this, "isPolygonGeometry", !0);
    f(this, "_useUV", !1);
    f(this, "_useEarCut", !1);
    f(this, "_sideUVNormalized", !1);
    f(this, "_sideUVReversed", !1);
    f(this, "_sideUVUseHeight", !1);
    f(this, "_rectangle", null);
    f(this, "triangulate", (e, i) => {
      const n = e.reduce((o, r) => o.concat(r.toArray()), []);
      return cr.exports(n, i);
    });
    f(this, "addGeoPolygonToVertices", (e, i, n = 0, o = 0, r, a, g, c, l, h, d, C, p, m, b = !1) => {
      let S = e.vertices;
      const A = e.dimensions;
      Array.isArray(d) || (d = vl);
      let u = 1 / 0, y = 1 / 0, I = -1 / 0, M = -1 / 0;
      for (let T = 0, R = S.length - A + 1; T < R; T += A)
        u = S[T] < u ? S[T] : u, y = S[T + 1] < y ? S[T + 1] : y, I = S[T] > I ? S[T] : I, M = S[T + 1] > M ? S[T + 1] : M;
      const G = new Z((I + u) / 2, (M + y) / 2), x = new B(), L = new B();
      let E = [];
      for (let T = 0; T <= i.length - A; T += A) {
        let R = [];
        for (let v = 0; v < 3; v++) {
          const K = i[T + v] * A;
          let P;
          A === 2 || b && !this.perPositionHeight ? P = new B(S[K], S[K + 1], n) : P = new B(S[K], S[K + 1], S[K + 2] + n), R.push(P), r.push(P.x, P.y, P.z), h.push(d[0], d[1], d[2], d[3]), this._pushHeightAndConcave(m, n, -1), CN(
            XI.set(S[K], S[K + 1]),
            G,
            l
          ), c.push(XI.x - u, XI.y - y), C.push(p), E.push(o + T + v);
        }
        let w = [0, 0, 1];
        A !== 2 && (x.subVectors(R[2], R[1]), L.subVectors(R[0], R[1]), x.cross(L), x.normalize(), w = x.toArray()), g.push(
          ...w,
          ...w,
          ...w
        );
      }
      b ? a.push(...E.reverse()) : a.push(...E);
    });
    f(this, "_encodeConcave", (e, i, n) => {
      let o = 0;
      return e && (o |= 1), i && (o |= 2), n && (o |= 4), o;
    });
    f(this, "_pushHeightAndConcave", (e, i, n, o, r, a, g) => {
      if (n === -1) {
        e.push(i, this._encodeConcave(!1, !1, !1));
        return;
      }
      const c = fN(o, r, a), l = Array.isArray(e);
      n === 0 ? l ? e.push(
        0,
        this._encodeConcave(!1, c, !1),
        i,
        this._encodeConcave(!0, c, !1)
      ) : (e.bottom.push(0, this._encodeConcave(!0, c, !1)), e.top.push(i, this._encodeConcave(!1, c, !1))) : n === g - 1 ? l ? e.push(
        i,
        this._encodeConcave(!1, c, !0),
        0,
        this._encodeConcave(!0, c, !0)
      ) : (e.bottom.push(
        0,
        this._encodeConcave(!0, c, !0)
      ), e.top.push(
        i,
        this._encodeConcave(!1, c, !0)
      )) : l ? e.push(
        i,
        this._encodeConcave(!1, c, !0),
        0,
        this._encodeConcave(!0, c, !0),
        0,
        this._encodeConcave(!0, c, !1),
        i,
        this._encodeConcave(!1, c, !1)
      ) : (e.bottom.push(
        0,
        this._encodeConcave(!0, c, !0),
        0,
        this._encodeConcave(!0, c, !1)
      ), e.top.push(
        i,
        this._encodeConcave(!1, c, !0),
        i,
        this._encodeConcave(!1, c, !1)
      ));
    });
    f(this, "_pushPosition", (e, i, n, o) => {
      const r = this._calculateHeights(i, n, o);
      e.push(
        i[0],
        i[1],
        r.bottom,
        i[0],
        i[1],
        r.top,
        n[0],
        n[1],
        r.nextTop,
        n[0],
        n[1],
        r.nextBottom
      );
    });
    f(this, "_pushNormal", (e, i, n) => {
      const o = this._calculateNormal(i, n);
      e.push(...o, ...o, ...o, ...o);
    });
    f(this, "_pushUV", (e, i, n, o, r) => {
      let g = 0, c = 0, l = n[0] - i[0], h = n[1] - i[1];
      const d = Math.sqrt(l * l + h * h);
      return this._sideUVUseHeight ? (g = o * 1, c = o * 1) : (g = 0, c = o * 1, this._sideUVNormalized && (c = 1), this._sideUVReversed && (g = c, c = 0)), e.push(
        r * 1,
        g,
        r * 1,
        c
      ), r += d, e.push(
        r * 1,
        c,
        r * 1,
        g
      ), r;
    });
    f(this, "_pushColor", (e, i, n = 4) => {
      for (let o = 0; o < n; o++)
        e.push(i[0], i[1], i[2], i[3]);
    });
    f(this, "_pushObjectIndex", (e, i) => {
      e.push(i, i, i, i);
    });
    f(this, "addSideFace", (e, i, n, o, r, a, g, c, l, h, d, C) => {
      let p = n;
      ZS(e) && e.reverse(), Array.isArray(l) || (l = vl);
      const m = e.length;
      let b = 0;
      for (let S = 0, A = m; S < A; S++) {
        let u = S === 0 ? e.length - 2 : S - 1, y = S === e.length - 1 ? 1 : S + 1, I = e[u], M = e[S], G = e[y];
        this._pushHeightAndConcave(
          C,
          i,
          S,
          I,
          M,
          G,
          m
        ), S !== e.length - 1 && (y = (S + 1) % m, G = e[y], this._pushPosition(o, M, G, i), this._pushNormal(a, M, G), this._pushColor(c, l), this._pushObjectIndex(h, d), b = this._pushUV(g, M, G, i, b), p = n + S * 4, r.push(
          p,
          p + 2,
          p + 1,
          p,
          p + 3,
          p + 2
        ));
      }
    });
    f(this, "subdivideLineCount", (e, i, n) => {
      const r = e.distanceTo(i) / n, a = Math.max(0, Math.ceil(Math.log2(r)));
      return Math.pow(2, a);
    });
    f(this, "subdivideLine", (e, i, n, o, r, a, g, c, l, h, d) => {
      const C = this.subdivideLineCount(e, i, a), p = e.distanceTo(i), m = p / C;
      this.extrude && this._extrudeValue > 0;
      let b = _.clone(e, new B()), S = _.clone(i, new B()), A = new B(), u = new B(), y = n, I = o;
      const M = g.scaleToGeodeticSurface(b);
      g.geodeticSurfaceNormal(b, A);
      const G = g.scaleToGeodeticSurface(S);
      g.geodeticSurfaceNormal(S, u), y += this._zOffset, I += this._zOffset, this.extrude && (y += c, I += c), _.multiplyByScalar(A, y, A), _.add(M, A, b), _.multiplyByScalar(u, I, u), _.add(G, u, S), h || (h = []), d || (d = []);
      const x = new B(), L = new B();
      let E = [], T, R;
      T = g.cartesianToCartographic(b, L).z, R = g.cartesianToCartographic(S, L).z, E = eY(C, T, R);
      const w = jS;
      let v = JS, D = qS, K = 0, P = 0;
      for (let k = 0; k < C; k++) {
        const V = x.fromArray(
          tY(b, S, m * k, p)
        );
        P = E[k], g.geodeticSurfaceNormal(V, w), D = g.scaleToGeodeticSurface(V, D), v = _.multiplyByScalar(w, this._zOffset + r, v), v = _.add(D, v, v), d[K] = v.x, d[K + 1] = v.y, d[K + 2] = v.z, k > 0 && l.bottom.push(0, this._encodeConcave(!0, !1, !1)), this.perPositionHeight ? (D = oe.clone(V, D), v = _.clone(D, v)) : (v = _.multiplyByScalar(w, P, v), v = _.add(D, v, v)), h[K] = v.x, h[K + 1] = v.y, h[K + 2] = v.z, k > 0 && l.top.push(c, this._encodeConcave(!0, !1, !1)), K += 3;
      }
      return g.geodeticSurfaceNormal(S, w), D = g.scaleToGeodeticSurface(S, D), v = _.multiplyByScalar(w, this._zOffset + r, v), v = _.add(D, v, v), d[K] = v.x, d[K + 1] = v.y, d[K + 2] = v.z, this.perPositionHeight ? v = oe.clone(S, v) : (v = _.multiplyByScalar(w, R, v), v = _.add(D, v, v)), h[K] = v.x, h[K + 1] = v.y, h[K + 2] = v.z, {
        topPositions: h,
        bottomPositions: d
      };
    });
    f(this, "crossVectors3", (e, i) => {
      const n = [];
      return n[0] = e[1] * i[2] - e[2] * i[1], n[1] = e[2] * i[0] - e[0] * i[2], n[2] = e[0] * i[1] - e[1] * i[0], n;
    });
    this.parameters = e, this._needsUpdate = !1, this._extrude = W(e.extrude, !1), this._extrudeValue = W(e.extrudeValue, 0), this._enableBottomFace = W(e.enableBottomFace, !1), this.perPositionHeight = W(e.perPositionHeight, !1), this._zOffset = W(e.zOffset, 0), this.cachedPositions = [], this.cachedObjectIndices = [];
  }
  setData(e) {
    this._needsUpdate = !0, this.cachedData = e, this.updateGeometry();
  }
  updateGeometry() {
    this.engine.map.isGlobe ? this.updateGeometry3D() : this.updateGeometryColumbus();
  }
  updateGeometry3D() {
    const e = this.cachedData, i = this.engine.map.map.ellipsoid || De.WGS84, n = [], o = [], r = [], a = [], g = [], c = [];
    let l = 0;
    const h = [], d = [], C = [], p = [], m = [], b = [];
    let S = 0;
    const A = jS;
    let u = JS;
    const y = j3;
    let I = qS;
    for (let G = 0; G < e.position.length; G++) {
      const x = e.position[G];
      e.index[G];
      const L = this.parameters.vertexHeights ? e.height[G] : this.extrudeValue, E = e.color ? pi(e.color[G]) : vl, T = lA(x[0], !0), R = Tv(T, i).map((ge) => ge), w = 0;
      if (T.length < 3)
        continue;
      for (let ge = 0; ge < T.length; ge++) {
        let lt = T[ge];
        i.scaleToGeodeticSurface(X3.fromArray(lt), US), T[ge] = US.toArray();
      }
      const v = sk(T, i), D = rk(
        v,
        T,
        i
      ), K = [];
      let P = Number.POSITIVE_INFINITY, k = Number.POSITIVE_INFINITY;
      P = Math.min(...D.map((ge) => ge.x)), k = Math.min(...D.map((ge) => ge.y));
      for (let ge = 0; ge < D.length; ge++) {
        const lt = D[ge], Ke = lt.x - P, Pe = lt.y - k;
        K.push(
          new Z(Ke, Pe)
        );
      }
      const V = this.triangulate(D), N = T.map((ge) => new B(...ge));
      let z = this.parameters.granularity;
      const O = this.extrude && this._enableBottomFace, Q = !(this.extrude && this.perPositionHeight), U = O || Q, {
        subdividedPositions: $,
        subdividedTexcoords: ee,
        subdividedIndices: se,
        subdividedHeights: ie
      } = sY(
        i,
        N,
        R,
        V,
        l,
        K,
        z,
        U
      );
      let Y = $.length;
      const Ie = g.length, xe = [];
      let fe = 0;
      if (Q) {
        for (let ge = 0; ge < Y; ge += 3)
          y.fromArray($, ge), i.geodeticSurfaceNormal(y, A), I = i.scaleToGeodeticSurface(y, I), fe = ie[ge / 3], this.extrudeValue && !this.perPositionHeight && (fe = 0), u = _.multiplyByScalar(A, this._zOffset + L + fe, u), u = _.add(I, u, u), xe[ge] = u.x, xe[ge + 1] = u.y, xe[ge + 2] = u.z, g[ge + Ie] = A.x, g[ge + 1 + Ie] = A.y, g[ge + 2 + Ie] = A.z, o.push(L, this._encodeConcave(!1, !1, !1));
        gi(n, xe), gi(r, se), gi(c, ee);
      } else {
        for (let ge = 0; ge < N.length; ge++) {
          const lt = N[ge], Ke = K[ge];
          i.geodeticSurfaceNormal(lt, A), g[ge * 3 + Ie] = A.x, g[ge * 3 + 1 + Ie] = A.y, g[ge * 3 + 2 + Ie] = A.z, I = _.clone(lt, I), u = _.multiplyByScalar(A, this._zOffset + R[ge] + L, u), u = _.add(I, u, u), xe[ge * 3] = u.x, xe[ge * 3 + 1] = u.y, xe[ge * 3 + 2] = u.z, o.push(L, this._encodeConcave(!1, !1, !1)), c.push(Ke.x, Ke.y);
        }
        n.push(...xe), r.push(...V);
      }
      const be = g.length;
      if (O)
        for (let ge = 0; ge < Y; ge += 3)
          y.fromArray($, ge), i.geodeticSurfaceNormal(y, A), I = i.scaleToGeodeticSurface(y, I), u = _.multiplyByScalar(A, this._zOffset + w, u), u = _.add(I, u, u), $[ge] = u.x, $[ge + 1] = u.y, $[ge + 2] = u.z, g[ge + be] = -A.x, g[ge + 1 + be] = -A.y, g[ge + 2 + be] = -A.z, o.push(0, this._encodeConcave(!0, !1, !1));
      let pe = xe.length / 3;
      if (this.extrude && this._enableBottomFace && (n.push(...$), pe += $.length / 3), l += pe, this.extrude && this._enableBottomFace) {
        const ge = [], lt = xe.length / 3, Ke = se.length - 1;
        for (let Pe = 0; Pe <= Ke; Pe++)
          ge.push(se[Pe] + lt);
        gi(c, ee), gi(r, ge.reverse());
      }
      const Te = Array.from({ length: pe }, () => E).flat();
      if (gi(a, Te), this.extrude) {
        ZS(D.map((rt) => rt.toArray())) && (N.reverse(), D.reverse());
        const {
          edgePositions: lt,
          edgeHeightAndConcaves: Ke,
          edgeIndices: Pe,
          edgeNormals: nt,
          edgeUvs: Ve
        } = this.computeWallGeometry3D(
          N,
          D,
          i,
          X.RADIANS_PER_DEGREE,
          S,
          L,
          R,
          w
        );
        h.push(...lt), d.push(...Ke), C.push(...Pe), p.push(...nt), m.push(...Array.from({ length: lt.length / 3 }, () => E).flat()), b.push(...Ve), S += lt.length / 3;
      }
    }
    const M = r.length;
    this.extrude && (C.forEach((G, x) => C[x] = G + l), gi(n, h), gi(o, d), gi(r, C), gi(g, p), gi(a, m), gi(c, b)), this.cachedPositions = n, this.setAttribute("position", new ae(n, 3)), this.setAttribute("heightAndConcave", new ae(o, 2)), this.parameters.vertexColors && this.setAttribute("aColor", new ae(a, 4)), this.setAttribute("uv", new ae(c, 2)), this.setAttribute("normal", new ae(g, 3)), this.setIndex(r), this.clearGroups(), this.addGroup(0, M, 1), this.extrude && this.addGroup(M, r.length - M, 0), this.computeBoundingSphere(), this._needsUpdate = !1;
  }
  updateGeometryColumbus() {
    let e = this.cachedData, i = null, n = null;
    const o = [], r = [], a = [], g = [], c = [];
    let l = [];
    const h = [], d = [], C = [], p = [], m = [], b = [], S = [], A = [], u = e.position && e.position.length || 0;
    for (let M = 0; M < u; M++) {
      const G = e.position[M], x = e.index[M], L = e.color ? pi(e.color[M]) : vl, E = this.parameters.vertexHeights ? e.height[M] : this.extrudeValue, T = this._useUV && e.uvRotation ? e.uvRotation[M] : 0;
      let R = !1;
      const w = G[0], v = F3(w), {
        indexMap: D,
        points: K
      } = V3(w), P = z3(v, D);
      i = cr.exports.flatten([K]);
      const k = k3(K, P);
      try {
        n = D3(K, P, {
          interior: !0,
          exterior: !1
        }).flat(), R = n.length === 0, (R || this._useEarCut) && (i = cr.exports.flatten(G), n = cr.exports(i.vertices, i.holes, i.dimensions));
      } catch {
        n = cr.exports(i.vertices, i.holes, i.dimensions);
      }
      this.extrude && this._enableBottomFace && this.addGeoPolygonToVertices(
        i,
        n,
        this._zOffset,
        o.length / 3,
        o,
        l,
        r,
        a,
        T,
        h,
        L,
        g,
        x,
        c,
        !0
      ), this.addGeoPolygonToVertices(
        i,
        n,
        this._zOffset + E,
        o.length / 3,
        o,
        l,
        r,
        a,
        T,
        h,
        L,
        g,
        x,
        c
      ), this.extrude && E > 0 && this.addSideFace(
        k,
        E,
        d.length / 3,
        d,
        A,
        C,
        p,
        S,
        L,
        m,
        x,
        b
      );
    }
    const y = l.length;
    let I = o.length / 3;
    for (let M = 0; M < A.length; M++)
      A[M] += I;
    gi(o, d), gi(r, C), gi(h, S), gi(a, p), gi(c, b), gi(l, A), this.cachedPositions = o, this.cachedObjectIndices = g, this.setAttribute("position", new ae(o, 3)), this.parameters.vertexColors && this.setAttribute("aColor", new ae(h, 4)), this._useUV ? this.setAttribute("uv", new ae(a, 2)) : this.deleteAttribute("uv"), this.setAttribute("heightAndConcave", new ae(c, 2)), this.setAttribute("normal", new ae(r, 3)), this.setIndex(l), this.clearGroups(), this.addGroup(0, y, 1), this.extrude && this.addGroup(y, l.length - y, 0), this.computeBoundingSphere(), this._needsUpdate = !1;
  }
  _calculateHeights(e, i, n) {
    const [o, r] = [e[2] || 0, i[2] || 0], a = this._zOffset || 0, g = this.perPositionHeight;
    return {
      bottom: a + (g ? o : 0),
      nextBottom: a + (g ? r : 0),
      top: o + a + n,
      nextTop: r + a + n
    };
  }
  _calculateNormal(e, i) {
    const n = i[0] - e[0], o = i[1] - e[1], r = Math.hypot(n, o);
    return [o / r, -n / r, 0];
  }
  computeWallGeometry3D(e, i, n, o, r, a, g, c) {
    let l, h, d, C, p, m = e.length;
    const b = X.chordLength(
      o,
      n.maximumRadius
    );
    let S = 0;
    for (d = 0; d < m; d++)
      S += this.subdivideLineCount(
        e[d],
        e[(d + 1) % m],
        b
      );
    const A = S + m;
    h = A * 3, l = new Array(h * 2);
    const u = [], y = [], I = {
      bottom: [],
      top: []
    };
    let M = 0, G = 0;
    for (d = 0; d < m + 1; d++) {
      C = e[d], p = e[(d + 1) % m], this.perPositionHeight && (M = g[d], G = g[(d + 1) % m]);
      let N = d === 0 ? m - 1 : d - 1, z = d === m ? 0 : d, O = d === m - 1 ? 0 : z + 1;
      if (i[N].toArray($S), i[z].toArray(eb), i[O].toArray(tb), this._pushHeightAndConcave(
        I,
        a,
        d,
        $S,
        eb,
        tb,
        m + 1
      ), d === m)
        continue;
      const {
        topPositions: Q,
        bottomPositions: U
      } = this.subdivideLine(
        C,
        p,
        M,
        G,
        c,
        b,
        n,
        a,
        I
      );
      u.push(...U), y.push(...Q);
    }
    l = [...u, ...u];
    const x = [...I.top, ...I.bottom];
    m = l.length;
    let L = [], E = 0;
    for (m /= 6, d = 0; d < m; d++) {
      const N = d, z = N + 1, O = N + m, Q = O + 1;
      C = iY.fromArray(l, N * 3), p = nY.fromArray(l, z * 3), !_.equalsEpsilon(
        C,
        p,
        X.EPSILON10,
        X.EPSILON10
      ) && (L[E++] = N + r, L[E++] = O + r, L[E++] = z + r, L[E++] = z + r, L[E++] = O + r, L[E++] = Q + r);
    }
    l = [...y, ...u], m = y.length / 3;
    const T = [];
    T.length = l.length;
    const R = [];
    R.length = m * 4;
    let w = new B(), v = new B(), D = new B(), K = !0, P = new B();
    const k = [];
    let V = 0;
    for (d = 0; d < A; d++) {
      w.fromArray(y, d * 3), v.fromArray(u, d * 3), D.fromArray(y, (d + 1) * 3);
      const N = n.cartesianToCartographic(w).z, z = n.cartesianToCartographic(v).z;
      let O = d * 2, Q = (d + h / 3) * 2;
      if (D.x === void 0 ? (R[O] = V, R[O + 1] = N, R[Q] = V, R[Q + 1] = z) : (k.push(w.distanceTo(D)), R[O] = V, R[O + 1] = N, R[Q] = V, R[Q + 1] = z, V += k[d]), (_.equalsEpsilon(
        w,
        D,
        X.EPSILON10
      ) || d === A - 1) && (K = !1), K) {
        const ee = _.subtract(
          D,
          w,
          q3
        ), se = _.subtract(
          v,
          w,
          J3
        );
        P = _.normalize(
          _.cross(se, ee, P),
          P
        );
      }
      let U = d * 3, $ = d * 3 + h;
      T[U] = P.x, T[U + 1] = P.y, T[U + 2] = P.z, T[$] = P.x, T[$ + 1] = P.y, T[$ + 2] = P.z, K = !0;
    }
    return {
      edgePositions: l,
      edgeIndices: L,
      edgeNormals: T,
      edgeUvs: R,
      edgeHeightAndConcaves: x,
      totalDistance: Array.from({ length: A * 2 }, () => V)
    };
  }
  get extrude() {
    return this._extrude;
  }
  set extrude(e) {
    const i = !!e;
    i !== this._extrude && (this._extrude = i, this._needsUpdate = !0);
  }
  get extrudeValue() {
    return this._extrudeValue;
  }
  set extrudeValue(e) {
    !isNaN(e) && e >= 0 && e !== this._extrudeValue && (this._extrudeValue = e, this._needsUpdate = !0);
  }
  get sideUVNormalized() {
    return this._sideUVNormalized;
  }
  set sideUVNormalized(e) {
    e !== this._sideUVNormalized && (this._extrude && (this._needsUpdate = !0), this._sideUVNormalized = e);
  }
  get sideUVReversed() {
    return this._sideUVReversed;
  }
  set sideUVReversed(e) {
    e !== this._sideUVReversed && (this._extrude && (this._needsUpdate = !0), this._sideUVReversed = e);
  }
  get sideUVUseHeight() {
    return this._sideUVUseHeight;
  }
  set sideUVUseHeight(e) {
    e !== this._sideUVUseHeight && (this._extrude && (this._needsUpdate = !0), this._sideUVUseHeight = e);
  }
  get useUV() {
    return this._useUV;
  }
  set useUV(e) {
    e !== this._useUV && (this._needsUpdate = !0, this._useUV = e);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  set useEarCut(e) {
    this._useEarCut !== e && (this._useEarCut = e);
  }
}
const rY = `#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>

#ifdef USE_MAP
    varying vec2 vUv;
    uniform float mapScale;
#else
    #ifdef MVT_USE_VERTEX_COLOR
        attribute vec4 aColor;
        varying vec4 vColor;
    #endif
#endif

uniform float normalOffset;

#ifdef USE_AO
attribute vec2 heightAndConcave;

varying float v_concave;
varying float v_h;
varying float v_ground;
#endif

#include <normal_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

void main() {

    #include <mvt_selective_vertex>

    #ifdef USE_MAP
        vUv = uv / mapScale;
    #else
        #ifdef MVT_USE_VERTEX_COLOR
            vColor = aColor;
        #endif
    #endif

    #include <begin_vertex>

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );
    viewCoord.xyz += normalize(transformedNormal) * 0.0;

    #ifdef USE_AO
    v_h = heightAndConcave.x;
    float encodeConcave = heightAndConcave.y;
    v_ground = mod(encodeConcave, 2.0);
    float concave = mod(floor(encodeConcave * 0.5), 2.0);
    float start = mod(floor(encodeConcave * 0.25), 2.0);
    concave = pow(concave, 2.2);
    v_concave = mix(concave, -concave, start);
    #endif

    gl_Position = projectionMatrix * viewCoord;
    #include <fog_vertex>
    #include <logdepthbuf_vertex>

}

`, aY = `#define GLSLIFY 1
#include <common>

#ifdef USE_MAP
    varying vec2 vUv;
    uniform sampler2D map;
    uniform vec2 mapLength;
#else
    #ifdef MVT_USE_VERTEX_COLOR
        varying vec4 vColor;
    #else
        uniform vec3 color;
    #endif
#endif

uniform float opacity;

#ifdef USE_AO
uniform float concaveIntensity;
uniform float heightIntensity;

varying float v_concave;
varying float v_ground;
varying float v_h;
#endif

#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    #ifdef USE_MAP
        gl_FragColor = texture2D(map, vec2(mod(vUv.x, mapLength.x) / mapLength.x, mod(vUv.y, mapLength.y) / mapLength.y));
    #else
        #ifdef MVT_USE_VERTEX_COLOR
            gl_FragColor = vColor;
        #else
            gl_FragColor = vec4(color, 1.0);
        #endif
    #endif

    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #if ( NUM_DIR_LIGHTS > 0 )
        // \u6839\u636E\u65B9\u5411\u5149\u7684\u65B9\u5411\u4E0E\u6CD5\u5411\uFF0C\u6765\u8BA1\u7B97\u989C\u8272\u8870\u51CF\u7A0B\u5EA6\uFF0C\u503C\u8303\u56F4\u4E3A-1~1\uFF0C\u7ED9\u91CD\u6620\u5C04\u52300.8~1\u7684\u8303\u56F4
        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);
        gl_FragColor = vec4(gl_FragColor.rgb * (normalLightIntensity / 10.0 + 0.9), gl_FragColor.a);
    #endif

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #ifdef USE_AO
    float ao_shade = 1.0;
    float concave = v_concave * v_concave;
    float intensity = concaveIntensity;
    float x_shade = mix(1.0, mix(0.6, 0.75, min(0.01, 1.0)), intensity) + 0.1 * intensity;
    ao_shade *= mix(1.0, x_shade * x_shade * x_shade, concave);

    intensity = heightIntensity;
    float h_floors = v_h / 3.0;
    float y_shade = 1.0 - 0.9 * intensity * min(v_ground, 1.0);
    ao_shade *= (1.0 - 0.08 * intensity) * (y_shade + (1.0 - y_shade) * (1.0 - pow(1.0 - min(h_floors / 16.0, 1.0), 16.0))) + 0.08 * intensity * min(h_floors / 160.0, 1.0);

    gl_FragColor.rgb *= ao_shade;
    #endif

    #include <mvt_selective_fragment>
    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>
    
}

`, gY = new Ot(), cY = we.merge([
  Xt.fog,
  Xt.lights,
  zn,
  Ho,
  {
    isEmissive: { value: !1 },
    opacity: { value: 1 },
    color: { value: [0, 1, 1] },
    vertexColors: { value: !1 },
    map: { value: void 0 },
    mapLength: { value: new Z() },
    mapSrc: { value: "" },
    mapScale: { value: 1 },
    normalOffset: { value: 0 },
    concaveIntensity: { value: 0.2 },
    heightIntensity: { value: 0.4 }
  }
]);
class lY extends di {
  constructor(t) {
    super(), this.name = "PolygonMaterial", this.isPolygonMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = aY, this.vertexShader = rY, Object.defineProperty(this, "mapSrc", {
      get: function() {
        return this.uniforms.map.value;
      },
      set: function(e) {
        const i = this.mapSrc, n = this.userData[this.urlCacheKey], o = this;
        if (n !== e) {
          if (i && i.dispose(), !e) {
            this.uniforms.map.value = null, delete this.defines.USE_MAP, delete this.userData[this.urlCacheKey];
            return;
          }
          gY.load(e, function(r) {
            r.colorSpace = gt, o.uniforms.map.value = r, o.uniforms.mapLength.value = new Z(r.image.naturalWidth, r.image.naturalHeight), o.userData[o.urlCacheKey] = e, o.defines.USE_MAP = !0, o.needsUpdate = !0;
          });
        }
      }
    }), Object.assign(this.uniforms, we.clone(cY)), t.mapSrc && (this.mapSrc = t.mapSrc, delete t.mapSrc), oi(this, [
      "opacity",
      "mapScale",
      "isEmissive",
      "normalOffset",
      "concaveIntensity",
      "heightIntensity"
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["useAO", "USE_AO"]
    ]), Po(this), No(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const hY = `#define GLSLIFY 1
#include <common>
#include <fog_pars_vertex>

#ifdef USE_MAP
    varying vec4 vSouthWestCorner;
    varying vec2 vInversePlaneExtents;

    uniform float mapScale;
    uniform vec4 rectBounds;
#else
    #ifdef MVT_USE_VERTEX_COLOR
        attribute vec4 aColor;
        varying vec4 vColor;
    #endif
#endif

uniform float normalOffset;

#include <normal_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <mvt_selective_pars_vertex>

// \u6A21\u62DFglDepthClamp,\u89E3\u51B3ZFail\u7684\u8FDC\u5E73\u9762\u88AB\u89C6\u9525\u4F53\u6240\u88C1\u526A\u7684\u95EE\u9898
#if !defined( USE_LOGDEPTHBUF )
    varying float vWindowZ;
#endif

vec4 depthClamp(vec4 coords) {
    #if !defined( USE_LOGDEPTHBUF )
        vWindowZ = (0.5 * (coords.z / coords.w) + 0.5) * coords.w;

        coords.z = 0.0; 
    #else 
        coords.z = min(coords.z, coords.w);
    #endif

    return coords;
}

void main() {

    #include <mvt_selective_vertex>

    #ifdef USE_MAP
        float eastExtend = rectBounds.z - rectBounds.x;
        float northExtend = rectBounds.w - rectBounds.y;

        vInversePlaneExtents = vec2(1.0 / eastExtend, 1.0 / northExtend);
        vSouthWestCorner = modelMatrix * vec4(rectBounds.xy, 0.0, 1.0);
    #else
        #ifdef MVT_USE_VERTEX_COLOR
            vColor = aColor;
        #endif
    #endif

    #include <begin_vertex>

    #include <beginnormal_vertex>
    #include <defaultnormal_vertex>
    #include <normal_vertex>

    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );
    viewCoord.xyz += normalize(transformedNormal) * normalOffset;

    gl_Position = projectionMatrix * viewCoord;
    #include <fog_vertex>
    #include <logdepthbuf_vertex>

    gl_Position = depthClamp(gl_Position);

}`, dY = `#define GLSLIFY 1
#include <common>

#include <packing>

varying vec4 vSouthWestCorner;
varying vec2 vInversePlaneExtents;
uniform mat4 inverseProjection;
uniform sampler2D depthTexture;
uniform vec2 resolution;
uniform float cameraNear;
uniform float cameraFar;
uniform mat4 viewInverseMatrix;
uniform float pixelRatio;

#ifdef USE_MAP
    uniform sampler2D map;
#endif

float linearize_depth(in float depth, in float cameraNear, in float cameraFar){
    float a = cameraFar / (cameraFar - cameraNear);
    float b = cameraFar * cameraNear / (cameraNear - cameraFar);
    return a + b / depth;
}

float reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){
    float depth = texture2D(tDepth, uv).x;
    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;
}

float getDepthFromTexture(sampler2D tDepth, vec2 uv) {
    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
        return linearize_depth(reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);
    #else
        return texture2D(tDepth, uv).x;
    #endif
}

vec3 getWorldPositionFromDepth(float depth, vec2 vUV) {
    float z = depth * 2.0 - 1.0;
    vec4 clipSpacePosition = vec4(vUV * 2.0 - 1.0, z, 1.0);

    vec4 viewSpacePosition = inverseProjection * clipSpacePosition;
    
    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;

    return worldSpacePosition.xyz / worldSpacePosition.w;
}

#ifdef USE_NORMAL

    vec3 vectorFromOffset(vec3 worldCoordinate, vec2 positiveOffset) {
        vec2 glFragCoordXY = gl_FragCoord.xy;
        // Sample depths at both offset and negative offset
        float upOrRightLogDepth = getDepthFromTexture(depthTexture, (glFragCoordXY + positiveOffset) / resolution.xy / pixelRatio);
        float downOrLeftLogDepth = getDepthFromTexture(depthTexture, (glFragCoordXY - positiveOffset) / resolution.xy / pixelRatio);
        // Explicitly evaluate both paths
        // Necessary for multifrustum and for edges of the screen
        bvec2 upOrRightInBounds = lessThan(glFragCoordXY + positiveOffset, resolution.xy * pixelRatio);
        float useUpOrRight = float(upOrRightLogDepth > 0.0 && upOrRightInBounds.x && upOrRightInBounds.y);
        float useDownOrLeft = float(useUpOrRight == 0.0);

        vec3 upOrRightEC = getWorldPositionFromDepth(upOrRightLogDepth, (glFragCoordXY + positiveOffset) / resolution.xy / pixelRatio);
        vec3 downOrLeftEC = getWorldPositionFromDepth(downOrLeftLogDepth, (glFragCoordXY - positiveOffset) / resolution.xy / pixelRatio);
        return (upOrRightEC - worldCoordinate.xyz) * useUpOrRight + (worldCoordinate.xyz - downOrLeftEC) * useDownOrLeft;
    }

#endif

#ifdef MVT_USE_VERTEX_COLOR
    varying vec4 vColor;
#else
    uniform vec3 color;
#endif

uniform float opacity;

// \u6A21\u62DFglDepthClamp
#if !defined( USE_LOGDEPTHBUF )
varying float vWindowZ;

void writeDepthClamp() {
    
    gl_FragDepthEXT = clamp(vWindowZ * gl_FragCoord.w, 0.0, 1.0);
    
}
#endif

#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <mvt_selective_pars_fragment>

void main() {
    vec2 coordUV = gl_FragCoord.xy / resolution / pixelRatio;
    float depth = getDepthFromTexture(depthTexture, coordUV);
    vec3 worldCoordinate = getWorldPositionFromDepth(depth, coordUV);

    #ifdef MVT_USE_VERTEX_COLOR
        gl_FragColor = vColor;
    #else
        gl_FragColor = vec4(color, 1.0);
    #endif

    #ifdef USE_MAP

        vec2 fragUv = vec2(0.0);
        fragUv.x = (worldCoordinate.x - vSouthWestCorner.x) * vInversePlaneExtents.x;
        fragUv.y = (worldCoordinate.y - vSouthWestCorner.y) * vInversePlaneExtents.y;

        vec4 mapColor = texture2D(map, fragUv);

        vec3 fragColor = vec3(0.0);
        #ifdef MVT_USE_VERTEX_COLOR
            mapColor *= vColor;
        #else
            mapColor *= vec4(color, 1.0);
        #endif

        gl_FragColor = mapColor;
    #endif

    #ifdef USE_NORMAL
        // Compute normal by sampling adjacent pixels in 2x2 block in screen space
        vec3 downUp = vectorFromOffset(worldCoordinate, vec2(0.0, 1.0));
        vec3 leftRight = vectorFromOffset(worldCoordinate, vec2(1.0, 0.0));
        vec3 normalWC = normalize(cross(leftRight, downUp));
    #endif

    gl_FragColor.a *= opacity;
    if (gl_FragColor.a <= 0.) {
        discard;
    }

    #ifdef OPAQUE
        gl_FragColor.a = 1.0;
    #endif

    #if !defined( USE_LOGDEPTHBUF ) 
        vFragDepth = writeDepthClamp();
    #endif

    #include <mvt_selective_fragment>
    #include <fog_fragment>
    #include <logdepthbuf_fragment>
    #include <tonemapping_fragment>
    #include <colorspace_fragment>

}`, uY = new Ot(), IY = we.merge([
  Xt.fog,
  Xt.lights,
  zn,
  Ho,
  {
    isEmissive: { value: !1 },
    opacity: { value: 1 },
    color: { value: new B(1, 1, 1) },
    vertexColors: { value: !1 },
    useNormal: { value: !1 },
    map: { value: void 0 },
    mapLength: { value: new Z() },
    mapSrc: { value: "" },
    mapScale: { value: 1 },
    normalOffset: { value: 0 },
    rectBounds: { value: new Me(0, 0, 0, 0) },
    inverseProjection: { value: new J() },
    depthTexture: { value: null },
    cameraNear: { value: 0 },
    cameraFar: { value: 0 },
    viewInverseMatrix: { value: new J() },
    cameraProjectionMatrix: { value: new J() }
  }
]);
class AY extends di {
  constructor(t) {
    super(), this.name = "ShadowVolumeMaterial", this.isShadowMaterial = !0, this.lights = !0, this.fog = !0, this.fragmentShader = dY, this.vertexShader = hY, Object.defineProperty(this, "mapSrc", {
      get: function() {
        return this.uniforms.map.value;
      },
      set: function(e) {
        const i = this.mapSrc, n = this.userData[this.urlCacheKey], o = this;
        if (n !== e) {
          if (i && i.dispose(), !e) {
            this.uniforms.map.value = null, delete this.defines.USE_MAP, delete this.userData[this.urlCacheKey];
            return;
          }
          uY.load(e, function(r) {
            r.colorSpace = gt, o.uniforms.map.value = r, o.uniforms.mapLength.value = new Z(r.image.naturalWidth, r.image.naturalHeight), o.userData[o.urlCacheKey] = e, o.defines.USE_MAP = !0, o.needsUpdate = !0;
          });
        }
      }
    }), Object.assign(this.uniforms, we.clone(IY)), t.mapSrc && (this.mapSrc = t.mapSrc, delete t.mapSrc), oi(this, [
      "opacity",
      "mapScale",
      "isEmissive",
      "normalOffset",
      "rectBounds"
    ]), Xn(this, [
      "color"
    ]), ri(this, [
      ["vertexColors", "MVT_USE_VERTEX_COLOR"],
      ["useNormal", "USE_NORMAL"]
    ]), Po(this), No(this), this.emissiveEnabled = !0, this.emissive = [0, 0, 0], this.setValues(t);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(), super.dispose();
  }
}
const Ig = {};
class Cf extends Fo {
  constructor(e = {}) {
    super();
    f(this, "isEventEntitySupported", !0);
    f(this, "geometry");
    f(this, "material");
    f(this, "extrude");
    f(this, "extrudeValue");
    f(this, "color");
    f(this, "vertexColors");
    f(this, "emissive");
    f(this, "opacity");
    f(this, "mapSrc");
    f(this, "mapScale");
    this.isPolygon = !0, this.parameters = e, this._nearScale = e.nearScale || 5, this.isGroundPrimitive = e.isGroundPrimitive, this.isDynamic = e.isDynamic || !1, this.needReMapUv = this.isGroundPrimitive, this.excludeElements = e.excludeElements || [], this._sharedResourcesId = this.getSharedResourceFromExcludeElement(this.excludeElements), this.renderOrder = e.renderOrder || 0, this.defineGeometryProxyProperties([
      "extrude",
      "extrudeValue",
      "vertexHeights",
      "enableBottomFace",
      "zOffset",
      "perPositionHeight"
    ]), this.defineMaterialProxyProperties([
      "transparent",
      "opacity",
      "color",
      "vertexColors",
      "emissive",
      "mapSrc",
      "mapScale",
      "side",
      "depthWrite",
      "colorWrite",
      "stencilWrite",
      "stencilFunc",
      "stencilZFail",
      "stencilZPass",
      "normalOffset",
      "useNormal",
      "useAO",
      "concaveIntensity",
      "heightIntensity"
    ]);
  }
  initObject() {
    const { extrude: e, extrudeValue: i, vertexHeights: n, enableBottomFace: o, zOffset: r, ...a } = this.parameters, g = this.geometry = new oY(this.parameters);
    g.engine = this.engine;
    let c = null;
    if (this.isGroundPrimitive) {
      if (c = this.material = new AY(a), this.needReMapUv) {
        const l = this._sharedResourcesId, h = Ig[l];
        if (h) {
          const { depthTexture: d, depthRenderTarget: C } = h;
          h.refCount++, this.depthRenderTarget = C, c.uniforms.depthTexture.value = d;
        } else {
          const d = this.engine.rendering.resolution, C = this.engine.rendering.pixelRatio, p = this.depthRenderTarget = new It(d.x * C, d.y * C), m = new Dh();
          m.type = FA, p.depthTexture = m, c.uniforms.depthTexture.value = m, Ig[l] = {
            depthRenderTarget: p,
            depthTexture: m,
            refCount: 1,
            lastRenderFrame: -1
          };
        }
      }
    } else
      c = this.material = new lY(a);
    c.setCommonUniforms(this.engine.rendering.uniforms);
  }
  onBeforeSceneRenderHook(e, i, n, o) {
    if (!this.needReMapUv)
      return;
    const r = o.frameCount, a = Ig[this._sharedResourcesId];
    if (a) {
      if (a.lastRenderFrame !== r) {
        const g = e.renderer;
        g.setRenderTarget(this.depthRenderTarget);
        let c = [];
        i.traverse((h) => {
          (h.isGroundPrimitive || this.excludeElements.includes(h)) && (h.originVisible = h.visible, h.visible = !1, c.push(h));
        });
        let l = n.near;
        n.near = l * this.nearScale, n.updateProjectionMatrix(), g.render(i, n);
        for (let h = 0; h < c.length; h++)
          c[h].visible = c[h].originVisible;
        this.material.uniforms.cameraNear.value = n.near, this.material.uniforms.cameraFar.value = n.far, this.material.uniforms.viewInverseMatrix.value.copy(n.matrixWorld), this.material.uniforms.pixelRatio.value = e.rendering.pixelRatio, this.material.uniforms.inverseProjection.value.copy(n.projectionMatrixInverse.clone()), n.near = l, n.updateProjectionMatrix(), g.setRenderTarget(null);
      } else {
        let g = n.near;
        n.near = g * this.nearScale, n.updateProjectionMatrix(), this.material.uniforms.cameraNear.value = n.near, this.material.uniforms.cameraFar.value = n.far, this.material.uniforms.viewInverseMatrix.value.copy(n.matrixWorld), this.material.uniforms.pixelRatio.value = e.rendering.pixelRatio, this.material.uniforms.inverseProjection.value.copy(n.projectionMatrixInverse.clone()), n.near = g, n.updateProjectionMatrix();
      }
      a.lastRenderFrame = r;
    }
  }
  _updateData() {
    let e = this.dataSource.data;
    if (this.geometry.setData(e), this.geometry.computeBoundingSphere(), this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox(), this.needsUpdate = !1, this.needReMapUv) {
      const i = this.computeRectangleBounds();
      this.material.rectBounds.fromArray(i);
    }
    this.needsUpdate = !1;
  }
  computeRectangleBounds() {
    const i = this.geometry.attributes.position.array, n = i.length;
    let o = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, g = Number.NEGATIVE_INFINITY;
    for (let c = 0; c < n; c += 3) {
      const l = i[c], h = i[c + 1];
      o = Math.min(o, l), a = Math.min(a, h), r = Math.max(r, l), g = Math.max(g, h);
    }
    return [
      o,
      a,
      r,
      g
    ];
  }
  afterGeometryUpdate() {
    this.makeGeometryOffsetPosition(this.geometry, this.geometry.cachedPositions), this.geometry.computeBoundingSphere(), this.geometry.computeBoundingBox();
  }
  getEntityIndexByFace(e, i) {
    return this.geometry.cachedObjectIndices[i];
  }
  getSharedResourceFromExcludeElement(e) {
    let i = "";
    return e.length > 0 && (i = e.map((o) => o.uuid).join("-")), i;
  }
  dispose() {
    if (this.needReMapUv) {
      const e = Ig[this._sharedResourcesId];
      if (e && (e.refCount--, e.refCount === 0)) {
        const {
          depthRenderTarget: i,
          depthTexture: n
        } = e;
        i.dispose(), n.dispose(), delete Ig[this._sharedResourcesId];
      }
    }
    super.dispose();
  }
  get nearScale() {
    return this._nearScale;
  }
  set nearScale(e) {
    this._nearScale = e;
  }
}
Cf.prototype.raycast = le.prototype.raycast;
Cf.prototype._computeIntersections = le.prototype._computeIntersections;
Cf.prototype.getVertexPosition = le.prototype.getVertexPosition;
jT(JT);
window.MAPVTHREE_VERSION = "1.0.0";
window._hmt = window._hmt || [], function() {
  let s = document.createElement("script");
  s.src = "https://hm.baidu.com/hm.js?1baab79677df9b34e5e6db4315726094";
  let t = document.getElementsByTagName("script")[0];
  t.parentNode.insertBefore(s, t);
}();
export {
  jC as BaiduMapConfig,
  EV as BaiduVectorTileProvider,
  Jk as BingImageryTileProvider,
  cg as CSVDataSource,
  Z_ as CesiumConfig,
  MY as CesiumTerrainTileProvider,
  kY as Circle,
  FY as ClusterPoint,
  wv as DOMOverlay,
  Ds as DataItem,
  Gi as DataSource,
  rv as Default3DTiles,
  ID as DefaultSky,
  NY as DomPoints,
  TY as DynamicSky,
  _p as DynamicWeather,
  gh as EmptySky,
  vY as Engine,
  T_ as FastTileLoaderStrategy,
  ZY as FatLine,
  Nd as GEOMETRY_TYPE_LINE,
  lc as GEOMETRY_TYPE_POINT,
  Fd as GEOMETRY_TYPE_POLYGON,
  gX as GLTFLoader,
  ad as GeoInstancedMesh,
  gr as GeoJSONDataSource,
  VY as Heatmap,
  L_ as HierarchicalTileLoaderStrategy,
  _v as Icon,
  OC as ImageryTileProvider,
  ra as JSONDataSource,
  RY as LODModel,
  Ii as Label,
  qk as MapView,
  HY as Marker,
  LY as OSMImageryTileProvider,
  Fg as PROJECTION_BD_MERCATOR,
  zs as PROJECTION_ECEF,
  SY as PROJECTION_EQUAL_EARTH,
  hi as PROJECTION_GEO,
  mw as PROJECTION_SCREEN_PIXEL,
  yY as PROJECTION_UTM,
  Mt as PROJECTION_WEB_MERCATOR,
  k_ as PlaneTerrainTileProvider,
  Cf as Polygon,
  KY as Popup,
  mD as RENDER_STAGE_BLOOM,
  yD as RENDER_STAGE_FEATURES,
  SD as RENDER_STAGE_POSTPROCESSING,
  bY as RENDER_STAGE_PREPARE,
  yw as RENDER_STAGE_SCENE,
  Vk as RasterSurface,
  XY as SDFText,
  WY as SimpleLine,
  EY as SimpleModel,
  PY as SimplePoint,
  kg as TerrainTileProvider,
  zY as Text,
  U_ as TiandituConfig,
  GY as TiandituImageryTileProvider,
  ZC as TileProvider,
  Xk as VectorSurface,
  eV as VectorTileProvider,
  UY as Wall,
  BY as colorUtils,
  wY as geojsonUtils,
  nf as gltfLoader,
  _Y as mapViewConstants,
  DY as modelUtils,
  pY as objectUtils,
  xY as requestUtils,
  mY as urlUtils
};
