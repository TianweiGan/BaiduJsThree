/**
 * Create an instance of an OrientedBoundingBox
 * Creates an instance of an OrientedBoundingBox.
 * An OrientedBoundingBox of some object is a closed and convex rectangular cuboid.
 * It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
 * @alias OrientedBoundingBox
 * @constructor
 *
 * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.
 * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.
 *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2
 *                                          cube centered at the origin.
 *
 *
 */
export class OrientedBoundingBox {
    constructor(center: any, halfAxes: any);
    isOrientedBoundingBox: boolean;
    /**
     * The center of the box.
     */
    center: any;
    /**
     * The three orthogonal half-axes of the bounding box. Equivalently, the
     * transformation matrix, to rotate and scale a 2x2x2 cube centered at the
     * origin.
     */
    halfAxes: any;
    intersectPlane(plane: any): number;
    distanceSquaredTo(cartesian: any): Interval;
    computeCorners(result: any): Cartesian3[];
    getCenter(result: any): any;
    /**
     * 检测当前OBB是否与另一个OBB相交
     * @param {OrientedBoundingBox} otherObb 另一个OBB
     * @returns {boolean} 是否相交
     */
    intersectsObb(otherObb: OrientedBoundingBox): boolean;
}
export namespace OrientedBoundingBox {
    /**
     * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.
     * There are no guarantees about the orientation of the bounding box.
     *
     * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.
     * @param {number} [minimumHeight=0.0] The minimum height (elevation) within the tile.
     * @param {number} [maximumHeight=0.0] The maximum height (elevation) within the tile.
     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.
     * @param {OrientedBoundingBox} [result] The object onto which to store the result.
     * @returns {OrientedBoundingBox} The modified result parameter
     * or a new OrientedBoundingBox instance if none was provided.
     *
     * @exception {DeveloperError} rectangle.width must be between 0 and 2 * pi.
     * @exception {DeveloperError} rectangle.height must be between 0 and pi.
     * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)
     */
    function fromRectangle(rectangle: Rectangle, minimumHeight?: number, maximumHeight?: number, ellipsoid?: Ellipsoid, result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding box.
     *
     * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.
     * @param {Cartesian3} position The position to calculate the distance from.
     * @param {Cartesian3} direction The direction from position.
     * @param {Interval} [result] A Interval to store the nearest and farthest distances.
     * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.
     */
    function distanceSquaredTo(box: OrientedBoundingBox, cartesian: any): Interval;
    function intersectPlane(box: any, plane: any): number;
    /**
     * Computes the eight corners of an oriented bounding box. The corners are ordered by
     * (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
     *
     * @param {OrientedBoundingBox} box The oriented bounding box.
     * @param {Cartesian3[]} [result] An array of eight {@link Cartesian3} instances onto which to store the corners.
     * @returns {Cartesian3[]} The modified result parameter or a new array if none was provided.
     */
    function computeCorners(box: OrientedBoundingBox, result?: Cartesian3[]): Cartesian3[];
    function fromGeoBoundingBox(geoBoundingBox: any, result: any): OrientedBoundingBox;
}
import { Cartesian3 } from './Cartesian3';
import { Rectangle } from './Rectangle';
import { Ellipsoid } from './Ellipsoid';
