export default TileBoundingRegion;
/**
 * A tile bounding volume specified as a longitude/latitude/height region.
 * @alias TileBoundingRegion
 * @constructor
 *
 * @param {object} options Object with the following properties:
 * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.
 * @param {number} [options.minimumHeight=0.0] The minimum height of the region.
 * @param {number} [options.maximumHeight=0.0] The maximum height of the region.
 * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.
 * @param {boolean} [options.computeBoundingVolumes=true]
 * True to compute the {@link TileBoundingRegion#boundingVolume} and
 * {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.
 *
 * @private
 */
declare function TileBoundingRegion(options: {
    rectangle: Rectangle;
    minimumHeight?: number | undefined;
    maximumHeight?: number | undefined;
    ellipsoid?: Ellipsoid | undefined;
    computeBoundingVolumes?: boolean | undefined;
}): void;
declare class TileBoundingRegion {
    /**
     * A tile bounding volume specified as a longitude/latitude/height region.
     * @alias TileBoundingRegion
     * @constructor
     *
     * @param {object} options Object with the following properties:
     * @param {Rectangle} options.rectangle The rectangle specifying the longitude and latitude range of the region.
     * @param {number} [options.minimumHeight=0.0] The minimum height of the region.
     * @param {number} [options.maximumHeight=0.0] The maximum height of the region.
     * @param {Ellipsoid} [options.ellipsoid=Cesium.Ellipsoid.WGS84] The ellipsoid.
     * @param {boolean} [options.computeBoundingVolumes=true]
     * True to compute the {@link TileBoundingRegion#boundingVolume} and
     * {@link TileBoundingVolume#boundingSphere}. If false, these properties will be undefined.
     *
     * @private
     */
    private constructor();
    rectangle: any;
    minimumHeight: any;
    maximumHeight: any;
    /**
   * The world coordinates of the southwest corner of the tile's rectangle.
   *
   * @type {Vector3}
   * @default Vector3()
   */
    southwestCornerCartesian: Vector3;
    /**
   * The world coordinates of the northeast corner of the tile's rectangle.
   *
   * @type {Vector3}
   * @default Vector3()
   */
    northeastCornerCartesian: Vector3;
    /**
   * A normal that, along with southwestCornerCartesian, defines a plane at the western edge of
   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
   *
   * @type {Vector3}
   * @default Vector3()
   */
    westNormal: Vector3;
    /**
   * A normal that, along with southwestCornerCartesian, defines a plane at the southern edge of
   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
   * Because points of constant latitude do not necessary lie in a plane, positions below this
   * plane are not necessarily inside the tile, but they are close.
   *
   * @type {Vector3}
   * @default Vector3()
   */
    southNormal: Vector3;
    /**
   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of
   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
   *
   * @type {Vector3}
   * @default Cartesian3()
   */
    eastNormal: Vector3;
    /**
   * A normal that, along with northeastCornerCartesian, defines a plane at the eastern edge of
   * the tile.  Any position above (in the direction of the normal) this plane is outside the tile.
   * Because points of constant latitude do not necessary lie in a plane, positions below this
   * plane are not necessarily inside the tile, but they are close.
   *
   * @type {Vector3}
   * @default Vector3()
   */
    northNormal: Vector3;
    _orientedBoundingBox: OrientedBoundingBox | undefined;
    _boundingSphere: any;
    computeBoundingVolumes(ellipsoid: any): void;
    /**
     * Gets the distance from the camera to the closest point on the tile.  This is used for level of detail selection.
     *
     */
    distanceToCamera(cameraPosition: any, mode: any, mapProjection: any, ellipsoid: any): number;
    /**
     * Determines which side of a plane this box is located.
     *
     * @param {Plane} plane The plane to test against.
     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
     *                      intersects the plane.
     */
    intersectPlane(plane: Plane): Intersect;
}
import { Rectangle } from './Rectangle';
import { Ellipsoid } from './Ellipsoid';
import { OrientedBoundingBox } from './OrientedBoundingBox';
