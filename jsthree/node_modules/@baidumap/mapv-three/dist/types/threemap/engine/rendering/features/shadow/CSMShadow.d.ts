export class CSMShadow {
    constructor(rendering: any);
    /** @private */
    private _lights;
    /** @private */
    private _light;
    /** @private */
    private _parent;
    /** @private */
    private _cascades;
    /** @private */
    private _maxFar;
    /** @private */
    private _shadowMapSize;
    /** @private */
    private _lightNear;
    /** @private */
    private _lightFar;
    /** @private */
    private _lightMargin;
    /** @private */
    private _shadowBias;
    /** @private */
    private _mainFrustum;
    /** @private */
    private _frustums;
    /** @private */
    private _breaks;
    /** @private */
    private _helper;
    /** @private */
    private _fade;
    _rendering: any;
    _engine: any;
    _uniforms: {
        CSM_cascades: {
            value: never[];
        };
        cameraNear: {
            value: number;
        };
        shadowFar: {
            value: number;
        };
    };
    init(): void;
    _old_lights_fragment_begin: any;
    _old_lights_pars_begin: any;
    update(light: any, direction: any, parent: any): void;
    updateFrame(mainLight: any, direction: any): void;
    _createLight(mainLight: any, parent: any): void;
    _mainLightCastShadow: any;
    getBreaks(): void;
    initCascades(): void;
    updateShadowBounds(): void;
    updateUniforms(): void;
    getExtendedBreaks(target: any): void;
    updateFrustums(): void;
    updateCSMShadow(material: any, shader: any): void;
    _destroyLight(): void;
    dispose(): void;
    getCurrentUsedTextures(): any[];
    set shadowBias(value: number);
    get shadowBias(): number;
    set showHelper(value: boolean);
    get showHelper(): boolean;
}
