export default RequestScheduler;
declare class RequestScheduler {
    /**
     * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
     * @type {number}
     * @default 50
     */
    static maximumRequests: number;
    /**
     * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically
     * listed in {@link requestsByServer} do not observe this limit.
     * @type {number}
     * @default 18
     */
    static maximumRequestsPerServer: number;
    /**
     * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.
     * Useful when streaming data from a known HTTP/2 or HTTP/3 server.
     * @type {object}
     *
     * @example
     * RequestScheduler.requestsByServer["myserver.com:443"] = 18;
     *
     * @example
     * RequestScheduler.requestsByServer = {
     *   "api.cesium.com:443": 18,
     *   "assets.cesium.com:443": 18,
     * };
    */
    static requestsByServer: object;
    /**
     * Specifies if the request scheduler should throttle incoming requests,
     * or let the browser queue requests under its control.
     * @type {boolean}
     * @default true
     */
    static throttleRequests: boolean;
    /**
     * An event that's raised when a request is completed.  Event handlers are passed
     * the error object if the request fails.
     *
     * @type {Event}
     * @default Event()
     * @private
     */
    private static debugShowStatistics;
    static get statistics(): {
        numberOfAttemptedRequests: number;
        numberOfActiveRequests: number;
        numberOfCancelledRequests: number;
        numberOfCancelledActiveRequests: number;
        numberOfFailedRequests: number;
        numberOfActiveRequestsEver: number;
        lastNumberOfActiveRequests: number;
    };
    static set priorityHeapLength(value: number);
    static get priorityHeapLength(): number;
    /**
     * Sort requests by priority and start requests.
     * @private
     */
    private static update;
    static getServerKey: (url: any) => any;
    /**
      * 检查特定serverKey是否有可用的插槽。如果 desiredRequests 大于 1，则此方法会检查队列是否有足够的空间来安排多个请求。
      * @param {string} serverKey 由 {@link RequestScheduler.getServerKey} 返回的服务器键。
      * @param {number} [desiredRequests=1] 调用者计划请求的数量
      * @return {boolean} 如果有足够的插槽可以处理 <code>desiredRequests</code> 数量的请求，则返回 true。
      * @private
     */
    private static serverHasOpenSlots;
    static heapHasOpenSlots: (desiredRequests: any) => boolean;
    /**
     * Issue a request. If request.throttle is false, the request is sent immediately. Otherwise the request will be
     * queued and sorted by priority before being sent.
     *
     * @param {Request} request The request object.
     *
     * @returns {Promise|undefined} A Promise for the requested data, or undefined
     * if this request does not have high enough priority to be issued.
     *
     * @private
     */
    private static request;
}
