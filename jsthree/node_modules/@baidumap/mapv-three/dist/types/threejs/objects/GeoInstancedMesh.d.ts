/**
 * GeoInstancedMesh可以用来渲染大量具有相同几何体与材质、但具有不同世界变化的物体，
 * 它能够帮你减少draw call的数量，提升应用程序的整体性能
 *
 * @category Objects
 * @example
 * ```javascript
 * // 创建一个实例化格网
 * const instancedMesh = engine.add(new mapvthree.GeoInstancedMesh(geometry, material));
 * // 传入数据源
 * const data = mapvthree.GeoJSONDataSource.fromGeoJSON(randomPoints(center, 0.05, 1000));
 * instancedMesh.dataSource = data;
 * ```
 */
export class GeoInstancedMesh extends GeoObject {
    /**
     * 实例化网格构造函数
     * @param {BufferGeometry} geometry 一个BufferGeometry实例
     * @param {Material} material 一个Material实例
     */
    constructor(geometry: BufferGeometry, material: Material);
    /** @protected */ protected type: string;
    /** @protected */ protected isMesh: boolean;
    /** @protected */ protected isInstancedMesh: boolean;
    /** @protected */ protected frustumCulled: boolean;
    /** @protected */ protected instanceColor: null;
    /** @protected */ protected count: number;
    /** @protected */ protected instanceMatrix: any;
    /** @private */ private _enableInstanceColor;
    /** @private */
    private instanceMorphMatrix;
    /**
     * 是否支持返回的事件参数中携带entity实体数据
     */
    isEventEntitySupported: boolean;
    boundingBox: null;
    boundingSphere: null;
    parameters: {};
    geometry: BufferGeometry;
    material: Material;
    set enableInstanceColor(value: boolean);
    get enableInstanceColor(): boolean;
    /**
     * @internal
     * 计算模型本地变换矩阵
     */
    getInstanceLocalMatrix: (coordinates: any, dataItem: any, index: any, userData: any) => null;
    getEcefTransformMatrix: (coordinate: any, feature: any, index: any) => any;
    collisionTest(data: any): {
        width: any;
        height: any;
    };
    /**
     * @internal
     * TODO: 为了兼容InstancedModel的用法，先搬过来了，但是与原来传数据的设计不一致，后续需要统一
     * 添加数据
     * @param {*} bufferData
     * .instanceMatrix
     * .translation, .scale, .rotation
     * .id 必须要有，这是增删数据的唯一主键
     */
    setBufferData(bufferData: any): void;
    computeTempMatrix(bufferData: any): void;
    /** @protected */
    protected addCustomAttributes: () => void;
    computeBoundingBox(): void;
    computeBoundingSphere(): void;
    getMatrixAt(index: any, matrix: any): void;
    /**
     * @internal
     * 通过material上的size, height, zoomUnits等属性计算实例的变形矩阵
     */
    computeInstanceMorphMatrix(): void;
    /**
     * @protected
     * 通过index获取该index对应数据源的实体信息
     * @param {number} index
     * @returns
     */
    protected getEntityByIndex(index: number): {
        index: number;
        value: any;
        itemIndex: any;
        pairs: {};
    };
    /**
     * @internal
     * 一条投射出去的ray(射线)和这些实例化网格之间产生交互，Raycaster.intersectObject将会调用这个方法
     * @param {Raycaster} raycaster 光线投射
     * @param {Array} intersects
     * @returns
     */
    raycast(raycaster: Raycaster, intersects: any[]): void;
}
import { GeoObject } from './GeoObject';
