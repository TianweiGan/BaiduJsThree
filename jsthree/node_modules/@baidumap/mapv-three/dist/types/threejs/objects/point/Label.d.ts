export type LabelMeshParameters = {
    /**
     * - icon texture
     */
    spriteTexture?: Texture;
    /**
     * - 文字是否贴地
     */
    flat?: boolean | undefined;
    /**
     * - 是否在后处理中绘制
     */
    isRenderInPostprocess: boolean;
};
/**
 * @category Objects
 * @description 标签对象，用于在地图上渲染文本标签、图标标签或两者结合, 支持自定义样式。 `Label`组件一般用于批量管理大量标签数据, 比如整体显隐控制, 对于少量的标签加载和管理推荐使用{@link RenderingLabel}。
 * @example 文本标签
 * ```javascript
 * // 创建一个文本标签
 * const textLabel = engine.add(new mapvthree.Label({
 *     type: 'text',
 *     textSize: 16,
 *     textFillStyle: 'rgb(255, 8, 8)', // 字体颜色
 *     textStrokeStyle: 'rgba(0, 0, 0, 1)', // 边框颜色
 *     textStrokeWidth: 2, // 边框宽度
 * }))
 * const data = mapvthree.GeoJSONDataSource.fromGeoJSON([
 *  {
 *      type: 'Feature',
 *      geometry: {
 *          type: 'Point',
 *          coordinates: [116.404, 39.915]
 *      },
 *      properties: {
 *          text: '北京市',
 *      }
 *  }]);
 * data.defineAttribute('text', 'text');
 * textLabel.dataSource = data;
 * ```
 * @example 图标标签
 * ```javascript
 * // 创建一个图标标签
 * const iconLabel = engine.add(new mapvthree.Label({
 *     type: 'icon',
 *     vertexIcons: true,
 *     iconWidth: 40,
 *     iconHeight: 40,
 * }));
 * // 设置数据源
 * const data = mapvthree.GeoJSONDataSource.fromGeoJSON([
 *  {
 *      type: 'Feature',
 *      geometry: {
 *          type: 'Point',
 *          coordinates: [116.404, 39.915]
 *      },
 *      properties: {
 *          icon: 'path/icon.png',
 *      }
 *  }
 * ]);
 * // 设置数据源
 * data.defineAttribute('icon', 'icon');
 * iconLabel.dataSource = data;
 * ```
 *
 * @example 图标文字组合标签
 * ```javascript
 * // 创建一个图标和文字组合标签
 * const abel = engine.add(new mapvthree.Label({
 *     type: 'icontext',
 *     vertexIcons: true,
 *     textSize: 16,
 *     textFillStyle: 'rgb(255, 8, 8)', // 字体颜色
 *     textStrokeStyle: 'rgba(0, 0, 0, 1)', // 边框颜色
 *     textStrokeWidth: 2, // 边框宽度
 *     iconWidth: 40,
 *     iconHeight: 40,
 * }));
 * // 设置数据源
 * const data = mapvthree.GeoJSONDataSource.fromGeoJSON([
 *  {
 *      type: 'Feature',
 *      geometry: {
 *          type: 'Point',
 *          coordinates: [116.404, 39.915]
 *      },
 *      properties: {
 *          icon: 'path/icon.png',
 *      }
 *  }
 * ]);
 * // 设置数据源
 * data.defineAttribute('icon', 'icon');
 * data.defineAttribute('text', 'text');
 * label.dataSource = data;
 * ```
 * @description `Label`组件的样式可以通过初始化参数整体控制, 也支持丰富的自定义样式配置(在传入数据中携带)
 * @example 自定义样式
 * ```javascript
 * // 整体控制样式，在初始化时设置
 * const label = engine.add(new mapvthree.Label({
 *     type: 'icontext',
 *     vertexIcons: true,
 *     textSize: 16,
 *     textFillStyle: 'rgb(255, 8, 8)', // 字体颜色
 *     textStrokeStyle: 'rgba(0, 0, 0, 1)', // 边框颜色
 *     textStrokeWidth: 2, // 边框宽度
 *     iconWidth: 40,
 *     iconHeight: 40,
 * }));
 * // 自定义样式，在传入数据中设置
 * const data = mapvthree.GeoJSONDataSource.fromGeoJSON([
 *  {
 *      type: 'Feature',
 *      geometry: {
 *          type: 'Point',
 *          coordinates: [116.404, 39.915]
 *      },
 *      properties: {
 *          icon: 'path/icon.png',
 *          iconSize: [40, 40],
 *          text: '北京市',
 *          textSize: 16,
 *          textAnchor: 'center',
 *          textFillStyle: 'rgb(255, 8, 8)', // 字体颜色
 *          textStrokeStyle: 'rgba(0, 0, 0, 1)', // 边框颜色
 *          textStrokeWidth: 2, // 边框宽度
 *          textOffset: [0, 0],
 *          rotateZ: 0, // 旋转角度
 *      }
 * }
 * ]);
 * // 支持的自定义数据配置
 * // 图标相关
 * data.defineAttribute('icon', 'icon'); // 图标路径
 * data.defineAttribute('iconSize', 'iconSize'); // 图标尺寸
 * // 文字相关
 * data.defineAttribute('text', 'text'); // 文字内容
 * data.defineAttribute('textSize', 'textSize'); // 文字大小
 * data.defineAttribute('textFillStyle', 'textFillStyle'); // 文字颜色
 * data.defineAttribute('textStrokeStyle', 'textStrokeStyle'); // 文字边框颜色
 * data.defineAttribute('textStrokeWidth', 'textStrokeWidth'); // 文字边框宽度
 * data.defineAttribute('textOffset', 'textOffset'); // 文字偏移
 * data.defineAttribute('textAnchor', 'textAnchor'); // 文字对齐方式
 * // 其他
 * data.defineAttribute('rotateZ', 'rotateZ'); // 旋转角度
 * ```
 */
export class Label extends GeoMesh {
    /**
     * 构造函数
     * @param {Object} parameters 配置参数
     * @param {Boolean} [parameters.vertexIcons=false] 数据中是否携带icon(url资源), 默认为false
     * @param {Boolean} [parameters.flat=false] 是否贴地, 默认为false
     * @param {String} [parameters.type='icon'] 绘制类型,支持'icon'｜'text'｜'icontext'
     * @param {Boolean} [parameters.enableFade=false] 是否启用淡入淡出效果, 默认为false, 若要启用淡入淡出效果, 数据中需要指定id
     * @param {Number} [parameters.textSize=16] 文字大小, 默认16
     * @param {String} [parameters.textFamily='sans-serif'] 文字字体
     * @param {String|Array} [parameters.textFillStyle=[255,255,255]] 文字颜色, 默认[255,255,255]
     * @param {String|Array} [parameters.textStrokeStyle=[0,0,0]] 文字描边颜色, 默认[0,0,0]
     * @param {Number} [parameters.textStrokeWidth=0] 文字描边宽度, 默认0
     * @param {String} [parameters.textAnchor='center'] 文字锚点, 支持'left'|'right'|'top'|'bottom'|'top-left'|'top-right'|'bottom-left'|'bottom-right', 默认'center'
     * @param {Array} [parameters.textOffset=[0,0]] 文字偏移, 默认[0,0]
     * @param {String} [parameters.textWeight='400'] 文字粗细, 默认'400'
     * @param {Array} [parameters.textPadding=[0,0]] 文字内边距, 默认[0,0]
     * @param {Number} [parameters.iconWidth=40] 图标宽度, 默认40
     * @param {Number} [parameters.iconHeight=40] 图标高度, 默认40
     * @param {Number} [parameters.rotateZ=0] 旋转角度, 默认0
     * @param {String} [parameters.textAlign='center'] 文本对齐方式,支持'left'|'right'|'center', 默认'center'
     * @param {String} [parameters.mapSrc] 图标url
     * @param {Boolean} [parameters.transparent=false] 是否透明
     * @param {Array} [parameters.pixelOffset] 像素偏移, 默认[0,0]
     * @param {Array} [parameters.positionOffset] 坐标偏移, 默认[0,0]
    */
    constructor(parameters?: {
        vertexIcons?: boolean | undefined;
        flat?: boolean | undefined;
        type?: string | undefined;
        enableFade?: boolean | undefined;
        textSize?: number | undefined;
        textFamily?: string | undefined;
        textFillStyle?: string | any[] | undefined;
        textStrokeStyle?: string | any[] | undefined;
        textStrokeWidth?: number | undefined;
        textAnchor?: string | undefined;
        textOffset?: any[] | undefined;
        textWeight?: string | undefined;
        textPadding?: any[] | undefined;
        iconWidth?: number | undefined;
        iconHeight?: number | undefined;
        rotateZ?: number | undefined;
        textAlign?: string | undefined;
        mapSrc?: string | undefined;
        transparent?: boolean | undefined;
        pixelOffset?: any[] | undefined;
        positionOffset?: any[] | undefined;
    });
    /**
     * @type {LabelMeshParameters}
     */
    parameters: LabelMeshParameters;
    /**
     * @type {Texture}
     */
    spriteTexture: Texture;
    /**
     * @type {Texture}
     */
    textTexture: Texture;
    /** @private */
    private _maxChar;
    /** @private */
    private _version;
    /** @private */ private oldMapTextureRes;
    /** @protected */ protected iconUrlHash: LRUCache;
    /** @protected */ protected boxHash: Map<any, any>;
    /** @protected */ protected gap: number[];
    /** @protected */ protected geometry: any;
    /** @protected */ protected material: any;
    /** @protected */ protected canvas: HTMLCanvasElement;
    /** @protected */ protected ctx: CanvasRenderingContext2D | null;
    /** @protected */ protected cachedTextData: any[];
    /** @private */ private _collisionBoxCache;
    /** @private */ private isRenderInPostprocess;
    /**
     * @private
     */
    /** @private */
    private _bufferDataOffset;
    /**
     * @private
     */
    private _bufferData;
    vertexIcons: boolean | undefined;
    flat: any;
    symbolType: any;
    _enableFade: any;
    _enableFadeFilter: any;
    _textSize: any;
    _textFamily: any;
    _textFillStyle: any[];
    _textStrokeStyle: any[];
    _textStrokeWidth: any;
    _textAnchor: any;
    _textOffset: any;
    _textWeight: any;
    _rotateZ: any;
    _textPadding: any;
    textAlign: any;
    _iconWidth: any;
    _iconHeight: any;
    _offset: any;
    _fadeData: FadeData;
    fontAtalasManager: FontAtlasManager;
    iconCanvas: HTMLCanvasElement | undefined;
    iconCtx: CanvasRenderingContext2D | null | undefined;
    boxes: any[];
    collisionTest(data: any): any;
    computeBoundingBox(data: any): {
        width: any;
        height: any;
        tolerance: any;
        offsetX?: undefined;
        offsetY?: undefined;
        textBox?: undefined;
    } | {
        width: number;
        height: number;
        offsetX: number;
        offsetY: number;
        textBox: {
            width: number;
            height: number;
            wrappedText: any;
            widthList: any;
        };
        tolerance: any;
        wrappedText: any;
        widthList: any;
    } | {
        width: number;
        height: number;
        offsetX: number;
        offsetY: number;
        textBox: {
            width: number;
            height: number;
            wrappedText: any;
            widthList: any;
        };
        tolerance: any;
    } | undefined;
    _getTextIconOffset(textBox: any, anchor: any, iconWidth: any, iconHeight: any): {
        width: number;
        height: number;
        offsetX: number;
        offsetY: number;
    };
    _getTextOrIconOffset(anchor: any, width: any, height: any): {
        offsetX: number;
        offsetY: number;
    };
    packBuffer(data: any): void;
    _commitBuffer(): void;
    updateIconDataItem(data: any, indexOffset: any): any;
    packIconAndTextBuffer(datas: any, indexOffset?: number): number | undefined;
    packIconBuffer(iconDatas: any, indexOffset?: number): number | undefined;
    updateIconHash(iconDatas: any): Promise<void>;
    updateTextSprite(renderedData: any): Promise<void>;
    getTextureAndHash(data: any, texturePropName: any, width: any, height: any, isDataChanged: any): any;
    updateIconSprite(): Map<any, any>;
    updateTextTexture(characterSet: any): Promise<void>;
    _fontSettings: {
        fontSize: number;
        buffer: number;
        radius: number;
        fontFamily: any;
        fontWeight: string;
        characterSet: any;
        sdf: boolean;
    } | undefined;
    packTextBuffer(textData: any, indexOffset?: number): number | undefined;
    updateTextDataItem(data: any, indexOffset: any): any;
    packRotateZ(rotateZ: any): void;
    packRotationMatrix(position: any): void;
    packPosition(position: any): void;
    packFade(data: any): void;
    packOffset(offsetX: any, offsetY: any): void;
    packWH(frameWidth: any, frameHeight: any, iconSize: any, fontSize: any): void;
    packTypeAndPIndex(type: any): void;
    packIconStyle(opacity?: number): void;
    packIconUV(iconUV: any): void;
    packTextStyle(data: any): void;
    packTextWh(data: any, iconFrame: any): void;
    packTextUV(iconFrame: any): void;
    /** @private */
    private packTextOffset;
    _calculateRotation(viewMatrix: any, instanceMatrix: any, rotateZ: any): number;
    _calculateTransform(position: any, outputMatrix: any): any;
    /**
     * @private
     */
    private _getTextBox;
    _calculateWidths(arrays: any): any;
    _processTextLayout(text: any, lineHeight: any): {
        char: string;
        width: number;
        height: any;
        offsetX: number;
        offsetY: number;
    }[][];
    _applyRotateZ(charBoxes: any, rotateZ: any, rotationMatrix: any): any;
    onBeforeScenePrepareRenderHook(engine: any, scene: any, camera: any): void;
    _clearBufferDataOffset(): void;
    getStrictStyleId(data: any): string;
    set enableFade(value: any);
    get enableFade(): any;
}
import { GeoMesh } from '../GeoMesh';
import { LRUCache } from '../../../util/LRUCache';
import { FadeData } from '../FadeData';
import { FontAtlasManager } from '../text/font-atlas-manager';
