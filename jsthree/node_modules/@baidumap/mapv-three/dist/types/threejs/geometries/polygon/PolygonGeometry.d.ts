export class PolygonGeometry {
    constructor(parameters: any);
    isPolygonGeometry: boolean;
    _useUV: boolean;
    _useEarCut: boolean;
    _sideUVNormalized: boolean;
    _sideUVReversed: boolean;
    _sideUVUseHeight: boolean;
    _rectangle: null;
    parameters: any;
    _needsUpdate: boolean;
    _extrude: any;
    _extrudeValue: any;
    _enableBottomFace: any;
    perPositionHeight: any;
    _zOffset: any;
    cachedPositions: any[];
    cachedObjectIndices: any[];
    setData(data: any): void;
    cachedData: any;
    updateGeometry(): void;
    updateGeometry3D(): void;
    updateGeometryColumbus(): void;
    triangulate: (positions: any, holes: any) => any;
    addGeoPolygonToVertices: (flattenCoords: any, triangles: any, height: number | undefined, indexOffset: number | undefined, positions: any, indices: any, normals: any, uvs: any, uvRotation: any, colors: any, color: any, aObjectIndices: any, objectIndex: any, heightAndConcaves: any, isClockWise?: boolean) => void;
    /**
     * 将isGround,isConcave,isStart编码到一个值中
     * @param {Boolean} isGround 是否为底部,底部为1,顶部为0
     * @param {Boolean} isConcave 是否为凹角,凹为1,凸为0
     * @param {Boolean} isStart 是否为起点,起点为1,终点为0
     */
    _encodeConcave: (isGround: boolean, isConcave: boolean, isStart: boolean) => number;
    _pushHeightAndConcave: (heightAndConcave: any, height: any, index: any, p1: any, p2: any, p3: any, length: any) => void;
    _calculateHeights(p1: any, p2: any, height: any): {
        bottom: any;
        nextBottom: any;
        top: any;
        nextTop: any;
    };
    _pushPosition: (positions: any, p1: any, p2: any, height: any) => void;
    _calculateNormal(point: any, nextPoint: any): number[];
    _pushNormal: (normals: any, point: any, nextPoint: any) => void;
    _pushUV: (uvs: any, point: any, nextPoint: any, height: any, aggrLength: any) => any;
    _pushColor: (colors: any, color: any, count?: number) => void;
    _pushObjectIndex: (objectIndices: any, objectIndex: any) => void;
    addSideFace: (coordinates: any, height: any, indexOffset: any, aPositions: any, indices: any, normals: any, uvs: any, colors: any, color: any, aObjectIndices: any, objectIndex: any, heightAndConcave: any) => void;
    computeWallGeometry3D(positions: any, positions2D: any, ellipsoid: any, granularity: any, indexOffset: any, height: any, heights: any, minHeight: any): {
        edgePositions: any[];
        edgeIndices: any[];
        edgeNormals: any[];
        edgeUvs: any[];
        edgeHeightAndConcaves: never[];
        totalDistance: number[];
    };
    subdivideLineCount: (p0: any, p1: any, minDistance: any) => number;
    subdivideLine: (p0: any, p1: any, p0Height: any, p1Height: any, minHeight: any, minDistance: any, ellipsoid: any, extrudeHeight: any, heightAndConcave: any, topPositions: any, bottomPositions: any) => {
        topPositions: any;
        bottomPositions: any;
    };
    crossVectors3: (a: any, b: any) => number[];
    set extrude(value: any);
    get extrude(): any;
    set extrudeValue(value: any);
    get extrudeValue(): any;
    set sideUVNormalized(value: boolean);
    get sideUVNormalized(): boolean;
    set sideUVReversed(value: boolean);
    get sideUVReversed(): boolean;
    set sideUVUseHeight(value: boolean);
    get sideUVUseHeight(): boolean;
    set useUV(value: boolean);
    get useUV(): boolean;
    set needsUpdate(value: boolean);
    get needsUpdate(): boolean;
    set useEarCut(value: any);
}
